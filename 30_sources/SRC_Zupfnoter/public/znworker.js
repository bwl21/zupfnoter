(function(undefined) {
  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var global_object = this, console;

  // Detect the global object
  if (typeof(global) !== 'undefined') { global_object = global; }
  if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(this.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return this.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // Constructor for instances of BasicObject
  function BasicObject_alloc(){}

  // Constructor for instances of Object
  function Object_alloc(){}

  // Constructor for instances of Class
  function Class_alloc(){}

  // Constructor for instances of Module
  function Module_alloc(){}

  // Constructor for instances of NilClass (nil)
  function NilClass_alloc(){}

  // The Opal object that is exposed globally
  var Opal = this.Opal = {};

  // All bridged classes - keep track to donate methods from Object
  var BridgedClasses = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported fearures
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    enable_stack_trace: true                  // true, false
  }

  // Minify common function calls
  var $hasOwn = Object.hasOwnProperty;
  var $slice  = Opal.slice = Array.prototype.slice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    return obj.$$id || (obj.$$id = Opal.uid());
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    Opal.gvars["!"] = Opal.exceptions.pop() || nil;
  }

  // Inspect any kind of object, including non Ruby ones
  Opal.inspect = function(obj) {
    if (obj === undefined) {
      return "undefined";
    }
    else if (obj === null) {
      return "null";
    }
    else if (!obj.$$class) {
      return obj.toString();
    }
    else {
      return obj.$inspect();
    }
  }


  // Truth
  // -----

  Opal.truthy = function(val) {
    return (val !== nil && val != null && (!val.$$is_boolean || val == true));
  };

  Opal.falsy = function(val) {
    return (val === nil || val == null || (val.$$is_boolean && val == false))
  };


  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) return cref.$$const[name];
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, result, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) return constant;
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, result, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $hasOwn.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_a_module) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  }

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_a_module) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      cache = cref.$$const_cache = Object.create(null);
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      cache = nesting.$$const_cache = Object.create(null);
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  Opal.const_set = function(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    return value;
  };

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], module_constants, i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Don not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload != null && cref.$$autoload[name] != null) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };


  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `base` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `base` is an object (not a class/module), we simple get its class and
  // use that as the base instead.
  //
  // @param base        [Object] where the class is being created
  // @param superclass  [Class,null] superclass of the new class (may be null)
  // @param id          [String] the name of the class to be created
  // @param constructor [JS.Function] function to use as constructor
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.klass = function(base, superclass, name, constructor) {
    var klass, bridged, alloc;

    if (base == null) {
      base = _Object;
    }

    // If base is an object, use its class
    if (!base.$$is_class && !base.$$is_module) {
      base = base.$$class;
    }

    // If the superclass is a function then we're bridging a native JS class
    if (typeof(superclass) === 'function') {
      bridged = superclass;
      superclass = _Object;
    }

    // Try to find the class in the current scope
    klass = const_get_name(base, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      // Make sure existing class has same superclass
      if (superclass && klass.$$super !== superclass) {
        throw Opal.TypeError.$new("superclass mismatch for class " + name);
      }

      return klass;
    }

    // Class doesnt exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // If bridged the JS class will also be the alloc function
    alloc = bridged || Opal.boot_class_alloc(name, constructor, superclass);

    // Create the class object (instance of Class)
    klass = Opal.setup_class_object(name, alloc, superclass.$$name, superclass.constructor);

    // @property $$super the superclass, doesn't get changed by module inclusions
    klass.$$super = superclass;

    // @property $$parent direct parent class
    //                    starts with the superclass, after klass inclusion is
    //                    the last included klass
    klass.$$parent = superclass;

    Opal.const_set(base, name, klass);

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    base[name] = klass;

    if (bridged) {
      Opal.bridge(klass, alloc);
    }
    else {
      // Call .inherited() hook with new class on the superclass
      if (superclass.$inherited) {
        superclass.$inherited(klass);
      }
    }

    return klass;
  };

  // Boot a base class (makes instances).
  //
  // @param name [String,null] the class name
  // @param constructor [JS.Function] the class' instances constructor/alloc function
  // @param superclass  [Class,null] the superclass object
  // @return [JS.Function] the consturctor holding the prototype for the class' instances
  Opal.boot_class_alloc = function(name, constructor, superclass) {
    if (superclass) {
      var alloc_proxy = function() {};
      alloc_proxy.prototype = superclass.$$proto || superclass.prototype;
      constructor.prototype = new alloc_proxy();
    }

    if (name) {
      constructor.displayName = name+'_alloc';
    }

    constructor.prototype.constructor = constructor;

    return constructor;
  };

  Opal.setup_module_or_class = function(module) {
    // @property $$id Each class/module is assigned a unique `id` that helps
    //                comparation and implementation of `#object_id`
    module.$$id = Opal.uid();

    // @property $$is_a_module Will be true for Module and its subclasses
    //                         instances (namely: Class).
    module.$$is_a_module = true;

    // @property $$inc included modules
    module.$$inc = [];

    // initialize the name with nil
    module.$$name = nil;

    // Initialize the constants table
    module.$$const = Object.create(null);

    // @property $$cvars class variables defined in the current module
    module.$$cvars = Object.create(null);
  }



  // Adds common/required properties to class object (as in `Class.new`)
  //
  // @param name  [String,null] The name of the class
  //
  // @param alloc [JS.Function] The constructor of the class' instances
  //
  // @param superclass_name [String,null]
  //   The name of the super class, this is
  //   usefule to build the `.displayName` of the singleton class
  //
  // @param superclass_alloc [JS.Function]
  //   The constructor of the superclass from which the singleton_class is
  //   derived.
  //
  // @return [Class]
  Opal.setup_class_object = function(name, alloc, superclass_name, superclass_alloc) {
    // Grab the superclass prototype and use it to build an intermediary object
    // in the prototype chain.
    var superclass_alloc_proxy = function() {};
        superclass_alloc_proxy.prototype = superclass_alloc.prototype;
        superclass_alloc_proxy.displayName = superclass_name;

    var singleton_class_alloc = function() {}
        singleton_class_alloc.prototype = new superclass_alloc_proxy();

    // The built class is the only instance of its singleton_class
    var klass = new singleton_class_alloc();

    Opal.setup_module_or_class(klass);

    // @property $$alloc This is the constructor of instances of the current
    //                   class. Its prototype will be used for method lookup
    klass.$$alloc = alloc;

    klass.$$name = name || nil;

    // Set a displayName for the singleton_class
    singleton_class_alloc.displayName = "#<Class:"+(name || ("#<Class:"+klass.$$id+">"))+">";

    // @property $$proto This is the prototype on which methods will be defined
    klass.$$proto = alloc.prototype;

    // @property $$proto.$$class Make available to instances a reference to the
    //                           class they belong to.
    klass.$$proto.$$class = klass;

    // @property constructor keeps a ref to the constructor, but apparently the
    //                       constructor is already set on:
    //
    //                          `var klass = new constructor` is called.
    //
    //                       Maybe there are some browsers not abiding (IE6?)
    klass.constructor = singleton_class_alloc;

    // @property $$is_class Clearly mark this as a class
    klass.$$is_class = true;

    // @property $$class Classes are instances of the class Class
    klass.$$class    = Class;

    return klass;
  };

  // Define new module (or return existing module). The given `base` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the base is a ruby
  // object then that objects real ruby class is used (e.g. if the base is the
  // main object, then the top level `Object` class is used as the base).
  //
  // If a module of the given name is already defined in the base, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the base, then an error is
  // generated instead (cannot have a class and module of same name in same base).
  //
  // Otherwise, a new module is created in the base with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  base [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.module = function(base, name) {
    var module;

    if (base == null) {
      base = _Object;
    }

    if (!base.$$is_class && !base.$$is_module) {
      base = base.$$class;
    }

    module = const_get_name(base, name);
    if (module == null && base === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }
    else {
      module = Opal.module_allocate(Module);
      Opal.const_set(base, name, module);
    }

    return module;
  };

  // The implementation for Module#initialize
  // @param module [Module]
  // @param block [Proc,nil]
  // @return nil
  Opal.module_initialize = function(module, block) {
    if (block !== nil) {
      var block_self = block.$$s;
      block.$$s = null;
      block.call(module);
      block.$$s = block_self;
    }
    return nil;
  };

  // Internal function to create a new module instance. This simply sets up
  // the prototype hierarchy and method tables.
  //
  Opal.module_allocate = function(superclass) {
    var mtor = function() {};
    mtor.prototype = superclass.$$alloc.prototype;

    var module_constructor = function() {};
    module_constructor.prototype = new mtor();

    var module = new module_constructor();
    var module_prototype = {};

    Opal.setup_module_or_class(module);

    // initialize dependency tracking
    module.$$included_in = [];

    // Set the display name of the singleton prototype holder
    module_constructor.displayName = "#<Class:#<Module:"+module.$$id+">>"

    // @property $$proto This is the prototype on which methods will be defined
    module.$$proto = module_prototype;

    // @property constructor
    //   keeps a ref to the constructor, but apparently the
    //   constructor is already set on:
    //
    //      `var module = new constructor` is called.
    //
    //   Maybe there are some browsers not abiding (IE6?)
    module.constructor = module_constructor;

    // @property $$is_module Clearly mark this as a module
    module.$$is_module = true;
    module.$$class     = Module;

    // @property $$super
    //   the superclass, doesn't get changed by module inclusions
    module.$$super = superclass;

    // @property $$parent
    //   direct parent class or module
    //   starts with the superclass, after module inclusion is
    //   the last included module
    module.$$parent = superclass;

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.$$is_class || object.$$is_module) {
      return Opal.build_class_singleton_class(object);
    }

    return Opal.build_object_singleton_class(object);
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(object) {
    var alloc, superclass, klass;

    if (object.$$meta) {
      return object.$$meta;
    }

    // The constructor and prototype of the singleton_class instances is the
    // current class constructor and prototype.
    alloc = object.constructor;

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = object === BasicObject ? Class : Opal.build_class_singleton_class(object.$$super);

    klass = Opal.setup_class_object(null, alloc, superclass.$$name, superclass.constructor);
    klass.$$super  = superclass;
    klass.$$parent = superclass;

    klass.$$is_singleton = true;
    klass.$$singleton_of = object;

    return object.$$meta = klass;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        name = "#<Class:#<" + superclass.$$name + ":" + superclass.$$id + ">>";

    var alloc = Opal.boot_class_alloc(name, function(){}, superclass)
    var klass = Opal.setup_class_object(name, alloc, superclass.$$name, superclass.constructor);

    klass.$$super  = superclass;
    klass.$$parent = superclass;
    klass.$$class  = superclass.$$class;
    klass.$$proto  = object;

    klass.$$is_singleton = true;
    klass.$$singleton_of = object;

    return object.$$meta = klass;
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  }

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($hasOwn.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  }

  // Bridges a single method.
  //
  // @param target [JS::Function] the constructor of the bridged class
  // @param from [Module] the module/class we are importing the method from
  // @param name [String] the method name in JS land (i.e. starting with $)
  // @param body [JS::Function] the body of the method
  Opal.bridge_method = function(target_constructor, from, name, body) {
    var ancestors, i, ancestor, length;

    ancestors = target_constructor.$$bridge.$ancestors();

    // order important here, we have to check for method presence in
    // ancestors from the bridged class to the last ancestor
    for (i = 0, length = ancestors.length; i < length; i++) {
      ancestor = ancestors[i];

      if ($hasOwn.call(ancestor.$$proto, name) &&
          ancestor.$$proto[name] &&
          !ancestor.$$proto[name].$$donated &&
          !ancestor.$$proto[name].$$stub &&
          ancestor !== from) {
        break;
      }

      if (ancestor === from) {
        target_constructor.prototype[name] = body
        break;
      }
    }
  };

  // Bridges from *donator* to a *target*.
  //
  // @param target [Module] the potentially associated with bridged classes module
  // @param donator [Module] the module/class source of the methods that should be bridged
  Opal.bridge_methods = function(target, donator) {
    var i,
        bridged = BridgedClasses[target.$__id__()],
        donator_id = donator.$__id__();

    if (bridged) {
      BridgedClasses[donator_id] = bridged.slice();

      for (i = bridged.length - 1; i >= 0; i--) {
        Opal_bridge_methods_to_constructor(bridged[i], donator)
      }
    }
  };

  // Actually bridge methods to the bridged (shared) prototype.
  function Opal_bridge_methods_to_constructor(target_constructor, donator) {
    var i,
        method,
        methods = donator.$instance_methods();

    for (i = methods.length - 1; i >= 0; i--) {
      method = '$' + methods[i];
      Opal.bridge_method(target_constructor, donator, method, donator.$$proto[method]);
    }
  }

  // Associate the target as a bridged class for the current "donator"
  function Opal_add_bridged_constructor(target_constructor, donator) {
    var donator_id = donator.$__id__();

    if (!BridgedClasses[donator_id]) {
      BridgedClasses[donator_id] = [];
    }
    BridgedClasses[donator_id].push(target_constructor);
  }

  // Walks the dependency tree detecting the presence of the base among its
  // own dependencies.
  //
  // @param [Integer] base_id The id of the base module (eg. the "includer")
  // @param [Array<Module>] deps The array of dependencies (eg. the included module, included.$$deps)
  // @param [String] prop The property that holds dependencies (eg. "$$deps")
  // @param [JS::Object] seen A JS object holding the cache of already visited objects
  // @return [Boolean] true if a cyclic dependency is present
  Opal.has_cyclic_dep = function has_cyclic_dep(base_id, deps, prop, seen) {
    var i, dep_id, dep;

    for (i = deps.length - 1; i >= 0; i--) {
      dep = deps[i];
      dep_id = dep.$$id;

      if (seen[dep_id]) {
        continue;
      }
      seen[dep_id] = true;

      if (dep_id === base_id) {
        return true;
      }

      if (has_cyclic_dep(base_id, dep[prop], prop, seen)) {
        return true;
      }
    }

    return false;
  }

  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var iclass, donator, prototype, methods, id, i;

    // check if this module is already included in the class
    for (i = includer.$$inc.length - 1; i >= 0; i--) {
      if (includer.$$inc[i] === module) {
        return;
      }
    }

    // Check that the base module is not also a dependency, classes can't be
    // dependencies so we have a special case for them.
    if (!includer.$$is_class && Opal.has_cyclic_dep(includer.$$id, [module], '$$inc', {})) {
      throw Opal.ArgumentError.$new('cyclic include detected')
    }

    Opal.const_cache_version++;
    includer.$$inc.push(module);
    module.$$included_in.push(includer);
    Opal.bridge_methods(includer, module);

    // iclass
    iclass = {
      $$name:   module.$$name,
      $$proto:  module.$$proto,
      $$parent: includer.$$parent,
      $$module: module,
      $$iclass: true
    };

    includer.$$parent = iclass;

    methods = module.$instance_methods();

    for (i = methods.length - 1; i >= 0; i--) {
      Opal.update_includer(module, includer, '$' + methods[i])
    }
  };

  // Table that holds all methods that have been defined on all objects
  // It is used for defining method stubs for new coming native classes
  Opal.stubs = {};

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for th new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(klass, constructor) {
    if (constructor.$$bridge) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    Opal.stub_subscribers.push(constructor.prototype);

    // Populate constructor with previously stored stubs
    for (var method_name in Opal.stubs) {
      if (!(method_name in constructor.prototype)) {
        constructor.prototype[method_name] = Opal.stub_for(method_name);
      }
    }

    constructor.prototype.$$class = klass;
    constructor.$$bridge          = klass;

    var ancestors = klass.$ancestors();

    // order important here, we have to bridge from the last ancestor to the
    // bridged class
    for (var i = ancestors.length - 1; i >= 0; i--) {
      Opal_add_bridged_constructor(constructor, ancestors[i]);
      Opal_bridge_methods_to_constructor(constructor, ancestors[i]);
    }

    for (var name in BasicObject_alloc.prototype) {
      var method = BasicObject_alloc.prototype[method];

      if (method && method.$$stub && !(name in constructor.prototype)) {
        constructor.prototype[name] = method;
      }
    }

    return klass;
  };

  // Update `jsid` method cache of all classes / modules including `module`.
  Opal.update_includer = function(module, includer, jsid) {
    var dest, current, body,
        klass_includees, j, jj, current_owner_index, module_index;

    body    = module.$$proto[jsid];
    dest    = includer.$$proto;
    current = dest[jsid];

    if (dest.hasOwnProperty(jsid) && !current.$$donated && !current.$$stub) {
      // target class has already defined the same method name - do nothing
    }
    else if (dest.hasOwnProperty(jsid) && !current.$$stub) {
      // target class includes another module that has defined this method
      klass_includees = includer.$$inc;

      for (j = 0, jj = klass_includees.length; j < jj; j++) {
        if (klass_includees[j] === current.$$donated) {
          current_owner_index = j;
        }
        if (klass_includees[j] === module) {
          module_index = j;
        }
      }

      // only redefine method on class if the module was included AFTER
      // the module which defined the current method body. Also make sure
      // a module can overwrite a method it defined before
      if (current_owner_index <= module_index) {
        dest[jsid] = body;
        dest[jsid].$$donated = module;
      }
    }
    else {
      // neither a class, or module included by class, has defined method
      dest[jsid] = body;
      dest[jsid].$$donated = module;
    }

    // if the includer is a module, recursively update all of its includres.
    if (includer.$$included_in) {
      Opal.update_includers(includer, jsid);
    }
  };

  // Update `jsid` method cache of all classes / modules including `module`.
  Opal.update_includers = function(module, jsid) {
    var i, ii, includee, included_in;

    included_in = module.$$included_in;

    if (!included_in) {
      return;
    }

    for (i = 0, ii = included_in.length; i < ii; i++) {
      includee = included_in[i];
      Opal.update_includer(module, includee, jsid);
    }
  };

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module_or_class) {
    var parent = module_or_class,
        result = [],
        modules, i, ii, j, jj;

    while (parent) {
      result.push(parent);
      for (i = parent.$$inc.length-1; i >= 0; i--) {
        modules = Opal.ancestors(parent.$$inc[i]);

        for(j = 0, jj = modules.length; j < jj; j++) {
          result.push(modules[j]);
        }
      }

      // only the actual singleton class gets included in its ancestry
      // after that, traverse the normal class hierarchy
      if (parent.$$is_singleton && parent.$$singleton_of.$$is_module) {
        parent = parent.$$singleton_of.$$super;
      }
      else {
        parent = parent.$$is_class ? parent.$$super : null;
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs(["$foo", "$bar", "$baz="]);
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var subscriber, subscribers = Opal.stub_subscribers,
        i, ilength = stubs.length,
        j, jlength = subscribers.length,
        method_name, stub,
        opal_stubs = Opal.stubs;

    for (i = 0; i < ilength; i++) {
      method_name = stubs[i];

      if(!opal_stubs.hasOwnProperty(method_name)) {
        // Save method name to populate other subscribers with this stub
        opal_stubs[method_name] = true;
        stub = Opal.stub_for(method_name);

        for (j = 0; j < jlength; j++) {
          subscriber = subscribers[j];

          if (!(method_name in subscriber)) {
            subscriber[method_name] = stub;
          }
        }
      }
    }
  };

  // Keep a list of prototypes that want method_missing stubs to be added.
  //
  // @default [Prototype List] BasicObject_alloc.prototype
  //
  Opal.stub_subscribers = [BasicObject_alloc.prototype];

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    var method_missing_stub = Opal.stub_for(stub);
    prototype[stub] = method_missing_stub;
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {
    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_class || object.$$is_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, defs) {
    var dispatcher, super_method;

    if (defs) {
      if (obj.$$is_class || obj.$$is_module) {
        dispatcher = defs.$$super;
      }
      else {
        dispatcher = obj.$$class.$$proto;
      }
    }
    else {
      dispatcher = Opal.find_obj_super_dispatcher(obj, mid, current_func);
    }

    super_method = dispatcher['$' + mid];

    if (!defcheck && super_method.$$stub && Opal.Kernel.$method_missing === obj.$method_missing) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
  };

  Opal.find_obj_super_dispatcher = function(obj, mid, current_func) {
    var klass = obj.$$meta || obj.$$class;

    // first we need to find the class/module current_func is located on
    klass = Opal.find_owning_class(klass, current_func);

    if (!klass) {
      throw new Error("could not find current class for super()");
    }

    return Opal.find_super_func(klass, '$' + mid, current_func);
  };

  Opal.find_owning_class = function(klass, current_func) {
    var owner = current_func.$$owner;

    while (klass) {
      // repeating for readability

      if (klass.$$iclass && klass.$$module === current_func.$$donated) {
        // this klass was the last one the module donated to
        // case is also hit with multiple module includes
        break;
      }
      else if (klass.$$iclass && klass.$$module === owner) {
        // module has donated to other classes but klass isn't one of those
        break;
      }
      else if (owner.$$is_singleton && klass === owner.$$singleton_of.$$class) {
        // cases like stdlib `Singleton::included` that use a singleton of a singleton
        break;
      }
      else if (klass === owner) {
        // no modules, pure class inheritance
        break;
      }

      klass = klass.$$parent;
    }

    return klass;
  };

  Opal.find_super_func = function(owning_klass, jsid, current_func) {
    var klass = owning_klass.$$parent;

    // now we can find the super
    while (klass) {
      var working = klass.$$proto[jsid];

      if (working && working !== current_func) {
        // ok
        break;
      }

      klass = klass.$$parent;
    }

    return klass.$$proto;
  };

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return true;
    }

    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && kwargs['$respond_to?']('to_hash', true)) {
      Array.prototype.splice.call(parameters, parameters.length - 1, 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  }

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key       = null,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block) {
    var body = (typeof(method) === 'string') ? recv['$'+method] : method;

    if (body != null) {
      body.$$p = block;
      return body.apply(recv, args);
    }

    return recv.$method_missing.apply(recv, [method].concat(args));
  }

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @return [null]
  //
  Opal.def = function(obj, jsid, body) {
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    if (!obj.$$eval && (obj.$$is_class || obj.$$is_module)) {
      Opal.defn(obj, jsid, body);
    }
    else {
      Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(obj, jsid, body) {
    obj.$$proto[jsid] = body;
    // for super dispatcher, etc.
    body.$$owner = obj;
    if (body.displayName == null) body.displayName = jsid.substr(1);

    // is it a module?
    if (obj.$$is_module) {
      Opal.update_includers(obj, jsid);

      if (obj.$$module_function) {
        Opal.defs(obj, jsid, body);
      }
    }

    // is it a bridged class?
    var bridged = obj.$__id__ && !obj.$__id__.$$stub && BridgedClasses[obj.$__id__()];
    if (bridged) {
      for (var i = bridged.length - 1; i >= 0; i--) {
        Opal.bridge_method(bridged[i], obj, jsid, body);
      }
    }

    // method_added/singleton_method_added hooks
    var singleton_of = obj.$$singleton_of;
    if (obj.$method_added && !obj.$method_added.$$stub && !singleton_of) {
      obj.$method_added(jsid.substr(1));
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(jsid.substr(1));
    }

    return nil;
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body) {
    Opal.defn(Opal.get_singleton_class(obj), jsid, body)
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    // TODO: remove from BridgedClasses as well

    if (!$hasOwn.call(obj.$$proto, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$proto[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$proto.$singleton_method_removed && !obj.$$proto.$singleton_method_removed.$$stub) {
        obj.$$proto.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$proto[jsid] || obj.$$proto[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$proto, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$proto.$singleton_method_undefined && !obj.$$proto.$singleton_method_undefined.$$stub) {
        obj.$$proto.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body   = obj.$$proto['$' + old],
        alias;

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (typeof(body) !== "function" || body.$$stub) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (typeof(body) !== "function" || body.$$stub) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise method $$owner and other properties
    // would be ovrewritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      if (block != null) { alias.$$p = null }

      return Opal.send(this, body, args, block);
    };

    // Try to make the browser pick the right name
    alias.displayName       = name;
    alias.length            = body.length;
    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$proto[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$hasOwn.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$hasOwn.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($hasOwn.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($hasOwn.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value;

    if (key.$$is_string) {
      if (!$hasOwn.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        if (keys[i] === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$hasOwn.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$hasOwn.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash.$$alloc();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($hasOwn.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash.$$alloc();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range.$$alloc();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  }


  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.'
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        return;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      module(Opal);
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        Opal.LoadError ? Opal.LoadError.$new(message) : function(){throw message}();
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Initialization
  // --------------

  // Constructors for *instances* of core objects
  Opal.boot_class_alloc('BasicObject', BasicObject_alloc);
  Opal.boot_class_alloc('Object',      Object_alloc,       BasicObject_alloc);
  Opal.boot_class_alloc('Module',      Module_alloc,       Object_alloc);
  Opal.boot_class_alloc('Class',       Class_alloc,        Module_alloc);

  // Constructors for *classes* of core objects
  Opal.BasicObject = BasicObject = Opal.setup_class_object('BasicObject', BasicObject_alloc, 'Class',       Class_alloc);
  Opal.Object      = _Object     = Opal.setup_class_object('Object',      Object_alloc,      'BasicObject', BasicObject.constructor);
  Opal.Module      = Module      = Opal.setup_class_object('Module',      Module_alloc,      'Object',      _Object.constructor);
  Opal.Class       = Class       = Opal.setup_class_object('Class',       Class_alloc,       'Module',      Module.constructor);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  Opal.const_set(_Object, "BasicObject",  BasicObject);
  Opal.const_set(_Object, "Object",       _Object);
  Opal.const_set(_Object, "Module",       Module);
  Opal.const_set(_Object, "Class",        Class);


  // Fix booted classes to use their metaclass
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;

  // Fix superclasses of booted classes
  BasicObject.$$super = null;
  _Object.$$super     = BasicObject;
  Module.$$super      = _Object;
  Class.$$super       = Module;

  BasicObject.$$parent = null;
  _Object.$$parent     = BasicObject;
  Module.$$parent      = _Object;
  Class.$$parent       = Module;

  // Forward .toString() to #to_s
  _Object.$$proto.toString = function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  };

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  _Object.$$proto.$require = Opal.require;

  // Instantiate the top object
  Opal.top = new _Object.$$alloc();

  // Nil
  Opal.klass(_Object, _Object, 'NilClass', NilClass_alloc);
  nil = Opal.nil = new NilClass_alloc();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');

  TypeError.$$super = Error;
}).call(this);
var Opal=this.Opal;Opal.loaded(["corelib/runtime"]);
/* Generated by Opal 0.11.4 */
Opal.modules["corelib/helpers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$class', '$===', '$respond_to?', '$raise', '$type_error', '$__send__', '$coerce_to', '$nil?', '$<=>', '$coerce_to!', '$!=', '$[]', '$upcase']);
  return (function($base, $parent_nesting) {
    var $Opal, self = $Opal = $module($base, 'Opal');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Opal_bridge_1, TMP_Opal_type_error_2, TMP_Opal_coerce_to_3, TMP_Opal_coerce_to$B_4, TMP_Opal_coerce_to$q_5, TMP_Opal_try_convert_6, TMP_Opal_compare_7, TMP_Opal_destructure_8, TMP_Opal_respond_to$q_9, TMP_Opal_inspect_obj_10, TMP_Opal_instance_variable_name$B_11, TMP_Opal_class_variable_name$B_12, TMP_Opal_const_name$B_13, TMP_Opal_pristine_14;

    
    Opal.defs(self, '$bridge', TMP_Opal_bridge_1 = function $$bridge(klass, constructor) {
      var self = this;

      return Opal.bridge(klass, constructor)
    }, TMP_Opal_bridge_1.$$arity = 2);
    Opal.defs(self, '$type_error', TMP_Opal_type_error_2 = function $$type_error(object, type, method, coerced) {
      var $a, self = this;

      if (method == null) {
        method = nil;
      }
      if (coerced == null) {
        coerced = nil;
      }
      if ($truthy(($truthy($a = method) ? coerced : $a))) {
        return Opal.const_get_relative($nesting, 'TypeError').$new("" + "can't convert " + (object.$class()) + " into " + (type) + " (" + (object.$class()) + "#" + (method) + " gives " + (coerced.$class()))
        } else {
        return Opal.const_get_relative($nesting, 'TypeError').$new("" + "no implicit conversion of " + (object.$class()) + " into " + (type))
      }
    }, TMP_Opal_type_error_2.$$arity = -3);
    Opal.defs(self, '$coerce_to', TMP_Opal_coerce_to_3 = function $$coerce_to(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
        } else {
        self.$raise(self.$type_error(object, type))
      };
      return object.$__send__(method);
    }, TMP_Opal_coerce_to_3.$$arity = 3);
    Opal.defs(self, '$coerce_to!', TMP_Opal_coerce_to$B_4 = function(object, type, method) {
      var self = this, coerced = nil;

      
      coerced = self.$coerce_to(object, type, method);
      if ($truthy(type['$==='](coerced))) {
        } else {
        self.$raise(self.$type_error(object, type, method, coerced))
      };
      return coerced;
    }, TMP_Opal_coerce_to$B_4.$$arity = 3);
    Opal.defs(self, '$coerce_to?', TMP_Opal_coerce_to$q_5 = function(object, type, method) {
      var self = this, coerced = nil;

      
      if ($truthy(object['$respond_to?'](method))) {
        } else {
        return nil
      };
      coerced = self.$coerce_to(object, type, method);
      if ($truthy(coerced['$nil?']())) {
        return nil};
      if ($truthy(type['$==='](coerced))) {
        } else {
        self.$raise(self.$type_error(object, type, method, coerced))
      };
      return coerced;
    }, TMP_Opal_coerce_to$q_5.$$arity = 3);
    Opal.defs(self, '$try_convert', TMP_Opal_try_convert_6 = function $$try_convert(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
        } else {
        return nil
      };
    }, TMP_Opal_try_convert_6.$$arity = 3);
    Opal.defs(self, '$compare', TMP_Opal_compare_7 = function $$compare(a, b) {
      var self = this, compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")};
      return compare;
    }, TMP_Opal_compare_7.$$arity = 2);
    Opal.defs(self, '$destructure', TMP_Opal_destructure_8 = function $$destructure(args) {
      var self = this;

      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, TMP_Opal_destructure_8.$$arity = 1);
    Opal.defs(self, '$respond_to?', TMP_Opal_respond_to$q_9 = function(obj, method) {
      var self = this;

      
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method);
    }, TMP_Opal_respond_to$q_9.$$arity = 2);
    Opal.defs(self, '$inspect_obj', TMP_Opal_inspect_obj_10 = function $$inspect_obj(obj) {
      var self = this;

      return Opal.inspect(obj)
    }, TMP_Opal_inspect_obj_10.$$arity = 1);
    Opal.defs(self, '$instance_variable_name!', TMP_Opal_instance_variable_name$B_11 = function(name) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](name, Opal.const_get_relative($nesting, 'String'), "to_str");
      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, TMP_Opal_instance_variable_name$B_11.$$arity = 1);
    Opal.defs(self, '$class_variable_name!', TMP_Opal_class_variable_name$B_12 = function(name) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](name, Opal.const_get_relative($nesting, 'String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "`" + (name) + "' is not allowed as a class variable name", name))};
      return name;
    }, TMP_Opal_class_variable_name$B_12.$$arity = 1);
    Opal.defs(self, '$const_name!', TMP_Opal_const_name$B_13 = function(const_name) {
      var self = this;

      
      const_name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](const_name, Opal.const_get_relative($nesting, 'String'), "to_str");
      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {
        self.$raise(Opal.const_get_relative($nesting, 'NameError'), "" + "wrong constant name " + (const_name))};
      return const_name;
    }, TMP_Opal_const_name$B_13.$$arity = 1);
    Opal.defs(self, '$pristine', TMP_Opal_pristine_14 = function $$pristine(owner_class, $a_rest) {
      var self = this, method_names;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      method_names = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        method_names[$arg_idx - 1] = arguments[$arg_idx];
      }
      
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$proto['$'+method_name];
        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, TMP_Opal_pristine_14.$$arity = -2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/module"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2;

  Opal.add_stubs(['$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$class_variable_name!', '$new', '$const_name!', '$=~', '$inject', '$split', '$const_get', '$==', '$!', '$start_with?', '$to_proc', '$lambda', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$+', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants']);
  return (function($base, $super, $parent_nesting) {
    function $Module(){};
    var self = $Module = $klass($base, $super, 'Module', $Module);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Module_allocate_1, TMP_Module_initialize_2, TMP_Module_$eq$eq$eq_3, TMP_Module_$lt_4, TMP_Module_$lt$eq_5, TMP_Module_$gt_6, TMP_Module_$gt$eq_7, TMP_Module_$lt$eq$gt_8, TMP_Module_alias_method_9, TMP_Module_alias_native_10, TMP_Module_ancestors_11, TMP_Module_append_features_12, TMP_Module_attr_accessor_13, TMP_Module_attr_reader_14, TMP_Module_attr_writer_15, TMP_Module_autoload_16, TMP_Module_class_variables_17, TMP_Module_class_variable_get_18, TMP_Module_class_variable_set_19, TMP_Module_class_variable_defined$q_20, TMP_Module_remove_class_variable_21, TMP_Module_constants_22, TMP_Module_constants_23, TMP_Module_nesting_24, TMP_Module_const_defined$q_25, TMP_Module_const_get_27, TMP_Module_const_missing_28, TMP_Module_const_set_29, TMP_Module_public_constant_30, TMP_Module_define_method_31, TMP_Module_remove_method_33, TMP_Module_singleton_class$q_34, TMP_Module_include_35, TMP_Module_included_modules_36, TMP_Module_include$q_37, TMP_Module_instance_method_38, TMP_Module_instance_methods_39, TMP_Module_included_40, TMP_Module_extended_41, TMP_Module_method_added_42, TMP_Module_method_removed_43, TMP_Module_method_undefined_44, TMP_Module_module_eval_45, TMP_Module_module_exec_47, TMP_Module_method_defined$q_48, TMP_Module_module_function_49, TMP_Module_name_50, TMP_Module_remove_const_51, TMP_Module_to_s_52, TMP_Module_undef_method_53, TMP_Module_instance_variables_54, TMP_Module_dup_55, TMP_Module_copy_class_variables_56, TMP_Module_copy_constants_57;

    
    Opal.defs(self, '$allocate', TMP_Module_allocate_1 = function $$allocate() {
      var self = this;

      
      var module;

      module = Opal.module_allocate(self);
      return module;
    
    }, TMP_Module_allocate_1.$$arity = 0);
    
    Opal.defn(self, '$initialize', TMP_Module_initialize_2 = function $$initialize() {
      var self = this, $iter = TMP_Module_initialize_2.$$p, block = $iter || nil;

      if ($iter) TMP_Module_initialize_2.$$p = null;
      return Opal.module_initialize(self, block)
    }, TMP_Module_initialize_2.$$arity = 0);
    
    Opal.defn(self, '$===', TMP_Module_$eq$eq$eq_3 = function(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false};
      return Opal.is_a(object, self);
    }, TMP_Module_$eq$eq$eq_3.$$arity = 1);
    
    Opal.defn(self, '$<', TMP_Module_$lt_4 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Module')['$==='](other))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, TMP_Module_$lt_4.$$arity = 1);
    
    Opal.defn(self, '$<=', TMP_Module_$lt$eq_5 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_lt(self, other))
    }, TMP_Module_$lt$eq_5.$$arity = 1);
    
    Opal.defn(self, '$>', TMP_Module_$gt_6 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Module')['$==='](other))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, TMP_Module_$gt_6.$$arity = 1);
    
    Opal.defn(self, '$>=', TMP_Module_$gt$eq_7 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_gt(self, other))
    }, TMP_Module_$gt$eq_7.$$arity = 1);
    
    Opal.defn(self, '$<=>', TMP_Module_$lt$eq$gt_8 = function(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if ($truthy(Opal.const_get_relative($nesting, 'Module')['$==='](other))) {
        } else {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil};
      if ($truthy(lt)) {
        return -1
        } else {
        return 1
      };
    }, TMP_Module_$lt$eq$gt_8.$$arity = 1);
    
    Opal.defn(self, '$alias_method', TMP_Module_alias_method_9 = function $$alias_method(newname, oldname) {
      var self = this;

      
      Opal.alias(self, newname, oldname);
      return self;
    }, TMP_Module_alias_method_9.$$arity = 2);
    
    Opal.defn(self, '$alias_native', TMP_Module_alias_native_10 = function $$alias_native(mid, jsid) {
      var self = this;

      if (jsid == null) {
        jsid = mid;
      }
      
      Opal.alias_native(self, mid, jsid);
      return self;
    }, TMP_Module_alias_native_10.$$arity = -2);
    
    Opal.defn(self, '$ancestors', TMP_Module_ancestors_11 = function $$ancestors() {
      var self = this;

      return Opal.ancestors(self)
    }, TMP_Module_ancestors_11.$$arity = 0);
    
    Opal.defn(self, '$append_features', TMP_Module_append_features_12 = function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, TMP_Module_append_features_12.$$arity = 1);
    
    Opal.defn(self, '$attr_accessor', TMP_Module_attr_accessor_13 = function $$attr_accessor($a_rest) {
      var self = this, names;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      names = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        names[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      $send(self, 'attr_reader', Opal.to_a(names));
      return $send(self, 'attr_writer', Opal.to_a(names));
    }, TMP_Module_attr_accessor_13.$$arity = -1);
    Opal.alias(self, "attr", "attr_accessor");
    
    Opal.defn(self, '$attr_reader', TMP_Module_attr_reader_14 = function $$attr_reader($a_rest) {
      var self = this, names;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      names = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        names[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      
      var proto = self.$$proto;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar) {
          return function() {
            if (this[ivar] == null) {
              return nil;
            }
            else {
              return this[ivar];
            }
          };
        })(ivar);

        // initialize the instance variable as nil
        proto[ivar] = nil;

        body.$$parameters = [];
        body.$$arity = 0;

        if (self.$$is_singleton) {
          proto.constructor.prototype[id] = body;
        }
        else {
          Opal.defn(self, id, body);
        }
      }
    ;
      return nil;
    }, TMP_Module_attr_reader_14.$$arity = -1);
    
    Opal.defn(self, '$attr_writer', TMP_Module_attr_writer_15 = function $$attr_writer($a_rest) {
      var self = this, names;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      names = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        names[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      
      var proto = self.$$proto;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar){
          return function(value) {
            return this[ivar] = value;
          }
        })(ivar);

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        proto[ivar] = nil;

        if (self.$$is_singleton) {
          proto.constructor.prototype[id] = body;
        }
        else {
          Opal.defn(self, id, body);
        }
      }
    ;
      return nil;
    }, TMP_Module_attr_writer_15.$$arity = -1);
    
    Opal.defn(self, '$autoload', TMP_Module_autoload_16 = function $$autoload(const$, path) {
      var self = this;

      
      if (self.$$autoload == null) self.$$autoload = {};
      Opal.const_cache_version++;
      self.$$autoload[const$] = path;
      return nil;
    
    }, TMP_Module_autoload_16.$$arity = 2);
    
    Opal.defn(self, '$class_variables', TMP_Module_class_variables_17 = function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self))
    }, TMP_Module_class_variables_17.$$arity = 0);
    
    Opal.defn(self, '$class_variable_get', TMP_Module_class_variable_get_18 = function $$class_variable_get(name) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$class_variable_name!'](name);
      
      var value = Opal.class_variables(self)[name];
      if (value == null) {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "uninitialized class variable " + (name) + " in " + (self), name))
      }
      return value;
    ;
    }, TMP_Module_class_variable_get_18.$$arity = 1);
    
    Opal.defn(self, '$class_variable_set', TMP_Module_class_variable_set_19 = function $$class_variable_set(name, value) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);
    }, TMP_Module_class_variable_set_19.$$arity = 2);
    
    Opal.defn(self, '$class_variable_defined?', TMP_Module_class_variable_defined$q_20 = function(name) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);
    }, TMP_Module_class_variable_defined$q_20.$$arity = 1);
    
    Opal.defn(self, '$remove_class_variable', TMP_Module_remove_class_variable_21 = function $$remove_class_variable(name) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "cannot remove " + (name) + " for " + (self)))
      }
    ;
    }, TMP_Module_remove_class_variable_21.$$arity = 1);
    
    Opal.defn(self, '$constants', TMP_Module_constants_22 = function $$constants(inherit) {
      var self = this;

      if (inherit == null) {
        inherit = true;
      }
      return Opal.constants(self, inherit)
    }, TMP_Module_constants_22.$$arity = -1);
    Opal.defs(self, '$constants', TMP_Module_constants_23 = function $$constants(inherit) {
      var self = this;

      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat(Opal.Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    
    }, TMP_Module_constants_23.$$arity = -1);
    Opal.defs(self, '$nesting', TMP_Module_nesting_24 = function $$nesting() {
      var self = this;

      return self.$$nesting || []
    }, TMP_Module_nesting_24.$$arity = 0);
    
    Opal.defn(self, '$const_defined?', TMP_Module_const_defined$q_25 = function(name, inherit) {
      var self = this;

      if (inherit == null) {
        inherit = true;
      }
      
      name = Opal.const_get_relative($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(name['$=~'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) {
          return true;
        }
      }

      return false;
    ;
    }, TMP_Module_const_defined$q_25.$$arity = -2);
    
    Opal.defn(self, '$const_get', TMP_Module_const_get_27 = function $$const_get(name, inherit) {
      var TMP_26, self = this;

      if (inherit == null) {
        inherit = true;
      }
      
      name = Opal.const_get_relative($nesting, 'Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], (TMP_26 = function(o, c){var self = TMP_26.$$s || this;
if (o == null) o = nil;if (c == null) c = nil;
        return o.$const_get(c)}, TMP_26.$$s = self, TMP_26.$$arity = 2, TMP_26))};
      if ($truthy(name['$=~'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return Opal.const_get_relative([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, TMP_Module_const_get_27.$$arity = -2);
    
    Opal.defn(self, '$const_missing', TMP_Module_const_missing_28 = function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      
      if (self.$$autoload) {
        var file = self.$$autoload[name];

        if (file) {
          self.$require(file);

          return self.$const_get(name);
        }
      }
    ;
      full_const_name = (function() {if (self['$=='](Opal.const_get_relative($nesting, 'Object'))) {
        return name
        } else {
        return "" + (self) + "::" + (name)
      }; return nil; })();
      return self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "uninitialized constant " + (full_const_name), name));
    }, TMP_Module_const_missing_28.$$arity = 1);
    
    Opal.defn(self, '$const_set', TMP_Module_const_set_29 = function $$const_set(name, value) {
      var $a, self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(($truthy($a = name['$=~'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Opal'), 'CONST_NAME_REGEXP'))['$!']()) ? $a : name['$start_with?']("::")))) {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))};
      Opal.const_set(self, name, value);
      return value;
    }, TMP_Module_const_set_29.$$arity = 2);
    
    Opal.defn(self, '$public_constant', TMP_Module_public_constant_30 = function $$public_constant(const_name) {
      var self = this;

      return nil
    }, TMP_Module_public_constant_30.$$arity = 1);
    
    Opal.defn(self, '$define_method', TMP_Module_define_method_31 = function $$define_method(name, method) {
      var $a, TMP_32, self = this, $iter = TMP_Module_define_method_31.$$p, block = $iter || nil, $case = nil;

      if ($iter) TMP_Module_define_method_31.$$p = null;
      
      if ($truthy(method === undefined && block === nil)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to create a Proc object without a block")};
      block = ($truthy($a = block) ? $a : (function() {$case = method;
      if (Opal.const_get_relative($nesting, 'Proc')['$===']($case)) {return method}
      else if (Opal.const_get_relative($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}
      else if (Opal.const_get_relative($nesting, 'UnboundMethod')['$===']($case)) {return $send(self, 'lambda', [], (TMP_32 = function($b_rest){var self = TMP_32.$$s || this, args, bound = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
      
        bound = method.$bind(self);
        return $send(bound, 'call', Opal.to_a(args));}, TMP_32.$$s = self, TMP_32.$$arity = -1, TMP_32))}
      else {return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "wrong argument type " + (block.$class()) + " (expected Proc/Method)")}})());
      
      var id = '$' + name;

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      Opal.defn(self, id, block);

      return name;
    ;
    }, TMP_Module_define_method_31.$$arity = -2);
    
    Opal.defn(self, '$remove_method', TMP_Module_remove_method_33 = function $$remove_method($a_rest) {
      var self = this, names;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      names = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        names[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, TMP_Module_remove_method_33.$$arity = -1);
    
    Opal.defn(self, '$singleton_class?', TMP_Module_singleton_class$q_34 = function() {
      var self = this;

      return !!self.$$is_singleton
    }, TMP_Module_singleton_class$q_34.$$arity = 0);
    
    Opal.defn(self, '$include', TMP_Module_include_35 = function $$include($a_rest) {
      var self = this, mods;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      mods = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        mods[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, TMP_Module_include_35.$$arity = -1);
    
    Opal.defn(self, '$included_modules', TMP_Module_included_modules_36 = function $$included_modules() {
      var self = this;

      
      var results;

      var module_chain = function(klass) {
        var included = [];

        for (var i = 0, ii = klass.$$inc.length; i < ii; i++) {
          var mod_or_class = klass.$$inc[i];
          included.push(mod_or_class);
          included = included.concat(module_chain(mod_or_class));
        }

        return included;
      };

      results = module_chain(self);

      // need superclass's modules
      if (self.$$is_class) {
        for (var cls = self; cls; cls = cls.$$super) {
          results = results.concat(module_chain(cls));
        }
      }

      return results;
    
    }, TMP_Module_included_modules_36.$$arity = 0);
    
    Opal.defn(self, '$include?', TMP_Module_include$q_37 = function(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, TMP_Module_include$q_37.$$arity = 1);
    
    Opal.defn(self, '$instance_method', TMP_Module_instance_method_38 = function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$proto['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return Opal.const_get_relative($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, TMP_Module_instance_method_38.$$arity = 1);
    
    Opal.defn(self, '$instance_methods', TMP_Module_instance_methods_39 = function $$instance_methods(include_super) {
      var self = this;

      if (include_super == null) {
        include_super = true;
      }
      
      var value,
          methods = [],
          proto   = self.$$proto;

      for (var prop in proto) {
        if (prop.charAt(0) !== '$' || prop.charAt(1) === '$') {
          continue;
        }

        value = proto[prop];

        if (typeof(value) !== "function") {
          continue;
        }

        if (value.$$stub) {
          continue;
        }

        if (!self.$$is_module) {
          if (self !== Opal.BasicObject && value === Opal.BasicObject.$$proto[prop]) {
            continue;
          }

          if (!include_super && !proto.hasOwnProperty(prop)) {
            continue;
          }

          if (!include_super && value.$$donated) {
            continue;
          }
        }

        methods.push(prop.substr(1));
      }

      return methods;
    
    }, TMP_Module_instance_methods_39.$$arity = -1);
    
    Opal.defn(self, '$included', TMP_Module_included_40 = function $$included(mod) {
      var self = this;

      return nil
    }, TMP_Module_included_40.$$arity = 1);
    
    Opal.defn(self, '$extended', TMP_Module_extended_41 = function $$extended(mod) {
      var self = this;

      return nil
    }, TMP_Module_extended_41.$$arity = 1);
    
    Opal.defn(self, '$method_added', TMP_Module_method_added_42 = function $$method_added($a_rest) {
      var self = this;

      return nil
    }, TMP_Module_method_added_42.$$arity = -1);
    
    Opal.defn(self, '$method_removed', TMP_Module_method_removed_43 = function $$method_removed($a_rest) {
      var self = this;

      return nil
    }, TMP_Module_method_removed_43.$$arity = -1);
    
    Opal.defn(self, '$method_undefined', TMP_Module_method_undefined_44 = function $$method_undefined($a_rest) {
      var self = this;

      return nil
    }, TMP_Module_method_undefined_44.$$arity = -1);
    
    Opal.defn(self, '$module_eval', TMP_Module_module_eval_45 = function $$module_eval($a_rest) {
      var $b, TMP_46, self = this, args, $iter = TMP_Module_module_eval_45.$$p, block = $iter || nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Module_module_eval_45.$$p = null;
      
      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          } else {
          Opal.const_get_relative($nesting, 'Kernel').$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy($b = file) ? $b : "(eval)"), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = Opal.const_get_relative($nesting, 'Opal').$compile(string, compiling_options);
        block = $send(Opal.const_get_relative($nesting, 'Kernel'), 'proc', [], (TMP_46 = function(){var self = TMP_46.$$s || this;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, TMP_46.$$s = self, TMP_46.$$arity = 0, TMP_46));
      } else if ($truthy($rb_gt(args.$size(), 0))) {
        Opal.const_get_relative($nesting, 'Kernel').$raise(Opal.const_get_relative($nesting, 'ArgumentError'), $rb_plus("" + "wrong number of arguments (" + (args.$size()) + " for 0)", "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n"))};
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, TMP_Module_module_eval_45.$$arity = -1);
    Opal.alias(self, "class_eval", "module_eval");
    
    Opal.defn(self, '$module_exec', TMP_Module_module_exec_47 = function $$module_exec($a_rest) {
      var self = this, args, $iter = TMP_Module_module_exec_47.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Module_module_exec_47.$$p = null;
      
      if (block === nil) {
        self.$raise(Opal.const_get_relative($nesting, 'LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    
    }, TMP_Module_module_exec_47.$$arity = -1);
    Opal.alias(self, "class_exec", "module_exec");
    
    Opal.defn(self, '$method_defined?', TMP_Module_method_defined$q_48 = function(method) {
      var self = this;

      
      var body = self.$$proto['$' + method];
      return (!!body) && !body.$$stub;
    
    }, TMP_Module_method_defined$q_48.$$arity = 1);
    
    Opal.defn(self, '$module_function', TMP_Module_module_function_49 = function $$module_function($a_rest) {
      var self = this, methods;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      methods = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        methods[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      if (methods.length === 0) {
        self.$$module_function = true;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$proto[id];

          Opal.defs(self, id, func);
        }
      }

      return self;
    
    }, TMP_Module_module_function_49.$$arity = -1);
    
    Opal.defn(self, '$name', TMP_Module_name_50 = function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === Opal.Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, TMP_Module_name_50.$$arity = 0);
    
    Opal.defn(self, '$remove_const', TMP_Module_remove_const_51 = function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name)
    }, TMP_Module_remove_const_51.$$arity = 1);
    
    Opal.defn(self, '$to_s', TMP_Module_to_s_52 = function $$to_s() {
      var $a, self = this;

      return ($truthy($a = Opal.Module.$name.call(self)) ? $a : "" + "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">")
    }, TMP_Module_to_s_52.$$arity = 0);
    
    Opal.defn(self, '$undef_method', TMP_Module_undef_method_53 = function $$undef_method($a_rest) {
      var self = this, names;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      names = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        names[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, TMP_Module_undef_method_53.$$arity = -1);
    
    Opal.defn(self, '$instance_variables', TMP_Module_instance_variables_54 = function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, TMP_Module_instance_variables_54.$$arity = 0);
    
    Opal.defn(self, '$dup', TMP_Module_dup_55 = function $$dup() {
      var self = this, $iter = TMP_Module_dup_55.$$p, $yield = $iter || nil, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Module_dup_55.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      copy = $send(self, Opal.find_super_dispatcher(self, 'dup', TMP_Module_dup_55, false), $zuper, $iter);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, TMP_Module_dup_55.$$arity = 0);
    
    Opal.defn(self, '$copy_class_variables', TMP_Module_copy_class_variables_56 = function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, TMP_Module_copy_class_variables_56.$$arity = 1);
    return (Opal.defn(self, '$copy_constants', TMP_Module_copy_constants_57 = function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        Opal.const_set(self, name, other_constants[name]);
      }
    
    }, TMP_Module_copy_constants_57.$$arity = 1), nil) && 'copy_constants';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/class"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$require', '$initialize_copy', '$allocate', '$name', '$to_s']);
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    function $Class(){};
    var self = $Class = $klass($base, $super, 'Class', $Class);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Class_new_1, TMP_Class_allocate_2, TMP_Class_inherited_3, TMP_Class_initialize_dup_4, TMP_Class_new_5, TMP_Class_superclass_6, TMP_Class_to_s_7;

    
    Opal.defs(self, '$new', TMP_Class_new_1 = function(superclass) {
      var self = this, $iter = TMP_Class_new_1.$$p, block = $iter || nil;

      if (superclass == null) {
        superclass = Opal.const_get_relative($nesting, 'Object');
      }
      if ($iter) TMP_Class_new_1.$$p = null;
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var alloc = Opal.boot_class_alloc(null, function(){}, superclass);
      var klass = Opal.setup_class_object(null, alloc, superclass.$$name, superclass.constructor);

      klass.$$super  = superclass;
      klass.$$parent = superclass;

      superclass.$inherited(klass);
      Opal.module_initialize(klass, block);

      return klass;
    
    }, TMP_Class_new_1.$$arity = -1);
    
    Opal.defn(self, '$allocate', TMP_Class_allocate_2 = function $$allocate() {
      var self = this;

      
      var obj = new self.$$alloc();
      obj.$$id = Opal.uid();
      return obj;
    
    }, TMP_Class_allocate_2.$$arity = 0);
    
    Opal.defn(self, '$inherited', TMP_Class_inherited_3 = function $$inherited(cls) {
      var self = this;

      return nil
    }, TMP_Class_inherited_3.$$arity = 1);
    
    Opal.defn(self, '$initialize_dup', TMP_Class_initialize_dup_4 = function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, TMP_Class_initialize_dup_4.$$arity = 1);
    
    Opal.defn(self, '$new', TMP_Class_new_5 = function($a_rest) {
      var self = this, args, $iter = TMP_Class_new_5.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Class_new_5.$$p = null;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    
    }, TMP_Class_new_5.$$arity = -1);
    
    Opal.defn(self, '$superclass', TMP_Class_superclass_6 = function $$superclass() {
      var self = this;

      return self.$$super || nil
    }, TMP_Class_superclass_6.$$arity = 0);
    return (Opal.defn(self, '$to_s', TMP_Class_to_s_7 = function $$to_s() {
      var self = this, $iter = TMP_Class_to_s_7.$$p, $yield = $iter || nil;

      if ($iter) TMP_Class_to_s_7.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && (singleton_of.$$is_class || singleton_of.$$is_module)) {
        return "" + "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "" + "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }
      return $send(self, Opal.find_super_dispatcher(self, 'to_s', TMP_Class_to_s_7, false), [], null);
    
    }, TMP_Class_to_s_7.$$arity = 0), nil) && 'to_s';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/basic_object"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$>', '$new', '$inspect']);
  return (function($base, $super, $parent_nesting) {
    function $BasicObject(){};
    var self = $BasicObject = $klass($base, $super, 'BasicObject', $BasicObject);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BasicObject_initialize_1, TMP_BasicObject_$eq$eq_2, TMP_BasicObject_eql$q_3, TMP_BasicObject___id___4, TMP_BasicObject___send___5, TMP_BasicObject_$B_6, TMP_BasicObject_$B$eq_7, TMP_BasicObject_instance_eval_8, TMP_BasicObject_instance_exec_10, TMP_BasicObject_singleton_method_added_11, TMP_BasicObject_singleton_method_removed_12, TMP_BasicObject_singleton_method_undefined_13, TMP_BasicObject_method_missing_14;

    
    
    Opal.defn(self, '$initialize', TMP_BasicObject_initialize_1 = function $$initialize($a_rest) {
      var self = this;

      return nil
    }, TMP_BasicObject_initialize_1.$$arity = -1);
    
    Opal.defn(self, '$==', TMP_BasicObject_$eq$eq_2 = function(other) {
      var self = this;

      return self === other
    }, TMP_BasicObject_$eq$eq_2.$$arity = 1);
    
    Opal.defn(self, '$eql?', TMP_BasicObject_eql$q_3 = function(other) {
      var self = this;

      return self['$=='](other)
    }, TMP_BasicObject_eql$q_3.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    
    Opal.defn(self, '$__id__', TMP_BasicObject___id___4 = function $$__id__() {
      var self = this;

      return self.$$id || (self.$$id = Opal.uid())
    }, TMP_BasicObject___id___4.$$arity = 0);
    
    Opal.defn(self, '$__send__', TMP_BasicObject___send___5 = function $$__send__(symbol, $a_rest) {
      var self = this, args, $iter = TMP_BasicObject___send___5.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      if ($iter) TMP_BasicObject___send___5.$$p = null;
      
      var func = self['$' + symbol]

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    
    }, TMP_BasicObject___send___5.$$arity = -2);
    
    Opal.defn(self, '$!', TMP_BasicObject_$B_6 = function() {
      var self = this;

      return false
    }, TMP_BasicObject_$B_6.$$arity = 0);
    
    Opal.defn(self, '$!=', TMP_BasicObject_$B$eq_7 = function(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, TMP_BasicObject_$B$eq_7.$$arity = 1);
    
    Opal.defn(self, '$instance_eval', TMP_BasicObject_instance_eval_8 = function $$instance_eval($a_rest) {
      var $b, TMP_9, self = this, args, $iter = TMP_BasicObject_instance_eval_8.$$p, block = $iter || nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_BasicObject_instance_eval_8.$$p = null;
      
      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          } else {
          Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy($b = file) ? $b : "(eval)"), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = Opal.const_get_qualified('::', 'Opal').$compile(string, compiling_options);
        block = $send(Opal.const_get_qualified('::', 'Kernel'), 'proc', [], (TMP_9 = function(){var self = TMP_9.$$s || this;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9));
      } else if ($truthy($rb_gt(args.$size(), 0))) {
        Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'ArgumentError'), "" + "wrong number of arguments (" + (args.$size()) + " for 0)")};
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_class || self.$$is_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, TMP_BasicObject_instance_eval_8.$$arity = -1);
    
    Opal.defn(self, '$instance_exec', TMP_BasicObject_instance_exec_10 = function $$instance_exec($a_rest) {
      var self = this, args, $iter = TMP_BasicObject_instance_exec_10.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_BasicObject_instance_exec_10.$$p = null;
      
      if ($truthy(block)) {
        } else {
        Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_class || self.$$is_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, TMP_BasicObject_instance_exec_10.$$arity = -1);
    
    Opal.defn(self, '$singleton_method_added', TMP_BasicObject_singleton_method_added_11 = function $$singleton_method_added($a_rest) {
      var self = this;

      return nil
    }, TMP_BasicObject_singleton_method_added_11.$$arity = -1);
    
    Opal.defn(self, '$singleton_method_removed', TMP_BasicObject_singleton_method_removed_12 = function $$singleton_method_removed($a_rest) {
      var self = this;

      return nil
    }, TMP_BasicObject_singleton_method_removed_12.$$arity = -1);
    
    Opal.defn(self, '$singleton_method_undefined', TMP_BasicObject_singleton_method_undefined_13 = function $$singleton_method_undefined($a_rest) {
      var self = this;

      return nil
    }, TMP_BasicObject_singleton_method_undefined_13.$$arity = -1);
    return (Opal.defn(self, '$method_missing', TMP_BasicObject_method_missing_14 = function $$method_missing(symbol, $a_rest) {
      var self = this, args, $iter = TMP_BasicObject_method_missing_14.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      if ($iter) TMP_BasicObject_method_missing_14.$$p = null;
      return Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_qualified('::', 'NoMethodError').$new((function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$inspect()) + ":" + (self.$$class)
        } else {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$$class)
      }; return nil; })(), symbol))
    }, TMP_BasicObject_method_missing_14.$$arity = -2), nil) && 'method_missing';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/kernel"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;

  Opal.add_stubs(['$raise', '$new', '$inspect', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$>', '$size', '$pop', '$call', '$coerce_to', '$append_features', '$extended', '$length', '$respond_to?', '$[]', '$nil?', '$to_a', '$to_int', '$fetch', '$Integer', '$Float', '$to_ary', '$to_str', '$to_s', '$__id__', '$instance_variable_name!', '$coerce_to!', '$===', '$enum_for', '$result', '$print', '$format', '$puts', '$each', '$<=', '$empty?', '$exception', '$kind_of?', '$rand', '$respond_to_missing?', '$try_convert!', '$expand_path', '$join', '$start_with?', '$srand', '$new_seed', '$sym', '$arg', '$open', '$include']);
  
  (function($base, $parent_nesting) {
    var $Kernel, self = $Kernel = $module($base, 'Kernel');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_method_missing_1, TMP_Kernel_$eq$_2, TMP_Kernel_$B$_3, TMP_Kernel_$eq$eq$eq_4, TMP_Kernel_$lt$eq$gt_5, TMP_Kernel_method_6, TMP_Kernel_methods_7, TMP_Kernel_Array_8, TMP_Kernel_at_exit_9, TMP_Kernel_caller_10, TMP_Kernel_class_11, TMP_Kernel_copy_instance_variables_12, TMP_Kernel_copy_singleton_methods_13, TMP_Kernel_clone_14, TMP_Kernel_initialize_clone_15, TMP_Kernel_define_singleton_method_16, TMP_Kernel_dup_17, TMP_Kernel_initialize_dup_18, TMP_Kernel_enum_for_19, TMP_Kernel_equal$q_20, TMP_Kernel_exit_21, TMP_Kernel_extend_22, TMP_Kernel_format_23, TMP_Kernel_hash_24, TMP_Kernel_initialize_copy_25, TMP_Kernel_inspect_26, TMP_Kernel_instance_of$q_27, TMP_Kernel_instance_variable_defined$q_28, TMP_Kernel_instance_variable_get_29, TMP_Kernel_instance_variable_set_30, TMP_Kernel_remove_instance_variable_31, TMP_Kernel_instance_variables_32, TMP_Kernel_Integer_33, TMP_Kernel_Float_34, TMP_Kernel_Hash_35, TMP_Kernel_is_a$q_36, TMP_Kernel_itself_37, TMP_Kernel_lambda_38, TMP_Kernel_load_39, TMP_Kernel_loop_40, TMP_Kernel_nil$q_42, TMP_Kernel_printf_43, TMP_Kernel_proc_44, TMP_Kernel_puts_45, TMP_Kernel_p_47, TMP_Kernel_print_48, TMP_Kernel_warn_49, TMP_Kernel_raise_50, TMP_Kernel_rand_51, TMP_Kernel_respond_to$q_52, TMP_Kernel_respond_to_missing$q_53, TMP_Kernel_require_54, TMP_Kernel_require_relative_55, TMP_Kernel_require_tree_56, TMP_Kernel_singleton_class_57, TMP_Kernel_sleep_58, TMP_Kernel_srand_59, TMP_Kernel_String_60, TMP_Kernel_tap_61, TMP_Kernel_to_proc_62, TMP_Kernel_to_s_63, TMP_Kernel_catch_64, TMP_Kernel_throw_65, TMP_Kernel_open_66;

    
    
    Opal.defn(self, '$method_missing', TMP_Kernel_method_missing_1 = function $$method_missing(symbol, $a_rest) {
      var self = this, args, $iter = TMP_Kernel_method_missing_1.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      if ($iter) TMP_Kernel_method_missing_1.$$p = null;
      return self.$raise(Opal.const_get_relative($nesting, 'NoMethodError').$new("" + "undefined method `" + (symbol) + "' for " + (self.$inspect()), symbol, args))
    }, TMP_Kernel_method_missing_1.$$arity = -2);
    
    Opal.defn(self, '$=~', TMP_Kernel_$eq$_2 = function(obj) {
      var self = this;

      return false
    }, TMP_Kernel_$eq$_2.$$arity = 1);
    
    Opal.defn(self, '$!~', TMP_Kernel_$B$_3 = function(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, TMP_Kernel_$B$_3.$$arity = 1);
    
    Opal.defn(self, '$===', TMP_Kernel_$eq$eq$eq_4 = function(other) {
      var $a, self = this;

      return ($truthy($a = self.$object_id()['$=='](other.$object_id())) ? $a : self['$=='](other))
    }, TMP_Kernel_$eq$eq$eq_4.$$arity = 1);
    
    Opal.defn(self, '$<=>', TMP_Kernel_$lt$eq$gt_5 = function(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, TMP_Kernel_$lt$eq$gt_5.$$arity = 1);
    
    Opal.defn(self, '$method', TMP_Kernel_method_6 = function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return Opal.const_get_relative($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, TMP_Kernel_method_6.$$arity = 1);
    
    Opal.defn(self, '$methods', TMP_Kernel_methods_7 = function $$methods(all) {
      var self = this;

      if (all == null) {
        all = true;
      }
      
      var methods = [];

      for (var key in self) {
        if (key[0] == "$" && typeof(self[key]) === "function") {
          if (all == false || all === nil) {
            if (!Opal.hasOwnProperty.call(self, key)) {
              continue;
            }
          }
          if (self[key].$$stub === undefined) {
            methods.push(key.substr(1));
          }
        }
      }

      return methods;
    
    }, TMP_Kernel_methods_7.$$arity = -1);
    Opal.alias(self, "public_methods", "methods");
    
    Opal.defn(self, '$Array', TMP_Kernel_Array_8 = function $$Array(object) {
      var self = this;

      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](object, Opal.const_get_relative($nesting, 'Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](object, Opal.const_get_relative($nesting, 'Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, TMP_Kernel_Array_8.$$arity = 1);
    
    Opal.defn(self, '$at_exit', TMP_Kernel_at_exit_9 = function $$at_exit() {
      var $a, self = this, $iter = TMP_Kernel_at_exit_9.$$p, block = $iter || nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      if ($iter) TMP_Kernel_at_exit_9.$$p = null;
      
      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);
      return $gvars.__at_exit__['$<<'](block);
    }, TMP_Kernel_at_exit_9.$$arity = 0);
    
    Opal.defn(self, '$caller', TMP_Kernel_caller_10 = function $$caller($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return []
    }, TMP_Kernel_caller_10.$$arity = -1);
    
    Opal.defn(self, '$class', TMP_Kernel_class_11 = function() {
      var self = this;

      return self.$$class
    }, TMP_Kernel_class_11.$$arity = 0);
    
    Opal.defn(self, '$copy_instance_variables', TMP_Kernel_copy_instance_variables_12 = function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, TMP_Kernel_copy_instance_variables_12.$$arity = 1);
    
    Opal.defn(self, '$copy_singleton_methods', TMP_Kernel_copy_singleton_methods_13 = function $$copy_singleton_methods(other) {
      var self = this;

      
      var name;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class_proto = Opal.get_singleton_class(other).$$proto;
        var self_singleton_class_proto = Opal.get_singleton_class(self).$$proto;

        for (name in other_singleton_class_proto) {
          if (name.charAt(0) === '$' && other_singleton_class_proto.hasOwnProperty(name)) {
            self_singleton_class_proto[name] = other_singleton_class_proto[name];
          }
        }
      }

      for (name in other) {
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, TMP_Kernel_copy_singleton_methods_13.$$arity = 1);
    
    Opal.defn(self, '$clone', TMP_Kernel_clone_14 = function $$clone($kwargs) {
      var self = this, freeze, copy = nil;

      if ($kwargs == null || !$kwargs.$$is_hash) {
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else {
          throw Opal.ArgumentError.$new('expected kwargs');
        }
      }
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      }
      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, TMP_Kernel_clone_14.$$arity = -1);
    
    Opal.defn(self, '$initialize_clone', TMP_Kernel_initialize_clone_15 = function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, TMP_Kernel_initialize_clone_15.$$arity = 1);
    
    Opal.defn(self, '$define_singleton_method', TMP_Kernel_define_singleton_method_16 = function $$define_singleton_method(name, method) {
      var self = this, $iter = TMP_Kernel_define_singleton_method_16.$$p, block = $iter || nil;

      if ($iter) TMP_Kernel_define_singleton_method_16.$$p = null;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc())
    }, TMP_Kernel_define_singleton_method_16.$$arity = -2);
    
    Opal.defn(self, '$dup', TMP_Kernel_dup_17 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, TMP_Kernel_dup_17.$$arity = 0);
    
    Opal.defn(self, '$initialize_dup', TMP_Kernel_initialize_dup_18 = function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, TMP_Kernel_initialize_dup_18.$$arity = 1);
    
    Opal.defn(self, '$enum_for', TMP_Kernel_enum_for_19 = function $$enum_for(method, $a_rest) {
      var self = this, args, $iter = TMP_Kernel_enum_for_19.$$p, block = $iter || nil;

      if (method == null) {
        method = "each";
      }
      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      if ($iter) TMP_Kernel_enum_for_19.$$p = null;
      return $send(Opal.const_get_relative($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc())
    }, TMP_Kernel_enum_for_19.$$arity = -1);
    Opal.alias(self, "to_enum", "enum_for");
    
    Opal.defn(self, '$equal?', TMP_Kernel_equal$q_20 = function(other) {
      var self = this;

      return self === other
    }, TMP_Kernel_equal$q_20.$$arity = 1);
    
    Opal.defn(self, '$exit', TMP_Kernel_exit_21 = function $$exit(status) {
      var $a, self = this, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      if (status == null) {
        status = true;
      }
      
      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);
      while ($truthy($rb_gt($gvars.__at_exit__.$size(), 0))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = Opal.const_get_relative($nesting, 'Opal').$coerce_to(status, Opal.const_get_relative($nesting, 'Integer'), "to_int")
      }

      Opal.exit(status);
    ;
      return nil;
    }, TMP_Kernel_exit_21.$$arity = -1);
    
    Opal.defn(self, '$extend', TMP_Kernel_extend_22 = function $$extend($a_rest) {
      var self = this, mods;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      mods = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        mods[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extended(self);
      }
    ;
      return self;
    }, TMP_Kernel_extend_22.$$arity = -1);
    
    Opal.defn(self, '$format', TMP_Kernel_format_23 = function $$format(format_string, $a_rest) {
      var $b, self = this, args, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      
      if ($truthy((($b = args.$length()['$=='](1)) ? args['$[]'](0)['$respond_to?']("to_ary") : args.$length()['$=='](1)))) {
        
        ary = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](args['$[]'](0), Opal.const_get_relative($nesting, 'Array'), "to_ary");
        if ($truthy(ary['$nil?']())) {
          } else {
          args = ary.$to_a()
        };};
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "flag after width") }
        if (flags&FPREC0) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "width given twice") }
        if (flags&FPREC0) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with numbered")
        case -2: self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with named")
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = self.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode(Opal.const_get_relative($nesting, 'Opal').$coerce_to(arg, Opal.const_get_relative($nesting, 'Integer'), "to_int"));
            }
            if (str.length !== 1) {
              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, TMP_Kernel_format_23.$$arity = -2);
    
    Opal.defn(self, '$hash', TMP_Kernel_hash_24 = function $$hash() {
      var self = this;

      return self.$__id__()
    }, TMP_Kernel_hash_24.$$arity = 0);
    
    Opal.defn(self, '$initialize_copy', TMP_Kernel_initialize_copy_25 = function $$initialize_copy(other) {
      var self = this;

      return nil
    }, TMP_Kernel_initialize_copy_25.$$arity = 1);
    
    Opal.defn(self, '$inspect', TMP_Kernel_inspect_26 = function $$inspect() {
      var self = this;

      return self.$to_s()
    }, TMP_Kernel_inspect_26.$$arity = 0);
    
    Opal.defn(self, '$instance_of?', TMP_Kernel_instance_of$q_27 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, TMP_Kernel_instance_of$q_27.$$arity = 1);
    
    Opal.defn(self, '$instance_variable_defined?', TMP_Kernel_instance_variable_defined$q_28 = function(name) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));
    }, TMP_Kernel_instance_variable_defined$q_28.$$arity = 1);
    
    Opal.defn(self, '$instance_variable_get', TMP_Kernel_instance_variable_get_29 = function $$instance_variable_get(name) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, TMP_Kernel_instance_variable_get_29.$$arity = 1);
    
    Opal.defn(self, '$instance_variable_set', TMP_Kernel_instance_variable_set_30 = function $$instance_variable_set(name, value) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;
    }, TMP_Kernel_instance_variable_set_30.$$arity = 2);
    
    Opal.defn(self, '$remove_instance_variable', TMP_Kernel_remove_instance_variable_31 = function $$remove_instance_variable(name) {
      var self = this;

      
      name = Opal.const_get_relative($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return self.$raise(Opal.const_get_relative($nesting, 'NameError'), "" + "instance variable " + (name) + " not defined");
    }, TMP_Kernel_remove_instance_variable_31.$$arity = 1);
    
    Opal.defn(self, '$instance_variables', TMP_Kernel_instance_variables_32 = function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, TMP_Kernel_instance_variables_32.$$arity = 0);
    
    Opal.defn(self, '$Integer', TMP_Kernel_Integer_33 = function $$Integer(value, base) {
      var self = this;

      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](value, Opal.const_get_relative($nesting, 'Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = Opal.const_get_relative($nesting, 'Opal').$coerce_to(base, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if (base === 1 || base < 0 || base > 36) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
        }
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    
    }, TMP_Kernel_Integer_33.$$arity = -2);
    
    Opal.defn(self, '$Float', TMP_Kernel_Float_34 = function $$Float(value) {
      var self = this;

      
      var str;

      if (value === nil) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return self.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](value, Opal.const_get_relative($nesting, 'Float'), "to_f");
    
    }, TMP_Kernel_Float_34.$$arity = 1);
    
    Opal.defn(self, '$Hash', TMP_Kernel_Hash_35 = function $$Hash(arg) {
      var $a, self = this;

      
      if ($truthy(($truthy($a = arg['$nil?']()) ? $a : arg['$==']([])))) {
        return $hash2([], {})};
      if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](arg))) {
        return arg};
      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](arg, Opal.const_get_relative($nesting, 'Hash'), "to_hash");
    }, TMP_Kernel_Hash_35.$$arity = 1);
    
    Opal.defn(self, '$is_a?', TMP_Kernel_is_a$q_36 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, TMP_Kernel_is_a$q_36.$$arity = 1);
    
    Opal.defn(self, '$itself', TMP_Kernel_itself_37 = function $$itself() {
      var self = this;

      return self
    }, TMP_Kernel_itself_37.$$arity = 0);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.defn(self, '$lambda', TMP_Kernel_lambda_38 = function $$lambda() {
      var self = this, $iter = TMP_Kernel_lambda_38.$$p, block = $iter || nil;

      if ($iter) TMP_Kernel_lambda_38.$$p = null;
      
      block.$$is_lambda = true;
      return block;
    }, TMP_Kernel_lambda_38.$$arity = 0);
    
    Opal.defn(self, '$load', TMP_Kernel_load_39 = function $$load(file) {
      var self = this;

      
      file = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](file, Opal.const_get_relative($nesting, 'String'), "to_str");
      return Opal.load(file);
    }, TMP_Kernel_load_39.$$arity = 1);
    
    Opal.defn(self, '$loop', TMP_Kernel_loop_40 = function $$loop() {
      var TMP_41, $a, self = this, $iter = TMP_Kernel_loop_40.$$p, $yield = $iter || nil, e = nil;

      if ($iter) TMP_Kernel_loop_40.$$p = null;
      
      if (($yield !== nil)) {
        } else {
        return $send(self, 'enum_for', ["loop"], (TMP_41 = function(){var self = TMP_41.$$s || this;

        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')}, TMP_41.$$s = self, TMP_41.$$arity = 0, TMP_41))
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StopIteration')])) {e = $err;
            try {
              return e.$result()
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      };
      return self;
    }, TMP_Kernel_loop_40.$$arity = 0);
    
    Opal.defn(self, '$nil?', TMP_Kernel_nil$q_42 = function() {
      var self = this;

      return false
    }, TMP_Kernel_nil$q_42.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.defn(self, '$printf', TMP_Kernel_printf_43 = function $$printf($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      if ($truthy($rb_gt(args.$length(), 0))) {
        self.$print($send(self, 'format', Opal.to_a(args)))};
      return nil;
    }, TMP_Kernel_printf_43.$$arity = -1);
    
    Opal.defn(self, '$proc', TMP_Kernel_proc_44 = function $$proc() {
      var self = this, $iter = TMP_Kernel_proc_44.$$p, block = $iter || nil;

      if ($iter) TMP_Kernel_proc_44.$$p = null;
      
      if ($truthy(block)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, TMP_Kernel_proc_44.$$arity = 0);
    
    Opal.defn(self, '$puts', TMP_Kernel_puts_45 = function $$puts($a_rest) {
      var self = this, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      strs = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        strs[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send($gvars.stdout, 'puts', Opal.to_a(strs))
    }, TMP_Kernel_puts_45.$$arity = -1);
    
    Opal.defn(self, '$p', TMP_Kernel_p_47 = function $$p($a_rest) {
      var TMP_46, self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      $send(args, 'each', [], (TMP_46 = function(obj){var self = TMP_46.$$s || this;
        if ($gvars.stdout == null) $gvars.stdout = nil;
if (obj == null) obj = nil;
      return $gvars.stdout.$puts(obj.$inspect())}, TMP_46.$$s = self, TMP_46.$$arity = 1, TMP_46));
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
        } else {
        return args
      };
    }, TMP_Kernel_p_47.$$arity = -1);
    
    Opal.defn(self, '$print', TMP_Kernel_print_48 = function $$print($a_rest) {
      var self = this, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      strs = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        strs[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send($gvars.stdout, 'print', Opal.to_a(strs))
    }, TMP_Kernel_print_48.$$arity = -1);
    
    Opal.defn(self, '$warn', TMP_Kernel_warn_49 = function $$warn($a_rest) {
      var $b, self = this, strs;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      strs = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        strs[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($truthy(($truthy($b = $gvars.VERBOSE['$nil?']()) ? $b : strs['$empty?']()))) {
        return nil
        } else {
        return $send($gvars.stderr, 'puts', Opal.to_a(strs))
      }
    }, TMP_Kernel_warn_49.$$arity = -1);
    
    Opal.defn(self, '$raise', TMP_Kernel_raise_50 = function $$raise(exception, string, _backtrace) {
      var self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      if (string == null) {
        string = nil;
      }
      if (_backtrace == null) {
        _backtrace = nil;
      }
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = Opal.const_get_relative($nesting, 'RuntimeError').$new();
      }
      else if (exception.$$is_string) {
        exception = Opal.const_get_relative($nesting, 'RuntimeError').$new(exception);
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && exception['$respond_to?']("exception")) {
        exception = exception.$exception(string);
      }
      else if (exception['$kind_of?'](Opal.const_get_relative($nesting, 'Exception'))) {
        // exception is fine
      }
      else {
        exception = Opal.const_get_relative($nesting, 'TypeError').$new("exception class/object expected");
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;

      throw exception;
    
    }, TMP_Kernel_raise_50.$$arity = -1);
    Opal.alias(self, "fail", "raise");
    
    Opal.defn(self, '$rand', TMP_Kernel_rand_51 = function $$rand(max) {
      var self = this;

      
      
      if (max === undefined) {
        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Random'), 'DEFAULT').$rand(max);
    }, TMP_Kernel_rand_51.$$arity = -1);
    
    Opal.defn(self, '$respond_to?', TMP_Kernel_respond_to$q_52 = function(name, include_all) {
      var self = this;

      if (include_all == null) {
        include_all = false;
      }
      
      if ($truthy(self['$respond_to_missing?'](name, include_all))) {
        return true};
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
    ;
      return false;
    }, TMP_Kernel_respond_to$q_52.$$arity = -2);
    
    Opal.defn(self, '$respond_to_missing?', TMP_Kernel_respond_to_missing$q_53 = function(method_name, include_all) {
      var self = this;

      if (include_all == null) {
        include_all = false;
      }
      return false
    }, TMP_Kernel_respond_to_missing$q_53.$$arity = -2);
    
    Opal.defn(self, '$require', TMP_Kernel_require_54 = function $$require(file) {
      var self = this;

      
      file = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](file, Opal.const_get_relative($nesting, 'String'), "to_str");
      return Opal.require(file);
    }, TMP_Kernel_require_54.$$arity = 1);
    
    Opal.defn(self, '$require_relative', TMP_Kernel_require_relative_55 = function $$require_relative(file) {
      var self = this;

      
      Opal.const_get_relative($nesting, 'Opal')['$try_convert!'](file, Opal.const_get_relative($nesting, 'String'), "to_str");
      file = Opal.const_get_relative($nesting, 'File').$expand_path(Opal.const_get_relative($nesting, 'File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, TMP_Kernel_require_relative_55.$$arity = 1);
    
    Opal.defn(self, '$require_tree', TMP_Kernel_require_tree_56 = function $$require_tree(path) {
      var self = this;

      
      var result = [];

      path = Opal.const_get_relative($nesting, 'File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          result.push([name, Opal.require(name)]);
        }
      }

      return result;
    
    }, TMP_Kernel_require_tree_56.$$arity = 1);
    Opal.alias(self, "send", "__send__");
    Opal.alias(self, "public_send", "__send__");
    
    Opal.defn(self, '$singleton_class', TMP_Kernel_singleton_class_57 = function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self)
    }, TMP_Kernel_singleton_class_57.$$arity = 0);
    
    Opal.defn(self, '$sleep', TMP_Kernel_sleep_58 = function $$sleep(seconds) {
      var self = this;

      if (seconds == null) {
        seconds = nil;
      }
      
      if (seconds === nil) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return seconds;
    
    }, TMP_Kernel_sleep_58.$$arity = -1);
    Opal.alias(self, "sprintf", "format");
    
    Opal.defn(self, '$srand', TMP_Kernel_srand_59 = function $$srand(seed) {
      var self = this;

      if (seed == null) {
        seed = Opal.const_get_relative($nesting, 'Random').$new_seed();
      }
      return Opal.const_get_relative($nesting, 'Random').$srand(seed)
    }, TMP_Kernel_srand_59.$$arity = -1);
    
    Opal.defn(self, '$String', TMP_Kernel_String_60 = function $$String(str) {
      var $a, self = this;

      return ($truthy($a = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](str, Opal.const_get_relative($nesting, 'String'), "to_str")) ? $a : Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](str, Opal.const_get_relative($nesting, 'String'), "to_s"))
    }, TMP_Kernel_String_60.$$arity = 1);
    
    Opal.defn(self, '$tap', TMP_Kernel_tap_61 = function $$tap() {
      var self = this, $iter = TMP_Kernel_tap_61.$$p, block = $iter || nil;

      if ($iter) TMP_Kernel_tap_61.$$p = null;
      
      Opal.yield1(block, self);
      return self;
    }, TMP_Kernel_tap_61.$$arity = 0);
    
    Opal.defn(self, '$to_proc', TMP_Kernel_to_proc_62 = function $$to_proc() {
      var self = this;

      return self
    }, TMP_Kernel_to_proc_62.$$arity = 0);
    
    Opal.defn(self, '$to_s', TMP_Kernel_to_s_63 = function $$to_s() {
      var self = this;

      return "" + "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, TMP_Kernel_to_s_63.$$arity = 0);
    
    Opal.defn(self, '$catch', TMP_Kernel_catch_64 = function(sym) {
      var self = this, $iter = TMP_Kernel_catch_64.$$p, $yield = $iter || nil, e = nil;

      if ($iter) TMP_Kernel_catch_64.$$p = null;
      try {
        return Opal.yieldX($yield, []);
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'UncaughtThrowError')])) {e = $err;
          try {
            
            if (e.$sym()['$=='](sym)) {
              return e.$arg()};
            return self.$raise();
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, TMP_Kernel_catch_64.$$arity = 1);
    
    Opal.defn(self, '$throw', TMP_Kernel_throw_65 = function($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return self.$raise(Opal.const_get_relative($nesting, 'UncaughtThrowError').$new(args))
    }, TMP_Kernel_throw_65.$$arity = -1);
    
    Opal.defn(self, '$open', TMP_Kernel_open_66 = function $$open($a_rest) {
      var self = this, args, $iter = TMP_Kernel_open_66.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Kernel_open_66.$$p = null;
      return $send(Opal.const_get_relative($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc())
    }, TMP_Kernel_open_66.$$arity = -1);
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    function $Object(){};
    var self = $Object = $klass($base, $super, 'Object', $Object);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return self.$include(Opal.const_get_relative($nesting, 'Kernel'))
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/error"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$new', '$clone', '$to_s', '$empty?', '$class', '$+', '$attr_reader', '$[]', '$>', '$length', '$inspect']);
  
  (function($base, $super, $parent_nesting) {
    function $Exception(){};
    var self = $Exception = $klass($base, $super, 'Exception', $Exception);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Exception_new_1, TMP_Exception_exception_2, TMP_Exception_initialize_3, TMP_Exception_backtrace_4, TMP_Exception_exception_5, TMP_Exception_message_6, TMP_Exception_inspect_7, TMP_Exception_to_s_8;

    def.message = nil;
    
    var Kernel$raise = Opal.const_get_relative($nesting, 'Kernel').$raise;
    Opal.defs(self, '$new', TMP_Exception_new_1 = function($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$alloc(message);
      error.name    = self.$$name;
      error.message = message;
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, Kernel$raise);
      }

      return error;
    
    }, TMP_Exception_new_1.$$arity = -1);
    Opal.defs(self, '$exception', TMP_Exception_exception_2 = function $$exception($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send(self, 'new', Opal.to_a(args))
    }, TMP_Exception_exception_2.$$arity = -1);
    
    Opal.defn(self, '$initialize', TMP_Exception_initialize_3 = function $$initialize($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return self.message = (args.length > 0) ? args[0] : nil
    }, TMP_Exception_initialize_3.$$arity = -1);
    
    Opal.defn(self, '$backtrace', TMP_Exception_backtrace_4 = function $$backtrace() {
      var self = this;

      
      var backtrace = self.stack;

      if (typeof(backtrace) === 'string') {
        return backtrace.split("\n").slice(0, 15);
      }
      else if (backtrace) {
        return backtrace.slice(0, 15);
      }

      return [];
    
    }, TMP_Exception_backtrace_4.$$arity = 0);
    
    Opal.defn(self, '$exception', TMP_Exception_exception_5 = function $$exception(str) {
      var self = this;

      if (str == null) {
        str = nil;
      }
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      return cloned;
    
    }, TMP_Exception_exception_5.$$arity = -1);
    
    Opal.defn(self, '$message', TMP_Exception_message_6 = function $$message() {
      var self = this;

      return self.$to_s()
    }, TMP_Exception_message_6.$$arity = 0);
    
    Opal.defn(self, '$inspect', TMP_Exception_inspect_7 = function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
        } else {
        return "" + "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, TMP_Exception_inspect_7.$$arity = 0);
    return (Opal.defn(self, '$to_s', TMP_Exception_to_s_8 = function $$to_s() {
      var $a, $b, self = this;

      return ($truthy($a = ($truthy($b = self.message) ? self.message.$to_s() : $b)) ? $a : self.$class().$to_s())
    }, TMP_Exception_to_s_8.$$arity = 0), nil) && 'to_s';
  })($nesting[0], Error, $nesting);
  (function($base, $super, $parent_nesting) {
    function $ScriptError(){};
    var self = $ScriptError = $klass($base, $super, 'ScriptError', $ScriptError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $SyntaxError(){};
    var self = $SyntaxError = $klass($base, $super, 'SyntaxError', $SyntaxError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $LoadError(){};
    var self = $LoadError = $klass($base, $super, 'LoadError', $LoadError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $NotImplementedError(){};
    var self = $NotImplementedError = $klass($base, $super, 'NotImplementedError', $NotImplementedError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $SystemExit(){};
    var self = $SystemExit = $klass($base, $super, 'SystemExit', $SystemExit);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $NoMemoryError(){};
    var self = $NoMemoryError = $klass($base, $super, 'NoMemoryError', $NoMemoryError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $SignalException(){};
    var self = $SignalException = $klass($base, $super, 'SignalException', $SignalException);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $Interrupt(){};
    var self = $Interrupt = $klass($base, $super, 'Interrupt', $Interrupt);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $SecurityError(){};
    var self = $SecurityError = $klass($base, $super, 'SecurityError', $SecurityError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $StandardError(){};
    var self = $StandardError = $klass($base, $super, 'StandardError', $StandardError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $ZeroDivisionError(){};
    var self = $ZeroDivisionError = $klass($base, $super, 'ZeroDivisionError', $ZeroDivisionError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $NameError(){};
    var self = $NameError = $klass($base, $super, 'NameError', $NameError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $NoMethodError(){};
    var self = $NoMethodError = $klass($base, $super, 'NoMethodError', $NoMethodError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'NameError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $RuntimeError(){};
    var self = $RuntimeError = $klass($base, $super, 'RuntimeError', $RuntimeError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $LocalJumpError(){};
    var self = $LocalJumpError = $klass($base, $super, 'LocalJumpError', $LocalJumpError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $TypeError(){};
    var self = $TypeError = $klass($base, $super, 'TypeError', $TypeError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $ArgumentError(){};
    var self = $ArgumentError = $klass($base, $super, 'ArgumentError', $ArgumentError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $IndexError(){};
    var self = $IndexError = $klass($base, $super, 'IndexError', $IndexError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $StopIteration(){};
    var self = $StopIteration = $klass($base, $super, 'StopIteration', $StopIteration);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $KeyError(){};
    var self = $KeyError = $klass($base, $super, 'KeyError', $KeyError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $RangeError(){};
    var self = $RangeError = $klass($base, $super, 'RangeError', $RangeError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $FloatDomainError(){};
    var self = $FloatDomainError = $klass($base, $super, 'FloatDomainError', $FloatDomainError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'RangeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $IOError(){};
    var self = $IOError = $klass($base, $super, 'IOError', $IOError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $SystemCallError(){};
    var self = $SystemCallError = $klass($base, $super, 'SystemCallError', $SystemCallError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $parent_nesting) {
    var $Errno, self = $Errno = $module($base, 'Errno');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $EINVAL(){};
      var self = $EINVAL = $klass($base, $super, 'EINVAL', $EINVAL);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_EINVAL_new_9;

      return Opal.defs(self, '$new', TMP_EINVAL_new_9 = function(name) {
        var self = this, $iter = TMP_EINVAL_new_9.$$p, $yield = $iter || nil, message = nil;

        if (name == null) {
          name = nil;
        }
        if ($iter) TMP_EINVAL_new_9.$$p = null;
        
        message = "Invalid argument";
        if ($truthy(name)) {
          message = $rb_plus(message, "" + " - " + (name))};
        return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_EINVAL_new_9, false, $EINVAL), [message], null);
      }, TMP_EINVAL_new_9.$$arity = -1)
    })($nesting[0], Opal.const_get_relative($nesting, 'SystemCallError'), $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $UncaughtThrowError(){};
    var self = $UncaughtThrowError = $klass($base, $super, 'UncaughtThrowError', $UncaughtThrowError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UncaughtThrowError_initialize_10;

    def.sym = nil;
    
    self.$attr_reader("sym", "arg");
    return (Opal.defn(self, '$initialize', TMP_UncaughtThrowError_initialize_10 = function $$initialize(args) {
      var self = this, $iter = TMP_UncaughtThrowError_initialize_10.$$p, $yield = $iter || nil;

      if ($iter) TMP_UncaughtThrowError_initialize_10.$$p = null;
      
      self.sym = args['$[]'](0);
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.arg = args['$[]'](1)};
      return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_UncaughtThrowError_initialize_10, false), ["" + "uncaught throw " + (self.sym.$inspect())], null);
    }, TMP_UncaughtThrowError_initialize_10.$$arity = 1), nil) && 'initialize';
  })($nesting[0], Opal.const_get_relative($nesting, 'ArgumentError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $NameError(){};
    var self = $NameError = $klass($base, $super, 'NameError', $NameError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NameError_initialize_11;

    
    self.$attr_reader("name");
    return (Opal.defn(self, '$initialize', TMP_NameError_initialize_11 = function $$initialize(message, name) {
      var self = this, $iter = TMP_NameError_initialize_11.$$p, $yield = $iter || nil;

      if (name == null) {
        name = nil;
      }
      if ($iter) TMP_NameError_initialize_11.$$p = null;
      
      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_NameError_initialize_11, false), [message], null);
      return (self.name = name);
    }, TMP_NameError_initialize_11.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $NoMethodError(){};
    var self = $NoMethodError = $klass($base, $super, 'NoMethodError', $NoMethodError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NoMethodError_initialize_12;

    
    self.$attr_reader("args");
    return (Opal.defn(self, '$initialize', TMP_NoMethodError_initialize_12 = function $$initialize(message, name, args) {
      var self = this, $iter = TMP_NoMethodError_initialize_12.$$p, $yield = $iter || nil;

      if (name == null) {
        name = nil;
      }
      if (args == null) {
        args = [];
      }
      if ($iter) TMP_NoMethodError_initialize_12.$$p = null;
      
      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_NoMethodError_initialize_12, false), [message, name], null);
      return (self.args = args);
    }, TMP_NoMethodError_initialize_12.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $StopIteration(){};
    var self = $StopIteration = $klass($base, $super, 'StopIteration', $StopIteration);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return self.$attr_reader("result")
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var $JS, self = $JS = $module($base, 'JS');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Error(){};
      var self = $Error = $klass($base, $super, 'Error', $Error);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/constants"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  
  Opal.const_set($nesting[0], 'RUBY_PLATFORM', "opal");
  Opal.const_set($nesting[0], 'RUBY_ENGINE', "opal");
  Opal.const_set($nesting[0], 'RUBY_VERSION', "2.4.5");
  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', "0.11.4");
  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', "2018-11-07");
  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);
  Opal.const_set($nesting[0], 'RUBY_REVISION', 0);
  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2015 Adam Beynon");
  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', "" + "opal " + (Opal.const_get_relative($nesting, 'RUBY_ENGINE_VERSION')) + " (" + (Opal.const_get_relative($nesting, 'RUBY_RELEASE_DATE')) + " revision " + (Opal.const_get_relative($nesting, 'RUBY_REVISION')) + ")");
};

/* Generated by Opal 0.11.4 */
Opal.modules["opal/base"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("corelib/runtime");
  self.$require("corelib/helpers");
  self.$require("corelib/module");
  self.$require("corelib/class");
  self.$require("corelib/basic_object");
  self.$require("corelib/kernel");
  self.$require("corelib/error");
  return self.$require("corelib/constants");
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/nil"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);
  
  (function($base, $super, $parent_nesting) {
    function $NilClass(){};
    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NilClass_$B_2, TMP_NilClass_$_3, TMP_NilClass_$_4, TMP_NilClass_$_5, TMP_NilClass_$eq$eq_6, TMP_NilClass_dup_7, TMP_NilClass_clone_8, TMP_NilClass_inspect_9, TMP_NilClass_nil$q_10, TMP_NilClass_singleton_class_11, TMP_NilClass_to_a_12, TMP_NilClass_to_h_13, TMP_NilClass_to_i_14, TMP_NilClass_to_s_15, TMP_NilClass_to_c_16, TMP_NilClass_rationalize_17, TMP_NilClass_to_r_18, TMP_NilClass_instance_variables_19;

    
    def.$$meta = self;
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1;

      
      
      Opal.defn(self, '$allocate', TMP_allocate_1 = function $$allocate() {
        var self = this;

        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, TMP_allocate_1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.defn(self, '$!', TMP_NilClass_$B_2 = function() {
      var self = this;

      return true
    }, TMP_NilClass_$B_2.$$arity = 0);
    
    Opal.defn(self, '$&', TMP_NilClass_$_3 = function(other) {
      var self = this;

      return false
    }, TMP_NilClass_$_3.$$arity = 1);
    
    Opal.defn(self, '$|', TMP_NilClass_$_4 = function(other) {
      var self = this;

      return other !== false && other !== nil
    }, TMP_NilClass_$_4.$$arity = 1);
    
    Opal.defn(self, '$^', TMP_NilClass_$_5 = function(other) {
      var self = this;

      return other !== false && other !== nil
    }, TMP_NilClass_$_5.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_NilClass_$eq$eq_6 = function(other) {
      var self = this;

      return other === nil
    }, TMP_NilClass_$eq$eq_6.$$arity = 1);
    
    Opal.defn(self, '$dup', TMP_NilClass_dup_7 = function $$dup() {
      var self = this;

      return nil
    }, TMP_NilClass_dup_7.$$arity = 0);
    
    Opal.defn(self, '$clone', TMP_NilClass_clone_8 = function $$clone($kwargs) {
      var self = this, freeze;

      if ($kwargs == null || !$kwargs.$$is_hash) {
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else {
          throw Opal.ArgumentError.$new('expected kwargs');
        }
      }
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      }
      return nil
    }, TMP_NilClass_clone_8.$$arity = -1);
    
    Opal.defn(self, '$inspect', TMP_NilClass_inspect_9 = function $$inspect() {
      var self = this;

      return "nil"
    }, TMP_NilClass_inspect_9.$$arity = 0);
    
    Opal.defn(self, '$nil?', TMP_NilClass_nil$q_10 = function() {
      var self = this;

      return true
    }, TMP_NilClass_nil$q_10.$$arity = 0);
    
    Opal.defn(self, '$singleton_class', TMP_NilClass_singleton_class_11 = function $$singleton_class() {
      var self = this;

      return Opal.const_get_relative($nesting, 'NilClass')
    }, TMP_NilClass_singleton_class_11.$$arity = 0);
    
    Opal.defn(self, '$to_a', TMP_NilClass_to_a_12 = function $$to_a() {
      var self = this;

      return []
    }, TMP_NilClass_to_a_12.$$arity = 0);
    
    Opal.defn(self, '$to_h', TMP_NilClass_to_h_13 = function $$to_h() {
      var self = this;

      return Opal.hash()
    }, TMP_NilClass_to_h_13.$$arity = 0);
    
    Opal.defn(self, '$to_i', TMP_NilClass_to_i_14 = function $$to_i() {
      var self = this;

      return 0
    }, TMP_NilClass_to_i_14.$$arity = 0);
    Opal.alias(self, "to_f", "to_i");
    
    Opal.defn(self, '$to_s', TMP_NilClass_to_s_15 = function $$to_s() {
      var self = this;

      return ""
    }, TMP_NilClass_to_s_15.$$arity = 0);
    
    Opal.defn(self, '$to_c', TMP_NilClass_to_c_16 = function $$to_c() {
      var self = this;

      return Opal.const_get_relative($nesting, 'Complex').$new(0, 0)
    }, TMP_NilClass_to_c_16.$$arity = 0);
    
    Opal.defn(self, '$rationalize', TMP_NilClass_rationalize_17 = function $$rationalize($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'))};
      return self.$Rational(0, 1);
    }, TMP_NilClass_rationalize_17.$$arity = -1);
    
    Opal.defn(self, '$to_r', TMP_NilClass_to_r_18 = function $$to_r() {
      var self = this;

      return self.$Rational(0, 1)
    }, TMP_NilClass_to_r_18.$$arity = 0);
    return (Opal.defn(self, '$instance_variables', TMP_NilClass_instance_variables_19 = function $$instance_variables() {
      var self = this;

      return []
    }, TMP_NilClass_instance_variables_19.$$arity = 0), nil) && 'instance_variables';
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], 'NIL', nil);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/boolean"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$raise', '$name']);
  
  (function($base, $super, $parent_nesting) {
    function $Boolean(){};
    var self = $Boolean = $klass($base, $super, 'Boolean', $Boolean);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Boolean___id___2, TMP_Boolean_$B_3, TMP_Boolean_$_4, TMP_Boolean_$_5, TMP_Boolean_$_6, TMP_Boolean_$eq$eq_7, TMP_Boolean_singleton_class_8, TMP_Boolean_to_s_9, TMP_Boolean_dup_10, TMP_Boolean_clone_11;

    
    def.$$is_boolean = true;
    def.$$meta = self;
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1;

      
      
      Opal.defn(self, '$allocate', TMP_allocate_1 = function $$allocate() {
        var self = this;

        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, TMP_allocate_1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.defn(self, '$__id__', TMP_Boolean___id___2 = function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0
    }, TMP_Boolean___id___2.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.defn(self, '$!', TMP_Boolean_$B_3 = function() {
      var self = this;

      return self != true
    }, TMP_Boolean_$B_3.$$arity = 0);
    
    Opal.defn(self, '$&', TMP_Boolean_$_4 = function(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false
    }, TMP_Boolean_$_4.$$arity = 1);
    
    Opal.defn(self, '$|', TMP_Boolean_$_5 = function(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil)
    }, TMP_Boolean_$_5.$$arity = 1);
    
    Opal.defn(self, '$^', TMP_Boolean_$_6 = function(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil)
    }, TMP_Boolean_$_6.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_Boolean_$eq$eq_7 = function(other) {
      var self = this;

      return (self == true) === other.valueOf()
    }, TMP_Boolean_$eq$eq_7.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    Opal.alias(self, "eql?", "==");
    
    Opal.defn(self, '$singleton_class', TMP_Boolean_singleton_class_8 = function $$singleton_class() {
      var self = this;

      return Opal.const_get_relative($nesting, 'Boolean')
    }, TMP_Boolean_singleton_class_8.$$arity = 0);
    
    Opal.defn(self, '$to_s', TMP_Boolean_to_s_9 = function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false'
    }, TMP_Boolean_to_s_9.$$arity = 0);
    
    Opal.defn(self, '$dup', TMP_Boolean_dup_10 = function $$dup() {
      var self = this;

      return self
    }, TMP_Boolean_dup_10.$$arity = 0);
    return (Opal.defn(self, '$clone', TMP_Boolean_clone_11 = function $$clone($kwargs) {
      var self = this, freeze;

      if ($kwargs == null || !$kwargs.$$is_hash) {
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else {
          throw Opal.ArgumentError.$new('expected kwargs');
        }
      }
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      }
      return self
    }, TMP_Boolean_clone_11.$$arity = -1), nil) && 'clone';
  })($nesting[0], Boolean, $nesting);
  Opal.const_set($nesting[0], 'TrueClass', Opal.const_get_relative($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'FalseClass', Opal.const_get_relative($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'TRUE', true);
  return Opal.const_set($nesting[0], 'FALSE', false);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$===', '$>', '$<', '$equal?', '$<=>', '$normalize', '$raise', '$class']);
  return (function($base, $parent_nesting) {
    var $Comparable, self = $Comparable = $module($base, 'Comparable');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Comparable_normalize_1, TMP_Comparable_$eq$eq_2, TMP_Comparable_$gt_3, TMP_Comparable_$gt$eq_4, TMP_Comparable_$lt_5, TMP_Comparable_$lt$eq_6, TMP_Comparable_between$q_7, TMP_Comparable_clamp_8;

    
    Opal.defs(self, '$normalize', TMP_Comparable_normalize_1 = function $$normalize(what) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](what))) {
        return what};
      if ($truthy($rb_gt(what, 0))) {
        return 1};
      if ($truthy($rb_lt(what, 0))) {
        return -1};
      return 0;
    }, TMP_Comparable_normalize_1.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_Comparable_$eq$eq_2 = function(other) {
      var self = this, cmp = nil;

      try {
        
        if ($truthy(self['$equal?'](other))) {
          return true};
        
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
        if ($truthy((cmp = self['$<=>'](other)))) {
          } else {
          return false
        };
        return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) == 0;
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
          try {
            return false
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, TMP_Comparable_$eq$eq_2.$$arity = 1);
    
    Opal.defn(self, '$>', TMP_Comparable_$gt_3 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) > 0;
    }, TMP_Comparable_$gt_3.$$arity = 1);
    
    Opal.defn(self, '$>=', TMP_Comparable_$gt$eq_4 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) >= 0;
    }, TMP_Comparable_$gt$eq_4.$$arity = 1);
    
    Opal.defn(self, '$<', TMP_Comparable_$lt_5 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) < 0;
    }, TMP_Comparable_$lt_5.$$arity = 1);
    
    Opal.defn(self, '$<=', TMP_Comparable_$lt$eq_6 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) <= 0;
    }, TMP_Comparable_$lt$eq_6.$$arity = 1);
    
    Opal.defn(self, '$between?', TMP_Comparable_between$q_7 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, TMP_Comparable_between$q_7.$$arity = 2);
    
    Opal.defn(self, '$clamp', TMP_Comparable_clamp_8 = function $$clamp(min, max) {
      var self = this, cmp = nil;

      
      cmp = min['$<=>'](max);
      if ($truthy(cmp)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (min.$class()) + " with " + (max.$class()) + " failed")
      };
      if ($truthy($rb_gt(Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp), 0))) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "min argument must be smaller than max argument")};
      if ($truthy($rb_lt(Opal.const_get_relative($nesting, 'Comparable').$normalize(self['$<=>'](min)), 0))) {
        return min};
      if ($truthy($rb_gt(Opal.const_get_relative($nesting, 'Comparable').$normalize(self['$<=>'](max)), 0))) {
        return max};
      return self;
    }, TMP_Comparable_clamp_8.$$arity = 2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/regexp"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$coerce_to', '$call', '$=~', '$attr_reader', '$===', '$inspect', '$to_a']);
  
  (function($base, $super, $parent_nesting) {
    function $RegexpError(){};
    var self = $RegexpError = $klass($base, $super, 'RegexpError', $RegexpError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $Regexp(){};
    var self = $Regexp = $klass($base, $super, 'Regexp', $Regexp);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Regexp_$eq$eq_6, TMP_Regexp_$eq$eq$eq_7, TMP_Regexp_$eq$_8, TMP_Regexp_inspect_9, TMP_Regexp_match_10, TMP_Regexp_match$q_11, TMP_Regexp_$_12, TMP_Regexp_source_13, TMP_Regexp_options_14, TMP_Regexp_casefold$q_15;

    
    Opal.const_set($nesting[0], 'IGNORECASE', 1);
    Opal.const_set($nesting[0], 'MULTILINE', 4);
    def.$$is_regexp = true;
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1, TMP_escape_2, TMP_last_match_3, TMP_union_4, TMP_new_5;

      
      
      Opal.defn(self, '$allocate', TMP_allocate_1 = function $$allocate() {
        var self = this, $iter = TMP_allocate_1.$$p, $yield = $iter || nil, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) TMP_allocate_1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        allocated = $send(self, Opal.find_super_dispatcher(self, 'allocate', TMP_allocate_1, false), $zuper, $iter);
        allocated.uninitialized = true;
        return allocated;
      }, TMP_allocate_1.$$arity = 0);
      
      Opal.defn(self, '$escape', TMP_escape_2 = function $$escape(string) {
        var self = this;

        return Opal.escape_regexp(string)
      }, TMP_escape_2.$$arity = 1);
      
      Opal.defn(self, '$last_match', TMP_last_match_3 = function $$last_match(n) {
        var self = this;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        if (n == null) {
          n = nil;
        }
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
          } else {
          return $gvars["~"]['$[]'](n)
        }
      }, TMP_last_match_3.$$arity = -1);
      Opal.alias(self, "quote", "escape");
      
      Opal.defn(self, '$union', TMP_union_4 = function $$union($a_rest) {
        var self = this, parts;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        parts = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          parts[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, TMP_union_4.$$arity = -1);
      return (Opal.defn(self, '$new', TMP_new_5 = function(regexp, options) {
        var self = this;

        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](regexp, Opal.const_get_relative($nesting, 'String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          self.$raise(Opal.const_get_relative($nesting, 'RegexpError'), "" + "too short escape sequence: /" + (regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if (Opal.const_get_relative($nesting, 'IGNORECASE') & options) { temp += 'i'; }
          if (Opal.const_get_relative($nesting, 'MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      
      }, TMP_new_5.$$arity = -2), nil) && 'new';
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.defn(self, '$==', TMP_Regexp_$eq$eq_6 = function(other) {
      var self = this;

      return other.constructor == RegExp && self.toString() === other.toString()
    }, TMP_Regexp_$eq$eq_6.$$arity = 1);
    
    Opal.defn(self, '$===', TMP_Regexp_$eq$eq$eq_7 = function(string) {
      var self = this;

      return self.$match(Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](string, Opal.const_get_relative($nesting, 'String'), "to_str")) !== nil
    }, TMP_Regexp_$eq$eq$eq_7.$$arity = 1);
    
    Opal.defn(self, '$=~', TMP_Regexp_$eq$_8 = function(string) {
      var $a, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      return ($truthy($a = self.$match(string)) ? $gvars["~"].$begin(0) : $a)
    }, TMP_Regexp_$eq$_8.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.defn(self, '$inspect', TMP_Regexp_inspect_9 = function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, TMP_Regexp_inspect_9.$$arity = 0);
    
    Opal.defn(self, '$match', TMP_Regexp_match_10 = function $$match(string, pos) {
      var self = this, $iter = TMP_Regexp_match_10.$$p, block = $iter || nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($iter) TMP_Regexp_match_10.$$p = null;
      
      if (self.uninitialized) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        pos = 0;
      } else {
        pos = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pos, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = Opal.const_get_relative($nesting, 'Opal').$coerce_to(string, Opal.const_get_relative($nesting, 'String'), "to_str");

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      var source = self.source;
      var flags = 'g';
      // m flag + a . in Ruby will match white space, but in JS, it only matches beginning/ending of lines, so we get the equivalent here
      if (self.multiline) {
        source = source.replace('.', "[\\s\\S]");
        flags += 'm';
      }

      // global RegExp maintains state, so not using self/this
      var md, re = new RegExp(source, flags + (self.ignoreCase ? 'i' : ''));

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = Opal.const_get_relative($nesting, 'MatchData').$new(re, md))
          return block === nil ? $gvars["~"] : block.$call($gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    
    }, TMP_Regexp_match_10.$$arity = -2);
    
    Opal.defn(self, '$match?', TMP_Regexp_match$q_11 = function(string, pos) {
      var self = this;

      
      if (self.uninitialized) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        pos = 0;
      } else {
        pos = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pos, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }

      if (string === nil) {
        return false;
      }

      string = Opal.const_get_relative($nesting, 'Opal').$coerce_to(string, Opal.const_get_relative($nesting, 'String'), "to_str");

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      var source = self.source;
      var flags = 'g';
      // m flag + a . in Ruby will match white space, but in JS, it only matches beginning/ending of lines, so we get the equivalent here
      if (self.multiline) {
        source = source.replace('.', "[\\s\\S]");
        flags += 'm';
      }

      // global RegExp maintains state, so not using self/this
      var md, re = new RegExp(source, flags + (self.ignoreCase ? 'i' : ''));

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    
    }, TMP_Regexp_match$q_11.$$arity = -2);
    
    Opal.defn(self, '$~', TMP_Regexp_$_12 = function() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, TMP_Regexp_$_12.$$arity = 0);
    
    Opal.defn(self, '$source', TMP_Regexp_source_13 = function $$source() {
      var self = this;

      return self.source
    }, TMP_Regexp_source_13.$$arity = 0);
    
    Opal.defn(self, '$options', TMP_Regexp_options_14 = function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= Opal.const_get_relative($nesting, 'MULTILINE');
      }
      if (self.ignoreCase) {
        result |= Opal.const_get_relative($nesting, 'IGNORECASE');
      }
      return result;
    
    }, TMP_Regexp_options_14.$$arity = 0);
    
    Opal.defn(self, '$casefold?', TMP_Regexp_casefold$q_15 = function() {
      var self = this;

      return self.ignoreCase
    }, TMP_Regexp_casefold$q_15.$$arity = 0);
    return Opal.alias(self, "to_s", "source");
  })($nesting[0], RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    function $MatchData(){};
    var self = $MatchData = $klass($base, $super, 'MatchData', $MatchData);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MatchData_initialize_16, TMP_MatchData_$$_17, TMP_MatchData_offset_18, TMP_MatchData_$eq$eq_19, TMP_MatchData_begin_20, TMP_MatchData_end_21, TMP_MatchData_captures_22, TMP_MatchData_inspect_23, TMP_MatchData_length_24, TMP_MatchData_to_a_25, TMP_MatchData_to_s_26, TMP_MatchData_values_at_27;

    def.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    Opal.defn(self, '$initialize', TMP_MatchData_initialize_16 = function $$initialize(regexp, match_groups) {
      var self = this;

      
      $gvars["~"] = self;
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, TMP_MatchData_initialize_16.$$arity = 2);
    
    Opal.defn(self, '$[]', TMP_MatchData_$$_17 = function($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send(self.matches, '[]', Opal.to_a(args))
    }, TMP_MatchData_$$_17.$$arity = -1);
    
    Opal.defn(self, '$offset', TMP_MatchData_offset_18 = function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, TMP_MatchData_offset_18.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_MatchData_$eq$eq_19 = function(other) {
      var $a, $b, $c, $d, self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'MatchData')['$==='](other))) {
        } else {
        return false
      };
      return ($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = self.string == other.string) ? self.regexp.toString() == other.regexp.toString() : $d)) ? self.pre_match == other.pre_match : $c)) ? self.post_match == other.post_match : $b)) ? self.begin == other.begin : $a);
    }, TMP_MatchData_$eq$eq_19.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.defn(self, '$begin', TMP_MatchData_begin_20 = function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, TMP_MatchData_begin_20.$$arity = 1);
    
    Opal.defn(self, '$end', TMP_MatchData_end_21 = function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, TMP_MatchData_end_21.$$arity = 1);
    
    Opal.defn(self, '$captures', TMP_MatchData_captures_22 = function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, TMP_MatchData_captures_22.$$arity = 0);
    
    Opal.defn(self, '$inspect', TMP_MatchData_inspect_23 = function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      for (var i = 1, length = self.matches.length; i < length; i++) {
        str += " " + i + ":" + (self.matches[i]).$inspect();
      }

      return str + ">";
    
    }, TMP_MatchData_inspect_23.$$arity = 0);
    
    Opal.defn(self, '$length', TMP_MatchData_length_24 = function $$length() {
      var self = this;

      return self.matches.length
    }, TMP_MatchData_length_24.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.defn(self, '$to_a', TMP_MatchData_to_a_25 = function $$to_a() {
      var self = this;

      return self.matches
    }, TMP_MatchData_to_a_25.$$arity = 0);
    
    Opal.defn(self, '$to_s', TMP_MatchData_to_s_26 = function $$to_s() {
      var self = this;

      return self.matches[0]
    }, TMP_MatchData_to_s_26.$$arity = 0);
    return (Opal.defn(self, '$values_at', TMP_MatchData_values_at_27 = function $$values_at($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](args[i], Opal.const_get_relative($nesting, 'Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    
    }, TMP_MatchData_values_at_27.$$arity = -1), nil) && 'values_at';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/string"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$coerce_to', '$raise', '$===', '$format', '$to_s', '$respond_to?', '$to_str', '$<=>', '$==', '$=~', '$new', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$to_a', '$each_char', '$to_proc', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$size', '$chomp', '$[]', '$to_i', '$each_line', '$class', '$match', '$captures', '$proc', '$succ', '$escape']);
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String___id___1, TMP_String_try_convert_2, TMP_String_new_3, TMP_String_initialize_4, TMP_String_$_5, TMP_String_$_6, TMP_String_$_7, TMP_String_$lt$eq$gt_8, TMP_String_$eq$eq_9, TMP_String_$eq$_10, TMP_String_$$_11, TMP_String_capitalize_12, TMP_String_casecmp_13, TMP_String_center_14, TMP_String_chars_15, TMP_String_chomp_16, TMP_String_chop_17, TMP_String_chr_18, TMP_String_clone_19, TMP_String_dup_20, TMP_String_count_21, TMP_String_delete_22, TMP_String_downcase_23, TMP_String_each_char_24, TMP_String_each_line_26, TMP_String_empty$q_27, TMP_String_end_with$q_28, TMP_String_gsub_29, TMP_String_hash_30, TMP_String_hex_31, TMP_String_include$q_32, TMP_String_index_33, TMP_String_inspect_34, TMP_String_intern_35, TMP_String_lines_36, TMP_String_length_37, TMP_String_ljust_38, TMP_String_lstrip_39, TMP_String_ascii_only$q_40, TMP_String_match_41, TMP_String_next_42, TMP_String_oct_43, TMP_String_ord_44, TMP_String_partition_45, TMP_String_reverse_46, TMP_String_rindex_47, TMP_String_rjust_48, TMP_String_rpartition_49, TMP_String_rstrip_50, TMP_String_scan_51, TMP_String_split_52, TMP_String_squeeze_53, TMP_String_start_with$q_54, TMP_String_strip_55, TMP_String_sub_56, TMP_String_sum_57, TMP_String_swapcase_58, TMP_String_to_f_59, TMP_String_to_i_60, TMP_String_to_proc_62, TMP_String_to_s_63, TMP_String_tr_64, TMP_String_tr_s_65, TMP_String_upcase_66, TMP_String_upto_67, TMP_String_instance_variables_68, TMP_String__load_69, TMP_String_unpack_70;

    def.length = nil;
    
    self.$include(Opal.const_get_relative($nesting, 'Comparable'));
    def.$$is_string = true;
    
    Opal.defn(self, '$__id__', TMP_String___id___1 = function $$__id__() {
      var self = this;

      return self.toString()
    }, TMP_String___id___1.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    Opal.defs(self, '$try_convert', TMP_String_try_convert_2 = function $$try_convert(what) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](what, Opal.const_get_relative($nesting, 'String'), "to_str")
    }, TMP_String_try_convert_2.$$arity = 1);
    Opal.defs(self, '$new', TMP_String_new_3 = function(str) {
      var self = this;

      if (str == null) {
        str = "";
      }
      
      str = Opal.const_get_relative($nesting, 'Opal').$coerce_to(str, Opal.const_get_relative($nesting, 'String'), "to_str");
      return new String(str);
    }, TMP_String_new_3.$$arity = -1);
    
    Opal.defn(self, '$initialize', TMP_String_initialize_4 = function $$initialize(str) {
      var self = this;

      
      
      if (str === undefined) {
        return self;
      }
    ;
      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), "Mutable strings are not supported in Opal.");
    }, TMP_String_initialize_4.$$arity = -1);
    
    Opal.defn(self, '$%', TMP_String_$_5 = function(data) {
      var self = this;

      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](data))) {
        return $send(self, 'format', [self].concat(Opal.to_a(data)))
        } else {
        return self.$format(self, data)
      }
    }, TMP_String_$_5.$$arity = 1);
    
    Opal.defn(self, '$*', TMP_String_$_6 = function(count) {
      var self = this;

      
      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return '';
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return result;
    
    }, TMP_String_$_6.$$arity = 1);
    
    Opal.defn(self, '$+', TMP_String_$_7 = function(other) {
      var self = this;

      
      other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'String'), "to_str");
      return self + other.$to_s();
    }, TMP_String_$_7.$$arity = 1);
    
    Opal.defn(self, '$<=>', TMP_String_$lt$eq$gt_8 = function(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);
        } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, TMP_String_$lt$eq$gt_8.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_String_$eq$eq_9 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](other, "to_str")) {
        return other['$=='](self);
      }
      return false;
    
    }, TMP_String_$eq$eq_9.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    
    Opal.defn(self, '$=~', TMP_String_$eq$_10 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, TMP_String_$eq$_10.$$arity = 1);
    
    Opal.defn(self, '$[]', TMP_String_$$_11 = function(index, length) {
      var self = this;

      
      var size = self.length, exclude;

      if (index.$$is_range) {
        exclude = index.excl;
        length  = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index.end, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        index   = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index.begin, Opal.const_get_relative($nesting, 'Integer'), "to_int");

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.substr(index, length);
      }


      if (index.$$is_string) {
        if (length != null) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'))
        }
        return self.indexOf(index) !== -1 ? index : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = Opal.const_get_relative($nesting, 'MatchData').$new(index, match))

        if (length == null) {
          return match[0];
        }

        length = Opal.const_get_relative($nesting, 'Opal').$coerce_to(length, Opal.const_get_relative($nesting, 'Integer'), "to_int");

        if (length < 0 && -length < match.length) {
          return match[length += match.length];
        }

        if (length >= 0 && length < match.length) {
          return match[length];
        }

        return nil;
      }


      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.substr(index, 1);
      }

      length = Opal.const_get_relative($nesting, 'Opal').$coerce_to(length, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.substr(index, length);
    
    }, TMP_String_$$_11.$$arity = -2);
    Opal.alias(self, "byteslice", "[]");
    
    Opal.defn(self, '$capitalize', TMP_String_capitalize_12 = function $$capitalize() {
      var self = this;

      return self.charAt(0).toUpperCase() + self.substr(1).toLowerCase()
    }, TMP_String_capitalize_12.$$arity = 0);
    
    Opal.defn(self, '$casecmp', TMP_String_casecmp_13 = function $$casecmp(other) {
      var self = this;

      
      other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, TMP_String_casecmp_13.$$arity = 1);
    
    Opal.defn(self, '$center', TMP_String_center_14 = function $$center(width, padstr) {
      var self = this;

      if (padstr == null) {
        padstr = " ";
      }
      
      width = Opal.const_get_relative($nesting, 'Opal').$coerce_to(width, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      padstr = Opal.const_get_relative($nesting, 'Opal').$coerce_to(padstr, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return rjustified + ljustified.slice(self.length);
    ;
    }, TMP_String_center_14.$$arity = -2);
    
    Opal.defn(self, '$chars', TMP_String_chars_15 = function $$chars() {
      var self = this, $iter = TMP_String_chars_15.$$p, block = $iter || nil;

      if ($iter) TMP_String_chars_15.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, TMP_String_chars_15.$$arity = 0);
    
    Opal.defn(self, '$chomp', TMP_String_chomp_16 = function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if (separator == null) {
        separator = $gvars["/"];
      }
      
      if ($truthy(separator === nil || self.length === 0)) {
        return self};
      separator = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](separator, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
      
      if (separator === "\n") {
        return self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        return self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length > separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          return self.substr(0, self.length - separator.length);
        }
      }
    ;
      return self;
    }, TMP_String_chomp_16.$$arity = -1);
    
    Opal.defn(self, '$chop', TMP_String_chop_17 = function $$chop() {
      var self = this;

      
      var length = self.length;

      if (length <= 1) {
        return "";
      }

      if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        return self.substr(0, length - 2);
      }
      else {
        return self.substr(0, length - 1);
      }
    
    }, TMP_String_chop_17.$$arity = 0);
    
    Opal.defn(self, '$chr', TMP_String_chr_18 = function $$chr() {
      var self = this;

      return self.charAt(0)
    }, TMP_String_chr_18.$$arity = 0);
    
    Opal.defn(self, '$clone', TMP_String_clone_19 = function $$clone() {
      var self = this, copy = nil;

      
      copy = self.slice();
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, TMP_String_clone_19.$$arity = 0);
    
    Opal.defn(self, '$dup', TMP_String_dup_20 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.slice();
      copy.$initialize_dup(self);
      return copy;
    }, TMP_String_dup_20.$$arity = 0);
    
    Opal.defn(self, '$count', TMP_String_count_21 = function $$count($a_rest) {
      var self = this, sets;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      sets = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        sets[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      if (sets.length === 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    
    }, TMP_String_count_21.$$arity = -1);
    
    Opal.defn(self, '$delete', TMP_String_delete_22 = function($a_rest) {
      var self = this, sets;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      sets = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        sets[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      if (sets.length === 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp(char_class, 'g'), '');
    
    }, TMP_String_delete_22.$$arity = -1);
    
    Opal.defn(self, '$downcase', TMP_String_downcase_23 = function $$downcase() {
      var self = this;

      return self.toLowerCase()
    }, TMP_String_downcase_23.$$arity = 0);
    
    Opal.defn(self, '$each_char', TMP_String_each_char_24 = function $$each_char() {
      var TMP_25, self = this, $iter = TMP_String_each_char_24.$$p, block = $iter || nil;

      if ($iter) TMP_String_each_char_24.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["each_char"], (TMP_25 = function(){var self = TMP_25.$$s || this;

        return self.$size()}, TMP_25.$$s = self, TMP_25.$$arity = 0, TMP_25))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.charAt(i));
      }
    ;
      return self;
    }, TMP_String_each_char_24.$$arity = 0);
    
    Opal.defn(self, '$each_line', TMP_String_each_line_26 = function $$each_line(separator) {
      var self = this, $iter = TMP_String_each_line_26.$$p, block = $iter || nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if (separator == null) {
        separator = $gvars["/"];
      }
      if ($iter) TMP_String_each_line_26.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("each_line", separator)
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = Opal.const_get_relative($nesting, 'Opal').$coerce_to(separator, Opal.const_get_relative($nesting, 'String'), "to_str")

      var a, i, n, length, chomped, trailing, splitted;

      if (separator.length === 0) {
        for (a = self.split(/(\n{2,})/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            Opal.yield1(block, (a[i] || "") + (a[i + 1] || ""));
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        if (i < length - 1 || trailing) {
          Opal.yield1(block, splitted[i] + separator);
        }
        else {
          Opal.yield1(block, splitted[i]);
        }
      }
    ;
      return self;
    }, TMP_String_each_line_26.$$arity = -1);
    
    Opal.defn(self, '$empty?', TMP_String_empty$q_27 = function() {
      var self = this;

      return self.length === 0
    }, TMP_String_empty$q_27.$$arity = 0);
    
    Opal.defn(self, '$end_with?', TMP_String_end_with$q_28 = function($a_rest) {
      var self = this, suffixes;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      suffixes = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        suffixes[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = Opal.const_get_relative($nesting, 'Opal').$coerce_to(suffixes[i], Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, TMP_String_end_with$q_28.$$arity = -1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "equal?", "===");
    
    Opal.defn(self, '$gsub', TMP_String_gsub_29 = function $$gsub(pattern, replacement) {
      var self = this, $iter = TMP_String_gsub_29.$$p, block = $iter || nil;

      if ($iter) TMP_String_gsub_29.$$p = null;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      } else {
        pattern = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pattern, Opal.const_get_relative($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = Opal.const_get_relative($nesting, 'MatchData').$new(pattern, match);

        if (replacement === undefined) {
          _replacement = block(match[0]);
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = Opal.const_get_relative($nesting, 'Opal').$coerce_to(replacement, Opal.const_get_relative($nesting, 'String'), "to_str");
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (_replacement + self.slice(index, match.index + 1))
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return result;
    
    }, TMP_String_gsub_29.$$arity = -2);
    
    Opal.defn(self, '$hash', TMP_String_hash_30 = function $$hash() {
      var self = this;

      return self.toString()
    }, TMP_String_hash_30.$$arity = 0);
    
    Opal.defn(self, '$hex', TMP_String_hex_31 = function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, TMP_String_hex_31.$$arity = 0);
    
    Opal.defn(self, '$include?', TMP_String_include$q_32 = function(other) {
      var self = this;

      
      if (!other.$$is_string) {
        (other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'String'), "to_str"))
      }
      return self.indexOf(other) !== -1;
    
    }, TMP_String_include$q_32.$$arity = 1);
    
    Opal.defn(self, '$index', TMP_String_index_33 = function $$index(search, offset) {
      var self = this;

      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = Opal.const_get_relative($nesting, 'Opal').$coerce_to(offset, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = new RegExp(search.source, 'gm' + (search.ignoreCase ? 'i' : ''));
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = Opal.const_get_relative($nesting, 'MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = Opal.const_get_relative($nesting, 'Opal').$coerce_to(search, Opal.const_get_relative($nesting, 'String'), "to_str");
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    
    }, TMP_String_index_33.$$arity = -2);
    
    Opal.defn(self, '$inspect', TMP_String_inspect_34 = function $$inspect() {
      var self = this;

      
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            return meta[chr] || '\\u' + ('0000' + chr.charCodeAt(0).toString(16).toUpperCase()).slice(-4);
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
    
    }, TMP_String_inspect_34.$$arity = 0);
    
    Opal.defn(self, '$intern', TMP_String_intern_35 = function $$intern() {
      var self = this;

      return self
    }, TMP_String_intern_35.$$arity = 0);
    
    Opal.defn(self, '$lines', TMP_String_lines_36 = function $$lines(separator) {
      var self = this, $iter = TMP_String_lines_36.$$p, block = $iter || nil, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if (separator == null) {
        separator = $gvars["/"];
      }
      if ($iter) TMP_String_lines_36.$$p = null;
      
      e = $send(self, 'each_line', [separator], block.$to_proc());
      if ($truthy(block)) {
        return self
        } else {
        return e.$to_a()
      };
    }, TMP_String_lines_36.$$arity = -1);
    
    Opal.defn(self, '$length', TMP_String_length_37 = function $$length() {
      var self = this;

      return self.length
    }, TMP_String_length_37.$$arity = 0);
    
    Opal.defn(self, '$ljust', TMP_String_ljust_38 = function $$ljust(width, padstr) {
      var self = this;

      if (padstr == null) {
        padstr = " ";
      }
      
      width = Opal.const_get_relative($nesting, 'Opal').$coerce_to(width, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      padstr = Opal.const_get_relative($nesting, 'Opal').$coerce_to(padstr, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self + result.slice(0, width);
    ;
    }, TMP_String_ljust_38.$$arity = -2);
    
    Opal.defn(self, '$lstrip', TMP_String_lstrip_39 = function $$lstrip() {
      var self = this;

      return self.replace(/^\s*/, '')
    }, TMP_String_lstrip_39.$$arity = 0);
    
    Opal.defn(self, '$ascii_only?', TMP_String_ascii_only$q_40 = function() {
      var self = this;

      return self.match(/[ -~\n]*/)[0] === self
    }, TMP_String_ascii_only$q_40.$$arity = 0);
    
    Opal.defn(self, '$match', TMP_String_match_41 = function $$match(pattern, pos) {
      var $a, self = this, $iter = TMP_String_match_41.$$p, block = $iter || nil;

      if ($iter) TMP_String_match_41.$$p = null;
      
      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'String')['$==='](pattern)) ? $a : pattern['$respond_to?']("to_str")))) {
        pattern = Opal.const_get_relative($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy(Opal.const_get_relative($nesting, 'Regexp')['$==='](pattern))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, TMP_String_match_41.$$arity = -2);
    
    Opal.defn(self, '$next', TMP_String_next_42 = function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return '';
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return result;
    
    }, TMP_String_next_42.$$arity = 0);
    
    Opal.defn(self, '$oct', TMP_String_oct_43 = function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, TMP_String_oct_43.$$arity = 0);
    
    Opal.defn(self, '$ord', TMP_String_ord_44 = function $$ord() {
      var self = this;

      return self.charCodeAt(0)
    }, TMP_String_ord_44.$$arity = 0);
    
    Opal.defn(self, '$partition', TMP_String_partition_45 = function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          Opal.const_get_relative($nesting, 'MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = Opal.const_get_relative($nesting, 'Opal').$coerce_to(sep, Opal.const_get_relative($nesting, 'String'), "to_str");
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, TMP_String_partition_45.$$arity = 1);
    
    Opal.defn(self, '$reverse', TMP_String_reverse_46 = function $$reverse() {
      var self = this;

      return self.split('').reverse().join('')
    }, TMP_String_reverse_46.$$arity = 0);
    
    Opal.defn(self, '$rindex', TMP_String_rindex_47 = function $$rindex(search, offset) {
      var self = this;

      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = Opal.const_get_relative($nesting, 'Opal').$coerce_to(offset, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = new RegExp(search.source, 'gm' + (search.ignoreCase ? 'i' : ''));
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          Opal.const_get_relative($nesting, 'MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = Opal.const_get_relative($nesting, 'Opal').$coerce_to(search, Opal.const_get_relative($nesting, 'String'), "to_str");
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    
    }, TMP_String_rindex_47.$$arity = -2);
    
    Opal.defn(self, '$rjust', TMP_String_rjust_48 = function $$rjust(width, padstr) {
      var self = this;

      if (padstr == null) {
        padstr = " ";
      }
      
      width = Opal.const_get_relative($nesting, 'Opal').$coerce_to(width, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      padstr = Opal.const_get_relative($nesting, 'Opal').$coerce_to(padstr, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return result + padstr.slice(0, remaining) + self;
    ;
    }, TMP_String_rjust_48.$$arity = -2);
    
    Opal.defn(self, '$rpartition', TMP_String_rpartition_49 = function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = new RegExp(sep.source, 'gm' + (sep.ignoreCase ? 'i' : ''));

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          Opal.const_get_relative($nesting, 'MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = Opal.const_get_relative($nesting, 'Opal').$coerce_to(sep, Opal.const_get_relative($nesting, 'String'), "to_str");
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, TMP_String_rpartition_49.$$arity = 1);
    
    Opal.defn(self, '$rstrip', TMP_String_rstrip_50 = function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '')
    }, TMP_String_rstrip_50.$$arity = 0);
    
    Opal.defn(self, '$scan', TMP_String_scan_51 = function $$scan(pattern) {
      var self = this, $iter = TMP_String_scan_51.$$p, block = $iter || nil;

      if ($iter) TMP_String_scan_51.$$p = null;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      } else {
        pattern = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pattern, Opal.const_get_relative($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = Opal.const_get_relative($nesting, 'MatchData').$new(pattern, match);
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      ($gvars["~"] = match_data)

      return (block !== nil ? self : result);
    
    }, TMP_String_scan_51.$$arity = 1);
    Opal.alias(self, "size", "length");
    Opal.alias(self, "slice", "[]");
    
    Opal.defn(self, '$split', TMP_String_split_52 = function $$split(pattern, limit) {
      var $a, self = this;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](limit, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy($a = $gvars[";"]) ? $a : " ");
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      } else {
        pattern = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pattern, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return result;
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        return result;
      }

      if (limit >= result.length) {
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      return result;
    
    }, TMP_String_split_52.$$arity = -1);
    
    Opal.defn(self, '$squeeze', TMP_String_squeeze_53 = function $$squeeze($a_rest) {
      var self = this, sets;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      sets = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        sets[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      if (sets.length === 0) {
        return self.replace(/(.)\1+/g, '$1');
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1');
    
    }, TMP_String_squeeze_53.$$arity = -1);
    
    Opal.defn(self, '$start_with?', TMP_String_start_with$q_54 = function($a_rest) {
      var self = this, prefixes;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      prefixes = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        prefixes[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        var prefix = Opal.const_get_relative($nesting, 'Opal').$coerce_to(prefixes[i], Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();

        if (self.indexOf(prefix) === 0) {
          return true;
        }
      }

      return false;
    
    }, TMP_String_start_with$q_54.$$arity = -1);
    
    Opal.defn(self, '$strip', TMP_String_strip_55 = function $$strip() {
      var self = this;

      return self.replace(/^\s*/, '').replace(/[\s\u0000]*$/, '')
    }, TMP_String_strip_55.$$arity = 0);
    
    Opal.defn(self, '$sub', TMP_String_sub_56 = function $$sub(pattern, replacement) {
      var self = this, $iter = TMP_String_sub_56.$$p, block = $iter || nil;

      if ($iter) TMP_String_sub_56.$$p = null;
      
      if (!pattern.$$is_regexp) {
        pattern = Opal.const_get_relative($nesting, 'Opal').$coerce_to(pattern, Opal.const_get_relative($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result = pattern.exec(self);

      if (result === null) {
        ($gvars["~"] = nil)
        return self.toString();
      }

      Opal.const_get_relative($nesting, 'MatchData').$new(pattern, result)

      if (replacement === undefined) {
        if (block === nil) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "wrong number of arguments (1 for 2)")
        }
        return self.slice(0, result.index) + block(result[0]) + self.slice(result.index + result[0].length);
      }

      if (replacement.$$is_hash) {
        return self.slice(0, result.index) + (replacement)['$[]'](result[0]).$to_s() + self.slice(result.index + result[0].length);
      }

      replacement = Opal.const_get_relative($nesting, 'Opal').$coerce_to(replacement, Opal.const_get_relative($nesting, 'String'), "to_str");

      replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
        if (slashes.length % 2 === 0) {
          return original;
        }
        switch (command) {
        case "+":
          for (var i = result.length - 1; i > 0; i--) {
            if (result[i] !== undefined) {
              return slashes.slice(1) + result[i];
            }
          }
          return '';
        case "&": return slashes.slice(1) + result[0];
        case "`": return slashes.slice(1) + self.slice(0, result.index);
        case "'": return slashes.slice(1) + self.slice(result.index + result[0].length);
        default:  return slashes.slice(1) + (result[command] || '');
        }
      }).replace(/\\\\/g, '\\');

      return self.slice(0, result.index) + replacement + self.slice(result.index + result[0].length);
    
    }, TMP_String_sub_56.$$arity = -2);
    Opal.alias(self, "succ", "next");
    
    Opal.defn(self, '$sum', TMP_String_sum_57 = function $$sum(n) {
      var self = this;

      if (n == null) {
        n = 16;
      }
      
      n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    
    }, TMP_String_sum_57.$$arity = -1);
    
    Opal.defn(self, '$swapcase', TMP_String_swapcase_58 = function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return self.$class().$new(str);
    
    }, TMP_String_swapcase_58.$$arity = 0);
    
    Opal.defn(self, '$to_f', TMP_String_to_f_59 = function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, TMP_String_to_f_59.$$arity = 0);
    
    Opal.defn(self, '$to_i', TMP_String_to_i_60 = function $$to_i(base) {
      var self = this;

      if (base == null) {
        base = 10;
      }
      
      var result,
          string = self.toLowerCase(),
          radix = Opal.const_get_relative($nesting, 'Opal').$coerce_to(base, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      if (radix === 1 || radix < 0 || radix > 36) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, TMP_String_to_i_60.$$arity = -1);
    
    Opal.defn(self, '$to_proc', TMP_String_to_proc_62 = function $$to_proc() {
      var TMP_61, self = this, sym = nil;

      
      sym = self.valueOf();
      return $send(self, 'proc', [], (TMP_61 = function($a_rest){var self = TMP_61.$$s || this, block, args;

        block = TMP_61.$$p || nil;
        if (block) TMP_61.$$p = null;
        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
      
        if (args.length === 0) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "no receiver given")
        }
        var obj = args.shift();
        if (obj == null) obj = nil;
        return Opal.send(obj, sym, args, block);
      }, TMP_61.$$s = self, TMP_61.$$arity = -1, TMP_61));
    }, TMP_String_to_proc_62.$$arity = 0);
    
    Opal.defn(self, '$to_s', TMP_String_to_s_63 = function $$to_s() {
      var self = this;

      return self.toString()
    }, TMP_String_to_s_63.$$arity = 0);
    Opal.alias(self, "to_str", "to_s");
    Opal.alias(self, "to_sym", "intern");
    
    Opal.defn(self, '$tr', TMP_String_tr_64 = function $$tr(from, to) {
      var self = this;

      
      from = Opal.const_get_relative($nesting, 'Opal').$coerce_to(from, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
      to = Opal.const_get_relative($nesting, 'Opal').$coerce_to(to, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
      
      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return new_str;
    ;
    }, TMP_String_tr_64.$$arity = 2);
    
    Opal.defn(self, '$tr_s', TMP_String_tr_s_65 = function $$tr_s(from, to) {
      var self = this;

      
      from = Opal.const_get_relative($nesting, 'Opal').$coerce_to(from, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
      to = Opal.const_get_relative($nesting, 'Opal').$coerce_to(to, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s();
      
      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return new_str;
    ;
    }, TMP_String_tr_s_65.$$arity = 2);
    
    Opal.defn(self, '$upcase', TMP_String_upcase_66 = function $$upcase() {
      var self = this;

      return self.toUpperCase()
    }, TMP_String_upcase_66.$$arity = 0);
    
    Opal.defn(self, '$upto', TMP_String_upto_67 = function $$upto(stop, excl) {
      var self = this, $iter = TMP_String_upto_67.$$p, block = $iter || nil;

      if (excl == null) {
        excl = false;
      }
      if ($iter) TMP_String_upto_67.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("upto", stop, excl)
      };
      stop = Opal.const_get_relative($nesting, 'Opal').$coerce_to(stop, Opal.const_get_relative($nesting, 'String'), "to_str");
      
      var a, b, s = self.toString();

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, TMP_String_upto_67.$$arity = -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = Opal.const_get_relative($nesting, 'Opal').$coerce_to(sets[i], Opal.const_get_relative($nesting, 'String'), "to_str");
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + Opal.const_get_relative($nesting, 'Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + Opal.const_get_relative($nesting, 'Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    Opal.defn(self, '$instance_variables', TMP_String_instance_variables_68 = function $$instance_variables() {
      var self = this;

      return []
    }, TMP_String_instance_variables_68.$$arity = 0);
    Opal.defs(self, '$_load', TMP_String__load_69 = function $$_load($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send(self, 'new', Opal.to_a(args))
    }, TMP_String__load_69.$$arity = -1);
    return (Opal.defn(self, '$unpack', TMP_String_unpack_70 = function $$unpack(pattern) {
      var self = this, $case = nil;

      
      
      function stringToBytes(string) {
        var i,
            singleByte,
            l = string.length,
            result = [];

        for (i = 0; i < l; i++) {
          singleByte = string.charCodeAt(i);
          result.push(singleByte);
        }
        return result;
      }
    ;
      return (function() {$case = pattern;
      if ("U*"['$===']($case) || "C*"['$===']($case)) {return stringToBytes(self);}
      else {return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))}})();
    }, TMP_String_unpack_70.$$arity = 1), nil) && 'unpack';
  })($nesting[0], String, $nesting);
  return Opal.const_set($nesting[0], 'Symbol', Opal.const_get_relative($nesting, 'String'));
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/enumerable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy, $falsy = Opal.falsy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$each', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$coerce_to', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$===', '$<<', '$[]', '$[]=', '$inspect', '$__send__', '$<=>', '$first', '$reverse', '$sort', '$to_proc', '$compare', '$call', '$dup', '$to_a', '$lambda', '$sort!', '$map!', '$has_key?', '$values', '$zip']);
  return (function($base, $parent_nesting) {
    var $Enumerable, self = $Enumerable = $module($base, 'Enumerable');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerable_all$q_1, TMP_Enumerable_any$q_4, TMP_Enumerable_chunk_7, TMP_Enumerable_chunk_while_10, TMP_Enumerable_collect_12, TMP_Enumerable_collect_concat_14, TMP_Enumerable_count_17, TMP_Enumerable_cycle_21, TMP_Enumerable_detect_23, TMP_Enumerable_drop_25, TMP_Enumerable_drop_while_26, TMP_Enumerable_each_cons_27, TMP_Enumerable_each_entry_29, TMP_Enumerable_each_slice_31, TMP_Enumerable_each_with_index_33, TMP_Enumerable_each_with_object_35, TMP_Enumerable_entries_37, TMP_Enumerable_find_all_38, TMP_Enumerable_find_index_40, TMP_Enumerable_first_45, TMP_Enumerable_grep_46, TMP_Enumerable_grep_v_47, TMP_Enumerable_group_by_48, TMP_Enumerable_include$q_51, TMP_Enumerable_inject_52, TMP_Enumerable_lazy_54, TMP_Enumerable_enumerator_size_55, TMP_Enumerable_max_56, TMP_Enumerable_max_by_57, TMP_Enumerable_min_59, TMP_Enumerable_min_by_60, TMP_Enumerable_minmax_62, TMP_Enumerable_minmax_by_64, TMP_Enumerable_none$q_65, TMP_Enumerable_one$q_68, TMP_Enumerable_partition_71, TMP_Enumerable_reject_73, TMP_Enumerable_reverse_each_75, TMP_Enumerable_slice_before_77, TMP_Enumerable_slice_after_79, TMP_Enumerable_slice_when_82, TMP_Enumerable_sort_84, TMP_Enumerable_sort_by_86, TMP_Enumerable_sum_91, TMP_Enumerable_take_93, TMP_Enumerable_take_while_94, TMP_Enumerable_uniq_96, TMP_Enumerable_zip_98;

    
    
    Opal.defn(self, '$all?', TMP_Enumerable_all$q_1 = function() {try {

      var TMP_2, TMP_3, self = this, $iter = TMP_Enumerable_all$q_1.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_all$q_1.$$p = null;
      
      if ((block !== nil)) {
        $send(self, 'each', [], (TMP_2 = function($a_rest){var self = TMP_2.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            return nil
            } else {
            Opal.ret(false)
          }}, TMP_2.$$s = self, TMP_2.$$arity = -1, TMP_2))
        } else {
        $send(self, 'each', [], (TMP_3 = function($a_rest){var self = TMP_3.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        if ($truthy(Opal.const_get_relative($nesting, 'Opal').$destructure(value))) {
            return nil
            } else {
            Opal.ret(false)
          }}, TMP_3.$$s = self, TMP_3.$$arity = -1, TMP_3))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Enumerable_all$q_1.$$arity = 0);
    
    Opal.defn(self, '$any?', TMP_Enumerable_any$q_4 = function() {try {

      var TMP_5, TMP_6, self = this, $iter = TMP_Enumerable_any$q_4.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_any$q_4.$$p = null;
      
      if ((block !== nil)) {
        $send(self, 'each', [], (TMP_5 = function($a_rest){var self = TMP_5.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(true)
            } else {
            return nil
          }}, TMP_5.$$s = self, TMP_5.$$arity = -1, TMP_5))
        } else {
        $send(self, 'each', [], (TMP_6 = function($a_rest){var self = TMP_6.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        if ($truthy(Opal.const_get_relative($nesting, 'Opal').$destructure(value))) {
            Opal.ret(true)
            } else {
            return nil
          }}, TMP_6.$$s = self, TMP_6.$$arity = -1, TMP_6))
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Enumerable_any$q_4.$$arity = 0);
    
    Opal.defn(self, '$chunk', TMP_Enumerable_chunk_7 = function $$chunk() {
      var TMP_8, TMP_9, self = this, $iter = TMP_Enumerable_chunk_7.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_chunk_7.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'to_enum', ["chunk"], (TMP_8 = function(){var self = TMP_8.$$s || this;

        return self.$enumerator_size()}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8))
      };
      return $send(Opal.const_get_qualified('::', 'Enumerator'), 'new', [], (TMP_9 = function(yielder){var self = TMP_9.$$s || this;
if (yielder == null) yielder = nil;
      
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = Opal.yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      }, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));
    }, TMP_Enumerable_chunk_7.$$arity = 0);
    
    Opal.defn(self, '$chunk_while', TMP_Enumerable_chunk_while_10 = function $$chunk_while() {
      var TMP_11, self = this, $iter = TMP_Enumerable_chunk_while_10.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_chunk_while_10.$$p = null;
      
      if ((block !== nil)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], (TMP_11 = function(before, after){var self = TMP_11.$$s || this;
if (before == null) before = nil;if (after == null) after = nil;
      return Opal.yieldX(block, [before, after])['$!']()}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11));
    }, TMP_Enumerable_chunk_while_10.$$arity = 0);
    
    Opal.defn(self, '$collect', TMP_Enumerable_collect_12 = function $$collect() {
      var TMP_13, self = this, $iter = TMP_Enumerable_collect_12.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_collect_12.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["collect"], (TMP_13 = function(){var self = TMP_13.$$s || this;

        return self.$enumerator_size()}, TMP_13.$$s = self, TMP_13.$$arity = 0, TMP_13))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = Opal.yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, TMP_Enumerable_collect_12.$$arity = 0);
    
    Opal.defn(self, '$collect_concat', TMP_Enumerable_collect_concat_14 = function $$collect_concat() {
      var TMP_15, TMP_16, self = this, $iter = TMP_Enumerable_collect_concat_14.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_collect_concat_14.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["collect_concat"], (TMP_15 = function(){var self = TMP_15.$$s || this;

        return self.$enumerator_size()}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15))
      };
      return $send(self, 'map', [], (TMP_16 = function(item){var self = TMP_16.$$s || this;
if (item == null) item = nil;
      return Opal.yield1(block, item);}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16)).$flatten(1);
    }, TMP_Enumerable_collect_concat_14.$$arity = 0);
    
    Opal.defn(self, '$count', TMP_Enumerable_count_17 = function $$count(object) {
      var TMP_18, TMP_19, TMP_20, self = this, $iter = TMP_Enumerable_count_17.$$p, block = $iter || nil, result = nil;

      if ($iter) TMP_Enumerable_count_17.$$p = null;
      
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send(self, 'proc', [], (TMP_18 = function($a_rest){var self = TMP_18.$$s || this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
        return Opal.const_get_relative($nesting, 'Opal').$destructure(args)['$=='](object)}, TMP_18.$$s = self, TMP_18.$$arity = -1, TMP_18))
      } else if ($truthy(block['$nil?']())) {
        block = $send(self, 'proc', [], (TMP_19 = function(){var self = TMP_19.$$s || this;

        return true}, TMP_19.$$s = self, TMP_19.$$arity = 0, TMP_19))};
      $send(self, 'each', [], (TMP_20 = function($a_rest){var self = TMP_20.$$s || this, args;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
      if ($truthy(Opal.yieldX(block, args))) {
          return result++
          } else {
          return nil
        }}, TMP_20.$$s = self, TMP_20.$$arity = -1, TMP_20));
      return result;
    }, TMP_Enumerable_count_17.$$arity = -1);
    
    Opal.defn(self, '$cycle', TMP_Enumerable_cycle_21 = function $$cycle(n) {
      var TMP_22, self = this, $iter = TMP_Enumerable_cycle_21.$$p, block = $iter || nil;

      if (n == null) {
        n = nil;
      }
      if ($iter) TMP_Enumerable_cycle_21.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["cycle", n], (TMP_22 = function(){var self = TMP_22.$$s || this;

        if (n['$=='](nil)) {
            if ($truthy(self['$respond_to?']("size"))) {
              return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')
              } else {
              return nil
            }
            } else {
            
            n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
              } else {
              return 0
            };
          }}, TMP_22.$$s = self, TMP_22.$$arity = 0, TMP_22))
      };
      if ($truthy(n['$nil?']())) {
        } else {
        
        n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil};
      };
      
      var result,
          all = [], i, length, value;

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, TMP_Enumerable_cycle_21.$$arity = -1);
    
    Opal.defn(self, '$detect', TMP_Enumerable_detect_23 = function $$detect(ifnone) {try {

      var TMP_24, self = this, $iter = TMP_Enumerable_detect_23.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_detect_23.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], (TMP_24 = function($a_rest){var self = TMP_24.$$s || this, args, value = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
      
        value = Opal.const_get_relative($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
          } else {
          return nil
        };}, TMP_24.$$s = self, TMP_24.$$arity = -1, TMP_24));
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Enumerable_detect_23.$$arity = -1);
    
    Opal.defn(self, '$drop', TMP_Enumerable_drop_25 = function $$drop(number) {
      var self = this;

      
      number = Opal.const_get_relative($nesting, 'Opal').$coerce_to(number, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      if ($truthy(number < 0)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "attempt to drop negative size")};
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push(Opal.const_get_relative($nesting, 'Opal').$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, TMP_Enumerable_drop_25.$$arity = 1);
    
    Opal.defn(self, '$drop_while', TMP_Enumerable_drop_while_26 = function $$drop_while() {
      var self = this, $iter = TMP_Enumerable_drop_while_26.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_drop_while_26.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

        if (dropping) {
          var value = Opal.yield1(block, param);

          if ($falsy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, TMP_Enumerable_drop_while_26.$$arity = 0);
    
    Opal.defn(self, '$each_cons', TMP_Enumerable_each_cons_27 = function $$each_cons(n) {
      var TMP_28, self = this, $iter = TMP_Enumerable_each_cons_27.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_each_cons_27.$$p = null;
      
      if ($truthy(arguments.length != 1)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 1)")};
      n = Opal.const_get_relative($nesting, 'Opal').$try_convert(n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "invalid size")};
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["each_cons", n], (TMP_28 = function(){var self = TMP_28.$$s || this, $a, enum_size = nil;

        
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if ($truthy(($truthy($a = enum_size['$=='](0)) ? $a : $rb_lt(enum_size, n)))) {
            return 0
            } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, TMP_28.$$s = self, TMP_28.$$arity = 0, TMP_28))
      };
      
      var buffer = [], result = nil;

      self.$each.$$p = function() {
        var element = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          Opal.yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return result;
    ;
    }, TMP_Enumerable_each_cons_27.$$arity = 1);
    
    Opal.defn(self, '$each_entry', TMP_Enumerable_each_entry_29 = function $$each_entry($a_rest) {
      var TMP_30, self = this, data, $iter = TMP_Enumerable_each_entry_29.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      data = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        data[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Enumerable_each_entry_29.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'to_enum', ["each_entry"].concat(Opal.to_a(data)), (TMP_30 = function(){var self = TMP_30.$$s || this;

        return self.$enumerator_size()}, TMP_30.$$s = self, TMP_30.$$arity = 0, TMP_30))
      };
      
      self.$each.$$p = function() {
        var item = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

        Opal.yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, TMP_Enumerable_each_entry_29.$$arity = -1);
    
    Opal.defn(self, '$each_slice', TMP_Enumerable_each_slice_31 = function $$each_slice(n) {
      var TMP_32, self = this, $iter = TMP_Enumerable_each_slice_31.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_each_slice_31.$$p = null;
      
      n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "invalid slice size")};
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["each_slice", n], (TMP_32 = function(){var self = TMP_32.$$s || this;

        if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
            } else {
            return nil
          }}, TMP_32.$$s = self, TMP_32.$$arity = 0, TMP_32))
      };
      
      var result,
          slice = []

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          Opal.yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      if (result !== undefined) {
        return result;
      }

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        Opal.yield1(block, slice);
      }
    ;
      return nil;
    }, TMP_Enumerable_each_slice_31.$$arity = 1);
    
    Opal.defn(self, '$each_with_index', TMP_Enumerable_each_with_index_33 = function $$each_with_index($a_rest) {
      var TMP_34, self = this, args, $iter = TMP_Enumerable_each_with_index_33.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Enumerable_each_with_index_33.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["each_with_index"].concat(Opal.to_a(args)), (TMP_34 = function(){var self = TMP_34.$$s || this;

        return self.$enumerator_size()}, TMP_34.$$s = self, TMP_34.$$arity = 0, TMP_34))
      };
      
      var result,
          index = 0;

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);

      if (result !== undefined) {
        return result;
      }
    ;
      return self;
    }, TMP_Enumerable_each_with_index_33.$$arity = -1);
    
    Opal.defn(self, '$each_with_object', TMP_Enumerable_each_with_object_35 = function $$each_with_object(object) {
      var TMP_36, self = this, $iter = TMP_Enumerable_each_with_object_35.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_each_with_object_35.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["each_with_object", object], (TMP_36 = function(){var self = TMP_36.$$s || this;

        return self.$enumerator_size()}, TMP_36.$$s = self, TMP_36.$$arity = 0, TMP_36))
      };
      
      var result;

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

        block(param, object);
      };

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return object;
    }, TMP_Enumerable_each_with_object_35.$$arity = 1);
    
    Opal.defn(self, '$entries', TMP_Enumerable_entries_37 = function $$entries($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      var result = [];

      self.$each.$$p = function() {
        result.push(Opal.const_get_relative($nesting, 'Opal').$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    
    }, TMP_Enumerable_entries_37.$$arity = -1);
    Opal.alias(self, "find", "detect");
    
    Opal.defn(self, '$find_all', TMP_Enumerable_find_all_38 = function $$find_all() {
      var TMP_39, self = this, $iter = TMP_Enumerable_find_all_38.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_find_all_38.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["find_all"], (TMP_39 = function(){var self = TMP_39.$$s || this;

        return self.$enumerator_size()}, TMP_39.$$s = self, TMP_39.$$arity = 0, TMP_39))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, TMP_Enumerable_find_all_38.$$arity = 0);
    
    Opal.defn(self, '$find_index', TMP_Enumerable_find_index_40 = function $$find_index(object) {try {

      var TMP_41, TMP_42, self = this, $iter = TMP_Enumerable_find_index_40.$$p, block = $iter || nil, index = nil;

      if ($iter) TMP_Enumerable_find_index_40.$$p = null;
      
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")};
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], (TMP_41 = function($a_rest){var self = TMP_41.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        
          if (Opal.const_get_relative($nesting, 'Opal').$destructure(value)['$=='](object)) {
            Opal.ret(index)};
          return index += 1;}, TMP_41.$$s = self, TMP_41.$$arity = -1, TMP_41))
        } else {
        $send(self, 'each', [], (TMP_42 = function($a_rest){var self = TMP_42.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(index)};
          return index += 1;}, TMP_42.$$s = self, TMP_42.$$arity = -1, TMP_42))
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Enumerable_find_index_40.$$arity = -1);
    
    Opal.defn(self, '$first', TMP_Enumerable_first_45 = function $$first(number) {try {

      var TMP_43, TMP_44, self = this, result = nil, current = nil;

      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], (TMP_43 = function(value){var self = TMP_43.$$s || this;
if (value == null) value = nil;
        Opal.ret(value)}, TMP_43.$$s = self, TMP_43.$$arity = 1, TMP_43))
        } else {
        
        result = [];
        number = Opal.const_get_relative($nesting, 'Opal').$coerce_to(number, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy(number < 0)) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "attempt to take negative size")};
        if ($truthy(number == 0)) {
          return []};
        current = 0;
        $send(self, 'each', [], (TMP_44 = function($a_rest){var self = TMP_44.$$s || this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
        
          result.push(Opal.const_get_relative($nesting, 'Opal').$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
            } else {
            return nil
          };}, TMP_44.$$s = self, TMP_44.$$arity = -1, TMP_44));
        return result;
      }
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Enumerable_first_45.$$arity = -1);
    Opal.alias(self, "flat_map", "collect_concat");
    
    Opal.defn(self, '$grep', TMP_Enumerable_grep_46 = function $$grep(pattern) {
      var self = this, $iter = TMP_Enumerable_grep_46.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_grep_46.$$p = null;
      
      var result = [];

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
              value = pattern['$==='](param);

          if ($truthy(value)) {
            value = Opal.yield1(block, param);

            result.push(value);
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
              value = pattern['$==='](param);

          if ($truthy(value)) {
            result.push(param);
          }
        };
      }

      self.$each();

      return result;
    
    }, TMP_Enumerable_grep_46.$$arity = 1);
    
    Opal.defn(self, '$grep_v', TMP_Enumerable_grep_v_47 = function $$grep_v(pattern) {
      var self = this, $iter = TMP_Enumerable_grep_v_47.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_grep_v_47.$$p = null;
      
      var result = [];

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
              value = pattern['$==='](param);

          if ($falsy(value)) {
            value = Opal.yield1(block, param);

            result.push(value);
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
              value = pattern['$==='](param);

          if ($falsy(value)) {
            result.push(param);
          }
        };
      }

      self.$each();

      return result;
    
    }, TMP_Enumerable_grep_v_47.$$arity = 1);
    
    Opal.defn(self, '$group_by', TMP_Enumerable_group_by_48 = function $$group_by() {
      var TMP_49, $a, self = this, $iter = TMP_Enumerable_group_by_48.$$p, block = $iter || nil, hash = nil, $writer = nil;

      if ($iter) TMP_Enumerable_group_by_48.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["group_by"], (TMP_49 = function(){var self = TMP_49.$$s || this;

        return self.$enumerator_size()}, TMP_49.$$s = self, TMP_49.$$arity = 0, TMP_49))
      };
      hash = Opal.const_get_relative($nesting, 'Hash').$new();
      
      var result;

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        ($truthy($a = hash['$[]'](value)) ? $a : (($writer = [value, []]), $send(hash, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, TMP_Enumerable_group_by_48.$$arity = 0);
    
    Opal.defn(self, '$include?', TMP_Enumerable_include$q_51 = function(obj) {try {

      var TMP_50, self = this;

      
      $send(self, 'each', [], (TMP_50 = function($a_rest){var self = TMP_50.$$s || this, args;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
      if (Opal.const_get_relative($nesting, 'Opal').$destructure(args)['$=='](obj)) {
          Opal.ret(true)
          } else {
          return nil
        }}, TMP_50.$$s = self, TMP_50.$$arity = -1, TMP_50));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Enumerable_include$q_51.$$arity = 1);
    
    Opal.defn(self, '$inject', TMP_Enumerable_inject_52 = function $$inject(object, sym) {
      var self = this, $iter = TMP_Enumerable_inject_52.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_inject_52.$$p = null;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = Opal.yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!Opal.const_get_relative($nesting, 'Symbol')['$==='](object)) {
            self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    
    }, TMP_Enumerable_inject_52.$$arity = -1);
    
    Opal.defn(self, '$lazy', TMP_Enumerable_lazy_54 = function $$lazy() {
      var TMP_53, self = this;

      return $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], (TMP_53 = function(enum$, $a_rest){var self = TMP_53.$$s || this, args;

        var $args_len = arguments.length, $rest_len = $args_len - 1;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 1] = arguments[$arg_idx];
        }if (enum$ == null) enum$ = nil;
      return $send(enum$, 'yield', Opal.to_a(args))}, TMP_53.$$s = self, TMP_53.$$arity = -2, TMP_53))
    }, TMP_Enumerable_lazy_54.$$arity = 0);
    
    Opal.defn(self, '$enumerator_size', TMP_Enumerable_enumerator_size_55 = function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
        } else {
        return nil
      }
    }, TMP_Enumerable_enumerator_size_55.$$arity = 0);
    Opal.alias(self, "map", "collect");
    
    Opal.defn(self, '$max', TMP_Enumerable_max_56 = function $$max(n) {
      var self = this, $iter = TMP_Enumerable_max_56.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_max_56.$$p = null;
      
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = Opal.yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }
    ;
      n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, TMP_Enumerable_max_56.$$arity = -1);
    
    Opal.defn(self, '$max_by', TMP_Enumerable_max_by_57 = function $$max_by() {
      var TMP_58, self = this, $iter = TMP_Enumerable_max_by_57.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_max_by_57.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["max_by"], (TMP_58 = function(){var self = TMP_58.$$s || this;

        return self.$enumerator_size()}, TMP_58.$$s = self, TMP_58.$$arity = 0, TMP_58))
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, TMP_Enumerable_max_by_57.$$arity = 0);
    Opal.alias(self, "member?", "include?");
    
    Opal.defn(self, '$min', TMP_Enumerable_min_59 = function $$min() {
      var self = this, $iter = TMP_Enumerable_min_59.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_min_59.$$p = null;
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if (Opal.const_get_relative($nesting, 'Opal').$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    
    }, TMP_Enumerable_min_59.$$arity = 0);
    
    Opal.defn(self, '$min_by', TMP_Enumerable_min_by_60 = function $$min_by() {
      var TMP_61, self = this, $iter = TMP_Enumerable_min_by_60.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_min_by_60.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["min_by"], (TMP_61 = function(){var self = TMP_61.$$s || this;

        return self.$enumerator_size()}, TMP_61.$$s = self, TMP_61.$$arity = 0, TMP_61))
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, TMP_Enumerable_min_by_60.$$arity = 0);
    
    Opal.defn(self, '$minmax', TMP_Enumerable_minmax_62 = function $$minmax() {
      var $a, TMP_63, self = this, $iter = TMP_Enumerable_minmax_62.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_minmax_62.$$p = null;
      
      block = ($truthy($a = block) ? $a : $send(self, 'proc', [], (TMP_63 = function(a, b){var self = TMP_63.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
      return a['$<=>'](b)}, TMP_63.$$s = self, TMP_63.$$arity = 2, TMP_63)));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, TMP_Enumerable_minmax_62.$$arity = 0);
    
    Opal.defn(self, '$minmax_by', TMP_Enumerable_minmax_by_64 = function $$minmax_by() {
      var self = this, $iter = TMP_Enumerable_minmax_by_64.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_minmax_by_64.$$p = null;
      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))
    }, TMP_Enumerable_minmax_by_64.$$arity = 0);
    
    Opal.defn(self, '$none?', TMP_Enumerable_none$q_65 = function() {try {

      var TMP_66, TMP_67, self = this, $iter = TMP_Enumerable_none$q_65.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_none$q_65.$$p = null;
      
      if ((block !== nil)) {
        $send(self, 'each', [], (TMP_66 = function($a_rest){var self = TMP_66.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(false)
            } else {
            return nil
          }}, TMP_66.$$s = self, TMP_66.$$arity = -1, TMP_66))
        } else {
        $send(self, 'each', [], (TMP_67 = function($a_rest){var self = TMP_67.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        if ($truthy(Opal.const_get_relative($nesting, 'Opal').$destructure(value))) {
            Opal.ret(false)
            } else {
            return nil
          }}, TMP_67.$$s = self, TMP_67.$$arity = -1, TMP_67))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Enumerable_none$q_65.$$arity = 0);
    
    Opal.defn(self, '$one?', TMP_Enumerable_one$q_68 = function() {try {

      var TMP_69, TMP_70, self = this, $iter = TMP_Enumerable_one$q_68.$$p, block = $iter || nil, count = nil;

      if ($iter) TMP_Enumerable_one$q_68.$$p = null;
      
      count = 0;
      if ((block !== nil)) {
        $send(self, 'each', [], (TMP_69 = function($a_rest){var self = TMP_69.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
              } else {
              return nil
            };
            } else {
            return nil
          }}, TMP_69.$$s = self, TMP_69.$$arity = -1, TMP_69))
        } else {
        $send(self, 'each', [], (TMP_70 = function($a_rest){var self = TMP_70.$$s || this, value;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          value = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            value[$arg_idx - 0] = arguments[$arg_idx];
          }
        if ($truthy(Opal.const_get_relative($nesting, 'Opal').$destructure(value))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
              } else {
              return nil
            };
            } else {
            return nil
          }}, TMP_70.$$s = self, TMP_70.$$arity = -1, TMP_70))
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Enumerable_one$q_68.$$arity = 0);
    
    Opal.defn(self, '$partition', TMP_Enumerable_partition_71 = function $$partition() {
      var TMP_72, self = this, $iter = TMP_Enumerable_partition_71.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_partition_71.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["partition"], (TMP_72 = function(){var self = TMP_72.$$s || this;

        return self.$enumerator_size()}, TMP_72.$$s = self, TMP_72.$$arity = 0, TMP_72))
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, TMP_Enumerable_partition_71.$$arity = 0);
    Opal.alias(self, "reduce", "inject");
    
    Opal.defn(self, '$reject', TMP_Enumerable_reject_73 = function $$reject() {
      var TMP_74, self = this, $iter = TMP_Enumerable_reject_73.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_reject_73.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["reject"], (TMP_74 = function(){var self = TMP_74.$$s || this;

        return self.$enumerator_size()}, TMP_74.$$s = self, TMP_74.$$arity = 0, TMP_74))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($falsy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, TMP_Enumerable_reject_73.$$arity = 0);
    
    Opal.defn(self, '$reverse_each', TMP_Enumerable_reverse_each_75 = function $$reverse_each() {
      var TMP_76, self = this, $iter = TMP_Enumerable_reverse_each_75.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_reverse_each_75.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["reverse_each"], (TMP_76 = function(){var self = TMP_76.$$s || this;

        return self.$enumerator_size()}, TMP_76.$$s = self, TMP_76.$$arity = 0, TMP_76))
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        Opal.yieldX(block, result[i]);
      }

      return result;
    ;
    }, TMP_Enumerable_reverse_each_75.$$arity = 0);
    Opal.alias(self, "select", "find_all");
    
    Opal.defn(self, '$slice_before', TMP_Enumerable_slice_before_77 = function $$slice_before(pattern) {
      var TMP_78, self = this, $iter = TMP_Enumerable_slice_before_77.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_slice_before_77.$$p = null;
      
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      return $send(Opal.const_get_relative($nesting, 'Enumerator'), 'new', [], (TMP_78 = function(e){var self = TMP_78.$$s || this;
if (e == null) e = nil;
      
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
                  value = Opal.yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      }, TMP_78.$$s = self, TMP_78.$$arity = 1, TMP_78));
    }, TMP_Enumerable_slice_before_77.$$arity = -1);
    
    Opal.defn(self, '$slice_after', TMP_Enumerable_slice_after_79 = function $$slice_after(pattern) {
      var TMP_80, TMP_81, self = this, $iter = TMP_Enumerable_slice_after_79.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_slice_after_79.$$p = null;
      
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      if ($truthy(pattern !== undefined)) {
        block = $send(self, 'proc', [], (TMP_80 = function(e){var self = TMP_80.$$s || this;
if (e == null) e = nil;
        return pattern['$==='](e)}, TMP_80.$$s = self, TMP_80.$$arity = 1, TMP_80))};
      return $send(Opal.const_get_relative($nesting, 'Enumerator'), 'new', [], (TMP_81 = function(yielder){var self = TMP_81.$$s || this;
if (yielder == null) yielder = nil;
      
        var accumulate;

        self.$each.$$p = function() {
          var element = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
              end_chunk = Opal.yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      }, TMP_81.$$s = self, TMP_81.$$arity = 1, TMP_81));
    }, TMP_Enumerable_slice_after_79.$$arity = -1);
    
    Opal.defn(self, '$slice_when', TMP_Enumerable_slice_when_82 = function $$slice_when() {
      var TMP_83, self = this, $iter = TMP_Enumerable_slice_when_82.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerable_slice_when_82.$$p = null;
      
      if ((block !== nil)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send(Opal.const_get_relative($nesting, 'Enumerator'), 'new', [], (TMP_83 = function(yielder){var self = TMP_83.$$s || this;
if (yielder == null) yielder = nil;
      
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
              before = params[0],
              after = params[1],
              match = Opal.yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      }, TMP_83.$$s = self, TMP_83.$$arity = 1, TMP_83));
    }, TMP_Enumerable_slice_when_82.$$arity = 0);
    
    Opal.defn(self, '$sort', TMP_Enumerable_sort_84 = function $$sort() {
      var TMP_85, self = this, $iter = TMP_Enumerable_sort_84.$$p, block = $iter || nil, ary = nil;

      if ($iter) TMP_Enumerable_sort_84.$$p = null;
      
      ary = self.$to_a();
      if ((block !== nil)) {
        } else {
        block = $send(self, 'lambda', [], (TMP_85 = function(a, b){var self = TMP_85.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
        return a['$<=>'](b)}, TMP_85.$$s = self, TMP_85.$$arity = 2, TMP_85))
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, TMP_Enumerable_sort_84.$$arity = 0);
    
    Opal.defn(self, '$sort_by', TMP_Enumerable_sort_by_86 = function $$sort_by() {
      var TMP_87, TMP_88, TMP_89, TMP_90, self = this, $iter = TMP_Enumerable_sort_by_86.$$p, block = $iter || nil, dup = nil;

      if ($iter) TMP_Enumerable_sort_by_86.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["sort_by"], (TMP_87 = function(){var self = TMP_87.$$s || this;

        return self.$enumerator_size()}, TMP_87.$$s = self, TMP_87.$$arity = 0, TMP_87))
      };
      dup = $send(self, 'map', [], (TMP_88 = function(){var self = TMP_88.$$s || this, arg = nil;

      
        arg = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, TMP_88.$$s = self, TMP_88.$$arity = 0, TMP_88));
      $send(dup, 'sort!', [], (TMP_89 = function(a, b){var self = TMP_89.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
      return (a[0])['$<=>'](b[0])}, TMP_89.$$s = self, TMP_89.$$arity = 2, TMP_89));
      return $send(dup, 'map!', [], (TMP_90 = function(i){var self = TMP_90.$$s || this;
if (i == null) i = nil;
      return i[1]}, TMP_90.$$s = self, TMP_90.$$arity = 1, TMP_90));
    }, TMP_Enumerable_sort_by_86.$$arity = 0);
    
    Opal.defn(self, '$sum', TMP_Enumerable_sum_91 = function $$sum(initial) {
      var TMP_92, self = this, $iter = TMP_Enumerable_sum_91.$$p, block = $iter || nil, result = nil;

      if (initial == null) {
        initial = 0;
      }
      if ($iter) TMP_Enumerable_sum_91.$$p = null;
      
      result = initial;
      $send(self, 'each', [], (TMP_92 = function($a_rest){var self = TMP_92.$$s || this, args, item = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
      
        if ((block !== nil)) {
          item = $send(block, 'call', Opal.to_a(args))
          } else {
          item = Opal.const_get_relative($nesting, 'Opal').$destructure(args)
        };
        return (result = $rb_plus(result, item));}, TMP_92.$$s = self, TMP_92.$$arity = -1, TMP_92));
      return result;
    }, TMP_Enumerable_sum_91.$$arity = -1);
    
    Opal.defn(self, '$take', TMP_Enumerable_take_93 = function $$take(num) {
      var self = this;

      return self.$first(num)
    }, TMP_Enumerable_take_93.$$arity = 1);
    
    Opal.defn(self, '$take_while', TMP_Enumerable_take_while_94 = function $$take_while() {try {

      var TMP_95, self = this, $iter = TMP_Enumerable_take_while_94.$$p, block = $iter || nil, result = nil;

      if ($iter) TMP_Enumerable_take_while_94.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], (TMP_95 = function($a_rest){var self = TMP_95.$$s || this, args, value = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
      
        value = Opal.const_get_relative($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          } else {
          Opal.ret(result)
        };
        return result.push(value);}, TMP_95.$$s = self, TMP_95.$$arity = -1, TMP_95));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Enumerable_take_while_94.$$arity = 0);
    
    Opal.defn(self, '$uniq', TMP_Enumerable_uniq_96 = function $$uniq() {
      var TMP_97, self = this, $iter = TMP_Enumerable_uniq_96.$$p, block = $iter || nil, hash = nil;

      if ($iter) TMP_Enumerable_uniq_96.$$p = null;
      
      hash = $hash2([], {});
      $send(self, 'each', [], (TMP_97 = function($a_rest){var self = TMP_97.$$s || this, args, value = nil, produced = nil, $writer = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
      
        value = Opal.const_get_relative($nesting, 'Opal').$destructure(args);
        produced = (function() {if ((block !== nil)) {
          return block.$call(value)
          } else {
          return value
        }; return nil; })();
        if ($truthy(hash['$has_key?'](produced))) {
          return nil
          } else {
          
          $writer = [produced, value];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };}, TMP_97.$$s = self, TMP_97.$$arity = -1, TMP_97));
      return hash.$values();
    }, TMP_Enumerable_uniq_96.$$arity = 0);
    Opal.alias(self, "to_a", "entries");
    
    Opal.defn(self, '$zip', TMP_Enumerable_zip_98 = function $$zip($a_rest) {
      var self = this, others, $iter = TMP_Enumerable_zip_98.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      others = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        others[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Enumerable_zip_98.$$p = null;
      return $send(self.$to_a(), 'zip', Opal.to_a(others))
    }, TMP_Enumerable_zip_98.$$arity = -1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/enumerator"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy;

  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$coerce_to', '$nil?', '$empty?', '$+', '$class', '$__send__', '$===', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$respond_to?', '$try_convert', '$<', '$for']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    function $Enumerator(){};
    var self = $Enumerator = $klass($base, $super, 'Enumerator', $Enumerator);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerator_for_1, TMP_Enumerator_initialize_2, TMP_Enumerator_each_3, TMP_Enumerator_size_4, TMP_Enumerator_with_index_5, TMP_Enumerator_inspect_7;

    def.size = def.args = def.object = def.method = nil;
    
    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
    def.$$is_enumerator = true;
    Opal.defs(self, '$for', TMP_Enumerator_for_1 = function(object, method, $a_rest) {
      var self = this, args, $iter = TMP_Enumerator_for_1.$$p, block = $iter || nil;

      if (method == null) {
        method = "each";
      }
      var $args_len = arguments.length, $rest_len = $args_len - 2;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 2; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 2] = arguments[$arg_idx];
      }
      if ($iter) TMP_Enumerator_for_1.$$p = null;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;

      return obj;
    
    }, TMP_Enumerator_for_1.$$arity = -2);
    
    Opal.defn(self, '$initialize', TMP_Enumerator_initialize_2 = function $$initialize($a_rest) {
      var self = this, $iter = TMP_Enumerator_initialize_2.$$p, block = $iter || nil;

      if ($iter) TMP_Enumerator_initialize_2.$$p = null;
      if ($truthy(block)) {
        
        self.object = $send(Opal.const_get_relative($nesting, 'Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if ($truthy(self.size)) {
          return (self.size = Opal.const_get_relative($nesting, 'Opal').$coerce_to(self.size, Opal.const_get_relative($nesting, 'Integer'), "to_int"))
          } else {
          return nil
        };
        } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      }
    }, TMP_Enumerator_initialize_2.$$arity = -1);
    
    Opal.defn(self, '$each', TMP_Enumerator_each_3 = function $$each($a_rest) {
      var $b, self = this, args, $iter = TMP_Enumerator_each_3.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Enumerator_each_3.$$p = null;
      
      if ($truthy(($truthy($b = block['$nil?']()) ? args['$empty?']() : $b))) {
        return self};
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};
      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());
    }, TMP_Enumerator_each_3.$$arity = -1);
    
    Opal.defn(self, '$size', TMP_Enumerator_size_4 = function $$size() {
      var self = this;

      if ($truthy(Opal.const_get_relative($nesting, 'Proc')['$==='](self.size))) {
        return $send(self.size, 'call', Opal.to_a(self.args))
        } else {
        return self.size
      }
    }, TMP_Enumerator_size_4.$$arity = 0);
    
    Opal.defn(self, '$with_index', TMP_Enumerator_with_index_5 = function $$with_index(offset) {
      var TMP_6, self = this, $iter = TMP_Enumerator_with_index_5.$$p, block = $iter || nil;

      if (offset == null) {
        offset = 0;
      }
      if ($iter) TMP_Enumerator_with_index_5.$$p = null;
      
      if ($truthy(offset)) {
        offset = Opal.const_get_relative($nesting, 'Opal').$coerce_to(offset, Opal.const_get_relative($nesting, 'Integer'), "to_int")
        } else {
        offset = 0
      };
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["with_index", offset], (TMP_6 = function(){var self = TMP_6.$$s || this;

        return self.$size()}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6))
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = Opal.const_get_relative($nesting, 'Opal').$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, TMP_Enumerator_with_index_5.$$arity = -1);
    Opal.alias(self, "with_object", "each_with_object");
    
    Opal.defn(self, '$inspect', TMP_Enumerator_inspect_7 = function $$inspect() {
      var self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$empty?']())) {
        } else {
        result = $rb_plus(result, "" + "(" + (self.args.$inspect()['$[]'](Opal.const_get_relative($nesting, 'Range').$new(1, -2))) + ")")
      };
      return $rb_plus(result, ">");
    }, TMP_Enumerator_inspect_7.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      function $Generator(){};
      var self = $Generator = $klass($base, $super, 'Generator', $Generator);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Generator_initialize_8, TMP_Generator_each_9;

      def.block = nil;
      
      self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
      
      Opal.defn(self, '$initialize', TMP_Generator_initialize_8 = function $$initialize() {
        var self = this, $iter = TMP_Generator_initialize_8.$$p, block = $iter || nil;

        if ($iter) TMP_Generator_initialize_8.$$p = null;
        
        if ($truthy(block)) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, TMP_Generator_initialize_8.$$arity = 0);
      return (Opal.defn(self, '$each', TMP_Generator_each_9 = function $$each($a_rest) {
        var self = this, args, $iter = TMP_Generator_each_9.$$p, block = $iter || nil, yielder = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
        if ($iter) TMP_Generator_each_9.$$p = null;
        
        yielder = $send(Opal.const_get_relative($nesting, 'Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, TMP_Generator_each_9.$$arity = -1), nil) && 'each';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      function $Yielder(){};
      var self = $Yielder = $klass($base, $super, 'Yielder', $Yielder);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Yielder_initialize_10, TMP_Yielder_yield_11, TMP_Yielder_$lt$lt_12;

      def.block = nil;
      
      
      Opal.defn(self, '$initialize', TMP_Yielder_initialize_10 = function $$initialize() {
        var self = this, $iter = TMP_Yielder_initialize_10.$$p, block = $iter || nil;

        if ($iter) TMP_Yielder_initialize_10.$$p = null;
        return (self.block = block)
      }, TMP_Yielder_initialize_10.$$arity = 0);
      
      Opal.defn(self, '$yield', TMP_Yielder_yield_11 = function($a_rest) {
        var self = this, values;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        values = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          values[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      
      }, TMP_Yielder_yield_11.$$arity = -1);
      return (Opal.defn(self, '$<<', TMP_Yielder_$lt$lt_12 = function($a_rest) {
        var self = this, values;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        values = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          values[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        $send(self, 'yield', Opal.to_a(values));
        return self;
      }, TMP_Yielder_$lt$lt_12.$$arity = -1), nil) && '<<';
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      function $Lazy(){};
      var self = $Lazy = $klass($base, $super, 'Lazy', $Lazy);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Lazy_initialize_13, TMP_Lazy_lazy_16, TMP_Lazy_collect_17, TMP_Lazy_collect_concat_19, TMP_Lazy_drop_24, TMP_Lazy_drop_while_25, TMP_Lazy_enum_for_27, TMP_Lazy_find_all_28, TMP_Lazy_grep_30, TMP_Lazy_reject_33, TMP_Lazy_take_36, TMP_Lazy_take_while_37, TMP_Lazy_inspect_39;

      def.enumerator = nil;
      
      (function($base, $super, $parent_nesting) {
        function $StopLazyError(){};
        var self = $StopLazyError = $klass($base, $super, 'StopLazyError', $StopLazyError);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], Opal.const_get_relative($nesting, 'Exception'), $nesting);
      
      Opal.defn(self, '$initialize', TMP_Lazy_initialize_13 = function $$initialize(object, size) {
        var TMP_14, self = this, $iter = TMP_Lazy_initialize_13.$$p, block = $iter || nil;

        if (size == null) {
          size = nil;
        }
        if ($iter) TMP_Lazy_initialize_13.$$p = null;
        
        if ((block !== nil)) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Lazy_initialize_13, false), [size], (TMP_14 = function(yielder, $a_rest){var self = TMP_14.$$s || this, each_args, TMP_15;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          each_args = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            each_args[$arg_idx - 1] = arguments[$arg_idx];
          }if (yielder == null) yielder = nil;
        
          try {
            return $send(object, 'each', Opal.to_a(each_args), (TMP_15 = function($a_rest){var self = TMP_15.$$s || this, args;

              var $args_len = arguments.length, $rest_len = $args_len - 0;
              if ($rest_len < 0) { $rest_len = 0; }
              args = new Array($rest_len);
              for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
                args[$arg_idx - 0] = arguments[$arg_idx];
              }
            
              args.unshift(yielder);

              Opal.yieldX(block, args);
            }, TMP_15.$$s = self, TMP_15.$$arity = -1, TMP_15))
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };}, TMP_14.$$s = self, TMP_14.$$arity = -2, TMP_14));
      }, TMP_Lazy_initialize_13.$$arity = -2);
      Opal.alias(self, "force", "to_a");
      
      Opal.defn(self, '$lazy', TMP_Lazy_lazy_16 = function $$lazy() {
        var self = this;

        return self
      }, TMP_Lazy_lazy_16.$$arity = 0);
      
      Opal.defn(self, '$collect', TMP_Lazy_collect_17 = function $$collect() {
        var TMP_18, self = this, $iter = TMP_Lazy_collect_17.$$p, block = $iter || nil;

        if ($iter) TMP_Lazy_collect_17.$$p = null;
        
        if ($truthy(block)) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], (TMP_18 = function(enum$, $a_rest){var self = TMP_18.$$s || this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 1] = arguments[$arg_idx];
          }if (enum$ == null) enum$ = nil;
        
          var value = Opal.yieldX(block, args);

          enum$.$yield(value);
        }, TMP_18.$$s = self, TMP_18.$$arity = -2, TMP_18));
      }, TMP_Lazy_collect_17.$$arity = 0);
      
      Opal.defn(self, '$collect_concat', TMP_Lazy_collect_concat_19 = function $$collect_concat() {
        var TMP_20, self = this, $iter = TMP_Lazy_collect_concat_19.$$p, block = $iter || nil;

        if ($iter) TMP_Lazy_collect_concat_19.$$p = null;
        
        if ($truthy(block)) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_20 = function(enum$, $a_rest){var self = TMP_20.$$s || this, args, TMP_21, TMP_22;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 1] = arguments[$arg_idx];
          }if (enum$ == null) enum$ = nil;
        
          var value = Opal.yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], (TMP_21 = function(v){var self = TMP_21.$$s || this;
if (v == null) v = nil;
          return enum$.$yield(v)}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21))
          }
          else {
            var array = Opal.const_get_relative($nesting, 'Opal').$try_convert(value, Opal.const_get_relative($nesting, 'Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], (TMP_22 = function(v){var self = TMP_22.$$s || this;
if (v == null) v = nil;
          return enum$.$yield(v)}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22));
            }
          }
        }, TMP_20.$$s = self, TMP_20.$$arity = -2, TMP_20));
      }, TMP_Lazy_collect_concat_19.$$arity = 0);
      
      Opal.defn(self, '$drop', TMP_Lazy_drop_24 = function $$drop(n) {
        var TMP_23, self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(n, 0))) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "attempt to drop negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
            } else {
            return current_size
          }
          } else {
          return current_size
        }; return nil; })();
        dropped = 0;
        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, set_size], (TMP_23 = function(enum$, $a_rest){var self = TMP_23.$$s || this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 1] = arguments[$arg_idx];
          }if (enum$ == null) enum$ = nil;
        if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
            } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          }}, TMP_23.$$s = self, TMP_23.$$arity = -2, TMP_23));
      }, TMP_Lazy_drop_24.$$arity = 1);
      
      Opal.defn(self, '$drop_while', TMP_Lazy_drop_while_25 = function $$drop_while() {
        var TMP_26, self = this, $iter = TMP_Lazy_drop_while_25.$$p, block = $iter || nil, succeeding = nil;

        if ($iter) TMP_Lazy_drop_while_25.$$p = null;
        
        if ($truthy(block)) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_26 = function(enum$, $a_rest){var self = TMP_26.$$s || this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 1] = arguments[$arg_idx];
          }if (enum$ == null) enum$ = nil;
        if ($truthy(succeeding)) {
            
            var value = Opal.yieldX(block, args);

            if ($falsy(value)) {
              succeeding = false;

              $send(enum$, 'yield', Opal.to_a(args));
            }
          
            } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          }}, TMP_26.$$s = self, TMP_26.$$arity = -2, TMP_26));
      }, TMP_Lazy_drop_while_25.$$arity = 0);
      
      Opal.defn(self, '$enum_for', TMP_Lazy_enum_for_27 = function $$enum_for(method, $a_rest) {
        var self = this, args, $iter = TMP_Lazy_enum_for_27.$$p, block = $iter || nil;

        if (method == null) {
          method = "each";
        }
        var $args_len = arguments.length, $rest_len = $args_len - 1;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 1] = arguments[$arg_idx];
        }
        if ($iter) TMP_Lazy_enum_for_27.$$p = null;
        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc())
      }, TMP_Lazy_enum_for_27.$$arity = -1);
      
      Opal.defn(self, '$find_all', TMP_Lazy_find_all_28 = function $$find_all() {
        var TMP_29, self = this, $iter = TMP_Lazy_find_all_28.$$p, block = $iter || nil;

        if ($iter) TMP_Lazy_find_all_28.$$p = null;
        
        if ($truthy(block)) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to call lazy select without a block")
        };
        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_29 = function(enum$, $a_rest){var self = TMP_29.$$s || this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 1] = arguments[$arg_idx];
          }if (enum$ == null) enum$ = nil;
        
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        }, TMP_29.$$s = self, TMP_29.$$arity = -2, TMP_29));
      }, TMP_Lazy_find_all_28.$$arity = 0);
      Opal.alias(self, "flat_map", "collect_concat");
      
      Opal.defn(self, '$grep', TMP_Lazy_grep_30 = function $$grep(pattern) {
        var TMP_31, TMP_32, self = this, $iter = TMP_Lazy_grep_30.$$p, block = $iter || nil;

        if ($iter) TMP_Lazy_grep_30.$$p = null;
        if ($truthy(block)) {
          return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_31 = function(enum$, $a_rest){var self = TMP_31.$$s || this, args;

            var $args_len = arguments.length, $rest_len = $args_len - 1;
            if ($rest_len < 0) { $rest_len = 0; }
            args = new Array($rest_len);
            for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
              args[$arg_idx - 1] = arguments[$arg_idx];
            }if (enum$ == null) enum$ = nil;
          
            var param = Opal.const_get_relative($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = Opal.yield1(block, param);

              enum$.$yield(Opal.yield1(block, param));
            }
          }, TMP_31.$$s = self, TMP_31.$$arity = -2, TMP_31))
          } else {
          return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_32 = function(enum$, $a_rest){var self = TMP_32.$$s || this, args;

            var $args_len = arguments.length, $rest_len = $args_len - 1;
            if ($rest_len < 0) { $rest_len = 0; }
            args = new Array($rest_len);
            for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
              args[$arg_idx - 1] = arguments[$arg_idx];
            }if (enum$ == null) enum$ = nil;
          
            var param = Opal.const_get_relative($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          }, TMP_32.$$s = self, TMP_32.$$arity = -2, TMP_32))
        }
      }, TMP_Lazy_grep_30.$$arity = 1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "select", "find_all");
      
      Opal.defn(self, '$reject', TMP_Lazy_reject_33 = function $$reject() {
        var TMP_34, self = this, $iter = TMP_Lazy_reject_33.$$p, block = $iter || nil;

        if ($iter) TMP_Lazy_reject_33.$$p = null;
        
        if ($truthy(block)) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_34 = function(enum$, $a_rest){var self = TMP_34.$$s || this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 1] = arguments[$arg_idx];
          }if (enum$ == null) enum$ = nil;
        
          var value = Opal.yieldX(block, args);

          if ($falsy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        }, TMP_34.$$s = self, TMP_34.$$arity = -2, TMP_34));
      }, TMP_Lazy_reject_33.$$arity = 0);
      
      Opal.defn(self, '$take', TMP_Lazy_take_36 = function $$take(n) {
        var TMP_35, self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(n, 0))) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "attempt to take negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
            } else {
            return current_size
          }
          } else {
          return current_size
        }; return nil; })();
        taken = 0;
        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, set_size], (TMP_35 = function(enum$, $a_rest){var self = TMP_35.$$s || this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 1] = arguments[$arg_idx];
          }if (enum$ == null) enum$ = nil;
        if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', Opal.to_a(args));
            return (taken = $rb_plus(taken, 1));
            } else {
            return self.$raise(Opal.const_get_relative($nesting, 'StopLazyError'))
          }}, TMP_35.$$s = self, TMP_35.$$arity = -2, TMP_35));
      }, TMP_Lazy_take_36.$$arity = 1);
      
      Opal.defn(self, '$take_while', TMP_Lazy_take_while_37 = function $$take_while() {
        var TMP_38, self = this, $iter = TMP_Lazy_take_while_37.$$p, block = $iter || nil;

        if ($iter) TMP_Lazy_take_while_37.$$p = null;
        
        if ($truthy(block)) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send(Opal.const_get_relative($nesting, 'Lazy'), 'new', [self, nil], (TMP_38 = function(enum$, $a_rest){var self = TMP_38.$$s || this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 1] = arguments[$arg_idx];
          }if (enum$ == null) enum$ = nil;
        
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
          else {
            self.$raise(Opal.const_get_relative($nesting, 'StopLazyError'));
          }
        }, TMP_38.$$s = self, TMP_38.$$arity = -2, TMP_38));
      }, TMP_Lazy_take_while_37.$$arity = 0);
      Opal.alias(self, "to_enum", "enum_for");
      return (Opal.defn(self, '$inspect', TMP_Lazy_inspect_39 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, TMP_Lazy_inspect_39.$$arity = 0), nil) && 'inspect';
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/numeric"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$coerce', '$===', '$raise', '$__send__', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$to_i', '$truncate', '$>']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    function $Numeric(){};
    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numeric_coerce_1, TMP_Numeric___coerced___2, TMP_Numeric_$lt$eq$gt_3, TMP_Numeric_$$_4, TMP_Numeric_$$_5, TMP_Numeric_$_6, TMP_Numeric_abs_7, TMP_Numeric_abs2_8, TMP_Numeric_angle_9, TMP_Numeric_ceil_10, TMP_Numeric_conj_11, TMP_Numeric_denominator_12, TMP_Numeric_div_13, TMP_Numeric_divmod_14, TMP_Numeric_fdiv_15, TMP_Numeric_floor_16, TMP_Numeric_i_17, TMP_Numeric_imag_18, TMP_Numeric_integer$q_19, TMP_Numeric_nonzero$q_20, TMP_Numeric_numerator_21, TMP_Numeric_polar_22, TMP_Numeric_quo_23, TMP_Numeric_real_24, TMP_Numeric_real$q_25, TMP_Numeric_rect_26, TMP_Numeric_round_27, TMP_Numeric_to_c_28, TMP_Numeric_to_int_29, TMP_Numeric_truncate_30, TMP_Numeric_zero$q_31, TMP_Numeric_positive$q_32, TMP_Numeric_negative$q_33, TMP_Numeric_dup_34, TMP_Numeric_clone_35;

    
    self.$include(Opal.const_get_relative($nesting, 'Comparable'));
    
    Opal.defn(self, '$coerce', TMP_Numeric_coerce_1 = function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]};
      return [self.$Float(other), self.$Float(self)];
    }, TMP_Numeric_coerce_1.$$arity = 1);
    
    Opal.defn(self, '$__coerced__', TMP_Numeric___coerced___2 = function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil, $case = nil;

      
      
      try {
        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
          try {
            $case = method;
            if ("+"['$===']($case) || "-"['$===']($case) || "*"['$===']($case) || "/"['$===']($case) || "%"['$===']($case) || "&"['$===']($case) || "|"['$===']($case) || "^"['$===']($case) || "**"['$===']($case)) {self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerce into Numeric")}
            else if (">"['$===']($case) || ">="['$===']($case) || "<"['$===']($case) || "<="['$===']($case) || "<=>"['$===']($case)) {self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")}
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };;
      return a.$__send__(method, b);
    }, TMP_Numeric___coerced___2.$$arity = 2);
    
    Opal.defn(self, '$<=>', TMP_Numeric_$lt$eq$gt_3 = function(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0};
      return nil;
    }, TMP_Numeric_$lt$eq$gt_3.$$arity = 1);
    
    Opal.defn(self, '$+@', TMP_Numeric_$$_4 = function() {
      var self = this;

      return self
    }, TMP_Numeric_$$_4.$$arity = 0);
    
    Opal.defn(self, '$-@', TMP_Numeric_$$_5 = function() {
      var self = this;

      return $rb_minus(0, self)
    }, TMP_Numeric_$$_5.$$arity = 0);
    
    Opal.defn(self, '$%', TMP_Numeric_$_6 = function(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, TMP_Numeric_$_6.$$arity = 1);
    
    Opal.defn(self, '$abs', TMP_Numeric_abs_7 = function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
        } else {
        return self
      }
    }, TMP_Numeric_abs_7.$$arity = 0);
    
    Opal.defn(self, '$abs2', TMP_Numeric_abs2_8 = function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, TMP_Numeric_abs2_8.$$arity = 0);
    
    Opal.defn(self, '$angle', TMP_Numeric_angle_9 = function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Math'), 'PI')
        } else {
        return 0
      }
    }, TMP_Numeric_angle_9.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.defn(self, '$ceil', TMP_Numeric_ceil_10 = function $$ceil() {
      var self = this;

      return self.$to_f().$ceil()
    }, TMP_Numeric_ceil_10.$$arity = 0);
    
    Opal.defn(self, '$conj', TMP_Numeric_conj_11 = function $$conj() {
      var self = this;

      return self
    }, TMP_Numeric_conj_11.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.defn(self, '$denominator', TMP_Numeric_denominator_12 = function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, TMP_Numeric_denominator_12.$$arity = 0);
    
    Opal.defn(self, '$div', TMP_Numeric_div_13 = function $$div(other) {
      var self = this;

      
      if (other['$=='](0)) {
        self.$raise(Opal.const_get_relative($nesting, 'ZeroDivisionError'), "divided by o")};
      return $rb_divide(self, other).$floor();
    }, TMP_Numeric_div_13.$$arity = 1);
    
    Opal.defn(self, '$divmod', TMP_Numeric_divmod_14 = function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, TMP_Numeric_divmod_14.$$arity = 1);
    
    Opal.defn(self, '$fdiv', TMP_Numeric_fdiv_15 = function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, TMP_Numeric_fdiv_15.$$arity = 1);
    
    Opal.defn(self, '$floor', TMP_Numeric_floor_16 = function $$floor() {
      var self = this;

      return self.$to_f().$floor()
    }, TMP_Numeric_floor_16.$$arity = 0);
    
    Opal.defn(self, '$i', TMP_Numeric_i_17 = function $$i() {
      var self = this;

      return self.$Complex(0, self)
    }, TMP_Numeric_i_17.$$arity = 0);
    
    Opal.defn(self, '$imag', TMP_Numeric_imag_18 = function $$imag() {
      var self = this;

      return 0
    }, TMP_Numeric_imag_18.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.defn(self, '$integer?', TMP_Numeric_integer$q_19 = function() {
      var self = this;

      return false
    }, TMP_Numeric_integer$q_19.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.defn(self, '$nonzero?', TMP_Numeric_nonzero$q_20 = function() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
        } else {
        return self
      }
    }, TMP_Numeric_nonzero$q_20.$$arity = 0);
    
    Opal.defn(self, '$numerator', TMP_Numeric_numerator_21 = function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, TMP_Numeric_numerator_21.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.defn(self, '$polar', TMP_Numeric_polar_22 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, TMP_Numeric_polar_22.$$arity = 0);
    
    Opal.defn(self, '$quo', TMP_Numeric_quo_23 = function $$quo(other) {
      var self = this;

      return $rb_divide(Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](self, Opal.const_get_relative($nesting, 'Rational'), "to_r"), other)
    }, TMP_Numeric_quo_23.$$arity = 1);
    
    Opal.defn(self, '$real', TMP_Numeric_real_24 = function $$real() {
      var self = this;

      return self
    }, TMP_Numeric_real_24.$$arity = 0);
    
    Opal.defn(self, '$real?', TMP_Numeric_real$q_25 = function() {
      var self = this;

      return true
    }, TMP_Numeric_real$q_25.$$arity = 0);
    
    Opal.defn(self, '$rect', TMP_Numeric_rect_26 = function $$rect() {
      var self = this;

      return [self, 0]
    }, TMP_Numeric_rect_26.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.defn(self, '$round', TMP_Numeric_round_27 = function $$round(digits) {
      var self = this;

      return self.$to_f().$round(digits)
    }, TMP_Numeric_round_27.$$arity = -1);
    
    Opal.defn(self, '$to_c', TMP_Numeric_to_c_28 = function $$to_c() {
      var self = this;

      return self.$Complex(self, 0)
    }, TMP_Numeric_to_c_28.$$arity = 0);
    
    Opal.defn(self, '$to_int', TMP_Numeric_to_int_29 = function $$to_int() {
      var self = this;

      return self.$to_i()
    }, TMP_Numeric_to_int_29.$$arity = 0);
    
    Opal.defn(self, '$truncate', TMP_Numeric_truncate_30 = function $$truncate() {
      var self = this;

      return self.$to_f().$truncate()
    }, TMP_Numeric_truncate_30.$$arity = 0);
    
    Opal.defn(self, '$zero?', TMP_Numeric_zero$q_31 = function() {
      var self = this;

      return self['$=='](0)
    }, TMP_Numeric_zero$q_31.$$arity = 0);
    
    Opal.defn(self, '$positive?', TMP_Numeric_positive$q_32 = function() {
      var self = this;

      return $rb_gt(self, 0)
    }, TMP_Numeric_positive$q_32.$$arity = 0);
    
    Opal.defn(self, '$negative?', TMP_Numeric_negative$q_33 = function() {
      var self = this;

      return $rb_lt(self, 0)
    }, TMP_Numeric_negative$q_33.$$arity = 0);
    
    Opal.defn(self, '$dup', TMP_Numeric_dup_34 = function $$dup() {
      var self = this;

      return self
    }, TMP_Numeric_dup_34.$$arity = 0);
    return (Opal.defn(self, '$clone', TMP_Numeric_clone_35 = function $$clone($kwargs) {
      var self = this, freeze;

      if ($kwargs == null || !$kwargs.$$is_hash) {
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else {
          throw Opal.ArgumentError.$new('expected kwargs');
        }
      }
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      }
      return self
    }, TMP_Numeric_clone_35.$$arity = -1), nil) && 'clone';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/array"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to', '$coerce_to?', '$===', '$join', '$to_str', '$class', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$bsearch_index', '$to_proc', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$[]', '$dig', '$eql?', '$length', '$begin', '$end', '$exclude_end?', '$flatten', '$__id__', '$to_s', '$new', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$-', '$<<', '$values', '$kind_of?', '$last', '$first', '$upto', '$reject', '$pristine']);
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    function $Array(){};
    var self = $Array = $klass($base, $super, 'Array', $Array);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_$$_1, TMP_Array_initialize_2, TMP_Array_try_convert_3, TMP_Array_$_4, TMP_Array_$_5, TMP_Array_$_6, TMP_Array_$_7, TMP_Array_$_8, TMP_Array_$lt$lt_9, TMP_Array_$lt$eq$gt_10, TMP_Array_$eq$eq_11, TMP_Array_$$_12, TMP_Array_$$$eq_13, TMP_Array_any$q_14, TMP_Array_assoc_15, TMP_Array_at_16, TMP_Array_bsearch_index_17, TMP_Array_bsearch_18, TMP_Array_cycle_19, TMP_Array_clear_21, TMP_Array_count_22, TMP_Array_initialize_copy_23, TMP_Array_collect_24, TMP_Array_collect$B_26, TMP_Array_combination_28, TMP_Array_repeated_combination_30, TMP_Array_compact_32, TMP_Array_compact$B_33, TMP_Array_concat_36, TMP_Array_delete_37, TMP_Array_delete_at_38, TMP_Array_delete_if_39, TMP_Array_dig_41, TMP_Array_drop_42, TMP_Array_dup_43, TMP_Array_each_44, TMP_Array_each_index_46, TMP_Array_empty$q_48, TMP_Array_eql$q_49, TMP_Array_fetch_50, TMP_Array_fill_51, TMP_Array_first_52, TMP_Array_flatten_53, TMP_Array_flatten$B_54, TMP_Array_hash_55, TMP_Array_include$q_56, TMP_Array_index_57, TMP_Array_insert_58, TMP_Array_inspect_59, TMP_Array_join_60, TMP_Array_keep_if_61, TMP_Array_last_63, TMP_Array_length_64, TMP_Array_permutation_65, TMP_Array_repeated_permutation_67, TMP_Array_pop_69, TMP_Array_product_70, TMP_Array_push_71, TMP_Array_rassoc_72, TMP_Array_reject_73, TMP_Array_reject$B_75, TMP_Array_replace_77, TMP_Array_reverse_78, TMP_Array_reverse$B_79, TMP_Array_reverse_each_80, TMP_Array_rindex_82, TMP_Array_rotate_83, TMP_Array_rotate$B_84, TMP_Array_sample_87, TMP_Array_select_88, TMP_Array_select$B_90, TMP_Array_shift_92, TMP_Array_shuffle_93, TMP_Array_shuffle$B_94, TMP_Array_slice$B_95, TMP_Array_sort_96, TMP_Array_sort$B_97, TMP_Array_sort_by$B_98, TMP_Array_take_100, TMP_Array_take_while_101, TMP_Array_to_a_102, TMP_Array_to_h_103, TMP_Array_transpose_106, TMP_Array_uniq_107, TMP_Array_uniq$B_108, TMP_Array_unshift_109, TMP_Array_values_at_112, TMP_Array_zip_113, TMP_Array_inherited_114, TMP_Array_instance_variables_115;

    
    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
    def.$$is_array = true;
    
    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }
  ;
    Opal.defs(self, '$[]', TMP_Array_$$_1 = function($a_rest) {
      var self = this, objects;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      objects = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        objects[$arg_idx - 0] = arguments[$arg_idx];
      }
      return toArraySubclass(objects, self)
    }, TMP_Array_$$_1.$$arity = -1);
    
    Opal.defn(self, '$initialize', TMP_Array_initialize_2 = function $$initialize(size, obj) {
      var self = this, $iter = TMP_Array_initialize_2.$$p, block = $iter || nil;

      if (size == null) {
        size = nil;
      }
      if (obj == null) {
        obj = nil;
      }
      if ($iter) TMP_Array_initialize_2.$$p = null;
      
      if (obj !== nil && block !== nil) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (size > Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Integer'), 'MAX')) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = Opal.const_get_relative($nesting, 'Opal').$coerce_to(size, Opal.const_get_relative($nesting, 'Integer'), "to_int")

      if (size < 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    
    }, TMP_Array_initialize_2.$$arity = -1);
    Opal.defs(self, '$try_convert', TMP_Array_try_convert_3 = function $$try_convert(obj) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](obj, Opal.const_get_relative($nesting, 'Array'), "to_ary")
    }, TMP_Array_try_convert_3.$$arity = 1);
    
    Opal.defn(self, '$&', TMP_Array_$_4 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
        } else {
        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), "to_ary").$to_a()
      };
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if (Opal.hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, TMP_Array_$_4.$$arity = 1);
    
    Opal.defn(self, '$|', TMP_Array_$_5 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
        } else {
        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), "to_ary").$to_a()
      };
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        Opal.hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, TMP_Array_$_5.$$arity = 1);
    
    Opal.defn(self, '$*', TMP_Array_$_6 = function(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())};
      other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      if ($truthy(other < 0)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "negative argument")};
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return toArraySubclass(result, self.$class());
    ;
    }, TMP_Array_$_6.$$arity = 1);
    
    Opal.defn(self, '$+', TMP_Array_$_7 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
        } else {
        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), "to_ary").$to_a()
      };
      return self.concat(other);
    }, TMP_Array_$_7.$$arity = 1);
    
    Opal.defn(self, '$-', TMP_Array_$_8 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
        } else {
        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), "to_ary").$to_a()
      };
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(other.length === 0)) {
        return self.slice()};
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if (Opal.hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, TMP_Array_$_8.$$arity = 1);
    
    Opal.defn(self, '$<<', TMP_Array_$lt$lt_9 = function(object) {
      var self = this;

      
      self.push(object);;
      return self;
    }, TMP_Array_$lt$lt_9.$$arity = 1);
    
    Opal.defn(self, '$<=>', TMP_Array_$lt$eq$gt_10 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
        } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, TMP_Array_$lt$eq$gt_10.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_Array_$eq$eq_11 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](other, "to_ary")) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.constructor !== Array)
          array = (array).$to_a();
        if (other.constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, TMP_Array_$eq$eq_11.$$arity = 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = Opal.Opal.$coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = Opal.Opal.$coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude) {
        to += 1;
      }

      result = self.slice(from, to);
      return toArraySubclass(result, self.$class());
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = Opal.Opal.$coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = Opal.Opal.$coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return toArraySubclass(result, self.$class());
    }
  ;
    
    Opal.defn(self, '$[]', TMP_Array_$$_12 = function(index, length) {
      var self = this;

      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    
    }, TMP_Array_$$_12.$$arity = -2);
    
    Opal.defn(self, '$[]=', TMP_Array_$$$eq_13 = function(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      
      var i, size = self.length;
    ;
      if ($truthy(Opal.const_get_relative($nesting, 'Range')['$==='](index))) {
        
        if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](value))) {
          data = value.$to_a()
        } else if ($truthy(value['$respond_to?']("to_ary"))) {
          data = value.$to_ary().$to_a()
          } else {
          data = [value]
        };
        
        var exclude = index.excl,
            from    = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index.begin, Opal.const_get_relative($nesting, 'Integer'), "to_int"),
            to      = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index.end, Opal.const_get_relative($nesting, 'Integer'), "to_int");

        if (from < 0) {
          from += size;

          if (from < 0) {
            self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      ;
        } else {
        
        if ($truthy(extra === undefined)) {
          length = 1
          } else {
          
          length = value;
          value = extra;
          if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](value))) {
            data = value.$to_a()
          } else if ($truthy(value['$respond_to?']("to_ary"))) {
            data = value.$to_ary().$to_a()
            } else {
            data = [value]
          };
        };
        
        var old;

        index  = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        length = Opal.const_get_relative($nesting, 'Opal').$coerce_to(length, Opal.const_get_relative($nesting, 'Integer'), "to_int");

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      ;
      };
    }, TMP_Array_$$$eq_13.$$arity = -3);
    
    Opal.defn(self, '$any?', TMP_Array_any$q_14 = function() {
      var self = this, $iter = TMP_Array_any$q_14.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Array_any$q_14.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if (self.length === 0) return false;;
      return $send(self, Opal.find_super_dispatcher(self, 'any?', TMP_Array_any$q_14, false), $zuper, $iter);
    }, TMP_Array_any$q_14.$$arity = 0);
    
    Opal.defn(self, '$assoc', TMP_Array_assoc_15 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, TMP_Array_assoc_15.$$arity = 1);
    
    Opal.defn(self, '$at', TMP_Array_at_16 = function $$at(index) {
      var self = this;

      
      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      
      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    ;
    }, TMP_Array_at_16.$$arity = 1);
    
    Opal.defn(self, '$bsearch_index', TMP_Array_bsearch_index_17 = function $$bsearch_index() {
      var self = this, $iter = TMP_Array_bsearch_index_17.$$p, block = $iter || nil;

      if ($iter) TMP_Array_bsearch_index_17.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = Opal.yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, TMP_Array_bsearch_index_17.$$arity = 0);
    
    Opal.defn(self, '$bsearch', TMP_Array_bsearch_18 = function $$bsearch() {
      var self = this, $iter = TMP_Array_bsearch_18.$$p, block = $iter || nil, index = nil;

      if ($iter) TMP_Array_bsearch_18.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, TMP_Array_bsearch_18.$$arity = 0);
    
    Opal.defn(self, '$cycle', TMP_Array_cycle_19 = function $$cycle(n) {
      var TMP_20, $a, self = this, $iter = TMP_Array_cycle_19.$$p, block = $iter || nil;

      if (n == null) {
        n = nil;
      }
      if ($iter) TMP_Array_cycle_19.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["cycle", n], (TMP_20 = function(){var self = TMP_20.$$s || this;

        if (n['$=='](nil)) {
            return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')
            } else {
            
            n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
              } else {
              return 0
            };
          }}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20))
      };
      if ($truthy(($truthy($a = self['$empty?']()) ? $a : n['$=='](0)))) {
        return nil};
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = Opal.yield1(block, self[i]);
          }
        }
      }
      else {
        n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = Opal.yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, TMP_Array_cycle_19.$$arity = -1);
    
    Opal.defn(self, '$clear', TMP_Array_clear_21 = function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, TMP_Array_clear_21.$$arity = 0);
    
    Opal.defn(self, '$count', TMP_Array_count_22 = function $$count(object) {
      var $a, self = this, $iter = TMP_Array_count_22.$$p, block = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if (object == null) {
        object = nil;
      }
      if ($iter) TMP_Array_count_22.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = object) ? $a : block))) {
        return $send(self, Opal.find_super_dispatcher(self, 'count', TMP_Array_count_22, false), $zuper, $iter)
        } else {
        return self.$size()
      }
    }, TMP_Array_count_22.$$arity = -1);
    
    Opal.defn(self, '$initialize_copy', TMP_Array_initialize_copy_23 = function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, TMP_Array_initialize_copy_23.$$arity = 1);
    
    Opal.defn(self, '$collect', TMP_Array_collect_24 = function $$collect() {
      var TMP_25, self = this, $iter = TMP_Array_collect_24.$$p, block = $iter || nil;

      if ($iter) TMP_Array_collect_24.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["collect"], (TMP_25 = function(){var self = TMP_25.$$s || this;

        return self.$size()}, TMP_25.$$s = self, TMP_25.$$arity = 0, TMP_25))
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, TMP_Array_collect_24.$$arity = 0);
    
    Opal.defn(self, '$collect!', TMP_Array_collect$B_26 = function() {
      var TMP_27, self = this, $iter = TMP_Array_collect$B_26.$$p, block = $iter || nil;

      if ($iter) TMP_Array_collect$B_26.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["collect!"], (TMP_27 = function(){var self = TMP_27.$$s || this;

        return self.$size()}, TMP_27.$$s = self, TMP_27.$$arity = 0, TMP_27))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, TMP_Array_collect$B_26.$$arity = 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    Opal.defn(self, '$combination', TMP_Array_combination_28 = function $$combination(n) {
      var TMP_29, self = this, $iter = TMP_Array_combination_28.$$p, $yield = $iter || nil, num = nil;

      if ($iter) TMP_Array_combination_28.$$p = null;
      
      num = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
        } else {
        return $send(self, 'enum_for', ["combination", num], (TMP_29 = function(){var self = TMP_29.$$s || this;

        return binomial_coefficient(self.length, num)}, TMP_29.$$s = self, TMP_29.$$arity = 0, TMP_29))
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, TMP_Array_combination_28.$$arity = 1);
    
    Opal.defn(self, '$repeated_combination', TMP_Array_repeated_combination_30 = function $$repeated_combination(n) {
      var TMP_31, self = this, $iter = TMP_Array_repeated_combination_30.$$p, $yield = $iter || nil, num = nil;

      if ($iter) TMP_Array_repeated_combination_30.$$p = null;
      
      num = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
        } else {
        return $send(self, 'enum_for', ["repeated_combination", num], (TMP_31 = function(){var self = TMP_31.$$s || this;

        return binomial_coefficient(self.length + num - 1, num)}, TMP_31.$$s = self, TMP_31.$$arity = 0, TMP_31))
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, TMP_Array_repeated_combination_30.$$arity = 1);
    
    Opal.defn(self, '$compact', TMP_Array_compact_32 = function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, TMP_Array_compact_32.$$arity = 0);
    
    Opal.defn(self, '$compact!', TMP_Array_compact$B_33 = function() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, TMP_Array_compact$B_33.$$arity = 0);
    
    Opal.defn(self, '$concat', TMP_Array_concat_36 = function $$concat($a_rest) {
      var TMP_34, TMP_35, self = this, others;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      others = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        others[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      others = $send(others, 'map', [], (TMP_34 = function(other){var self = TMP_34.$$s || this;
if (other == null) other = nil;
      
        if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {
          other = other.$to_a()
          } else {
          other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), "to_ary").$to_a()
        };
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()};
        return other;}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));
      $send(others, 'each', [], (TMP_35 = function(other){var self = TMP_35.$$s || this;
if (other == null) other = nil;
      
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      }, TMP_35.$$s = self, TMP_35.$$arity = 1, TMP_35));
      return self;
    }, TMP_Array_concat_36.$$arity = -1);
    
    Opal.defn(self, '$delete', TMP_Array_delete_37 = function(object) {
      var self = this, $iter = TMP_Array_delete_37.$$p, $yield = $iter || nil;

      if ($iter) TMP_Array_delete_37.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, TMP_Array_delete_37.$$arity = 1);
    
    Opal.defn(self, '$delete_at', TMP_Array_delete_at_38 = function $$delete_at(index) {
      var self = this;

      
      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, TMP_Array_delete_at_38.$$arity = 1);
    
    Opal.defn(self, '$delete_if', TMP_Array_delete_if_39 = function $$delete_if() {
      var TMP_40, self = this, $iter = TMP_Array_delete_if_39.$$p, block = $iter || nil;

      if ($iter) TMP_Array_delete_if_39.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["delete_if"], (TMP_40 = function(){var self = TMP_40.$$s || this;

        return self.$size()}, TMP_40.$$s = self, TMP_40.$$arity = 0, TMP_40))
      };
      
      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value !== false && value !== nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }
    ;
      return self;
    }, TMP_Array_delete_if_39.$$arity = 0);
    
    Opal.defn(self, '$dig', TMP_Array_dig_41 = function $$dig(idx, $a_rest) {
      var self = this, idxs, item = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      idxs = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        idxs[$arg_idx - 1] = arguments[$arg_idx];
      }
      
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(idxs));
    }, TMP_Array_dig_41.$$arity = -2);
    
    Opal.defn(self, '$drop', TMP_Array_drop_42 = function $$drop(number) {
      var self = this;

      
      if (number < 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'))
      }

      return self.slice(number);
    
    }, TMP_Array_drop_42.$$arity = 1);
    
    Opal.defn(self, '$dup', TMP_Array_dup_43 = function $$dup() {
      var self = this, $iter = TMP_Array_dup_43.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Array_dup_43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if (
        self.$$class === Opal.Array &&
        self.$$class.$allocate.$$pristine &&
        self.$copy_instance_variables.$$pristine &&
        self.$initialize_dup.$$pristine
      ) return self.slice(0);
    ;
      return $send(self, Opal.find_super_dispatcher(self, 'dup', TMP_Array_dup_43, false), $zuper, $iter);
    }, TMP_Array_dup_43.$$arity = 0);
    
    Opal.defn(self, '$each', TMP_Array_each_44 = function $$each() {
      var TMP_45, self = this, $iter = TMP_Array_each_44.$$p, block = $iter || nil;

      if ($iter) TMP_Array_each_44.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["each"], (TMP_45 = function(){var self = TMP_45.$$s || this;

        return self.$size()}, TMP_45.$$s = self, TMP_45.$$arity = 0, TMP_45))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
      }
    ;
      return self;
    }, TMP_Array_each_44.$$arity = 0);
    
    Opal.defn(self, '$each_index', TMP_Array_each_index_46 = function $$each_index() {
      var TMP_47, self = this, $iter = TMP_Array_each_index_46.$$p, block = $iter || nil;

      if ($iter) TMP_Array_each_index_46.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["each_index"], (TMP_47 = function(){var self = TMP_47.$$s || this;

        return self.$size()}, TMP_47.$$s = self, TMP_47.$$arity = 0, TMP_47))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, i);
      }
    ;
      return self;
    }, TMP_Array_each_index_46.$$arity = 0);
    
    Opal.defn(self, '$empty?', TMP_Array_empty$q_48 = function() {
      var self = this;

      return self.length === 0
    }, TMP_Array_empty$q_48.$$arity = 0);
    
    Opal.defn(self, '$eql?', TMP_Array_eql$q_49 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, TMP_Array_eql$q_49.$$arity = 1);
    
    Opal.defn(self, '$fetch', TMP_Array_fetch_50 = function $$fetch(index, defaults) {
      var self = this, $iter = TMP_Array_fetch_50.$$p, block = $iter || nil;

      if ($iter) TMP_Array_fetch_50.$$p = null;
      
      var original = index;

      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    
    }, TMP_Array_fetch_50.$$arity = -2);
    
    Opal.defn(self, '$fill', TMP_Array_fill_51 = function $$fill($a_rest) {
      var $b, $c, self = this, args, $iter = TMP_Array_fill_51.$$p, block = $iter || nil, one = nil, two = nil, obj = nil, left = nil, right = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Array_fill_51.$$p = null;
      
      
      var i, length, value;
    ;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 0..2)")};
        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
        } else {
        
        if ($truthy(args.length == 0)) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 1..3)")};
        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($truthy(Opal.const_get_relative($nesting, 'Range')['$==='](one))) {
        
        if ($truthy(two)) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "length invalid with range")};
        left = Opal.const_get_relative($nesting, 'Opal').$coerce_to(one.$begin(), Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "" + (one.$inspect()) + " out of range")};
        right = Opal.const_get_relative($nesting, 'Opal').$coerce_to(one.$end(), Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy(right < 0)) {
          right += this.length};
        if ($truthy(one['$exclude_end?']())) {
          } else {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self};
      } else if ($truthy(one)) {
        
        left = Opal.const_get_relative($nesting, 'Opal').$coerce_to(one, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          left = 0};
        if ($truthy(two)) {
          
          right = Opal.const_get_relative($nesting, 'Opal').$coerce_to(two, Opal.const_get_relative($nesting, 'Integer'), "to_int");
          if ($truthy(right == 0)) {
            return self};
          right += left;
          } else {
          right = this.length
        };
        } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      };
      if ($truthy(right > this.length)) {
        this.length = right};
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
        } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, TMP_Array_fill_51.$$arity = -1);
    
    Opal.defn(self, '$first', TMP_Array_first_52 = function $$first(count) {
      var self = this;

      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    
    }, TMP_Array_first_52.$$arity = -1);
    
    Opal.defn(self, '$flatten', TMP_Array_flatten_53 = function $$flatten(level) {
      var self = this;

      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](item, "to_ary")) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            self.$raise(Opal.const_get_relative($nesting, 'TypeError'));
          }

          if (ary === self) {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = Opal.const_get_relative($nesting, 'Opal').$coerce_to(level, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }

      return toArraySubclass(_flatten(self, level), self.$class());
    
    }, TMP_Array_flatten_53.$$arity = -1);
    
    Opal.defn(self, '$flatten!', TMP_Array_flatten$B_54 = function(level) {
      var self = this;

      
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, TMP_Array_flatten$B_54.$$arity = -1);
    
    Opal.defn(self, '$hash', TMP_Array_hash_55 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if (Opal.hash_ids[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, TMP_Array_hash_55.$$arity = 0);
    
    Opal.defn(self, '$include?', TMP_Array_include$q_56 = function(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, TMP_Array_include$q_56.$$arity = 1);
    
    Opal.defn(self, '$index', TMP_Array_index_57 = function $$index(object) {
      var self = this, $iter = TMP_Array_index_57.$$p, block = $iter || nil;

      if ($iter) TMP_Array_index_57.$$p = null;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    
    }, TMP_Array_index_57.$$arity = -1);
    
    Opal.defn(self, '$insert', TMP_Array_insert_58 = function $$insert(index, $a_rest) {
      var self = this, objects;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      objects = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        objects[$arg_idx - 1] = arguments[$arg_idx];
      }
      
      
      index = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, TMP_Array_insert_58.$$arity = -2);
    
    Opal.defn(self, '$inspect', TMP_Array_inspect_59 = function $$inspect() {
      var self = this;

      
      var result = [],
          id     = self.$__id__();

      for (var i = 0, length = self.length; i < length; i++) {
        var item = self['$[]'](i);

        if ((item).$__id__() === id) {
          result.push('[...]');
        }
        else {
          result.push((item).$inspect());
        }
      }

      return '[' + result.join(', ') + ']';
    
    }, TMP_Array_inspect_59.$$arity = 0);
    
    Opal.defn(self, '$join', TMP_Array_join_60 = function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      if (sep == null) {
        sep = nil;
      }
      
      if ($truthy(self.length === 0)) {
        return ""};
      if ($truthy(sep === nil)) {
        sep = $gvars[","]};
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](item, "to_str")) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](item, "to_ary")) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if (Opal.const_get_relative($nesting, 'Opal')['$respond_to?'](item, "to_s")) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        self.$raise(Opal.const_get_relative($nesting, 'NoMethodError').$new("" + (Opal.inspect(item)) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join(Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](sep, Opal.const_get_relative($nesting, 'String'), "to_str").$to_s());
      }
    ;
    }, TMP_Array_join_60.$$arity = -1);
    
    Opal.defn(self, '$keep_if', TMP_Array_keep_if_61 = function $$keep_if() {
      var TMP_62, self = this, $iter = TMP_Array_keep_if_61.$$p, block = $iter || nil;

      if ($iter) TMP_Array_keep_if_61.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["keep_if"], (TMP_62 = function(){var self = TMP_62.$$s || this;

        return self.$size()}, TMP_62.$$s = self, TMP_62.$$arity = 0, TMP_62))
      };
      
      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }
    ;
      return self;
    }, TMP_Array_keep_if_61.$$arity = 0);
    
    Opal.defn(self, '$last', TMP_Array_last_63 = function $$last(count) {
      var self = this;

      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    
    }, TMP_Array_last_63.$$arity = -1);
    
    Opal.defn(self, '$length', TMP_Array_length_64 = function $$length() {
      var self = this;

      return self.length
    }, TMP_Array_length_64.$$arity = 0);
    Opal.alias(self, "map", "collect");
    Opal.alias(self, "map!", "collect!");
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    Opal.defn(self, '$permutation', TMP_Array_permutation_65 = function $$permutation(num) {
      var TMP_66, self = this, $iter = TMP_Array_permutation_65.$$p, block = $iter || nil, perm = nil, used = nil;

      if ($iter) TMP_Array_permutation_65.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["permutation", num], (TMP_66 = function(){var self = TMP_66.$$s || this;

        return descending_factorial(self.length, num === undefined ? self.length : num)}, TMP_66.$$s = self, TMP_66.$$arity = 0, TMP_66))
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = Opal.const_get_relative($nesting, 'Opal').$coerce_to(num, Opal.const_get_relative($nesting, 'Integer'), "to_int")
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = Opal.const_get_relative($nesting, 'Array').$new(num));
        (used = Opal.const_get_relative($nesting, 'Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                Opal.yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, TMP_Array_permutation_65.$$arity = -1);
    
    Opal.defn(self, '$repeated_permutation', TMP_Array_repeated_permutation_67 = function $$repeated_permutation(n) {
      var TMP_68, self = this, $iter = TMP_Array_repeated_permutation_67.$$p, $yield = $iter || nil, num = nil;

      if ($iter) TMP_Array_repeated_permutation_67.$$p = null;
      
      num = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
        } else {
        return $send(self, 'enum_for', ["repeated_permutation", num], (TMP_68 = function(){var self = TMP_68.$$s || this;

        if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
            } else {
            return 0
          }}, TMP_68.$$s = self, TMP_68.$$arity = 0, TMP_68))
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, TMP_Array_repeated_permutation_67.$$arity = 1);
    
    Opal.defn(self, '$pop', TMP_Array_pop_69 = function $$pop(count) {
      var self = this;

      
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.pop();};
      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      if ($truthy(count < 0)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(count > self.length)) {
        return self.splice(0, self.length)
        } else {
        return self.splice(self.length - count, self.length)
      };
    }, TMP_Array_pop_69.$$arity = -1);
    
    Opal.defn(self, '$product', TMP_Array_product_70 = function $$product($a_rest) {
      var self = this, args, $iter = TMP_Array_product_70.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Array_product_70.$$p = null;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = Opal.const_get_relative($nesting, 'Opal').$coerce_to(args[i - 1], Opal.const_get_relative($nesting, 'Array'), "to_ary");
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    
    }, TMP_Array_product_70.$$arity = -1);
    
    Opal.defn(self, '$push', TMP_Array_push_71 = function $$push($a_rest) {
      var self = this, objects;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      objects = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        objects[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, TMP_Array_push_71.$$arity = -1);
    
    Opal.defn(self, '$rassoc', TMP_Array_rassoc_72 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, TMP_Array_rassoc_72.$$arity = 1);
    
    Opal.defn(self, '$reject', TMP_Array_reject_73 = function $$reject() {
      var TMP_74, self = this, $iter = TMP_Array_reject_73.$$p, block = $iter || nil;

      if ($iter) TMP_Array_reject_73.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["reject"], (TMP_74 = function(){var self = TMP_74.$$s || this;

        return self.$size()}, TMP_74.$$s = self, TMP_74.$$arity = 0, TMP_74))
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, TMP_Array_reject_73.$$arity = 0);
    
    Opal.defn(self, '$reject!', TMP_Array_reject$B_75 = function() {
      var TMP_76, self = this, $iter = TMP_Array_reject$B_75.$$p, block = $iter || nil, original = nil;

      if ($iter) TMP_Array_reject$B_75.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["reject!"], (TMP_76 = function(){var self = TMP_76.$$s || this;

        return self.$size()}, TMP_76.$$s = self, TMP_76.$$arity = 0, TMP_76))
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if (self.$length()['$=='](original)) {
        return nil
        } else {
        return self
      };
    }, TMP_Array_reject$B_75.$$arity = 0);
    
    Opal.defn(self, '$replace', TMP_Array_replace_77 = function $$replace(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
        } else {
        other = Opal.const_get_relative($nesting, 'Opal').$coerce_to(other, Opal.const_get_relative($nesting, 'Array'), "to_ary").$to_a()
      };
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, TMP_Array_replace_77.$$arity = 1);
    
    Opal.defn(self, '$reverse', TMP_Array_reverse_78 = function $$reverse() {
      var self = this;

      return self.slice(0).reverse()
    }, TMP_Array_reverse_78.$$arity = 0);
    
    Opal.defn(self, '$reverse!', TMP_Array_reverse$B_79 = function() {
      var self = this;

      return self.reverse()
    }, TMP_Array_reverse$B_79.$$arity = 0);
    
    Opal.defn(self, '$reverse_each', TMP_Array_reverse_each_80 = function $$reverse_each() {
      var TMP_81, self = this, $iter = TMP_Array_reverse_each_80.$$p, block = $iter || nil;

      if ($iter) TMP_Array_reverse_each_80.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["reverse_each"], (TMP_81 = function(){var self = TMP_81.$$s || this;

        return self.$size()}, TMP_81.$$s = self, TMP_81.$$arity = 0, TMP_81))
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, TMP_Array_reverse_each_80.$$arity = 0);
    
    Opal.defn(self, '$rindex', TMP_Array_rindex_82 = function $$rindex(object) {
      var self = this, $iter = TMP_Array_rindex_82.$$p, block = $iter || nil;

      if ($iter) TMP_Array_rindex_82.$$p = null;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    
    }, TMP_Array_rindex_82.$$arity = -1);
    
    Opal.defn(self, '$rotate', TMP_Array_rotate_83 = function $$rotate(n) {
      var self = this;

      if (n == null) {
        n = 1;
      }
      
      n = Opal.const_get_relative($nesting, 'Opal').$coerce_to(n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      
      var ary, idx, firstPart, lastPart;

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, TMP_Array_rotate_83.$$arity = -1);
    
    Opal.defn(self, '$rotate!', TMP_Array_rotate$B_84 = function(cnt) {
      var self = this, ary = nil;

      if (cnt == null) {
        cnt = 1;
      }
      
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
    ;
      cnt = Opal.const_get_relative($nesting, 'Opal').$coerce_to(cnt, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, TMP_Array_rotate$B_84.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      function $SampleRandom(){};
      var self = $SampleRandom = $klass($base, $super, 'SampleRandom', $SampleRandom);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SampleRandom_initialize_85, TMP_SampleRandom_rand_86;

      def.rng = nil;
      
      
      Opal.defn(self, '$initialize', TMP_SampleRandom_initialize_85 = function $$initialize(rng) {
        var self = this;

        return (self.rng = rng)
      }, TMP_SampleRandom_initialize_85.$$arity = 1);
      return (Opal.defn(self, '$rand', TMP_SampleRandom_rand_86 = function $$rand(size) {
        var self = this, random = nil;

        
        random = Opal.const_get_relative($nesting, 'Opal').$coerce_to(self.rng.$rand(size), Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy(random < 0)) {
          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "random value must be >= 0")};
        if ($truthy(random < size)) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "random value must be less than Array size")
        };
        return random;
      }, TMP_SampleRandom_rand_86.$$arity = 1), nil) && 'rand';
    })($nesting[0], null, $nesting);
    
    Opal.defn(self, '$sample', TMP_Array_sample_87 = function $$sample(count, options) {
      var $a, self = this, o = nil, rng = nil;

      
      if ($truthy(count === undefined)) {
        return self.$at(Opal.const_get_relative($nesting, 'Kernel').$rand(self.length))};
      if ($truthy(options === undefined)) {
        if ($truthy((o = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](count, Opal.const_get_relative($nesting, 'Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
          } else {
          
          options = nil;
          count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        }
        } else {
        
        count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        options = Opal.const_get_relative($nesting, 'Opal').$coerce_to(options, Opal.const_get_relative($nesting, 'Hash'), "to_hash");
      };
      if ($truthy(($truthy($a = count) ? count < 0 : $a))) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "count must be greater than 0")};
      if ($truthy(options)) {
        rng = options['$[]']("random")};
      if ($truthy(($truthy($a = rng) ? rng['$respond_to?']("rand") : $a))) {
        rng = Opal.const_get_relative($nesting, 'SampleRandom').$new(rng)
        } else {
        rng = Opal.const_get_relative($nesting, 'Kernel')
      };
      if ($truthy(count)) {
        } else {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = Opal.const_get_relative($nesting, 'Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, TMP_Array_sample_87.$$arity = -1);
    
    Opal.defn(self, '$select', TMP_Array_select_88 = function $$select() {
      var TMP_89, self = this, $iter = TMP_Array_select_88.$$p, block = $iter || nil;

      if ($iter) TMP_Array_select_88.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["select"], (TMP_89 = function(){var self = TMP_89.$$s || this;

        return self.$size()}, TMP_89.$$s = self, TMP_89.$$arity = 0, TMP_89))
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = Opal.yield1(block, item);

        if (value !== false && value !== nil) {
          result.push(item);
        }
      }

      return result;
    ;
    }, TMP_Array_select_88.$$arity = 0);
    
    Opal.defn(self, '$select!', TMP_Array_select$B_90 = function() {
      var TMP_91, self = this, $iter = TMP_Array_select$B_90.$$p, block = $iter || nil;

      if ($iter) TMP_Array_select$B_90.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["select!"], (TMP_91 = function(){var self = TMP_91.$$s || this;

        return self.$size()}, TMP_91.$$s = self, TMP_91.$$arity = 0, TMP_91))
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, TMP_Array_select$B_90.$$arity = 0);
    
    Opal.defn(self, '$shift', TMP_Array_shift_92 = function $$shift(count) {
      var self = this;

      
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.shift();};
      count = Opal.const_get_relative($nesting, 'Opal').$coerce_to(count, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      if ($truthy(count < 0)) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      return self.splice(0, count);
    }, TMP_Array_shift_92.$$arity = -1);
    Opal.alias(self, "size", "length");
    
    Opal.defn(self, '$shuffle', TMP_Array_shuffle_93 = function $$shuffle(rng) {
      var self = this;

      return self.$dup().$to_a()['$shuffle!'](rng)
    }, TMP_Array_shuffle_93.$$arity = -1);
    
    Opal.defn(self, '$shuffle!', TMP_Array_shuffle$B_94 = function(rng) {
      var self = this;

      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](rng, Opal.const_get_relative($nesting, 'Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "" + "random number too small " + (j))
          }

          if (j >= i) {
            self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "" + "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    
    }, TMP_Array_shuffle$B_94.$$arity = -1);
    Opal.alias(self, "slice", "[]");
    
    Opal.defn(self, '$slice!', TMP_Array_slice$B_95 = function(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      result = nil;
      if ($truthy(length === undefined)) {
        if ($truthy(Opal.const_get_relative($nesting, 'Range')['$==='](index))) {
          
          range = index;
          result = self['$[]'](range);
          range_start = Opal.const_get_relative($nesting, 'Opal').$coerce_to(range.$begin(), Opal.const_get_relative($nesting, 'Integer'), "to_int");
          range_end = Opal.const_get_relative($nesting, 'Opal').$coerce_to(range.$end(), Opal.const_get_relative($nesting, 'Integer'), "to_int");
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
          } else {
          
          start = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), "to_int");
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
        } else {
        
        start = Opal.const_get_relative($nesting, 'Opal').$coerce_to(index, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        length = Opal.const_get_relative($nesting, 'Opal').$coerce_to(length, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, TMP_Array_slice$B_95.$$arity = -2);
    
    Opal.defn(self, '$sort', TMP_Array_sort_96 = function $$sort() {
      var self = this, $iter = TMP_Array_sort_96.$$p, block = $iter || nil;

      if ($iter) TMP_Array_sort_96.$$p = null;
      
      if ($truthy(self.length > 1)) {
        } else {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, TMP_Array_sort_96.$$arity = 0);
    
    Opal.defn(self, '$sort!', TMP_Array_sort$B_97 = function() {
      var self = this, $iter = TMP_Array_sort$B_97.$$p, block = $iter || nil;

      if ($iter) TMP_Array_sort$B_97.$$p = null;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    
    }, TMP_Array_sort$B_97.$$arity = 0);
    
    Opal.defn(self, '$sort_by!', TMP_Array_sort_by$B_98 = function() {
      var TMP_99, self = this, $iter = TMP_Array_sort_by$B_98.$$p, block = $iter || nil;

      if ($iter) TMP_Array_sort_by$B_98.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["sort_by!"], (TMP_99 = function(){var self = TMP_99.$$s || this;

        return self.$size()}, TMP_99.$$s = self, TMP_99.$$arity = 0, TMP_99))
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, TMP_Array_sort_by$B_98.$$arity = 0);
    
    Opal.defn(self, '$take', TMP_Array_take_100 = function $$take(count) {
      var self = this;

      
      if (count < 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'));
      }

      return self.slice(0, count);
    
    }, TMP_Array_take_100.$$arity = 1);
    
    Opal.defn(self, '$take_while', TMP_Array_take_while_101 = function $$take_while() {
      var self = this, $iter = TMP_Array_take_while_101.$$p, block = $iter || nil;

      if ($iter) TMP_Array_take_while_101.$$p = null;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    
    }, TMP_Array_take_while_101.$$arity = 0);
    
    Opal.defn(self, '$to_a', TMP_Array_to_a_102 = function $$to_a() {
      var self = this;

      return self
    }, TMP_Array_to_a_102.$$arity = 0);
    Opal.alias(self, "to_ary", "to_a");
    
    Opal.defn(self, '$to_h', TMP_Array_to_h_103 = function $$to_h() {
      var self = this;

      
      var i, len = self.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](self[i], Opal.const_get_relative($nesting, 'Array'), "to_ary");
        if (!ary.$$is_array) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        Opal.hash_put(hash, key, val);
      }

      return hash;
    
    }, TMP_Array_to_h_103.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.defn(self, '$transpose', TMP_Array_transpose_106 = function $$transpose() {
      var TMP_104, self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []};
      result = [];
      max = nil;
      $send(self, 'each', [], (TMP_104 = function(row){var self = TMP_104.$$s || this, $a, TMP_105;
if (row == null) row = nil;
      
        if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](row))) {
          row = row.$to_a()
          } else {
          row = Opal.const_get_relative($nesting, 'Opal').$coerce_to(row, Opal.const_get_relative($nesting, 'Array'), "to_ary").$to_a()
        };
        max = ($truthy($a = max) ? $a : row.length);
        if ($truthy((row.length)['$!='](max))) {
          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + "element size differs (" + (row.length) + " should be " + (max) + ")")};
        return $send((row.length), 'times', [], (TMP_105 = function(i){var self = TMP_105.$$s || this, $b, entry = nil, $writer = nil;
if (i == null) i = nil;
        
          entry = ($truthy($b = result['$[]'](i)) ? $b : (($writer = [i, []]), $send(result, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          return entry['$<<'](row.$at(i));}, TMP_105.$$s = self, TMP_105.$$arity = 1, TMP_105));}, TMP_104.$$s = self, TMP_104.$$arity = 1, TMP_104));
      return result;
    }, TMP_Array_transpose_106.$$arity = 0);
    
    Opal.defn(self, '$uniq', TMP_Array_uniq_107 = function $$uniq() {
      var self = this, $iter = TMP_Array_uniq_107.$$p, block = $iter || nil;

      if ($iter) TMP_Array_uniq_107.$$p = null;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if (Opal.hash_get(hash, item) === undefined) {
            Opal.hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = Opal.yield1(block, item);
          if (Opal.hash_get(hash, key) === undefined) {
            Opal.hash_put(hash, key, item);
          }
        }
      }

      return toArraySubclass((hash).$values(), self.$class());
    
    }, TMP_Array_uniq_107.$$arity = 0);
    
    Opal.defn(self, '$uniq!', TMP_Array_uniq$B_108 = function() {
      var self = this, $iter = TMP_Array_uniq$B_108.$$p, block = $iter || nil;

      if ($iter) TMP_Array_uniq$B_108.$$p = null;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : Opal.yield1(block, item));

        if (Opal.hash_get(hash, key) === undefined) {
          Opal.hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    
    }, TMP_Array_uniq$B_108.$$arity = 0);
    
    Opal.defn(self, '$unshift', TMP_Array_unshift_109 = function $$unshift($a_rest) {
      var self = this, objects;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      objects = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        objects[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      
      for (var i = objects.length - 1; i >= 0; i--) {
        self.unshift(objects[i]);
      }
    ;
      return self;
    }, TMP_Array_unshift_109.$$arity = -1);
    
    Opal.defn(self, '$values_at', TMP_Array_values_at_112 = function $$values_at($a_rest) {
      var TMP_110, self = this, args, out = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      out = [];
      $send(args, 'each', [], (TMP_110 = function(elem){var self = TMP_110.$$s || this, TMP_111, finish = nil, start = nil, i = nil;
if (elem == null) elem = nil;
      if ($truthy(elem['$kind_of?'](Opal.const_get_relative($nesting, 'Range')))) {
          
          finish = Opal.const_get_relative($nesting, 'Opal').$coerce_to(elem.$last(), Opal.const_get_relative($nesting, 'Integer'), "to_int");
          start = Opal.const_get_relative($nesting, 'Opal').$coerce_to(elem.$first(), Opal.const_get_relative($nesting, 'Integer'), "to_int");
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']()) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], (TMP_111 = function(i){var self = TMP_111.$$s || this;
if (i == null) i = nil;
          return out['$<<'](self.$at(i))}, TMP_111.$$s = self, TMP_111.$$arity = 1, TMP_111));
          } else {
          
          i = Opal.const_get_relative($nesting, 'Opal').$coerce_to(elem, Opal.const_get_relative($nesting, 'Integer'), "to_int");
          return out['$<<'](self.$at(i));
        }}, TMP_110.$$s = self, TMP_110.$$arity = 1, TMP_110));
      return out;
    }, TMP_Array_values_at_112.$$arity = -1);
    
    Opal.defn(self, '$zip', TMP_Array_zip_113 = function $$zip($a_rest) {
      var $b, self = this, others, $iter = TMP_Array_zip_113.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      others = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        others[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Array_zip_113.$$p = null;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_enumerator) {
          if (o.$size() === Infinity) {
            others[j] = o.$take(size);
          } else {
            others[j] = o.$to_a();
          }
          continue;
        }
        others[j] = ($truthy($b = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](o, Opal.const_get_relative($nesting, 'Array'), "to_ary")) ? $b : Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](o, Opal.const_get_relative($nesting, 'Enumerator'), "each")).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          block(result[i]);
        }

        return nil;
      }

      return result;
    
    }, TMP_Array_zip_113.$$arity = -1);
    Opal.defs(self, '$inherited', TMP_Array_inherited_114 = function $$inherited(klass) {
      var self = this;

      
      klass.$$proto.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, TMP_Array_inherited_114.$$arity = 1);
    
    Opal.defn(self, '$instance_variables', TMP_Array_instance_variables_115 = function $$instance_variables() {
      var TMP_116, self = this, $iter = TMP_Array_instance_variables_115.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Array_instance_variables_115.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return $send($send(self, Opal.find_super_dispatcher(self, 'instance_variables', TMP_Array_instance_variables_115, false), $zuper, $iter), 'reject', [], (TMP_116 = function(ivar){var self = TMP_116.$$s || this, $a;
if (ivar == null) ivar = nil;
      return ($truthy($a = /^@\d+$/.test(ivar)) ? $a : ivar['$==']("@length"))}, TMP_116.$$s = self, TMP_116.$$arity = 1, TMP_116))
    }, TMP_Array_instance_variables_115.$$arity = 0);
    return Opal.const_get_relative($nesting, 'Opal').$pristine(self, "allocate", "copy_instance_variables", "initialize_dup");
  })($nesting[0], Array, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/hash"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$call', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$dup', '$default_proc', '$default_proc=', '$-', '$default=', '$alias_method', '$proc']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    function $Hash(){};
    var self = $Hash = $klass($base, $super, 'Hash', $Hash);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_$$_1, TMP_Hash_allocate_2, TMP_Hash_try_convert_3, TMP_Hash_initialize_4, TMP_Hash_$eq$eq_5, TMP_Hash_$gt$eq_7, TMP_Hash_$gt_8, TMP_Hash_$lt_9, TMP_Hash_$lt$eq_10, TMP_Hash_$$_11, TMP_Hash_$$$eq_12, TMP_Hash_assoc_13, TMP_Hash_clear_14, TMP_Hash_clone_15, TMP_Hash_compact_16, TMP_Hash_compact$B_17, TMP_Hash_compare_by_identity_18, TMP_Hash_compare_by_identity$q_19, TMP_Hash_default_20, TMP_Hash_default$eq_21, TMP_Hash_default_proc_22, TMP_Hash_default_proc$eq_23, TMP_Hash_delete_24, TMP_Hash_delete_if_25, TMP_Hash_dig_27, TMP_Hash_each_28, TMP_Hash_each_key_30, TMP_Hash_each_value_32, TMP_Hash_empty$q_34, TMP_Hash_fetch_35, TMP_Hash_fetch_values_36, TMP_Hash_flatten_38, TMP_Hash_has_key$q_39, TMP_Hash_has_value$q_40, TMP_Hash_hash_41, TMP_Hash_index_42, TMP_Hash_indexes_43, TMP_Hash_inspect_44, TMP_Hash_invert_45, TMP_Hash_keep_if_46, TMP_Hash_keys_48, TMP_Hash_length_49, TMP_Hash_merge_50, TMP_Hash_merge$B_51, TMP_Hash_rassoc_52, TMP_Hash_rehash_53, TMP_Hash_reject_54, TMP_Hash_reject$B_56, TMP_Hash_replace_58, TMP_Hash_select_59, TMP_Hash_select$B_61, TMP_Hash_shift_63, TMP_Hash_to_a_64, TMP_Hash_to_h_65, TMP_Hash_to_hash_66, TMP_Hash_to_proc_68, TMP_Hash_transform_values_69, TMP_Hash_transform_values$B_71, TMP_Hash_values_73;

    
    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
    def.$$is_hash = true;
    Opal.defs(self, '$[]', TMP_Hash_$$_1 = function($a_rest) {
      var self = this, argv;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      argv = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        argv[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), Opal.const_get_relative($nesting, 'Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), Opal.const_get_relative($nesting, 'Array'), "to_ary");
        if (argv === nil) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    
    }, TMP_Hash_$$_1.$$arity = -1);
    Opal.defs(self, '$allocate', TMP_Hash_allocate_2 = function $$allocate() {
      var self = this;

      
      var hash = new self.$$alloc();

      Opal.hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, TMP_Hash_allocate_2.$$arity = 0);
    Opal.defs(self, '$try_convert', TMP_Hash_try_convert_3 = function $$try_convert(obj) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to?'](obj, Opal.const_get_relative($nesting, 'Hash'), "to_hash")
    }, TMP_Hash_try_convert_3.$$arity = 1);
    
    Opal.defn(self, '$initialize', TMP_Hash_initialize_4 = function $$initialize(defaults) {
      var self = this, $iter = TMP_Hash_initialize_4.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_initialize_4.$$p = null;
      
      
      if (defaults !== undefined && block !== nil) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;
    ;
      return self;
    }, TMP_Hash_initialize_4.$$arity = -1);
    
    Opal.defn(self, '$==', TMP_Hash_$eq$eq_5 = function(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = Opal.hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, TMP_Hash_$eq$eq_5.$$arity = 1);
    
    Opal.defn(self, '$>=', TMP_Hash_$gt$eq_7 = function(other) {
      var TMP_6, self = this, result = nil;

      
      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], (TMP_6 = function(other_key, other_val){var self = TMP_6.$$s || this, val = nil;
if (other_key == null) other_key = nil;if (other_val == null) other_val = nil;
      
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, TMP_6.$$s = self, TMP_6.$$arity = 2, TMP_6));
      return result;
    }, TMP_Hash_$gt$eq_7.$$arity = 1);
    
    Opal.defn(self, '$>', TMP_Hash_$gt_8 = function(other) {
      var self = this;

      
      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, TMP_Hash_$gt_8.$$arity = 1);
    
    Opal.defn(self, '$<', TMP_Hash_$lt_9 = function(other) {
      var self = this;

      
      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), "to_hash");
      return $rb_gt(other, self);
    }, TMP_Hash_$lt_9.$$arity = 1);
    
    Opal.defn(self, '$<=', TMP_Hash_$lt$eq_10 = function(other) {
      var self = this;

      
      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), "to_hash");
      return $rb_ge(other, self);
    }, TMP_Hash_$lt$eq_10.$$arity = 1);
    
    Opal.defn(self, '$[]', TMP_Hash_$$_11 = function(key) {
      var self = this;

      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, TMP_Hash_$$_11.$$arity = 1);
    
    Opal.defn(self, '$[]=', TMP_Hash_$$$eq_12 = function(key, value) {
      var self = this;

      
      Opal.hash_put(self, key, value);
      return value;
    
    }, TMP_Hash_$$$eq_12.$$arity = 2);
    
    Opal.defn(self, '$assoc', TMP_Hash_assoc_13 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, TMP_Hash_assoc_13.$$arity = 1);
    
    Opal.defn(self, '$clear', TMP_Hash_clear_14 = function $$clear() {
      var self = this;

      
      Opal.hash_init(self);
      return self;
    
    }, TMP_Hash_clear_14.$$arity = 0);
    
    Opal.defn(self, '$clone', TMP_Hash_clone_15 = function $$clone() {
      var self = this;

      
      var hash = new self.$$class.$$alloc();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, TMP_Hash_clone_15.$$arity = 0);
    
    Opal.defn(self, '$compact', TMP_Hash_compact_16 = function $$compact() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, TMP_Hash_compact_16.$$arity = 0);
    
    Opal.defn(self, '$compact!', TMP_Hash_compact$B_17 = function() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, TMP_Hash_compact$B_17.$$arity = 0);
    
    Opal.defn(self, '$compare_by_identity', TMP_Hash_compare_by_identity_18 = function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, TMP_Hash_compare_by_identity_18.$$arity = 0);
    
    Opal.defn(self, '$compare_by_identity?', TMP_Hash_compare_by_identity$q_19 = function() {
      var self = this;

      return self.$$by_identity === true
    }, TMP_Hash_compare_by_identity$q_19.$$arity = 0);
    
    Opal.defn(self, '$default', TMP_Hash_default_20 = function(key) {
      var self = this;

      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    
    }, TMP_Hash_default_20.$$arity = -1);
    
    Opal.defn(self, '$default=', TMP_Hash_default$eq_21 = function(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, TMP_Hash_default$eq_21.$$arity = 1);
    
    Opal.defn(self, '$default_proc', TMP_Hash_default_proc_22 = function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, TMP_Hash_default_proc_22.$$arity = 0);
    
    Opal.defn(self, '$default_proc=', TMP_Hash_default_proc$eq_23 = function(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](proc, Opal.const_get_relative($nesting, 'Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, TMP_Hash_default_proc$eq_23.$$arity = 1);
    
    Opal.defn(self, '$delete', TMP_Hash_delete_24 = function(key) {
      var self = this, $iter = TMP_Hash_delete_24.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_delete_24.$$p = null;
      
      var value = Opal.hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block.$call(key);
      }

      return nil;
    
    }, TMP_Hash_delete_24.$$arity = 1);
    
    Opal.defn(self, '$delete_if', TMP_Hash_delete_if_25 = function $$delete_if() {
      var TMP_26, self = this, $iter = TMP_Hash_delete_if_25.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_delete_if_25.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["delete_if"], (TMP_26 = function(){var self = TMP_26.$$s || this;

        return self.$size()}, TMP_26.$$s = self, TMP_26.$$arity = 0, TMP_26))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, TMP_Hash_delete_if_25.$$arity = 0);
    Opal.alias(self, "dup", "clone");
    
    Opal.defn(self, '$dig', TMP_Hash_dig_27 = function $$dig(key, $a_rest) {
      var self = this, keys, item = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      keys = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        keys[$arg_idx - 1] = arguments[$arg_idx];
      }
      
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, TMP_Hash_dig_27.$$arity = -2);
    
    Opal.defn(self, '$each', TMP_Hash_each_28 = function $$each() {
      var TMP_29, self = this, $iter = TMP_Hash_each_28.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_each_28.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["each"], (TMP_29 = function(){var self = TMP_29.$$s || this;

        return self.$size()}, TMP_29.$$s = self, TMP_29.$$arity = 0, TMP_29))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.yield1(block, [key, value]);
      }

      return self;
    ;
    }, TMP_Hash_each_28.$$arity = 0);
    
    Opal.defn(self, '$each_key', TMP_Hash_each_key_30 = function $$each_key() {
      var TMP_31, self = this, $iter = TMP_Hash_each_key_30.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_each_key_30.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["each_key"], (TMP_31 = function(){var self = TMP_31.$$s || this;

        return self.$size()}, TMP_31.$$s = self, TMP_31.$$arity = 0, TMP_31))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, TMP_Hash_each_key_30.$$arity = 0);
    Opal.alias(self, "each_pair", "each");
    
    Opal.defn(self, '$each_value', TMP_Hash_each_value_32 = function $$each_value() {
      var TMP_33, self = this, $iter = TMP_Hash_each_value_32.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_each_value_32.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["each_value"], (TMP_33 = function(){var self = TMP_33.$$s || this;

        return self.$size()}, TMP_33.$$s = self, TMP_33.$$arity = 0, TMP_33))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, TMP_Hash_each_value_32.$$arity = 0);
    
    Opal.defn(self, '$empty?', TMP_Hash_empty$q_34 = function() {
      var self = this;

      return self.$$keys.length === 0
    }, TMP_Hash_empty$q_34.$$arity = 0);
    Opal.alias(self, "eql?", "==");
    
    Opal.defn(self, '$fetch', TMP_Hash_fetch_35 = function $$fetch(key, defaults) {
      var self = this, $iter = TMP_Hash_fetch_35.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_fetch_35.$$p = null;
      
      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return self.$raise(Opal.const_get_relative($nesting, 'KeyError'), "" + "key not found: " + (key.$inspect()));
    }, TMP_Hash_fetch_35.$$arity = -2);
    
    Opal.defn(self, '$fetch_values', TMP_Hash_fetch_values_36 = function $$fetch_values($a_rest) {
      var TMP_37, self = this, keys, $iter = TMP_Hash_fetch_values_36.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      keys = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        keys[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Hash_fetch_values_36.$$p = null;
      return $send(keys, 'map', [], (TMP_37 = function(key){var self = TMP_37.$$s || this;
if (key == null) key = nil;
      return $send(self, 'fetch', [key], block.$to_proc())}, TMP_37.$$s = self, TMP_37.$$arity = 1, TMP_37))
    }, TMP_Hash_fetch_values_36.$$arity = -1);
    
    Opal.defn(self, '$flatten', TMP_Hash_flatten_38 = function $$flatten(level) {
      var self = this;

      if (level == null) {
        level = 1;
      }
      
      level = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](level, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, TMP_Hash_flatten_38.$$arity = -1);
    
    Opal.defn(self, '$has_key?', TMP_Hash_has_key$q_39 = function(key) {
      var self = this;

      return Opal.hash_get(self, key) !== undefined
    }, TMP_Hash_has_key$q_39.$$arity = 1);
    
    Opal.defn(self, '$has_value?', TMP_Hash_has_value$q_40 = function(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, TMP_Hash_has_value$q_40.$$arity = 1);
    
    Opal.defn(self, '$hash', TMP_Hash_hash_41 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, TMP_Hash_hash_41.$$arity = 0);
    Opal.alias(self, "include?", "has_key?");
    
    Opal.defn(self, '$index', TMP_Hash_index_42 = function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, TMP_Hash_index_42.$$arity = 1);
    
    Opal.defn(self, '$indexes', TMP_Hash_indexes_43 = function $$indexes($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = Opal.hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    
    }, TMP_Hash_indexes_43.$$arity = -1);
    Opal.alias(self, "indices", "indexes");
    var inspect_ids;;
    
    Opal.defn(self, '$inspect', TMP_Hash_inspect_44 = function $$inspect() {
      var self = this;

      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];

      try {
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push(key.$inspect() + '=>' + value.$inspect());
        }

        return '{' + result.join(', ') + '}';

      } finally {
        if (top) {
          inspect_ids = undefined;
        }
      }
    
    }, TMP_Hash_inspect_44.$$arity = 0);
    
    Opal.defn(self, '$invert', TMP_Hash_invert_45 = function $$invert() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.hash_put(hash, value, key);
      }

      return hash;
    
    }, TMP_Hash_invert_45.$$arity = 0);
    
    Opal.defn(self, '$keep_if', TMP_Hash_keep_if_46 = function $$keep_if() {
      var TMP_47, self = this, $iter = TMP_Hash_keep_if_46.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_keep_if_46.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["keep_if"], (TMP_47 = function(){var self = TMP_47.$$s || this;

        return self.$size()}, TMP_47.$$s = self, TMP_47.$$arity = 0, TMP_47))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, TMP_Hash_keep_if_46.$$arity = 0);
    Opal.alias(self, "key", "index");
    Opal.alias(self, "key?", "has_key?");
    
    Opal.defn(self, '$keys', TMP_Hash_keys_48 = function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, TMP_Hash_keys_48.$$arity = 0);
    
    Opal.defn(self, '$length', TMP_Hash_length_49 = function $$length() {
      var self = this;

      return self.$$keys.length
    }, TMP_Hash_length_49.$$arity = 0);
    Opal.alias(self, "member?", "has_key?");
    
    Opal.defn(self, '$merge', TMP_Hash_merge_50 = function $$merge(other) {
      var self = this, $iter = TMP_Hash_merge_50.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_merge_50.$$p = null;
      return $send(self.$dup(), 'merge!', [other], block.$to_proc())
    }, TMP_Hash_merge_50.$$arity = 1);
    
    Opal.defn(self, '$merge!', TMP_Hash_merge$B_51 = function(other) {
      var self = this, $iter = TMP_Hash_merge$B_51.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_merge$B_51.$$p = null;
      
      if (!other.$$is_hash) {
        other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), "to_hash");
      }

      var i, other_keys = other.$$keys, length = other_keys.length, key, value, other_value;

      if (block === nil) {
        for (i = 0; i < length; i++) {
          key = other_keys[i];

          if (key.$$is_string) {
            other_value = other.$$smap[key];
          } else {
            other_value = key.value;
            key = key.key;
          }

          Opal.hash_put(self, key, other_value);
        }

        return self;
      }

      for (i = 0; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        value = Opal.hash_get(self, key);

        if (value === undefined) {
          Opal.hash_put(self, key, other_value);
          continue;
        }

        Opal.hash_put(self, key, block(key, value, other_value));
      }

      return self;
    
    }, TMP_Hash_merge$B_51.$$arity = 1);
    
    Opal.defn(self, '$rassoc', TMP_Hash_rassoc_52 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, TMP_Hash_rassoc_52.$$arity = 1);
    
    Opal.defn(self, '$rehash', TMP_Hash_rehash_53 = function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, TMP_Hash_rehash_53.$$arity = 0);
    
    Opal.defn(self, '$reject', TMP_Hash_reject_54 = function $$reject() {
      var TMP_55, self = this, $iter = TMP_Hash_reject_54.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_reject_54.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["reject"], (TMP_55 = function(){var self = TMP_55.$$s || this;

        return self.$size()}, TMP_55.$$s = self, TMP_55.$$arity = 0, TMP_55))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, TMP_Hash_reject_54.$$arity = 0);
    
    Opal.defn(self, '$reject!', TMP_Hash_reject$B_56 = function() {
      var TMP_57, self = this, $iter = TMP_Hash_reject$B_56.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_reject$B_56.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["reject!"], (TMP_57 = function(){var self = TMP_57.$$s || this;

        return self.$size()}, TMP_57.$$s = self, TMP_57.$$arity = 0, TMP_57))
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, TMP_Hash_reject$B_56.$$arity = 0);
    
    Opal.defn(self, '$replace', TMP_Hash_replace_58 = function $$replace(other) {
      var self = this, $writer = nil;

      
      other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Hash'), "to_hash");
      
      Opal.hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        Opal.hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        
        $writer = [other.$default_proc()];
        $send(self, 'default_proc=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
        } else {
        
        $writer = [other.$default()];
        $send(self, 'default=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return self;
    }, TMP_Hash_replace_58.$$arity = 1);
    
    Opal.defn(self, '$select', TMP_Hash_select_59 = function $$select() {
      var TMP_60, self = this, $iter = TMP_Hash_select_59.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_select_59.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["select"], (TMP_60 = function(){var self = TMP_60.$$s || this;

        return self.$size()}, TMP_60.$$s = self, TMP_60.$$arity = 0, TMP_60))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, TMP_Hash_select_59.$$arity = 0);
    
    Opal.defn(self, '$select!', TMP_Hash_select$B_61 = function() {
      var TMP_62, self = this, $iter = TMP_Hash_select$B_61.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_select$B_61.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["select!"], (TMP_62 = function(){var self = TMP_62.$$s || this;

        return self.$size()}, TMP_62.$$s = self, TMP_62.$$arity = 0, TMP_62))
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, TMP_Hash_select$B_61.$$arity = 0);
    
    Opal.defn(self, '$shift', TMP_Hash_shift_63 = function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, Opal.hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, TMP_Hash_shift_63.$$arity = 0);
    Opal.alias(self, "size", "length");
    self.$alias_method("store", "[]=");
    
    Opal.defn(self, '$to_a', TMP_Hash_to_a_64 = function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, TMP_Hash_to_a_64.$$arity = 0);
    
    Opal.defn(self, '$to_h', TMP_Hash_to_h_65 = function $$to_h() {
      var self = this;

      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash.$$alloc();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, TMP_Hash_to_h_65.$$arity = 0);
    
    Opal.defn(self, '$to_hash', TMP_Hash_to_hash_66 = function $$to_hash() {
      var self = this;

      return self
    }, TMP_Hash_to_hash_66.$$arity = 0);
    
    Opal.defn(self, '$to_proc', TMP_Hash_to_proc_68 = function $$to_proc() {
      var TMP_67, self = this;

      return $send(self, 'proc', [], (TMP_67 = function(key){var self = TMP_67.$$s || this;

      
        
        if (key == null) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, TMP_67.$$s = self, TMP_67.$$arity = -1, TMP_67))
    }, TMP_Hash_to_proc_68.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.defn(self, '$transform_values', TMP_Hash_transform_values_69 = function $$transform_values() {
      var TMP_70, self = this, $iter = TMP_Hash_transform_values_69.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_transform_values_69.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["transform_values"], (TMP_70 = function(){var self = TMP_70.$$s || this;

        return self.$size()}, TMP_70.$$s = self, TMP_70.$$arity = 0, TMP_70))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, TMP_Hash_transform_values_69.$$arity = 0);
    
    Opal.defn(self, '$transform_values!', TMP_Hash_transform_values$B_71 = function() {
      var TMP_72, self = this, $iter = TMP_Hash_transform_values$B_71.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_transform_values$B_71.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["transform_values!"], (TMP_72 = function(){var self = TMP_72.$$s || this;

        return self.$size()}, TMP_72.$$s = self, TMP_72.$$arity = 0, TMP_72))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(self, key, value);
      }

      return self;
    ;
    }, TMP_Hash_transform_values$B_71.$$arity = 0);
    Opal.alias(self, "update", "merge!");
    Opal.alias(self, "value?", "has_value?");
    Opal.alias(self, "values_at", "indexes");
    return (Opal.defn(self, '$values', TMP_Hash_values_73 = function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, TMP_Hash_values_73.$$arity = 0), nil) && 'values';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/number"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$-@', '$size', '$<=', '$>=', '$<=>', '$compare', '$empty?']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    function $Number(){};
    var self = $Number = $klass($base, $super, 'Number', $Number);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Number_coerce_2, TMP_Number___id___3, TMP_Number_$_4, TMP_Number_$_5, TMP_Number_$_6, TMP_Number_$_7, TMP_Number_$_8, TMP_Number_$_9, TMP_Number_$_10, TMP_Number_$_11, TMP_Number_$lt_12, TMP_Number_$lt$eq_13, TMP_Number_$gt_14, TMP_Number_$gt$eq_15, TMP_Number_$lt$eq$gt_16, TMP_Number_$lt$lt_17, TMP_Number_$gt$gt_18, TMP_Number_$$_19, TMP_Number_$$_20, TMP_Number_$$_21, TMP_Number_$_22, TMP_Number_$$_23, TMP_Number_$eq$eq$eq_24, TMP_Number_$eq$eq_25, TMP_Number_abs_26, TMP_Number_abs2_27, TMP_Number_angle_28, TMP_Number_bit_length_29, TMP_Number_ceil_30, TMP_Number_chr_31, TMP_Number_denominator_32, TMP_Number_downto_33, TMP_Number_equal$q_35, TMP_Number_even$q_36, TMP_Number_floor_37, TMP_Number_gcd_38, TMP_Number_gcdlcm_39, TMP_Number_integer$q_40, TMP_Number_is_a$q_41, TMP_Number_instance_of$q_42, TMP_Number_lcm_43, TMP_Number_next_44, TMP_Number_nonzero$q_45, TMP_Number_numerator_46, TMP_Number_odd$q_47, TMP_Number_ord_48, TMP_Number_pred_49, TMP_Number_quo_50, TMP_Number_rationalize_51, TMP_Number_round_52, TMP_Number_step_53, TMP_Number_times_55, TMP_Number_to_f_57, TMP_Number_to_i_58, TMP_Number_to_r_59, TMP_Number_to_s_60, TMP_Number_divmod_61, TMP_Number_upto_62, TMP_Number_zero$q_64, TMP_Number_size_65, TMP_Number_nan$q_66, TMP_Number_finite$q_67, TMP_Number_infinite$q_68, TMP_Number_positive$q_69, TMP_Number_negative$q_70;

    
    Opal.const_get_relative($nesting, 'Opal').$bridge(self, Number);
    Number.prototype.$$is_number = true;
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1;

      
      
      Opal.defn(self, '$allocate', TMP_allocate_1 = function $$allocate() {
        var self = this;

        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, TMP_allocate_1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.defn(self, '$coerce', TMP_Number_coerce_2 = function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [self.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
    
    }, TMP_Number_coerce_2.$$arity = 1);
    
    Opal.defn(self, '$__id__', TMP_Number___id___3 = function $$__id__() {
      var self = this;

      return (self * 2) + 1
    }, TMP_Number___id___3.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.defn(self, '$+', TMP_Number_$_4 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, TMP_Number_$_4.$$arity = 1);
    
    Opal.defn(self, '$-', TMP_Number_$_5 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, TMP_Number_$_5.$$arity = 1);
    
    Opal.defn(self, '$*', TMP_Number_$_6 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, TMP_Number_$_6.$$arity = 1);
    
    Opal.defn(self, '$/', TMP_Number_$_7 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, TMP_Number_$_7.$$arity = 1);
    Opal.alias(self, "fdiv", "/");
    
    Opal.defn(self, '$%', TMP_Number_$_8 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          self.$raise(Opal.const_get_relative($nesting, 'ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, TMP_Number_$_8.$$arity = 1);
    
    Opal.defn(self, '$&', TMP_Number_$_9 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, TMP_Number_$_9.$$arity = 1);
    
    Opal.defn(self, '$|', TMP_Number_$_10 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, TMP_Number_$_10.$$arity = 1);
    
    Opal.defn(self, '$^', TMP_Number_$_11 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, TMP_Number_$_11.$$arity = 1);
    
    Opal.defn(self, '$<', TMP_Number_$lt_12 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, TMP_Number_$lt_12.$$arity = 1);
    
    Opal.defn(self, '$<=', TMP_Number_$lt$eq_13 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, TMP_Number_$lt$eq_13.$$arity = 1);
    
    Opal.defn(self, '$>', TMP_Number_$gt_14 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, TMP_Number_$gt_14.$$arity = 1);
    
    Opal.defn(self, '$>=', TMP_Number_$gt$eq_15 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, TMP_Number_$gt$eq_15.$$arity = 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    Opal.defn(self, '$<=>', TMP_Number_$lt$eq$gt_16 = function(other) {
      var self = this;

      try {
        
      return spaceship_operator(self, other);
    
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, TMP_Number_$lt$eq$gt_16.$$arity = 1);
    
    Opal.defn(self, '$<<', TMP_Number_$lt$lt_17 = function(count) {
      var self = this;

      
      count = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](count, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, TMP_Number_$lt$lt_17.$$arity = 1);
    
    Opal.defn(self, '$>>', TMP_Number_$gt$gt_18 = function(count) {
      var self = this;

      
      count = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](count, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, TMP_Number_$gt$gt_18.$$arity = 1);
    
    Opal.defn(self, '$[]', TMP_Number_$$_19 = function(bit) {
      var self = this;

      
      bit = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](bit, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, TMP_Number_$$_19.$$arity = 1);
    
    Opal.defn(self, '$+@', TMP_Number_$$_20 = function() {
      var self = this;

      return +self
    }, TMP_Number_$$_20.$$arity = 0);
    
    Opal.defn(self, '$-@', TMP_Number_$$_21 = function() {
      var self = this;

      return -self
    }, TMP_Number_$$_21.$$arity = 0);
    
    Opal.defn(self, '$~', TMP_Number_$_22 = function() {
      var self = this;

      return ~self
    }, TMP_Number_$_22.$$arity = 0);
    
    Opal.defn(self, '$**', TMP_Number_$$_23 = function(other) {
      var $a, $b, self = this;

      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](other))) {
        if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Integer')['$==='](self)['$!']()) ? $a : $rb_gt(other, 0)))) {
          return Math.pow(self, other)
          } else {
          return Opal.const_get_relative($nesting, 'Rational').$new(self, 1)['$**'](other)
        }
      } else if ($truthy((($a = $rb_lt(self, 0)) ? ($truthy($b = Opal.const_get_relative($nesting, 'Float')['$==='](other)) ? $b : Opal.const_get_relative($nesting, 'Rational')['$==='](other)) : $rb_lt(self, 0)))) {
        return Opal.const_get_relative($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other)
        } else {
        return self.$__coerced__("**", other)
      }
    }, TMP_Number_$$_23.$$arity = 1);
    
    Opal.defn(self, '$===', TMP_Number_$eq$eq$eq_24 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, TMP_Number_$eq$eq$eq_24.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_Number_$eq$eq_25 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, TMP_Number_$eq$eq_25.$$arity = 1);
    
    Opal.defn(self, '$abs', TMP_Number_abs_26 = function $$abs() {
      var self = this;

      return Math.abs(self)
    }, TMP_Number_abs_26.$$arity = 0);
    
    Opal.defn(self, '$abs2', TMP_Number_abs2_27 = function $$abs2() {
      var self = this;

      return Math.abs(self * self)
    }, TMP_Number_abs2_27.$$arity = 0);
    
    Opal.defn(self, '$angle', TMP_Number_angle_28 = function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self};
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, TMP_Number_angle_28.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    Opal.alias(self, "phase", "angle");
    
    Opal.defn(self, '$bit_length', TMP_Number_bit_length_29 = function $$bit_length() {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'NoMethodError').$new("" + "undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, TMP_Number_bit_length_29.$$arity = 0);
    
    Opal.defn(self, '$ceil', TMP_Number_ceil_30 = function $$ceil() {
      var self = this;

      return Math.ceil(self)
    }, TMP_Number_ceil_30.$$arity = 0);
    
    Opal.defn(self, '$chr', TMP_Number_chr_31 = function $$chr(encoding) {
      var self = this;

      return String.fromCharCode(self)
    }, TMP_Number_chr_31.$$arity = -1);
    
    Opal.defn(self, '$denominator', TMP_Number_denominator_32 = function $$denominator() {
      var $a, self = this, $iter = TMP_Number_denominator_32.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Number_denominator_32.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
        return 1
        } else {
        return $send(self, Opal.find_super_dispatcher(self, 'denominator', TMP_Number_denominator_32, false), $zuper, $iter)
      }
    }, TMP_Number_denominator_32.$$arity = 0);
    
    Opal.defn(self, '$downto', TMP_Number_downto_33 = function $$downto(stop) {
      var TMP_34, self = this, $iter = TMP_Number_downto_33.$$p, block = $iter || nil;

      if ($iter) TMP_Number_downto_33.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["downto", stop], (TMP_34 = function(){var self = TMP_34.$$s || this;

        
          if ($truthy(Opal.const_get_relative($nesting, 'Numeric')['$==='](stop))) {
            } else {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
            } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, TMP_34.$$s = self, TMP_34.$$arity = 0, TMP_34))
      };
      
      if (!stop.$$is_number) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, TMP_Number_downto_33.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.defn(self, '$equal?', TMP_Number_equal$q_35 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$=='](other)) ? $a : isNaN(self) && isNaN(other))
    }, TMP_Number_equal$q_35.$$arity = 1);
    
    Opal.defn(self, '$even?', TMP_Number_even$q_36 = function() {
      var self = this;

      return self % 2 === 0
    }, TMP_Number_even$q_36.$$arity = 0);
    
    Opal.defn(self, '$floor', TMP_Number_floor_37 = function $$floor() {
      var self = this;

      return Math.floor(self)
    }, TMP_Number_floor_37.$$arity = 0);
    
    Opal.defn(self, '$gcd', TMP_Number_gcd_38 = function $$gcd(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](other))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, TMP_Number_gcd_38.$$arity = 1);
    
    Opal.defn(self, '$gcdlcm', TMP_Number_gcdlcm_39 = function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(), self.$lcm()]
    }, TMP_Number_gcdlcm_39.$$arity = 1);
    
    Opal.defn(self, '$integer?', TMP_Number_integer$q_40 = function() {
      var self = this;

      return self % 1 === 0
    }, TMP_Number_integer$q_40.$$arity = 0);
    
    Opal.defn(self, '$is_a?', TMP_Number_is_a$q_41 = function(klass) {
      var $a, self = this, $iter = TMP_Number_is_a$q_41.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Number_is_a$q_41.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Fixnum'))) ? Opal.const_get_relative($nesting, 'Integer')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Fixnum'))))) {
        return true};
      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Integer'))) ? Opal.const_get_relative($nesting, 'Integer')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Float'))) ? Opal.const_get_relative($nesting, 'Float')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Float'))))) {
        return true};
      return $send(self, Opal.find_super_dispatcher(self, 'is_a?', TMP_Number_is_a$q_41, false), $zuper, $iter);
    }, TMP_Number_is_a$q_41.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.defn(self, '$instance_of?', TMP_Number_instance_of$q_42 = function(klass) {
      var $a, self = this, $iter = TMP_Number_instance_of$q_42.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Number_instance_of$q_42.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Fixnum'))) ? Opal.const_get_relative($nesting, 'Integer')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Fixnum'))))) {
        return true};
      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Integer'))) ? Opal.const_get_relative($nesting, 'Integer')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$=='](Opal.const_get_relative($nesting, 'Float'))) ? Opal.const_get_relative($nesting, 'Float')['$==='](self) : klass['$=='](Opal.const_get_relative($nesting, 'Float'))))) {
        return true};
      return $send(self, Opal.find_super_dispatcher(self, 'instance_of?', TMP_Number_instance_of$q_42, false), $zuper, $iter);
    }, TMP_Number_instance_of$q_42.$$arity = 1);
    
    Opal.defn(self, '$lcm', TMP_Number_lcm_43 = function $$lcm(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](other))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, TMP_Number_lcm_43.$$arity = 1);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.defn(self, '$next', TMP_Number_next_44 = function $$next() {
      var self = this;

      return self + 1
    }, TMP_Number_next_44.$$arity = 0);
    
    Opal.defn(self, '$nonzero?', TMP_Number_nonzero$q_45 = function() {
      var self = this;

      return self == 0 ? nil : self
    }, TMP_Number_nonzero$q_45.$$arity = 0);
    
    Opal.defn(self, '$numerator', TMP_Number_numerator_46 = function $$numerator() {
      var $a, self = this, $iter = TMP_Number_numerator_46.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Number_numerator_46.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
        return self
        } else {
        return $send(self, Opal.find_super_dispatcher(self, 'numerator', TMP_Number_numerator_46, false), $zuper, $iter)
      }
    }, TMP_Number_numerator_46.$$arity = 0);
    
    Opal.defn(self, '$odd?', TMP_Number_odd$q_47 = function() {
      var self = this;

      return self % 2 !== 0
    }, TMP_Number_odd$q_47.$$arity = 0);
    
    Opal.defn(self, '$ord', TMP_Number_ord_48 = function $$ord() {
      var self = this;

      return self
    }, TMP_Number_ord_48.$$arity = 0);
    
    Opal.defn(self, '$pred', TMP_Number_pred_49 = function $$pred() {
      var self = this;

      return self - 1
    }, TMP_Number_pred_49.$$arity = 0);
    
    Opal.defn(self, '$quo', TMP_Number_quo_50 = function $$quo(other) {
      var self = this, $iter = TMP_Number_quo_50.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Number_quo_50.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {
        return $send(self, Opal.find_super_dispatcher(self, 'quo', TMP_Number_quo_50, false), $zuper, $iter)
        } else {
        return $rb_divide(self, other)
      }
    }, TMP_Number_quo_50.$$arity = 1);
    
    Opal.defn(self, '$rationalize', TMP_Number_rationalize_51 = function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      
      if (arguments.length > 1) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {
        return Opal.const_get_relative($nesting, 'Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = Opal.const_get_relative($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = Opal.const_get_relative($nesting, 'Math').$ldexp(f, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'MANT_DIG'));
        return Opal.const_get_relative($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize(Opal.const_get_relative($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
        } else {
        return self.$to_r().$rationalize(eps)
      };
    }, TMP_Number_rationalize_51.$$arity = -1);
    
    Opal.defn(self, '$round', TMP_Number_round_52 = function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {
        
        if ($truthy(ndigits == null)) {
          return self};
        if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Float')['$==='](ndigits)) ? ndigits['$infinite?']() : $a))) {
          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "Infinity")};
        ndigits = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](ndigits, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Integer'), 'MIN')))) {
          self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "out of bounds")};
        if ($truthy(ndigits >= 0)) {
          return self};
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(x) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
        } else {
        
        if ($truthy(($truthy($a = self['$nan?']()) ? ndigits == null : $a))) {
          self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), "NaN")};
        ndigits = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](ndigits || 0, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), "Infinity")}
        } else if (ndigits['$=='](0)) {
          return Math.round(self)
        } else if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
          return self};
        $b = Opal.const_get_relative($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_divide(exp, 4)
          } else {
          return $rb_minus($rb_divide(exp, 3), 1)
        }; return nil; })())))) {
          return self};
        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_plus($rb_divide(exp, 3), 1)
          } else {
          return $rb_divide(exp, 4)
        }; return nil; })()['$-@']()))) {
          return 0};
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);
      }
    }, TMP_Number_round_52.$$arity = -1);
    
    Opal.defn(self, '$step', TMP_Number_step_53 = function $$step($limit, $step, $kwargs) {
      var TMP_54, self = this, $post_args, to, by, limit, step, $iter = TMP_Number_step_53.$$p, block = $iter || nil, positional_args = nil, keyword_args = nil;

      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      $kwargs = Opal.extract_kwargs($post_args);
      if ($kwargs == null || !$kwargs.$$is_hash) {
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else {
          throw Opal.ArgumentError.$new('expected kwargs');
        }
      }
      to = $kwargs.$$smap["to"];
      by = $kwargs.$$smap["by"];
      if (0 < $post_args.length) {
        limit = $post_args.splice(0,1)[0];
      }
      if (0 < $post_args.length) {
        step = $post_args.splice(0,1)[0];
      }
      if ($iter) TMP_Number_step_53.$$p = null;
      
      
      if (limit !== undefined && to !== undefined) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "step is given twice")
      }

      function validateParameters() {
        if (to !== undefined) {
          limit = to;
        }

        if (limit === undefined) {
          limit = nil;
        }

        if (step === nil) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "step must be numeric")
        }

        if (step === 0) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "step can't be 0")
        }

        if (by !== undefined) {
          step = by;
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY') : Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')['$-@']();
        }

        Opal.const_get_relative($nesting, 'Opal').$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }
    ;
      if ((block !== nil)) {
        } else {
        
        positional_args = [];
        keyword_args = $hash2([], {});
        
        if (limit !== undefined) {
          positional_args.push(limit);
        }

        if (step !== undefined) {
          positional_args.push(step);
        }

        if (to !== undefined) {
          Opal.hash_put(keyword_args, "to", to);
        }

        if (by !== undefined) {
          Opal.hash_put(keyword_args, "by", by);
        }

        if (!keyword_args['$empty?']()) {
          positional_args.push(keyword_args);
        }
      ;
        return $send(self, 'enum_for', ["step"].concat(Opal.to_a(positional_args)), (TMP_54 = function(){var self = TMP_54.$$s || this;

        return stepSize()}, TMP_54.$$s = self, TMP_54.$$arity = 0, TMP_54));
      };
      
      validateParameters();

      if (step === 0) {
        while (true) {
          block(self);
        }
      }

      if (self % 1 !== 0 || limit % 1 !== 0 || step % 1 !== 0) {
        var n = stepFloatSize();

        if (n > 0) {
          if (step === Infinity || step === -Infinity) {
            block(self);
          } else {
            var i = 0, d;

            if (step > 0) {
              while (i < n) {
                d = i * step + self;
                if (limit < d) {
                  d = limit;
                }
                block(d);
                i += 1;
              }
            } else {
              while (i < n) {
                d = i * step + self;
                if (limit > d) {
                  d = limit;
                }
                block(d);
                i += 1
              }
            }
          }
        }
      } else {
        var value = self;

        if (step > 0) {
          while (value <= limit) {
            block(value);
            value += step;
          }
        } else {
          while (value >= limit) {
            block(value);
            value += step
          }
        }
      }

      return self;
    ;
    }, TMP_Number_step_53.$$arity = -1);
    Opal.alias(self, "succ", "next");
    
    Opal.defn(self, '$times', TMP_Number_times_55 = function $$times() {
      var TMP_56, self = this, $iter = TMP_Number_times_55.$$p, block = $iter || nil;

      if ($iter) TMP_Number_times_55.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return $send(self, 'enum_for', ["times"], (TMP_56 = function(){var self = TMP_56.$$s || this;

        return self}, TMP_56.$$s = self, TMP_56.$$arity = 0, TMP_56))
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, TMP_Number_times_55.$$arity = 0);
    
    Opal.defn(self, '$to_f', TMP_Number_to_f_57 = function $$to_f() {
      var self = this;

      return self
    }, TMP_Number_to_f_57.$$arity = 0);
    
    Opal.defn(self, '$to_i', TMP_Number_to_i_58 = function $$to_i() {
      var self = this;

      return parseInt(self, 10)
    }, TMP_Number_to_i_58.$$arity = 0);
    Opal.alias(self, "to_int", "to_i");
    
    Opal.defn(self, '$to_r', TMP_Number_to_r_59 = function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](self))) {
        return Opal.const_get_relative($nesting, 'Rational').$new(self, 1)
        } else {
        
        $b = Opal.const_get_relative($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = Opal.const_get_relative($nesting, 'Math').$ldexp(f, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'MANT_DIG'));
        return $rb_times(f, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, TMP_Number_to_r_59.$$arity = 0);
    
    Opal.defn(self, '$to_s', TMP_Number_to_s_60 = function $$to_s(base) {
      var $a, self = this;

      if (base == null) {
        base = 10;
      }
      
      if ($truthy(($truthy($a = $rb_lt(base, 2)) ? $a : $rb_gt(base, 36)))) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "base must be between 2 and 36")};
      return self.toString(base);
    }, TMP_Number_to_s_60.$$arity = -1);
    Opal.alias(self, "truncate", "to_i");
    Opal.alias(self, "inspect", "to_s");
    
    Opal.defn(self, '$divmod', TMP_Number_divmod_61 = function $$divmod(other) {
      var $a, self = this, $iter = TMP_Number_divmod_61.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Number_divmod_61.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : other['$nan?']()))) {
        return self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise(Opal.const_get_relative($nesting, 'FloatDomainError'), "Infinity")
        } else {
        return $send(self, Opal.find_super_dispatcher(self, 'divmod', TMP_Number_divmod_61, false), $zuper, $iter)
      }
    }, TMP_Number_divmod_61.$$arity = 1);
    
    Opal.defn(self, '$upto', TMP_Number_upto_62 = function $$upto(stop) {
      var TMP_63, self = this, $iter = TMP_Number_upto_62.$$p, block = $iter || nil;

      if ($iter) TMP_Number_upto_62.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return $send(self, 'enum_for', ["upto", stop], (TMP_63 = function(){var self = TMP_63.$$s || this;

        
          if ($truthy(Opal.const_get_relative($nesting, 'Numeric')['$==='](stop))) {
            } else {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
            } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, TMP_63.$$s = self, TMP_63.$$arity = 0, TMP_63))
      };
      
      if (!stop.$$is_number) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, TMP_Number_upto_62.$$arity = 1);
    
    Opal.defn(self, '$zero?', TMP_Number_zero$q_64 = function() {
      var self = this;

      return self == 0
    }, TMP_Number_zero$q_64.$$arity = 0);
    
    Opal.defn(self, '$size', TMP_Number_size_65 = function $$size() {
      var self = this;

      return 4
    }, TMP_Number_size_65.$$arity = 0);
    
    Opal.defn(self, '$nan?', TMP_Number_nan$q_66 = function() {
      var self = this;

      return isNaN(self)
    }, TMP_Number_nan$q_66.$$arity = 0);
    
    Opal.defn(self, '$finite?', TMP_Number_finite$q_67 = function() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self)
    }, TMP_Number_finite$q_67.$$arity = 0);
    
    Opal.defn(self, '$infinite?', TMP_Number_infinite$q_68 = function() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, TMP_Number_infinite$q_68.$$arity = 0);
    
    Opal.defn(self, '$positive?', TMP_Number_positive$q_69 = function() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0)
    }, TMP_Number_positive$q_69.$$arity = 0);
    return (Opal.defn(self, '$negative?', TMP_Number_negative$q_70 = function() {
      var self = this;

      return self == -Infinity || 1 / self < 0
    }, TMP_Number_negative$q_70.$$arity = 0), nil) && 'negative?';
  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);
  Opal.const_set($nesting[0], 'Fixnum', Opal.const_get_relative($nesting, 'Number'));
  (function($base, $super, $parent_nesting) {
    function $Integer(){};
    var self = $Integer = $klass($base, $super, 'Integer', $Integer);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_71, TMP_$eq$eq$eq_72;

      
      
      Opal.defn(self, '$allocate', TMP_allocate_71 = function $$allocate() {
        var self = this;

        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, TMP_allocate_71.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.defn(self, '$===', TMP_$eq$eq$eq_72 = function(other) {
        var self = this;

        
        if (!other.$$is_number) {
          return false;
        }

        return (other % 1) === 0;
      
      }, TMP_$eq$eq$eq_72.$$arity = 1), nil) && '===';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);
    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));
  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    function $Float(){};
    var self = $Float = $klass($base, $super, 'Float', $Float);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_73, TMP_$eq$eq$eq_74;

      
      
      Opal.defn(self, '$allocate', TMP_allocate_73 = function $$allocate() {
        var self = this;

        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, TMP_allocate_73.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.defn(self, '$===', TMP_$eq$eq$eq_74 = function(other) {
        var self = this;

        return !!other.$$is_number
      }, TMP_$eq$eq$eq_74.$$arity = 1), nil) && '===';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'INFINITY', Infinity);
    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);
    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);
    Opal.const_set($nesting[0], 'NAN', NaN);
    Opal.const_set($nesting[0], 'DIG', 15);
    Opal.const_set($nesting[0], 'MANT_DIG', 53);
    Opal.const_set($nesting[0], 'RADIX', 2);
    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/range"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$include?', '$<=', '$<', '$enum_for', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$!', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-', '$abs', '$to_i', '$coerce_to!', '$ceil', '$/', '$size', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    function $Range(){};
    var self = $Range = $klass($base, $super, 'Range', $Range);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Range_initialize_1, TMP_Range_$eq$eq_2, TMP_Range_$eq$eq$eq_3, TMP_Range_cover$q_4, TMP_Range_each_5, TMP_Range_eql$q_6, TMP_Range_exclude_end$q_7, TMP_Range_first_8, TMP_Range_last_9, TMP_Range_max_10, TMP_Range_min_11, TMP_Range_size_12, TMP_Range_step_13, TMP_Range_bsearch_17, TMP_Range_to_s_18, TMP_Range_inspect_19, TMP_Range_marshal_load_20, TMP_Range_hash_21;

    def.begin = def.end = def.excl = nil;
    
    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
    def.$$is_range = true;;
    self.$attr_reader("begin", "end");
    
    Opal.defn(self, '$initialize', TMP_Range_initialize_1 = function $$initialize(first, last, exclude) {
      var self = this;

      if (exclude == null) {
        exclude = false;
      }
      
      if ($truthy(self.begin)) {
        self.$raise(Opal.const_get_relative($nesting, 'NameError'), "'initialize' called twice")};
      if ($truthy(first['$<=>'](last))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, TMP_Range_initialize_1.$$arity = -3);
    
    Opal.defn(self, '$==', TMP_Range_$eq$eq_2 = function(other) {
      var self = this;

      
      if (!other.$$is_range) {
        return false;
      }

      return self.excl  === other.excl &&
             self.begin ==  other.begin &&
             self.end   ==  other.end;
    
    }, TMP_Range_$eq$eq_2.$$arity = 1);
    
    Opal.defn(self, '$===', TMP_Range_$eq$eq$eq_3 = function(value) {
      var self = this;

      return self['$include?'](value)
    }, TMP_Range_$eq$eq$eq_3.$$arity = 1);
    
    Opal.defn(self, '$cover?', TMP_Range_cover$q_4 = function(value) {
      var $a, self = this, beg_cmp = nil, end_cmp = nil;

      
      beg_cmp = self.begin['$<=>'](value);
      if ($truthy(($truthy($a = beg_cmp) ? $rb_le(beg_cmp, 0) : $a))) {
        } else {
        return false
      };
      end_cmp = value['$<=>'](self.end);
      if ($truthy(self.excl)) {
        return ($truthy($a = end_cmp) ? $rb_lt(end_cmp, 0) : $a)
        } else {
        return ($truthy($a = end_cmp) ? $rb_le(end_cmp, 0) : $a)
      };
    }, TMP_Range_cover$q_4.$$arity = 1);
    
    Opal.defn(self, '$each', TMP_Range_each_5 = function $$each() {
      var $a, self = this, $iter = TMP_Range_each_5.$$p, block = $iter || nil, current = nil, last = nil;

      if ($iter) TMP_Range_each_5.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("each")
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {
        return 0
        } else {
        return 1
      }; return nil; })(); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if ($truthy(current['$respond_to?']("succ"))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "can't iterate from " + (current.$class()))
      };
      while ($truthy($rb_lt(current['$<=>'](last), 0))) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if ($truthy(($truthy($a = self.excl['$!']()) ? current['$=='](last) : $a))) {
        Opal.yield1(block, current)};
      return self;
    }, TMP_Range_each_5.$$arity = 0);
    
    Opal.defn(self, '$eql?', TMP_Range_eql$q_6 = function(other) {
      var $a, $b, self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Range')['$==='](other))) {
        } else {
        return false
      };
      return ($truthy($a = ($truthy($b = self.excl['$==='](other['$exclude_end?']())) ? self.begin['$eql?'](other.$begin()) : $b)) ? self.end['$eql?'](other.$end()) : $a);
    }, TMP_Range_eql$q_6.$$arity = 1);
    
    Opal.defn(self, '$exclude_end?', TMP_Range_exclude_end$q_7 = function() {
      var self = this;

      return self.excl
    }, TMP_Range_exclude_end$q_7.$$arity = 0);
    
    Opal.defn(self, '$first', TMP_Range_first_8 = function $$first(n) {
      var self = this, $iter = TMP_Range_first_8.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Range_first_8.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy(n == null)) {
        return self.begin};
      return $send(self, Opal.find_super_dispatcher(self, 'first', TMP_Range_first_8, false), $zuper, $iter);
    }, TMP_Range_first_8.$$arity = -1);
    Opal.alias(self, "include?", "cover?");
    
    Opal.defn(self, '$last', TMP_Range_last_9 = function $$last(n) {
      var self = this;

      
      if ($truthy(n == null)) {
        return self.end};
      return self.$to_a().$last(n);
    }, TMP_Range_last_9.$$arity = -1);
    
    Opal.defn(self, '$max', TMP_Range_max_10 = function $$max() {
      var $a, self = this, $iter = TMP_Range_max_10.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Range_max_10.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send(self, Opal.find_super_dispatcher(self, 'max', TMP_Range_max_10, false), $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {
        return nil
        } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, TMP_Range_max_10.$$arity = 0);
    Opal.alias(self, "member?", "cover?");
    
    Opal.defn(self, '$min', TMP_Range_min_11 = function $$min() {
      var $a, self = this, $iter = TMP_Range_min_11.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Range_min_11.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send(self, Opal.find_super_dispatcher(self, 'min', TMP_Range_min_11, false), $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {
        return nil
        } else {
        return self.begin
      }
    }, TMP_Range_min_11.$$arity = 0);
    
    Opal.defn(self, '$size', TMP_Range_size_12 = function $$size() {
      var $a, self = this, _begin = nil, _end = nil, infinity = nil;

      
      _begin = self.begin;
      _end = self.end;
      if ($truthy(self.excl)) {
        _end = $rb_minus(_end, 1)};
      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](_begin)) ? Opal.const_get_relative($nesting, 'Numeric')['$==='](_end) : $a))) {
        } else {
        return nil
      };
      if ($truthy($rb_lt(_end, _begin))) {
        return 0};
      infinity = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY');
      if ($truthy(($truthy($a = infinity['$=='](_begin.$abs())) ? $a : _end.$abs()['$=='](infinity)))) {
        return infinity};
      return (Math.abs(_end - _begin) + 1).$to_i();
    }, TMP_Range_size_12.$$arity = 0);
    
    Opal.defn(self, '$step', TMP_Range_step_13 = function $$step(n) {
      var TMP_14, TMP_15, TMP_16, self = this, $iter = TMP_Range_step_13.$$p, $yield = $iter || nil, i = nil;

      if (n == null) {
        n = 1;
      }
      if ($iter) TMP_Range_step_13.$$p = null;
      
      
      function coerceStepSize() {
        if (!n.$$is_number) {
          n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), "to_int")
        }

        if (n < 0) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (($yield !== nil)) {
        } else {
        return $send(self, 'enum_for', ["step", n], (TMP_14 = function(){var self = TMP_14.$$s || this;

        
          coerceStepSize();
          return enumeratorSize();
        }, TMP_14.$$s = self, TMP_14.$$arity = 0, TMP_14))
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_15 = function(){var self = TMP_15.$$s || this, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

        
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)}
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)};
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, TMP_15.$$s = self, TMP_15.$$brk = $brk, TMP_15.$$arity = 0, TMP_15))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], (TMP_16 = function(value, idx){var self = TMP_16.$$s || this;
if (value == null) value = nil;if (idx == null) idx = nil;
        if (idx['$%'](n)['$=='](0)) {
            return Opal.yield1($yield, value);
            } else {
            return nil
          }}, TMP_16.$$s = self, TMP_16.$$arity = 2, TMP_16));
      };
      return self;
    }, TMP_Range_step_13.$$arity = -1);
    
    Opal.defn(self, '$bsearch', TMP_Range_bsearch_17 = function $$bsearch() {
      var self = this, $iter = TMP_Range_bsearch_17.$$p, block = $iter || nil;

      if ($iter) TMP_Range_bsearch_17.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("bsearch")
      };
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, TMP_Range_bsearch_17.$$arity = 0);
    
    Opal.defn(self, '$to_s', TMP_Range_to_s_18 = function $$to_s() {
      var self = this;

      return "" + (self.begin) + ((function() {if ($truthy(self.excl)) {
        return "..."
        } else {
        return ".."
      }; return nil; })()) + (self.end)
    }, TMP_Range_to_s_18.$$arity = 0);
    
    Opal.defn(self, '$inspect', TMP_Range_inspect_19 = function $$inspect() {
      var self = this;

      return "" + (self.begin.$inspect()) + ((function() {if ($truthy(self.excl)) {
        return "..."
        } else {
        return ".."
      }; return nil; })()) + (self.end.$inspect())
    }, TMP_Range_inspect_19.$$arity = 0);
    
    Opal.defn(self, '$marshal_load', TMP_Range_marshal_load_20 = function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, TMP_Range_marshal_load_20.$$arity = 1);
    return (Opal.defn(self, '$hash', TMP_Range_hash_21 = function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, TMP_Range_hash_21.$$arity = 0), nil) && 'hash';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/proc"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    function $Proc(){};
    var self = $Proc = $klass($base, $super, 'Proc', $Proc);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Proc_new_1, TMP_Proc_call_2, TMP_Proc_to_proc_3, TMP_Proc_lambda$q_4, TMP_Proc_arity_5, TMP_Proc_source_location_6, TMP_Proc_binding_7, TMP_Proc_parameters_8, TMP_Proc_curry_9, TMP_Proc_dup_10;

    
    def.$$is_proc = true;
    def.$$is_lambda = false;
    Opal.defs(self, '$new', TMP_Proc_new_1 = function() {
      var self = this, $iter = TMP_Proc_new_1.$$p, block = $iter || nil;

      if ($iter) TMP_Proc_new_1.$$p = null;
      
      if ($truthy(block)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, TMP_Proc_new_1.$$arity = 0);
    
    Opal.defn(self, '$call', TMP_Proc_call_2 = function $$call($a_rest) {
      var self = this, args, $iter = TMP_Proc_call_2.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Proc_call_2.$$p = null;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    
    }, TMP_Proc_call_2.$$arity = -1);
    Opal.alias(self, "[]", "call");
    Opal.alias(self, "===", "call");
    Opal.alias(self, "yield", "call");
    
    Opal.defn(self, '$to_proc', TMP_Proc_to_proc_3 = function $$to_proc() {
      var self = this;

      return self
    }, TMP_Proc_to_proc_3.$$arity = 0);
    
    Opal.defn(self, '$lambda?', TMP_Proc_lambda$q_4 = function() {
      var self = this;

      return !!self.$$is_lambda
    }, TMP_Proc_lambda$q_4.$$arity = 0);
    
    Opal.defn(self, '$arity', TMP_Proc_arity_5 = function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, TMP_Proc_arity_5.$$arity = 0);
    
    Opal.defn(self, '$source_location', TMP_Proc_source_location_6 = function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, TMP_Proc_source_location_6.$$arity = 0);
    
    Opal.defn(self, '$binding', TMP_Proc_binding_7 = function $$binding() {
      var self = this;

      
      if (self.$$is_curried) { self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "Can't create Binding") };
      return nil;
    }, TMP_Proc_binding_7.$$arity = 0);
    
    Opal.defn(self, '$parameters', TMP_Proc_parameters_8 = function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, TMP_Proc_parameters_8.$$arity = 0);
    
    Opal.defn(self, '$curry', TMP_Proc_curry_9 = function $$curry(arity) {
      var self = this;

      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](arity, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    
    }, TMP_Proc_curry_9.$$arity = -1);
    
    Opal.defn(self, '$dup', TMP_Proc_dup_10 = function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, TMP_Proc_dup_10.$$arity = 0);
    return Opal.alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/method"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$arity', '$new', '$class', '$join', '$source_location', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    function $Method(){};
    var self = $Method = $klass($base, $super, 'Method', $Method);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Method_initialize_1, TMP_Method_arity_2, TMP_Method_parameters_3, TMP_Method_source_location_4, TMP_Method_comments_5, TMP_Method_call_6, TMP_Method_unbind_7, TMP_Method_to_proc_8, TMP_Method_inspect_9;

    def.method = def.receiver = def.owner = def.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    Opal.defn(self, '$initialize', TMP_Method_initialize_1 = function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, TMP_Method_initialize_1.$$arity = 4);
    
    Opal.defn(self, '$arity', TMP_Method_arity_2 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, TMP_Method_arity_2.$$arity = 0);
    
    Opal.defn(self, '$parameters', TMP_Method_parameters_3 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, TMP_Method_parameters_3.$$arity = 0);
    
    Opal.defn(self, '$source_location', TMP_Method_source_location_4 = function $$source_location() {
      var $a, self = this;

      return ($truthy($a = self.method.$$source_location) ? $a : ["(eval)", 0])
    }, TMP_Method_source_location_4.$$arity = 0);
    
    Opal.defn(self, '$comments', TMP_Method_comments_5 = function $$comments() {
      var $a, self = this;

      return ($truthy($a = self.method.$$comments) ? $a : [])
    }, TMP_Method_comments_5.$$arity = 0);
    
    Opal.defn(self, '$call', TMP_Method_call_6 = function $$call($a_rest) {
      var self = this, args, $iter = TMP_Method_call_6.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Method_call_6.$$p = null;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    
    }, TMP_Method_call_6.$$arity = -1);
    Opal.alias(self, "[]", "call");
    
    Opal.defn(self, '$unbind', TMP_Method_unbind_7 = function $$unbind() {
      var self = this;

      return Opal.const_get_relative($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, TMP_Method_unbind_7.$$arity = 0);
    
    Opal.defn(self, '$to_proc', TMP_Method_to_proc_8 = function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      return proc;
    
    }, TMP_Method_to_proc_8.$$arity = 0);
    return (Opal.defn(self, '$inspect', TMP_Method_inspect_9 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, TMP_Method_inspect_9.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    function $UnboundMethod(){};
    var self = $UnboundMethod = $klass($base, $super, 'UnboundMethod', $UnboundMethod);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UnboundMethod_initialize_10, TMP_UnboundMethod_arity_11, TMP_UnboundMethod_parameters_12, TMP_UnboundMethod_source_location_13, TMP_UnboundMethod_comments_14, TMP_UnboundMethod_bind_15, TMP_UnboundMethod_inspect_16;

    def.method = def.owner = def.name = def.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    Opal.defn(self, '$initialize', TMP_UnboundMethod_initialize_10 = function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, TMP_UnboundMethod_initialize_10.$$arity = 4);
    
    Opal.defn(self, '$arity', TMP_UnboundMethod_arity_11 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, TMP_UnboundMethod_arity_11.$$arity = 0);
    
    Opal.defn(self, '$parameters', TMP_UnboundMethod_parameters_12 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, TMP_UnboundMethod_parameters_12.$$arity = 0);
    
    Opal.defn(self, '$source_location', TMP_UnboundMethod_source_location_13 = function $$source_location() {
      var $a, self = this;

      return ($truthy($a = self.method.$$source_location) ? $a : ["(eval)", 0])
    }, TMP_UnboundMethod_source_location_13.$$arity = 0);
    
    Opal.defn(self, '$comments', TMP_UnboundMethod_comments_14 = function $$comments() {
      var $a, self = this;

      return ($truthy($a = self.method.$$comments) ? $a : [])
    }, TMP_UnboundMethod_comments_14.$$arity = 0);
    
    Opal.defn(self, '$bind', TMP_UnboundMethod_bind_15 = function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return Opal.const_get_relative($nesting, 'Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, TMP_UnboundMethod_bind_15.$$arity = 1);
    return (Opal.defn(self, '$inspect', TMP_UnboundMethod_inspect_16 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, TMP_UnboundMethod_inspect_16.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/variables"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new']);
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  Opal.const_set($nesting[0], 'ARGV', []);
  Opal.const_set($nesting[0], 'ARGF', Opal.const_get_relative($nesting, 'Object').$new());
  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

/* Generated by Opal 0.11.4 */
Opal.modules["opal/regexp_anchors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$==', '$new']);
  return (function($base, $parent_nesting) {
    var $Opal, self = $Opal = $module($base, 'Opal');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    
    Opal.const_set($nesting[0], 'REGEXP_START', (function() {if (Opal.const_get_relative($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "^"
      } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'REGEXP_END', (function() {if (Opal.const_get_relative($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "$"
      } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', Opal.const_get_relative($nesting, 'Regexp').$new("" + "[^" + (Opal.const_get_relative($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + (Opal.const_get_relative($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', Opal.const_get_relative($nesting, 'Regexp').$new("" + (Opal.const_get_relative($nesting, 'REGEXP_START')) + "(::)?[A-Z][^" + (Opal.const_get_relative($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + (Opal.const_get_relative($nesting, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["opal/mini"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("corelib/nil");
  self.$require("corelib/boolean");
  self.$require("corelib/string");
  self.$require("corelib/comparable");
  self.$require("corelib/enumerable");
  self.$require("corelib/enumerator");
  self.$require("corelib/array");
  self.$require("corelib/hash");
  self.$require("corelib/number");
  self.$require("corelib/range");
  self.$require("corelib/proc");
  self.$require("corelib/method");
  self.$require("corelib/regexp");
  self.$require("corelib/variables");
  return self.$require("opal/regexp_anchors");
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/string/inheritance"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$new', '$allocate', '$initialize', '$to_proc', '$__send__', '$class', '$clone', '$respond_to?', '$==', '$to_s', '$inspect', '$+', '$*', '$map', '$split', '$enum_for', '$each_line', '$to_a', '$%', '$-']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_inherited_1;

    return Opal.defs(self, '$inherited', TMP_String_inherited_1 = function $$inherited(klass) {
      var self = this, replace = nil;

      
      replace = Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'String'), 'Wrapper'));
      
      klass.$$proto         = replace.$$proto;
      klass.$$proto.$$class = klass;
      klass.$$alloc         = replace.$$alloc;
      klass.$$parent        = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'String'), 'Wrapper');

      klass.$allocate = replace.$allocate;
      klass.$new      = replace.$new;
    ;
    }, TMP_String_inherited_1.$$arity = 1)
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    function $Wrapper(){};
    var self = $Wrapper = $klass($base, $super, 'Wrapper', $Wrapper);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Wrapper_allocate_2, TMP_Wrapper_new_3, TMP_Wrapper_$$_4, TMP_Wrapper_initialize_5, TMP_Wrapper_method_missing_6, TMP_Wrapper_initialize_copy_7, TMP_Wrapper_respond_to$q_8, TMP_Wrapper_$eq$eq_9, TMP_Wrapper_to_s_10, TMP_Wrapper_inspect_11, TMP_Wrapper_$_12, TMP_Wrapper_$_13, TMP_Wrapper_split_15, TMP_Wrapper_replace_16, TMP_Wrapper_each_line_17, TMP_Wrapper_lines_19, TMP_Wrapper_$_20, TMP_Wrapper_instance_variables_21;

    def.literal = nil;
    
    def.$$is_string = true;
    Opal.defs(self, '$allocate', TMP_Wrapper_allocate_2 = function $$allocate(string) {
      var self = this, $iter = TMP_Wrapper_allocate_2.$$p, $yield = $iter || nil, obj = nil;

      if (string == null) {
        string = "";
      }
      if ($iter) TMP_Wrapper_allocate_2.$$p = null;
      
      obj = $send(self, Opal.find_super_dispatcher(self, 'allocate', TMP_Wrapper_allocate_2, false, $Wrapper), [], null);
      obj.literal = string;
      return obj;
    }, TMP_Wrapper_allocate_2.$$arity = -1);
    Opal.defs(self, '$new', TMP_Wrapper_new_3 = function($a_rest) {
      var self = this, args, $iter = TMP_Wrapper_new_3.$$p, block = $iter || nil, obj = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Wrapper_new_3.$$p = null;
      
      obj = self.$allocate();
      $send(obj, 'initialize', Opal.to_a(args), block.$to_proc());
      return obj;
    }, TMP_Wrapper_new_3.$$arity = -1);
    Opal.defs(self, '$[]', TMP_Wrapper_$$_4 = function($a_rest) {
      var self = this, objects;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      objects = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        objects[$arg_idx - 0] = arguments[$arg_idx];
      }
      return self.$allocate(objects)
    }, TMP_Wrapper_$$_4.$$arity = -1);
    
    Opal.defn(self, '$initialize', TMP_Wrapper_initialize_5 = function $$initialize(string) {
      var self = this;

      if (string == null) {
        string = "";
      }
      return (self.literal = string)
    }, TMP_Wrapper_initialize_5.$$arity = -1);
    
    Opal.defn(self, '$method_missing', TMP_Wrapper_method_missing_6 = function $$method_missing($a_rest) {
      var self = this, args, $iter = TMP_Wrapper_method_missing_6.$$p, block = $iter || nil, result = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Wrapper_method_missing_6.$$p = null;
      
      result = $send(self.literal, '__send__', Opal.to_a(args), block.$to_proc());
      if ($truthy(result.$$is_string != null)) {
        if ($truthy(result == self.literal)) {
          return self
          } else {
          return self.$class().$allocate(result)
        }
        } else {
        return result
      };
    }, TMP_Wrapper_method_missing_6.$$arity = -1);
    
    Opal.defn(self, '$initialize_copy', TMP_Wrapper_initialize_copy_7 = function $$initialize_copy(other) {
      var self = this;

      return (self.literal = (other.literal).$clone())
    }, TMP_Wrapper_initialize_copy_7.$$arity = 1);
    
    Opal.defn(self, '$respond_to?', TMP_Wrapper_respond_to$q_8 = function(name, $a_rest) {
      var $b, self = this, $iter = TMP_Wrapper_respond_to$q_8.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Wrapper_respond_to$q_8.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return ($truthy($b = $send(self, Opal.find_super_dispatcher(self, 'respond_to?', TMP_Wrapper_respond_to$q_8, false), $zuper, $iter)) ? $b : self.literal['$respond_to?'](name))
    }, TMP_Wrapper_respond_to$q_8.$$arity = -2);
    
    Opal.defn(self, '$==', TMP_Wrapper_$eq$eq_9 = function(other) {
      var self = this;

      return self.literal['$=='](other)
    }, TMP_Wrapper_$eq$eq_9.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    
    Opal.defn(self, '$to_s', TMP_Wrapper_to_s_10 = function $$to_s() {
      var self = this;

      return self.literal.$to_s()
    }, TMP_Wrapper_to_s_10.$$arity = 0);
    Opal.alias(self, "to_str", "to_s");
    
    Opal.defn(self, '$inspect', TMP_Wrapper_inspect_11 = function $$inspect() {
      var self = this;

      return self.literal.$inspect()
    }, TMP_Wrapper_inspect_11.$$arity = 0);
    
    Opal.defn(self, '$+', TMP_Wrapper_$_12 = function(other) {
      var self = this;

      return $rb_plus(self.literal, other)
    }, TMP_Wrapper_$_12.$$arity = 1);
    
    Opal.defn(self, '$*', TMP_Wrapper_$_13 = function(other) {
      var self = this;

      
      var result = $rb_times(self.literal, other);

      if (result.$$is_string) {
        return self.$class().$allocate(result)
      }
      else {
        return result;
      }
    
    }, TMP_Wrapper_$_13.$$arity = 1);
    
    Opal.defn(self, '$split', TMP_Wrapper_split_15 = function $$split(pattern, limit) {
      var TMP_14, self = this;

      return $send(self.literal.$split(pattern, limit), 'map', [], (TMP_14 = function(str){var self = TMP_14.$$s || this;
if (str == null) str = nil;
      return self.$class().$allocate(str)}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14))
    }, TMP_Wrapper_split_15.$$arity = -1);
    
    Opal.defn(self, '$replace', TMP_Wrapper_replace_16 = function $$replace(string) {
      var self = this;

      return (self.literal = string)
    }, TMP_Wrapper_replace_16.$$arity = 1);
    
    Opal.defn(self, '$each_line', TMP_Wrapper_each_line_17 = function $$each_line(separator) {
      var TMP_18, self = this, $iter = TMP_Wrapper_each_line_17.$$p, $yield = $iter || nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if (separator == null) {
        separator = $gvars["/"];
      }
      if ($iter) TMP_Wrapper_each_line_17.$$p = null;
      
      if (($yield !== nil)) {
        } else {
        return self.$enum_for("each_line", separator)
      };
      return $send(self.literal, 'each_line', [separator], (TMP_18 = function(str){var self = TMP_18.$$s || this;
if (str == null) str = nil;
      return Opal.yield1($yield, self.$class().$allocate(str));}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18));
    }, TMP_Wrapper_each_line_17.$$arity = -1);
    
    Opal.defn(self, '$lines', TMP_Wrapper_lines_19 = function $$lines(separator) {
      var self = this, $iter = TMP_Wrapper_lines_19.$$p, block = $iter || nil, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if (separator == null) {
        separator = $gvars["/"];
      }
      if ($iter) TMP_Wrapper_lines_19.$$p = null;
      
      e = $send(self, 'each_line', [separator], block.$to_proc());
      if ($truthy(block)) {
        return self
        } else {
        return e.$to_a()
      };
    }, TMP_Wrapper_lines_19.$$arity = -1);
    
    Opal.defn(self, '$%', TMP_Wrapper_$_20 = function(data) {
      var self = this;

      return self.literal['$%'](data)
    }, TMP_Wrapper_$_20.$$arity = 1);
    return (Opal.defn(self, '$instance_variables', TMP_Wrapper_instance_variables_21 = function $$instance_variables() {
      var self = this, $iter = TMP_Wrapper_instance_variables_21.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_Wrapper_instance_variables_21.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return $rb_minus($send(self, Opal.find_super_dispatcher(self, 'instance_variables', TMP_Wrapper_instance_variables_21, false), $zuper, $iter), ["@literal"])
    }, TMP_Wrapper_instance_variables_21.$$arity = 0), nil) && 'instance_variables';
  })(Opal.const_get_relative($nesting, 'String'), null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/string/encoding"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var TMP_12, TMP_15, TMP_18, TMP_21, TMP_24, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$+', '$[]', '$new', '$to_proc', '$each', '$const_set', '$sub', '$==', '$default_external', '$upcase', '$raise', '$attr_accessor', '$attr_reader', '$register', '$length', '$bytes', '$to_a', '$each_byte', '$bytesize', '$enum_for', '$force_encoding', '$dup', '$coerce_to!', '$find', '$getbyte']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    function $Encoding(){};
    var self = $Encoding = $klass($base, $super, 'Encoding', $Encoding);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Encoding_register_1, TMP_Encoding_find_3, TMP_Encoding_initialize_4, TMP_Encoding_ascii_compatible$q_5, TMP_Encoding_dummy$q_6, TMP_Encoding_to_s_7, TMP_Encoding_inspect_8, TMP_Encoding_each_byte_9, TMP_Encoding_getbyte_10, TMP_Encoding_bytesize_11;

    def.ascii = def.dummy = def.name = nil;
    
    self["$$register"] = {};
    Opal.defs(self, '$register', TMP_Encoding_register_1 = function $$register(name, options) {
      var $a, TMP_2, self = this, $iter = TMP_Encoding_register_1.$$p, block = $iter || nil, names = nil, encoding = nil, register = nil;

      if (options == null) {
        options = $hash2([], {});
      }
      if ($iter) TMP_Encoding_register_1.$$p = null;
      
      names = $rb_plus([name], ($truthy($a = options['$[]']("aliases")) ? $a : []));
      encoding = $send(Opal.const_get_relative($nesting, 'Class'), 'new', [self], block.$to_proc()).$new(name, names, ($truthy($a = options['$[]']("ascii")) ? $a : false), ($truthy($a = options['$[]']("dummy")) ? $a : false));
      register = self["$$register"];
      return $send(names, 'each', [], (TMP_2 = function(name){var self = TMP_2.$$s || this;
if (name == null) name = nil;
      
        self.$const_set(name.$sub("-", "_"), encoding);
        return register["" + "$$" + (name)] = encoding;}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));
    }, TMP_Encoding_register_1.$$arity = -2);
    Opal.defs(self, '$find', TMP_Encoding_find_3 = function $$find(name) {
      var $a, self = this, register = nil, encoding = nil;

      
      if (name['$==']("default_external")) {
        return self.$default_external()};
      register = self["$$register"];
      encoding = ($truthy($a = register["" + "$$" + (name)]) ? $a : register["" + "$$" + (name.$upcase())]);
      if ($truthy(encoding)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "unknown encoding name - " + (name))
      };
      return encoding;
    }, TMP_Encoding_find_3.$$arity = 1);
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("default_external")
    })(Opal.get_singleton_class(self), $nesting);
    self.$attr_reader("name", "names");
    
    Opal.defn(self, '$initialize', TMP_Encoding_initialize_4 = function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, TMP_Encoding_initialize_4.$$arity = 4);
    
    Opal.defn(self, '$ascii_compatible?', TMP_Encoding_ascii_compatible$q_5 = function() {
      var self = this;

      return self.ascii
    }, TMP_Encoding_ascii_compatible$q_5.$$arity = 0);
    
    Opal.defn(self, '$dummy?', TMP_Encoding_dummy$q_6 = function() {
      var self = this;

      return self.dummy
    }, TMP_Encoding_dummy$q_6.$$arity = 0);
    
    Opal.defn(self, '$to_s', TMP_Encoding_to_s_7 = function $$to_s() {
      var self = this;

      return self.name
    }, TMP_Encoding_to_s_7.$$arity = 0);
    
    Opal.defn(self, '$inspect', TMP_Encoding_inspect_8 = function $$inspect() {
      var self = this;

      return "" + "#<Encoding:" + (self.name) + ((function() {if ($truthy(self.dummy)) {
        return " (dummy)"
        } else {
        return nil
      }; return nil; })()) + ">"
    }, TMP_Encoding_inspect_8.$$arity = 0);
    
    Opal.defn(self, '$each_byte', TMP_Encoding_each_byte_9 = function $$each_byte($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))
    }, TMP_Encoding_each_byte_9.$$arity = -1);
    
    Opal.defn(self, '$getbyte', TMP_Encoding_getbyte_10 = function $$getbyte($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))
    }, TMP_Encoding_getbyte_10.$$arity = -1);
    
    Opal.defn(self, '$bytesize', TMP_Encoding_bytesize_11 = function $$bytesize($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))
    }, TMP_Encoding_bytesize_11.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      function $EncodingError(){};
      var self = $EncodingError = $klass($base, $super, 'EncodingError', $EncodingError);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
    return (function($base, $super, $parent_nesting) {
      function $CompatibilityError(){};
      var self = $CompatibilityError = $klass($base, $super, 'CompatibilityError', $CompatibilityError);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], Opal.const_get_relative($nesting, 'EncodingError'), $nesting);
  })($nesting[0], null, $nesting);
  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], (TMP_12 = function(){var self = TMP_12.$$s || this, TMP_each_byte_13, TMP_bytesize_14;

  
    
    Opal.def(self, '$each_byte', TMP_each_byte_13 = function $$each_byte(string) {
      var self = this, $iter = TMP_each_byte_13.$$p, block = $iter || nil;

      if ($iter) TMP_each_byte_13.$$p = null;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        if (code <= 0x7f) {
          Opal.yield1(block, code);
        }
        else {
          var encoded = encodeURIComponent(string.charAt(i)).substr(1).split('%');

          for (var j = 0, encoded_length = encoded.length; j < encoded_length; j++) {
            Opal.yield1(block, parseInt(encoded[j], 16));
          }
        }
      }
    
    }, TMP_each_byte_13.$$arity = 1);
    return (Opal.def(self, '$bytesize', TMP_bytesize_14 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, TMP_bytesize_14.$$arity = 1), nil) && 'bytesize';}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12));
  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', ["UTF-16LE"], (TMP_15 = function(){var self = TMP_15.$$s || this, TMP_each_byte_16, TMP_bytesize_17;

  
    
    Opal.def(self, '$each_byte', TMP_each_byte_16 = function $$each_byte(string) {
      var self = this, $iter = TMP_each_byte_16.$$p, block = $iter || nil;

      if ($iter) TMP_each_byte_16.$$p = null;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    
    }, TMP_each_byte_16.$$arity = 1);
    return (Opal.def(self, '$bytesize', TMP_bytesize_17 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, TMP_bytesize_17.$$arity = 1), nil) && 'bytesize';}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15));
  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', ["UTF-16BE"], (TMP_18 = function(){var self = TMP_18.$$s || this, TMP_each_byte_19, TMP_bytesize_20;

  
    
    Opal.def(self, '$each_byte', TMP_each_byte_19 = function $$each_byte(string) {
      var self = this, $iter = TMP_each_byte_19.$$p, block = $iter || nil;

      if ($iter) TMP_each_byte_19.$$p = null;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    
    }, TMP_each_byte_19.$$arity = 1);
    return (Opal.def(self, '$bytesize', TMP_bytesize_20 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, TMP_bytesize_20.$$arity = 1), nil) && 'bytesize';}, TMP_18.$$s = self, TMP_18.$$arity = 0, TMP_18));
  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', ["UTF-32LE"], (TMP_21 = function(){var self = TMP_21.$$s || this, TMP_each_byte_22, TMP_bytesize_23;

  
    
    Opal.def(self, '$each_byte', TMP_each_byte_22 = function $$each_byte(string) {
      var self = this, $iter = TMP_each_byte_22.$$p, block = $iter || nil;

      if ($iter) TMP_each_byte_22.$$p = null;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    
    }, TMP_each_byte_22.$$arity = 1);
    return (Opal.def(self, '$bytesize', TMP_bytesize_23 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, TMP_bytesize_23.$$arity = 1), nil) && 'bytesize';}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21));
  $send(Opal.const_get_relative($nesting, 'Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii", "dummy"], {"aliases": ["BINARY", "US-ASCII", "ASCII"], "ascii": true, "dummy": true})], (TMP_24 = function(){var self = TMP_24.$$s || this, TMP_each_byte_25, TMP_bytesize_26;

  
    
    Opal.def(self, '$each_byte', TMP_each_byte_25 = function $$each_byte(string) {
      var self = this, $iter = TMP_each_byte_25.$$p, block = $iter || nil;

      if ($iter) TMP_each_byte_25.$$p = null;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    
    }, TMP_each_byte_25.$$arity = 1);
    return (Opal.def(self, '$bytesize', TMP_bytesize_26 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, TMP_bytesize_26.$$arity = 1), nil) && 'bytesize';}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24));
  return (function($base, $super, $parent_nesting) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_bytes_27, TMP_String_bytesize_28, TMP_String_each_byte_29, TMP_String_encode_30, TMP_String_encoding_31, TMP_String_force_encoding_32, TMP_String_getbyte_33, TMP_String_valid_encoding$q_34;

    def.encoding = nil;
    
    String.prototype.encoding = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'UTF_16LE');
    
    Opal.defn(self, '$bytes', TMP_String_bytes_27 = function $$bytes() {
      var self = this;

      return self.$each_byte().$to_a()
    }, TMP_String_bytes_27.$$arity = 0);
    
    Opal.defn(self, '$bytesize', TMP_String_bytesize_28 = function $$bytesize() {
      var self = this;

      return self.encoding.$bytesize(self)
    }, TMP_String_bytesize_28.$$arity = 0);
    
    Opal.defn(self, '$each_byte', TMP_String_each_byte_29 = function $$each_byte() {
      var self = this, $iter = TMP_String_each_byte_29.$$p, block = $iter || nil;

      if ($iter) TMP_String_each_byte_29.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("each_byte")
      };
      $send(self.encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, TMP_String_each_byte_29.$$arity = 0);
    
    Opal.defn(self, '$encode', TMP_String_encode_30 = function $$encode(encoding) {
      var self = this;

      return self.$dup().$force_encoding(encoding)
    }, TMP_String_encode_30.$$arity = 1);
    
    Opal.defn(self, '$encoding', TMP_String_encoding_31 = function $$encoding() {
      var self = this;

      return self.encoding
    }, TMP_String_encoding_31.$$arity = 0);
    
    Opal.defn(self, '$force_encoding', TMP_String_force_encoding_32 = function $$force_encoding(encoding) {
      var self = this;

      
      if (encoding === self.encoding) { return self; }

      encoding = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](encoding, Opal.const_get_relative($nesting, 'String'), "to_s");
      encoding = Opal.const_get_relative($nesting, 'Encoding').$find(encoding);

      if (encoding === self.encoding) { return self; }

      self.encoding = encoding;
      return self;
    
    }, TMP_String_force_encoding_32.$$arity = 1);
    
    Opal.defn(self, '$getbyte', TMP_String_getbyte_33 = function $$getbyte(idx) {
      var self = this;

      return self.encoding.$getbyte(self, idx)
    }, TMP_String_getbyte_33.$$arity = 1);
    return (Opal.defn(self, '$valid_encoding?', TMP_String_valid_encoding$q_34 = function() {
      var self = this;

      return true
    }, TMP_String_valid_encoding$q_34.$$arity = 0), nil) && 'valid_encoding?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/math"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$raise', '$Float', '$type_error', '$Integer', '$module_function', '$checked', '$float!', '$===', '$gamma', '$-', '$integer!', '$/', '$infinite?']);
  return (function($base, $parent_nesting) {
    var $Math, self = $Math = $module($base, 'Math');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Math_checked_1, TMP_Math_float$B_2, TMP_Math_integer$B_3, TMP_Math_acos_4, TMP_Math_acosh_5, TMP_Math_asin_6, TMP_Math_asinh_7, TMP_Math_atan_8, TMP_Math_atan2_9, TMP_Math_atanh_10, TMP_Math_cbrt_11, TMP_Math_cos_12, TMP_Math_cosh_13, TMP_Math_erf_14, TMP_Math_erfc_15, TMP_Math_exp_16, TMP_Math_frexp_17, TMP_Math_gamma_18, TMP_Math_hypot_19, TMP_Math_ldexp_20, TMP_Math_lgamma_21, TMP_Math_log_22, TMP_Math_log10_23, TMP_Math_log2_24, TMP_Math_sin_25, TMP_Math_sinh_26, TMP_Math_sqrt_27, TMP_Math_tan_28, TMP_Math_tanh_29;

    
    Opal.const_set($nesting[0], 'E', Math.E);
    Opal.const_set($nesting[0], 'PI', Math.PI);
    Opal.const_set($nesting[0], 'DomainError', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
    Opal.defs(self, '$checked', TMP_Math_checked_1 = function $$checked(method, $a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        self.$raise(Opal.const_get_relative($nesting, 'DomainError'), "" + "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    
    }, TMP_Math_checked_1.$$arity = -2);
    Opal.defs(self, '$float!', TMP_Math_float$B_2 = function(value) {
      var self = this;

      
      try {
        return self.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'ArgumentError')])) {
          try {
            return self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(value, Opal.const_get_relative($nesting, 'Float')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };
    }, TMP_Math_float$B_2.$$arity = 1);
    Opal.defs(self, '$integer!', TMP_Math_integer$B_3 = function(value) {
      var self = this;

      
      try {
        return self.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'ArgumentError')])) {
          try {
            return self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(value, Opal.const_get_relative($nesting, 'Integer')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };
    }, TMP_Math_integer$B_3.$$arity = 1);
    self.$module_function();
    
    Opal.defn(self, '$acos', TMP_Math_acos_4 = function $$acos(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("acos", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_acos_4.$$arity = 1);
    if ($truthy((typeof(Math.acosh) !== "undefined"))) {
      } else {
      
      Math.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      }
    
    };
    
    Opal.defn(self, '$acosh', TMP_Math_acosh_5 = function $$acosh(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("acosh", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_acosh_5.$$arity = 1);
    
    Opal.defn(self, '$asin', TMP_Math_asin_6 = function $$asin(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("asin", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_asin_6.$$arity = 1);
    if ($truthy((typeof(Math.asinh) !== "undefined"))) {
      } else {
      
      Math.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
      }
    
    };
    
    Opal.defn(self, '$asinh', TMP_Math_asinh_7 = function $$asinh(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("asinh", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_asinh_7.$$arity = 1);
    
    Opal.defn(self, '$atan', TMP_Math_atan_8 = function $$atan(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("atan", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_atan_8.$$arity = 1);
    
    Opal.defn(self, '$atan2', TMP_Math_atan2_9 = function $$atan2(y, x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("atan2", Opal.const_get_relative($nesting, 'Math')['$float!'](y), Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_atan2_9.$$arity = 2);
    if ($truthy((typeof(Math.atanh) !== "undefined"))) {
      } else {
      
      Math.atanh = function(x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      }
    
    };
    
    Opal.defn(self, '$atanh', TMP_Math_atanh_10 = function $$atanh(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("atanh", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_atanh_10.$$arity = 1);
    if ($truthy((typeof(Math.cbrt) !== "undefined"))) {
      } else {
      
      Math.cbrt = function(x) {
        if (x == 0) {
          return 0;
        }

        if (x < 0) {
          return -Math.cbrt(-x);
        }

        var r  = x,
            ex = 0;

        while (r < 0.125) {
          r *= 8;
          ex--;
        }

        while (r > 1.0) {
          r *= 0.125;
          ex++;
        }

        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;

        while (ex < 0) {
          r *= 0.5;
          ex++;
        }

        while (ex > 0) {
          r *= 2;
          ex--;
        }

        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);

        return r;
      }
    
    };
    
    Opal.defn(self, '$cbrt', TMP_Math_cbrt_11 = function $$cbrt(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("cbrt", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_cbrt_11.$$arity = 1);
    
    Opal.defn(self, '$cos', TMP_Math_cos_12 = function $$cos(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("cos", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_cos_12.$$arity = 1);
    if ($truthy((typeof(Math.cosh) !== "undefined"))) {
      } else {
      
      Math.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.defn(self, '$cosh', TMP_Math_cosh_13 = function $$cosh(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("cosh", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_cosh_13.$$arity = 1);
    if ($truthy((typeof(Math.erf) !== "undefined"))) {
      } else {
      
      Math.erf = function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      }
    
    };
    
    Opal.defn(self, '$erf', TMP_Math_erf_14 = function $$erf(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("erf", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_erf_14.$$arity = 1);
    if ($truthy((typeof(Math.erfc) !== "undefined"))) {
      } else {
      
      Math.erfc = function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      }
    
    };
    
    Opal.defn(self, '$erfc', TMP_Math_erfc_15 = function $$erfc(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("erfc", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_erfc_15.$$arity = 1);
    
    Opal.defn(self, '$exp', TMP_Math_exp_16 = function $$exp(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("exp", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_exp_16.$$arity = 1);
    
    Opal.defn(self, '$frexp', TMP_Math_frexp_17 = function $$frexp(x) {
      var self = this;

      
      x = Opal.const_get_relative($nesting, 'Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, TMP_Math_frexp_17.$$arity = 1);
    
    Opal.defn(self, '$gamma', TMP_Math_gamma_18 = function $$gamma(n) {
      var self = this;

      
      n = Opal.const_get_relative($nesting, 'Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        self.$raise(Opal.const_get_relative($nesting, 'DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if (Opal.const_get_relative($nesting, 'Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * Opal.const_get_relative($nesting, 'Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, TMP_Math_gamma_18.$$arity = 1);
    if ($truthy((typeof(Math.hypot) !== "undefined"))) {
      } else {
      
      Math.hypot = function(x, y) {
        return Math.sqrt(x * x + y * y)
      }
    
    };
    
    Opal.defn(self, '$hypot', TMP_Math_hypot_19 = function $$hypot(x, y) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("hypot", Opal.const_get_relative($nesting, 'Math')['$float!'](x), Opal.const_get_relative($nesting, 'Math')['$float!'](y))
    }, TMP_Math_hypot_19.$$arity = 2);
    
    Opal.defn(self, '$ldexp', TMP_Math_ldexp_20 = function $$ldexp(mantissa, exponent) {
      var self = this;

      
      mantissa = Opal.const_get_relative($nesting, 'Math')['$float!'](mantissa);
      exponent = Opal.const_get_relative($nesting, 'Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, TMP_Math_ldexp_20.$$arity = 2);
    
    Opal.defn(self, '$lgamma', TMP_Math_lgamma_21 = function $$lgamma(n) {
      var self = this;

      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs(Opal.const_get_relative($nesting, 'Math').$gamma(n))), Opal.const_get_relative($nesting, 'Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, TMP_Math_lgamma_21.$$arity = 1);
    
    Opal.defn(self, '$log', TMP_Math_log_22 = function $$log(x, base) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](x))) {
        self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(x, Opal.const_get_relative($nesting, 'Float')))};
      if ($truthy(base == null)) {
        return Opal.const_get_relative($nesting, 'Math').$checked("log", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
        } else {
        
        if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](base))) {
          self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(base, Opal.const_get_relative($nesting, 'Float')))};
        return $rb_divide(Opal.const_get_relative($nesting, 'Math').$checked("log", Opal.const_get_relative($nesting, 'Math')['$float!'](x)), Opal.const_get_relative($nesting, 'Math').$checked("log", Opal.const_get_relative($nesting, 'Math')['$float!'](base)));
      };
    }, TMP_Math_log_22.$$arity = -2);
    if ($truthy((typeof(Math.log10) !== "undefined"))) {
      } else {
      
      Math.log10 = function(x) {
        return Math.log(x) / Math.LN10;
      }
    
    };
    
    Opal.defn(self, '$log10', TMP_Math_log10_23 = function $$log10(x) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](x))) {
        self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(x, Opal.const_get_relative($nesting, 'Float')))};
      return Opal.const_get_relative($nesting, 'Math').$checked("log10", Opal.const_get_relative($nesting, 'Math')['$float!'](x));
    }, TMP_Math_log10_23.$$arity = 1);
    if ($truthy((typeof(Math.log2) !== "undefined"))) {
      } else {
      
      Math.log2 = function(x) {
        return Math.log(x) / Math.LN2;
      }
    
    };
    
    Opal.defn(self, '$log2', TMP_Math_log2_24 = function $$log2(x) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](x))) {
        self.$raise(Opal.const_get_relative($nesting, 'Opal').$type_error(x, Opal.const_get_relative($nesting, 'Float')))};
      return Opal.const_get_relative($nesting, 'Math').$checked("log2", Opal.const_get_relative($nesting, 'Math')['$float!'](x));
    }, TMP_Math_log2_24.$$arity = 1);
    
    Opal.defn(self, '$sin', TMP_Math_sin_25 = function $$sin(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("sin", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_sin_25.$$arity = 1);
    if ($truthy((typeof(Math.sinh) !== "undefined"))) {
      } else {
      
      Math.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.defn(self, '$sinh', TMP_Math_sinh_26 = function $$sinh(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("sinh", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_sinh_26.$$arity = 1);
    
    Opal.defn(self, '$sqrt', TMP_Math_sqrt_27 = function $$sqrt(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("sqrt", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_sqrt_27.$$arity = 1);
    
    Opal.defn(self, '$tan', TMP_Math_tan_28 = function $$tan(x) {
      var self = this;

      
      x = Opal.const_get_relative($nesting, 'Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'NAN')};
      return Opal.const_get_relative($nesting, 'Math').$checked("tan", Opal.const_get_relative($nesting, 'Math')['$float!'](x));
    }, TMP_Math_tan_28.$$arity = 1);
    if ($truthy((typeof(Math.tanh) !== "undefined"))) {
      } else {
      
      Math.tanh = function(x) {
        if (x == Infinity) {
          return 1;
        }
        else if (x == -Infinity) {
          return -1;
        }
        else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      }
    
    };
    
    Opal.defn(self, '$tanh', TMP_Math_tanh_29 = function $$tanh(x) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$checked("tanh", Opal.const_get_relative($nesting, 'Math')['$float!'](x))
    }, TMP_Math_tanh_29.$$arity = 1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/complex"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$===', '$real?', '$raise', '$new', '$*', '$cos', '$sin', '$attr_reader', '$class', '$==', '$real', '$imag', '$Complex', '$-@', '$+', '$__coerced__', '$-', '$nan?', '$/', '$conj', '$abs2', '$quo', '$polar', '$exp', '$log', '$>', '$!=', '$divmod', '$**', '$hypot', '$atan2', '$lcm', '$denominator', '$to_s', '$numerator', '$abs', '$arg', '$rationalize', '$to_f', '$to_i', '$to_r', '$inspect', '$positive?', '$zero?', '$infinite?']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    function $Complex(){};
    var self = $Complex = $klass($base, $super, 'Complex', $Complex);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Complex_rect_1, TMP_Complex_polar_2, TMP_Complex_initialize_3, TMP_Complex_coerce_4, TMP_Complex_$eq$eq_5, TMP_Complex_$$_6, TMP_Complex_$_7, TMP_Complex_$_8, TMP_Complex_$_9, TMP_Complex_$_10, TMP_Complex_$$_11, TMP_Complex_abs_12, TMP_Complex_abs2_13, TMP_Complex_angle_14, TMP_Complex_conj_15, TMP_Complex_denominator_16, TMP_Complex_eql$q_17, TMP_Complex_fdiv_18, TMP_Complex_hash_19, TMP_Complex_inspect_20, TMP_Complex_numerator_21, TMP_Complex_polar_22, TMP_Complex_rationalize_23, TMP_Complex_real$q_24, TMP_Complex_rect_25, TMP_Complex_to_f_26, TMP_Complex_to_i_27, TMP_Complex_to_r_28, TMP_Complex_to_s_29;

    def.real = def.imag = nil;
    
    Opal.defs(self, '$rect', TMP_Complex_rect_1 = function $$rect(real, imag) {
      var $a, $b, $c, self = this;

      if (imag == null) {
        imag = 0;
      }
      
      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = Opal.const_get_relative($nesting, 'Numeric')['$==='](real)) ? real['$real?']() : $c)) ? Opal.const_get_relative($nesting, 'Numeric')['$==='](imag) : $b)) ? imag['$real?']() : $a))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, TMP_Complex_rect_1.$$arity = -2);
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return Opal.alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$polar', TMP_Complex_polar_2 = function $$polar(r, theta) {
      var $a, $b, $c, self = this;

      if (theta == null) {
        theta = 0;
      }
      
      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = Opal.const_get_relative($nesting, 'Numeric')['$==='](r)) ? r['$real?']() : $c)) ? Opal.const_get_relative($nesting, 'Numeric')['$==='](theta) : $b)) ? theta['$real?']() : $a))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "not a real")
      };
      return self.$new($rb_times(r, Opal.const_get_relative($nesting, 'Math').$cos(theta)), $rb_times(r, Opal.const_get_relative($nesting, 'Math').$sin(theta)));
    }, TMP_Complex_polar_2.$$arity = -2);
    self.$attr_reader("real", "imag");
    
    Opal.defn(self, '$initialize', TMP_Complex_initialize_3 = function $$initialize(real, imag) {
      var self = this;

      if (imag == null) {
        imag = 0;
      }
      
      self.real = real;
      return (self.imag = imag);
    }, TMP_Complex_initialize_3.$$arity = -2);
    
    Opal.defn(self, '$coerce', TMP_Complex_coerce_4 = function $$coerce(other) {
      var $a, self = this;

      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {
        return [other, self]
      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return [Opal.const_get_relative($nesting, 'Complex').$new(other, 0), self]
        } else {
        return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, TMP_Complex_coerce_4.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_Complex_$eq$eq_5 = function(other) {
      var $a, self = this;

      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {
        return (($a = self.real['$=='](other.$real())) ? self.imag['$=='](other.$imag()) : self.real['$=='](other.$real()))
      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return (($a = self.real['$=='](other)) ? self.imag['$=='](0) : self.real['$=='](other))
        } else {
        return other['$=='](self)
      }
    }, TMP_Complex_$eq$eq_5.$$arity = 1);
    
    Opal.defn(self, '$-@', TMP_Complex_$$_6 = function() {
      var self = this;

      return self.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, TMP_Complex_$$_6.$$arity = 0);
    
    Opal.defn(self, '$+', TMP_Complex_$_7 = function(other) {
      var $a, self = this;

      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex($rb_plus(self.real, other), self.imag)
        } else {
        return self.$__coerced__("+", other)
      }
    }, TMP_Complex_$_7.$$arity = 1);
    
    Opal.defn(self, '$-', TMP_Complex_$_8 = function(other) {
      var $a, self = this;

      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex($rb_minus(self.real, other), self.imag)
        } else {
        return self.$__coerced__("-", other)
      }
    }, TMP_Complex_$_8.$$arity = 1);
    
    Opal.defn(self, '$*', TMP_Complex_$_9 = function(other) {
      var $a, self = this;

      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
        } else {
        return self.$__coerced__("*", other)
      }
    }, TMP_Complex_$_9.$$arity = 1);
    
    Opal.defn(self, '$/', TMP_Complex_$_10 = function(other) {
      var $a, $b, $c, $d, self = this;

      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {
        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = Opal.const_get_relative($nesting, 'Number')['$==='](self.real)) ? self.real['$nan?']() : $d)) ? $c : ($truthy($d = Opal.const_get_relative($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $d))) ? $b : ($truthy($c = Opal.const_get_relative($nesting, 'Number')['$==='](other.$real())) ? other.$real()['$nan?']() : $c))) ? $a : ($truthy($b = Opal.const_get_relative($nesting, 'Number')['$==='](other.$imag())) ? other.$imag()['$nan?']() : $b)))) {
          return Opal.const_get_relative($nesting, 'Complex').$new(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'NAN'), Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'NAN'))
          } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex(self.real.$quo(other), self.imag.$quo(other))
        } else {
        return self.$__coerced__("/", other)
      }
    }, TMP_Complex_$_10.$$arity = 1);
    
    Opal.defn(self, '$**', TMP_Complex_$$_11 = function(other) {
      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if (other['$=='](0)) {
        return Opal.const_get_relative($nesting, 'Complex').$new(1, 0)};
      if ($truthy(Opal.const_get_relative($nesting, 'Complex')['$==='](other))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = Opal.const_get_relative($nesting, 'Math').$exp($rb_minus($rb_times(ore, Opal.const_get_relative($nesting, 'Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, Opal.const_get_relative($nesting, 'Math').$log(r)));
        return Opal.const_get_relative($nesting, 'Complex').$polar(nr, ntheta);
      } else if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](other))) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($truthy(n['$!='](0))) {
            
            while ($truthy(($d = n.$divmod(2), $c = Opal.to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d, mod['$=='](0)))) {
              
              x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
          } else {
          return $rb_divide(Opal.const_get_relative($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Float')['$==='](other)) ? $a : Opal.const_get_relative($nesting, 'Rational')['$==='](other)))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return Opal.const_get_relative($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));
        } else {
        return self.$__coerced__("**", other)
      };
    }, TMP_Complex_$$_11.$$arity = 1);
    
    Opal.defn(self, '$abs', TMP_Complex_abs_12 = function $$abs() {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$hypot(self.real, self.imag)
    }, TMP_Complex_abs_12.$$arity = 0);
    
    Opal.defn(self, '$abs2', TMP_Complex_abs2_13 = function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, TMP_Complex_abs2_13.$$arity = 0);
    
    Opal.defn(self, '$angle', TMP_Complex_angle_14 = function $$angle() {
      var self = this;

      return Opal.const_get_relative($nesting, 'Math').$atan2(self.imag, self.real)
    }, TMP_Complex_angle_14.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.defn(self, '$conj', TMP_Complex_conj_15 = function $$conj() {
      var self = this;

      return self.$Complex(self.real, self.imag['$-@']())
    }, TMP_Complex_conj_15.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.defn(self, '$denominator', TMP_Complex_denominator_16 = function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, TMP_Complex_denominator_16.$$arity = 0);
    Opal.alias(self, "divide", "/");
    
    Opal.defn(self, '$eql?', TMP_Complex_eql$q_17 = function(other) {
      var $a, $b, self = this;

      return ($truthy($a = ($truthy($b = Opal.const_get_relative($nesting, 'Complex')['$==='](other)) ? self.real.$class()['$=='](self.imag.$class()) : $b)) ? self['$=='](other) : $a)
    }, TMP_Complex_eql$q_17.$$arity = 1);
    
    Opal.defn(self, '$fdiv', TMP_Complex_fdiv_18 = function $$fdiv(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Numeric')['$==='](other))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, TMP_Complex_fdiv_18.$$arity = 1);
    
    Opal.defn(self, '$hash', TMP_Complex_hash_19 = function $$hash() {
      var self = this;

      return "" + "Complex:" + (self.real) + ":" + (self.imag)
    }, TMP_Complex_hash_19.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.defn(self, '$inspect', TMP_Complex_inspect_20 = function $$inspect() {
      var self = this;

      return "" + "(" + (self.$to_s()) + ")"
    }, TMP_Complex_inspect_20.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.defn(self, '$numerator', TMP_Complex_numerator_21 = function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, TMP_Complex_numerator_21.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.defn(self, '$polar', TMP_Complex_polar_22 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, TMP_Complex_polar_22.$$arity = 0);
    
    Opal.udef(self, '$' + "positive?");;
    Opal.alias(self, "quo", "/");
    
    Opal.defn(self, '$rationalize', TMP_Complex_rationalize_23 = function $$rationalize(eps) {
      var self = this;

      
      
      if (arguments.length > 1) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy(self.imag['$!='](0))) {
        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "" + "can't' convert " + (self) + " into Rational")};
      return self.$real().$rationalize(eps);
    }, TMP_Complex_rationalize_23.$$arity = -1);
    
    Opal.defn(self, '$real?', TMP_Complex_real$q_24 = function() {
      var self = this;

      return false
    }, TMP_Complex_real$q_24.$$arity = 0);
    
    Opal.defn(self, '$rect', TMP_Complex_rect_25 = function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, TMP_Complex_rect_25.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.defn(self, '$to_f', TMP_Complex_to_f_26 = function $$to_f() {
      var self = this;

      
      if (self.imag['$=='](0)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, TMP_Complex_to_f_26.$$arity = 0);
    
    Opal.defn(self, '$to_i', TMP_Complex_to_i_27 = function $$to_i() {
      var self = this;

      
      if (self.imag['$=='](0)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, TMP_Complex_to_i_27.$$arity = 0);
    
    Opal.defn(self, '$to_r', TMP_Complex_to_r_28 = function $$to_r() {
      var self = this;

      
      if (self.imag['$=='](0)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, TMP_Complex_to_r_28.$$arity = 0);
    
    Opal.defn(self, '$to_s', TMP_Complex_to_s_29 = function $$to_s() {
      var $a, $b, $c, self = this, result = nil;

      
      result = self.real.$inspect();
      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = Opal.const_get_relative($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $c)) ? $b : self.imag['$positive?']())) ? $a : self.imag['$zero?']()))) {
        result = $rb_plus(result, "+")
        } else {
        result = $rb_plus(result, "-")
      };
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Number')['$==='](self.imag)) ? ($truthy($b = self.imag['$nan?']()) ? $b : self.imag['$infinite?']()) : $a))) {
        result = $rb_plus(result, "*")};
      return $rb_plus(result, "i");
    }, TMP_Complex_to_s_29.$$arity = 0);
    return Opal.const_set($nesting[0], 'I', self.$new(0, 1));
  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);
  return (function($base, $parent_nesting) {
    var $Kernel, self = $Kernel = $module($base, 'Kernel');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_Complex_30;

    
    Opal.defn(self, '$Complex', TMP_Kernel_Complex_30 = function $$Complex(real, imag) {
      var self = this;

      if (imag == null) {
        imag = nil;
      }
      if ($truthy(imag)) {
        return Opal.const_get_relative($nesting, 'Complex').$new(real, imag)
        } else {
        return Opal.const_get_relative($nesting, 'Complex').$new(real, 0)
      }
    }, TMP_Kernel_Complex_30.$$arity = -2)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/rational"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$to_i', '$==', '$raise', '$<', '$-@', '$new', '$gcd', '$/', '$nil?', '$===', '$reduce', '$to_r', '$equal?', '$!', '$coerce_to!', '$attr_reader', '$to_f', '$numerator', '$denominator', '$<=>', '$-', '$*', '$__coerced__', '$+', '$Rational', '$>', '$**', '$abs', '$ceil', '$with_precision', '$floor', '$to_s', '$<=', '$truncate', '$send', '$convert']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    function $Rational(){};
    var self = $Rational = $klass($base, $super, 'Rational', $Rational);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Rational_reduce_1, TMP_Rational_convert_2, TMP_Rational_initialize_3, TMP_Rational_numerator_4, TMP_Rational_denominator_5, TMP_Rational_coerce_6, TMP_Rational_$eq$eq_7, TMP_Rational_$lt$eq$gt_8, TMP_Rational_$_9, TMP_Rational_$_10, TMP_Rational_$_11, TMP_Rational_$_12, TMP_Rational_$$_13, TMP_Rational_abs_14, TMP_Rational_ceil_15, TMP_Rational_floor_16, TMP_Rational_hash_17, TMP_Rational_inspect_18, TMP_Rational_rationalize_19, TMP_Rational_round_20, TMP_Rational_to_f_21, TMP_Rational_to_i_22, TMP_Rational_to_r_23, TMP_Rational_to_s_24, TMP_Rational_truncate_25, TMP_Rational_with_precision_26;

    def.num = def.den = nil;
    
    Opal.defs(self, '$reduce', TMP_Rational_reduce_1 = function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if (den['$=='](0)) {
        self.$raise(Opal.const_get_relative($nesting, 'ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if (den['$=='](1)) {
        return self.$new(num, den)};
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, TMP_Rational_reduce_1.$$arity = 2);
    Opal.defs(self, '$convert', TMP_Rational_convert_2 = function $$convert(num, den) {
      var $a, $b, self = this;

      
      if ($truthy(($truthy($a = num['$nil?']()) ? $a : den['$nil?']()))) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "cannot convert nil into Rational")};
      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Integer')['$==='](num)) ? Opal.const_get_relative($nesting, 'Integer')['$==='](den) : $a))) {
        return self.$reduce(num, den)};
      if ($truthy(($truthy($a = ($truthy($b = Opal.const_get_relative($nesting, 'Float')['$==='](num)) ? $b : Opal.const_get_relative($nesting, 'String')['$==='](num))) ? $a : Opal.const_get_relative($nesting, 'Complex')['$==='](num)))) {
        num = num.$to_r()};
      if ($truthy(($truthy($a = ($truthy($b = Opal.const_get_relative($nesting, 'Float')['$==='](den)) ? $b : Opal.const_get_relative($nesting, 'String')['$==='](den))) ? $a : Opal.const_get_relative($nesting, 'Complex')['$==='](den)))) {
        den = den.$to_r()};
      if ($truthy(($truthy($a = den['$equal?'](1)) ? Opal.const_get_relative($nesting, 'Integer')['$==='](num)['$!']() : $a))) {
        return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](num, Opal.const_get_relative($nesting, 'Rational'), "to_r")
      } else if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Numeric')['$==='](num)) ? Opal.const_get_relative($nesting, 'Numeric')['$==='](den) : $a))) {
        return $rb_divide(num, den)
        } else {
        return self.$reduce(num, den)
      };
    }, TMP_Rational_convert_2.$$arity = 2);
    self.$attr_reader("numerator", "denominator");
    
    Opal.defn(self, '$initialize', TMP_Rational_initialize_3 = function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      return (self.den = den);
    }, TMP_Rational_initialize_3.$$arity = 2);
    
    Opal.defn(self, '$numerator', TMP_Rational_numerator_4 = function $$numerator() {
      var self = this;

      return self.num
    }, TMP_Rational_numerator_4.$$arity = 0);
    
    Opal.defn(self, '$denominator', TMP_Rational_denominator_5 = function $$denominator() {
      var self = this;

      return self.den
    }, TMP_Rational_denominator_5.$$arity = 0);
    
    Opal.defn(self, '$coerce', TMP_Rational_coerce_6 = function $$coerce(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {return [other, self]}
      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return [other.$to_r(), self]}
      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return [other, self.$to_f()]}
      else { return nil }})()
    }, TMP_Rational_coerce_6.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_Rational_$eq$eq_7 = function(other) {
      var $a, self = this, $case = nil;

      return (function() {$case = other;
      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {return (($a = self.num['$=='](other.$numerator())) ? self.den['$=='](other.$denominator()) : self.num['$=='](other.$numerator()))}
      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return (($a = self.num['$=='](other)) ? self.den['$=='](1) : self.num['$=='](other))}
      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return self.$to_f()['$=='](other)}
      else {return other['$=='](self)}})()
    }, TMP_Rational_$eq$eq_7.$$arity = 1);
    
    Opal.defn(self, '$<=>', TMP_Rational_$lt$eq$gt_8 = function(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)}
      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)}
      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return self.$to_f()['$<=>'](other)}
      else {return self.$__coerced__("<=>", other)}})()
    }, TMP_Rational_$lt$eq$gt_8.$$arity = 1);
    
    Opal.defn(self, '$+', TMP_Rational_$_9 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {
      num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)}
      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return $rb_plus(self.$to_f(), other)}
      else {return self.$__coerced__("+", other)}})()
    }, TMP_Rational_$_9.$$arity = 1);
    
    Opal.defn(self, '$-', TMP_Rational_$_10 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {
      num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)}
      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return $rb_minus(self.$to_f(), other)}
      else {return self.$__coerced__("-", other)}})()
    }, TMP_Rational_$_10.$$arity = 1);
    
    Opal.defn(self, '$*', TMP_Rational_$_11 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$numerator());
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_times(self.num, other), self.den)}
      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return $rb_times(self.$to_f(), other)}
      else {return self.$__coerced__("*", other)}})()
    }, TMP_Rational_$_11.$$arity = 1);
    
    Opal.defn(self, '$/', TMP_Rational_$_12 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$denominator());
      den = $rb_times(self.den, other.$numerator());
      return self.$Rational(num, den);}
      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {if (other['$=='](0)) {
        return $rb_divide(self.$to_f(), 0.0)
        } else {
        return self.$Rational(self.num, $rb_times(self.den, other))
      }}
      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return $rb_divide(self.$to_f(), other)}
      else {return self.$__coerced__("/", other)}})()
    }, TMP_Rational_$_12.$$arity = 1);
    
    Opal.defn(self, '$**', TMP_Rational_$$_13 = function(other) {
      var $a, self = this, $case = nil;

      return (function() {$case = other;
      if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {
        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Float'), 'INFINITY')
      } else if ($truthy($rb_gt(other, 0))) {
        return self.$Rational(self.num['$**'](other), self.den['$**'](other))
      } else if ($truthy($rb_lt(other, 0))) {
        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
        } else {
        return self.$Rational(1, 1)
      }}
      else if (Opal.const_get_relative($nesting, 'Float')['$===']($case)) {return self.$to_f()['$**'](other)}
      else if (Opal.const_get_relative($nesting, 'Rational')['$===']($case)) {if (other['$=='](0)) {
        return self.$Rational(1, 1)
      } else if (other.$denominator()['$=='](1)) {
        if ($truthy($rb_lt(other, 0))) {
          return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
          } else {
          return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
        }
      } else if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {
        return self.$raise(Opal.const_get_relative($nesting, 'ZeroDivisionError'), "divided by 0")
        } else {
        return self.$to_f()['$**'](other)
      }}
      else {return self.$__coerced__("**", other)}})()
    }, TMP_Rational_$$_13.$$arity = 1);
    
    Opal.defn(self, '$abs', TMP_Rational_abs_14 = function $$abs() {
      var self = this;

      return self.$Rational(self.num.$abs(), self.den.$abs())
    }, TMP_Rational_abs_14.$$arity = 0);
    
    Opal.defn(self, '$ceil', TMP_Rational_ceil_15 = function $$ceil(precision) {
      var self = this;

      if (precision == null) {
        precision = 0;
      }
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
        } else {
        return self.$with_precision("ceil", precision)
      }
    }, TMP_Rational_ceil_15.$$arity = -1);
    Opal.alias(self, "divide", "/");
    
    Opal.defn(self, '$floor', TMP_Rational_floor_16 = function $$floor(precision) {
      var self = this;

      if (precision == null) {
        precision = 0;
      }
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
        } else {
        return self.$with_precision("floor", precision)
      }
    }, TMP_Rational_floor_16.$$arity = -1);
    
    Opal.defn(self, '$hash', TMP_Rational_hash_17 = function $$hash() {
      var self = this;

      return "" + "Rational:" + (self.num) + ":" + (self.den)
    }, TMP_Rational_hash_17.$$arity = 0);
    
    Opal.defn(self, '$inspect', TMP_Rational_inspect_18 = function $$inspect() {
      var self = this;

      return "" + "(" + (self.$to_s()) + ")"
    }, TMP_Rational_inspect_18.$$arity = 0);
    Opal.alias(self, "quo", "/");
    
    Opal.defn(self, '$rationalize', TMP_Rational_rationalize_19 = function $$rationalize(eps) {
      var self = this;

      
      if (arguments.length > 1) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return self.$Rational(c * p1 + p0, c * q1 + q0);
    
    }, TMP_Rational_rationalize_19.$$arity = -1);
    
    Opal.defn(self, '$round', TMP_Rational_round_20 = function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      if (precision == null) {
        precision = 0;
      }
      
      if (precision['$=='](0)) {
        } else {
        return self.$with_precision("round", precision)
      };
      if (self.num['$=='](0)) {
        return 0};
      if (self.den['$=='](1)) {
        return self.num};
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
        } else {
        return approx
      };
    }, TMP_Rational_round_20.$$arity = -1);
    
    Opal.defn(self, '$to_f', TMP_Rational_to_f_21 = function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, TMP_Rational_to_f_21.$$arity = 0);
    
    Opal.defn(self, '$to_i', TMP_Rational_to_i_22 = function $$to_i() {
      var self = this;

      return self.$truncate()
    }, TMP_Rational_to_i_22.$$arity = 0);
    
    Opal.defn(self, '$to_r', TMP_Rational_to_r_23 = function $$to_r() {
      var self = this;

      return self
    }, TMP_Rational_to_r_23.$$arity = 0);
    
    Opal.defn(self, '$to_s', TMP_Rational_to_s_24 = function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, TMP_Rational_to_s_24.$$arity = 0);
    
    Opal.defn(self, '$truncate', TMP_Rational_truncate_25 = function $$truncate(precision) {
      var self = this;

      if (precision == null) {
        precision = 0;
      }
      if (precision['$=='](0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
          } else {
          return self.$floor()
        }
        } else {
        return self.$with_precision("truncate", precision)
      }
    }, TMP_Rational_truncate_25.$$arity = -1);
    return (Opal.defn(self, '$with_precision', TMP_Rational_with_precision_26 = function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](precision))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
        } else {
        return self.$Rational(s.$send(method), p)
      };
    }, TMP_Rational_with_precision_26.$$arity = 2), nil) && 'with_precision';
  })($nesting[0], Opal.const_get_relative($nesting, 'Numeric'), $nesting);
  return (function($base, $parent_nesting) {
    var $Kernel, self = $Kernel = $module($base, 'Kernel');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_Rational_27;

    
    Opal.defn(self, '$Rational', TMP_Kernel_Rational_27 = function $$Rational(numerator, denominator) {
      var self = this;

      if (denominator == null) {
        denominator = 1;
      }
      return Opal.const_get_relative($nesting, 'Rational').$convert(numerator, denominator)
    }, TMP_Kernel_Rational_27.$$arity = -2)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/time"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$include', '$===', '$raise', '$coerce_to!', '$respond_to?', '$to_str', '$to_i', '$new', '$<=>', '$to_f', '$nil?', '$>', '$<', '$strftime', '$year', '$month', '$day', '$+', '$round', '$/', '$-', '$copy_instance_variables', '$initialize_dup', '$is_a?', '$zero?', '$wday', '$utc?', '$mon', '$yday', '$hour', '$min', '$sec', '$rjust', '$ljust', '$zone', '$to_s', '$[]', '$cweek_cyear', '$isdst', '$<=', '$!=', '$==', '$ceil']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    function $Time(){};
    var self = $Time = $klass($base, $super, 'Time', $Time);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Time_at_1, TMP_Time_new_2, TMP_Time_local_3, TMP_Time_gm_4, TMP_Time_now_5, TMP_Time_$_6, TMP_Time_$_7, TMP_Time_$lt$eq$gt_8, TMP_Time_$eq$eq_9, TMP_Time_asctime_10, TMP_Time_day_11, TMP_Time_yday_12, TMP_Time_isdst_13, TMP_Time_dup_14, TMP_Time_eql$q_15, TMP_Time_friday$q_16, TMP_Time_hash_17, TMP_Time_hour_18, TMP_Time_inspect_19, TMP_Time_min_20, TMP_Time_mon_21, TMP_Time_monday$q_22, TMP_Time_saturday$q_23, TMP_Time_sec_24, TMP_Time_succ_25, TMP_Time_usec_26, TMP_Time_zone_27, TMP_Time_getgm_28, TMP_Time_gmtime_29, TMP_Time_gmt$q_30, TMP_Time_gmt_offset_31, TMP_Time_strftime_32, TMP_Time_sunday$q_33, TMP_Time_thursday$q_34, TMP_Time_to_a_35, TMP_Time_to_f_36, TMP_Time_to_i_37, TMP_Time_tuesday$q_38, TMP_Time_wday_39, TMP_Time_wednesday$q_40, TMP_Time_year_41, TMP_Time_cweek_cyear_42;

    
    self.$include(Opal.const_get_relative($nesting, 'Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    Opal.defs(self, '$at', TMP_Time_at_1 = function $$at(seconds, frac) {
      var self = this;

      
      var result;

      if (Opal.const_get_relative($nesting, 'Time')['$==='](seconds)) {
        if (frac !== undefined) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.is_utc = seconds.is_utc;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](seconds, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](frac, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    
    }, TMP_Time_at_1.$$arity = -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](year, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](month, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](day, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](hour, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](min, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](sec, Opal.const_get_relative($nesting, 'Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    Opal.defs(self, '$new', TMP_Time_new_2 = function(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      if (month == null) {
        month = nil;
      }
      if (day == null) {
        day = nil;
      }
      if (hour == null) {
        hour = nil;
      }
      if (min == null) {
        min = nil;
      }
      if (sec == null) {
        sec = nil;
      }
      if (utc_offset == null) {
        utc_offset = nil;
      }
      
      var args, result;

      if (year === undefined) {
        return new Date();
      }

      if (utc_offset !== nil) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "Opal does not support explicitly specifying UTC offset for Time")
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    
    }, TMP_Time_new_2.$$arity = -1);
    Opal.defs(self, '$local', TMP_Time_local_3 = function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      if (month == null) {
        month = nil;
      }
      if (day == null) {
        day = nil;
      }
      if (hour == null) {
        hour = nil;
      }
      if (min == null) {
        min = nil;
      }
      if (sec == null) {
        sec = nil;
      }
      if (millisecond == null) {
        millisecond = nil;
      }
      if (_dummy1 == null) {
        _dummy1 = nil;
      }
      if (_dummy2 == null) {
        _dummy2 = nil;
      }
      if (_dummy3 == null) {
        _dummy3 = nil;
      }
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    
    }, TMP_Time_local_3.$$arity = -2);
    Opal.defs(self, '$gm', TMP_Time_gm_4 = function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      if (month == null) {
        month = nil;
      }
      if (day == null) {
        day = nil;
      }
      if (hour == null) {
        hour = nil;
      }
      if (min == null) {
        min = nil;
      }
      if (sec == null) {
        sec = nil;
      }
      if (millisecond == null) {
        millisecond = nil;
      }
      if (_dummy1 == null) {
        _dummy1 = nil;
      }
      if (_dummy2 == null) {
        _dummy2 = nil;
      }
      if (_dummy3 == null) {
        _dummy3 = nil;
      }
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.is_utc = true;
      return result;
    
    }, TMP_Time_gm_4.$$arity = -2);
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      
      Opal.alias(self, "mktime", "local");
      return Opal.alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$now', TMP_Time_now_5 = function $$now() {
      var self = this;

      return self.$new()
    }, TMP_Time_now_5.$$arity = 0);
    
    Opal.defn(self, '$+', TMP_Time_$_6 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Time')['$==='](other))) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "time + time?")};
      
      if (!other.$$is_number) {
        other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, TMP_Time_$_6.$$arity = 1);
    
    Opal.defn(self, '$-', TMP_Time_$_7 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Time')['$==='](other))) {
        return (self.getTime() - other.getTime()) / 1000};
      
      if (!other.$$is_number) {
        other = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](other, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, TMP_Time_$_7.$$arity = 1);
    
    Opal.defn(self, '$<=>', TMP_Time_$lt$eq$gt_8 = function(other) {
      var self = this, r = nil;

      if ($truthy(Opal.const_get_relative($nesting, 'Time')['$==='](other))) {
        return self.$to_f()['$<=>'](other.$to_f())
        } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
          } else {
          return 0
        };
      }
    }, TMP_Time_$lt$eq$gt_8.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_Time_$eq$eq_9 = function(other) {
      var $a, self = this;

      return ($truthy($a = Opal.const_get_relative($nesting, 'Time')['$==='](other)) ? self.$to_f() === other.$to_f() : $a)
    }, TMP_Time_$eq$eq_9.$$arity = 1);
    
    Opal.defn(self, '$asctime', TMP_Time_asctime_10 = function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, TMP_Time_asctime_10.$$arity = 0);
    Opal.alias(self, "ctime", "asctime");
    
    Opal.defn(self, '$day', TMP_Time_day_11 = function $$day() {
      var self = this;

      return self.is_utc ? self.getUTCDate() : self.getDate()
    }, TMP_Time_day_11.$$arity = 0);
    
    Opal.defn(self, '$yday', TMP_Time_yday_12 = function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = Opal.const_get_relative($nesting, 'Time').$new(self.$year()).$to_i();
      start_of_day = Opal.const_get_relative($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, TMP_Time_yday_12.$$arity = 0);
    
    Opal.defn(self, '$isdst', TMP_Time_isdst_13 = function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, TMP_Time_isdst_13.$$arity = 0);
    Opal.alias(self, "dst?", "isdst");
    
    Opal.defn(self, '$dup', TMP_Time_dup_14 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, TMP_Time_dup_14.$$arity = 0);
    
    Opal.defn(self, '$eql?', TMP_Time_eql$q_15 = function(other) {
      var $a, self = this;

      return ($truthy($a = other['$is_a?'](Opal.const_get_relative($nesting, 'Time'))) ? self['$<=>'](other)['$zero?']() : $a)
    }, TMP_Time_eql$q_15.$$arity = 1);
    
    Opal.defn(self, '$friday?', TMP_Time_friday$q_16 = function() {
      var self = this;

      return self.$wday() == 5
    }, TMP_Time_friday$q_16.$$arity = 0);
    
    Opal.defn(self, '$hash', TMP_Time_hash_17 = function $$hash() {
      var self = this;

      return 'Time:' + self.getTime()
    }, TMP_Time_hash_17.$$arity = 0);
    
    Opal.defn(self, '$hour', TMP_Time_hour_18 = function $$hour() {
      var self = this;

      return self.is_utc ? self.getUTCHours() : self.getHours()
    }, TMP_Time_hour_18.$$arity = 0);
    
    Opal.defn(self, '$inspect', TMP_Time_inspect_19 = function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
        } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, TMP_Time_inspect_19.$$arity = 0);
    Opal.alias(self, "mday", "day");
    
    Opal.defn(self, '$min', TMP_Time_min_20 = function $$min() {
      var self = this;

      return self.is_utc ? self.getUTCMinutes() : self.getMinutes()
    }, TMP_Time_min_20.$$arity = 0);
    
    Opal.defn(self, '$mon', TMP_Time_mon_21 = function $$mon() {
      var self = this;

      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1
    }, TMP_Time_mon_21.$$arity = 0);
    
    Opal.defn(self, '$monday?', TMP_Time_monday$q_22 = function() {
      var self = this;

      return self.$wday() == 1
    }, TMP_Time_monday$q_22.$$arity = 0);
    Opal.alias(self, "month", "mon");
    
    Opal.defn(self, '$saturday?', TMP_Time_saturday$q_23 = function() {
      var self = this;

      return self.$wday() == 6
    }, TMP_Time_saturday$q_23.$$arity = 0);
    
    Opal.defn(self, '$sec', TMP_Time_sec_24 = function $$sec() {
      var self = this;

      return self.is_utc ? self.getUTCSeconds() : self.getSeconds()
    }, TMP_Time_sec_24.$$arity = 0);
    
    Opal.defn(self, '$succ', TMP_Time_succ_25 = function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.is_utc = self.is_utc;
      return result;
    
    }, TMP_Time_succ_25.$$arity = 0);
    
    Opal.defn(self, '$usec', TMP_Time_usec_26 = function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000
    }, TMP_Time_usec_26.$$arity = 0);
    
    Opal.defn(self, '$zone', TMP_Time_zone_27 = function $$zone() {
      var self = this;

      
      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, TMP_Time_zone_27.$$arity = 0);
    
    Opal.defn(self, '$getgm', TMP_Time_getgm_28 = function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.is_utc = true;
      return result;
    
    }, TMP_Time_getgm_28.$$arity = 0);
    Opal.alias(self, "getutc", "getgm");
    
    Opal.defn(self, '$gmtime', TMP_Time_gmtime_29 = function $$gmtime() {
      var self = this;

      
      self.is_utc = true;
      return self;
    
    }, TMP_Time_gmtime_29.$$arity = 0);
    Opal.alias(self, "utc", "gmtime");
    
    Opal.defn(self, '$gmt?', TMP_Time_gmt$q_30 = function() {
      var self = this;

      return self.is_utc === true
    }, TMP_Time_gmt$q_30.$$arity = 0);
    
    Opal.defn(self, '$gmt_offset', TMP_Time_gmt_offset_31 = function $$gmt_offset() {
      var self = this;

      return -self.getTimezoneOffset() * 60
    }, TMP_Time_gmt_offset_31.$$arity = 0);
    
    Opal.defn(self, '$strftime', TMP_Time_strftime_32 = function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "",
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = self.getTimezoneOffset(),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, TMP_Time_strftime_32.$$arity = 1);
    
    Opal.defn(self, '$sunday?', TMP_Time_sunday$q_33 = function() {
      var self = this;

      return self.$wday() == 0
    }, TMP_Time_sunday$q_33.$$arity = 0);
    
    Opal.defn(self, '$thursday?', TMP_Time_thursday$q_34 = function() {
      var self = this;

      return self.$wday() == 4
    }, TMP_Time_thursday$q_34.$$arity = 0);
    
    Opal.defn(self, '$to_a', TMP_Time_to_a_35 = function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, TMP_Time_to_a_35.$$arity = 0);
    
    Opal.defn(self, '$to_f', TMP_Time_to_f_36 = function $$to_f() {
      var self = this;

      return self.getTime() / 1000
    }, TMP_Time_to_f_36.$$arity = 0);
    
    Opal.defn(self, '$to_i', TMP_Time_to_i_37 = function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10)
    }, TMP_Time_to_i_37.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.defn(self, '$tuesday?', TMP_Time_tuesday$q_38 = function() {
      var self = this;

      return self.$wday() == 2
    }, TMP_Time_tuesday$q_38.$$arity = 0);
    Opal.alias(self, "tv_sec", "to_i");
    Opal.alias(self, "tv_usec", "usec");
    Opal.alias(self, "utc?", "gmt?");
    Opal.alias(self, "gmtoff", "gmt_offset");
    Opal.alias(self, "utc_offset", "gmt_offset");
    
    Opal.defn(self, '$wday', TMP_Time_wday_39 = function $$wday() {
      var self = this;

      return self.is_utc ? self.getUTCDay() : self.getDay()
    }, TMP_Time_wday_39.$$arity = 0);
    
    Opal.defn(self, '$wednesday?', TMP_Time_wednesday$q_40 = function() {
      var self = this;

      return self.$wday() == 3
    }, TMP_Time_wednesday$q_40.$$arity = 0);
    
    Opal.defn(self, '$year', TMP_Time_year_41 = function $$year() {
      var self = this;

      return self.is_utc ? self.getUTCFullYear() : self.getFullYear()
    }, TMP_Time_year_41.$$arity = 0);
    return (Opal.defn(self, '$cweek_cyear', TMP_Time_cweek_cyear_42 = function $$cweek_cyear() {
      var $a, self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = Opal.const_get_relative($nesting, 'Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if ($truthy(($truthy($a = $rb_le(jan01_wday, 4)) ? jan01_wday['$!='](0) : $a))) {
        offset = $rb_minus(jan01_wday, 1)
        } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if (offset['$=='](-8)) {
          offset = -1};
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return Opal.const_get_relative($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if (week['$=='](53)) {
        
        dec31 = Opal.const_get_relative($nesting, 'Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if ($truthy(($truthy($a = $rb_le(dec31_wday, 3)) ? dec31_wday['$!='](0) : $a))) {
          
          week = 1;
          year = $rb_plus(year, 1);};};
      return [week, year];
    }, TMP_Time_cweek_cyear_42.$$arity = 0), nil) && 'cweek_cyear';
  })($nesting[0], Date, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/struct"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$include', '$const_name!', '$unshift', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$module_eval', '$to_proc', '$const_set', '$==', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$>', '$length', '$class', '$each_with_index', '$[]', '$[]=', '$-', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$join', '$each_pair', '$inspect', '$inject', '$flatten', '$to_a', '$respond_to?', '$dig']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    function $Struct(){};
    var self = $Struct = $klass($base, $super, 'Struct', $Struct);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Struct_new_1, TMP_Struct_define_struct_attribute_8, TMP_Struct_members_9, TMP_Struct_inherited_11, TMP_Struct_initialize_13, TMP_Struct_members_14, TMP_Struct_hash_15, TMP_Struct_$$_16, TMP_Struct_$$$eq_17, TMP_Struct_$eq$eq_18, TMP_Struct_eql$q_19, TMP_Struct_each_20, TMP_Struct_each_pair_23, TMP_Struct_length_26, TMP_Struct_to_a_28, TMP_Struct_inspect_30, TMP_Struct_to_h_32, TMP_Struct_values_at_34, TMP_Struct_dig_35;

    
    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
    Opal.defs(self, '$new', TMP_Struct_new_1 = function(const_name, $a_rest) {
      var TMP_2, TMP_3, self = this, args, $iter = TMP_Struct_new_1.$$p, block = $iter || nil, klass = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      if ($iter) TMP_Struct_new_1.$$p = null;
      
      if ($truthy(const_name)) {
        
        try {
          const_name = Opal.const_get_relative($nesting, 'Opal')['$const_name!'](const_name)
        } catch ($err) {
          if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'TypeError'), Opal.const_get_relative($nesting, 'NameError')])) {
            try {
              
              args.$unshift(const_name);
              const_name = nil;
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };};
      $send(args, 'map', [], (TMP_2 = function(arg){var self = TMP_2.$$s || this;
if (arg == null) arg = nil;
      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](arg, Opal.const_get_relative($nesting, 'String'), "to_str")}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));
      klass = $send(Opal.const_get_relative($nesting, 'Class'), 'new', [self], (TMP_3 = function(){var self = TMP_3.$$s || this, TMP_4;

      
        $send(args, 'each', [], (TMP_4 = function(arg){var self = TMP_4.$$s || this;
if (arg == null) arg = nil;
        return self.$define_struct_attribute(arg)}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));
        return (function(self, $parent_nesting) {
          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_new_5;

          
          
          Opal.defn(self, '$new', TMP_new_5 = function($a_rest) {
            var self = this, args, instance = nil;

            var $args_len = arguments.length, $rest_len = $args_len - 0;
            if ($rest_len < 0) { $rest_len = 0; }
            args = new Array($rest_len);
            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
              args[$arg_idx - 0] = arguments[$arg_idx];
            }
            
            instance = self.$allocate();
            instance.$$data = {};;
            $send(instance, 'initialize', Opal.to_a(args));
            return instance;
          }, TMP_new_5.$$arity = -1);
          return Opal.alias(self, "[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3));
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())};
      if ($truthy(const_name)) {
        Opal.const_get_relative($nesting, 'Struct').$const_set(const_name, klass)};
      return klass;
    }, TMP_Struct_new_1.$$arity = -2);
    Opal.defs(self, '$define_struct_attribute', TMP_Struct_define_struct_attribute_8 = function $$define_struct_attribute(name) {
      var TMP_6, TMP_7, self = this;

      
      if (self['$=='](Opal.const_get_relative($nesting, 'Struct'))) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "you cannot define attributes to the Struct class")};
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], (TMP_6 = function(){var self = TMP_6.$$s || this;

      return self.$$data[name]}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6));
      return $send(self, 'define_method', ["" + (name) + "="], (TMP_7 = function(value){var self = TMP_7.$$s || this;
if (value == null) value = nil;
      return self.$$data[name] = value}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));
    }, TMP_Struct_define_struct_attribute_8.$$arity = 1);
    Opal.defs(self, '$members', TMP_Struct_members_9 = function $$members() {
      var $a, self = this;
      if (self.members == null) self.members = nil;

      
      if (self['$=='](Opal.const_get_relative($nesting, 'Struct'))) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "the Struct class has no members")};
      return (self.members = ($truthy($a = self.members) ? $a : []));
    }, TMP_Struct_members_9.$$arity = 0);
    Opal.defs(self, '$inherited', TMP_Struct_inherited_11 = function $$inherited(klass) {
      var TMP_10, self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], (TMP_10 = function(){var self = TMP_10.$$s || this;

      return (self.members = members)}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10));
    }, TMP_Struct_inherited_11.$$arity = 1);
    
    Opal.defn(self, '$initialize', TMP_Struct_initialize_13 = function $$initialize($a_rest) {
      var TMP_12, self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "struct size differs")};
      return $send(self.$class().$members(), 'each_with_index', [], (TMP_12 = function(name, index){var self = TMP_12.$$s || this, $writer = nil;
if (name == null) name = nil;if (index == null) index = nil;
      
        $writer = [name, args['$[]'](index)];
        $send(self, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, TMP_12.$$s = self, TMP_12.$$arity = 2, TMP_12));
    }, TMP_Struct_initialize_13.$$arity = -1);
    
    Opal.defn(self, '$members', TMP_Struct_members_14 = function $$members() {
      var self = this;

      return self.$class().$members()
    }, TMP_Struct_members_14.$$arity = 0);
    
    Opal.defn(self, '$hash', TMP_Struct_hash_15 = function $$hash() {
      var self = this;

      return Opal.const_get_relative($nesting, 'Hash').$new(self.$$data).$hash()
    }, TMP_Struct_hash_15.$$arity = 0);
    
    Opal.defn(self, '$[]', TMP_Struct_$$_16 = function(name) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](name))) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](name, Opal.const_get_relative($nesting, 'String'), "to_str");
      return self.$$data[name];
    }, TMP_Struct_$$_16.$$arity = 1);
    
    Opal.defn(self, '$[]=', TMP_Struct_$$$eq_17 = function(name, value) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise(Opal.const_get_relative($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](name))) {
        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](name, Opal.const_get_relative($nesting, 'String'), "to_str");
      return self.$$data[name] = value;
    }, TMP_Struct_$$$eq_17.$$arity = 2);
    
    Opal.defn(self, '$==', TMP_Struct_$eq$eq_18 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if (Opal.const_get_relative($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, TMP_Struct_$eq$eq_18.$$arity = 1);
    
    Opal.defn(self, '$eql?', TMP_Struct_eql$q_19 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if (Opal.const_get_relative($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, TMP_Struct_eql$q_19.$$arity = 1);
    
    Opal.defn(self, '$each', TMP_Struct_each_20 = function $$each() {
      var TMP_21, TMP_22, self = this, $iter = TMP_Struct_each_20.$$p, $yield = $iter || nil;

      if ($iter) TMP_Struct_each_20.$$p = null;
      
      if (($yield !== nil)) {
        } else {
        return $send(self, 'enum_for', ["each"], (TMP_21 = function(){var self = TMP_21.$$s || this;

        return self.$size()}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21))
      };
      $send(self.$class().$members(), 'each', [], (TMP_22 = function(name){var self = TMP_22.$$s || this;
if (name == null) name = nil;
      return Opal.yield1($yield, self['$[]'](name));}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22));
      return self;
    }, TMP_Struct_each_20.$$arity = 0);
    
    Opal.defn(self, '$each_pair', TMP_Struct_each_pair_23 = function $$each_pair() {
      var TMP_24, TMP_25, self = this, $iter = TMP_Struct_each_pair_23.$$p, $yield = $iter || nil;

      if ($iter) TMP_Struct_each_pair_23.$$p = null;
      
      if (($yield !== nil)) {
        } else {
        return $send(self, 'enum_for', ["each_pair"], (TMP_24 = function(){var self = TMP_24.$$s || this;

        return self.$size()}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24))
      };
      $send(self.$class().$members(), 'each', [], (TMP_25 = function(name){var self = TMP_25.$$s || this;
if (name == null) name = nil;
      return Opal.yield1($yield, [name, self['$[]'](name)]);}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25));
      return self;
    }, TMP_Struct_each_pair_23.$$arity = 0);
    
    Opal.defn(self, '$length', TMP_Struct_length_26 = function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, TMP_Struct_length_26.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.defn(self, '$to_a', TMP_Struct_to_a_28 = function $$to_a() {
      var TMP_27, self = this;

      return $send(self.$class().$members(), 'map', [], (TMP_27 = function(name){var self = TMP_27.$$s || this;
if (name == null) name = nil;
      return self['$[]'](name)}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27))
    }, TMP_Struct_to_a_28.$$arity = 0);
    Opal.alias(self, "values", "to_a");
    
    Opal.defn(self, '$inspect', TMP_Struct_inspect_30 = function $$inspect() {
      var $a, TMP_29, self = this, result = nil;

      
      result = "#<struct ";
      if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'Struct')['$==='](self)) ? self.$class().$name() : $a))) {
        result = $rb_plus(result, "" + (self.$class()) + " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], (TMP_29 = function(name, value){var self = TMP_29.$$s || this;
if (name == null) name = nil;if (value == null) value = nil;
      return "" + (name) + "=" + (value.$inspect())}, TMP_29.$$s = self, TMP_29.$$arity = 2, TMP_29)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
    }, TMP_Struct_inspect_30.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.defn(self, '$to_h', TMP_Struct_to_h_32 = function $$to_h() {
      var TMP_31, self = this;

      return $send(self.$class().$members(), 'inject', [$hash2([], {})], (TMP_31 = function(h, name){var self = TMP_31.$$s || this, $writer = nil;
if (h == null) h = nil;if (name == null) name = nil;
      
        
        $writer = [name, self['$[]'](name)];
        $send(h, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return h;}, TMP_31.$$s = self, TMP_31.$$arity = 2, TMP_31))
    }, TMP_Struct_to_h_32.$$arity = 0);
    
    Opal.defn(self, '$values_at', TMP_Struct_values_at_34 = function $$values_at($a_rest) {
      var TMP_33, self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      args = $send(args, 'map', [], (TMP_33 = function(arg){var self = TMP_33.$$s || this;
if (arg == null) arg = nil;
      return arg.$$is_range ? arg.$to_a() : arg}, TMP_33.$$s = self, TMP_33.$$arity = 1, TMP_33)).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, TMP_Struct_values_at_34.$$arity = -1);
    return (Opal.defn(self, '$dig', TMP_Struct_dig_35 = function $$dig(key, $a_rest) {
      var self = this, keys, item = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      keys = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        keys[$arg_idx - 1] = arguments[$arg_idx];
      }
      
      if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
        item = self.$$data[key] || nil
        } else {
        item = nil
      };
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, TMP_Struct_dig_35.$$arity = -2), nil) && 'dig';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $writer = nil;

  Opal.add_stubs(['$attr_accessor', '$size', '$write', '$join', '$map', '$String', '$empty?', '$concat', '$chomp', '$getbyte', '$getc', '$raise', '$new', '$write_proc=', '$-', '$extend']);
  
  (function($base, $super, $parent_nesting) {
    function $IO(){};
    var self = $IO = $klass($base, $super, 'IO', $IO);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_IO_tty$q_1, TMP_IO_closed$q_2, TMP_IO_write_3, TMP_IO_flush_4;

    def.tty = def.closed = nil;
    
    Opal.const_set($nesting[0], 'SEEK_SET', 0);
    Opal.const_set($nesting[0], 'SEEK_CUR', 1);
    Opal.const_set($nesting[0], 'SEEK_END', 2);
    
    Opal.defn(self, '$tty?', TMP_IO_tty$q_1 = function() {
      var self = this;

      return self.tty
    }, TMP_IO_tty$q_1.$$arity = 0);
    
    Opal.defn(self, '$closed?', TMP_IO_closed$q_2 = function() {
      var self = this;

      return self.closed
    }, TMP_IO_closed$q_2.$$arity = 0);
    self.$attr_accessor("write_proc");
    
    Opal.defn(self, '$write', TMP_IO_write_3 = function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, TMP_IO_write_3.$$arity = 1);
    self.$attr_accessor("sync", "tty");
    
    Opal.defn(self, '$flush', TMP_IO_flush_4 = function $$flush() {
      var self = this;

      return nil
    }, TMP_IO_flush_4.$$arity = 0);
    (function($base, $parent_nesting) {
      var $Writable, self = $Writable = $module($base, 'Writable');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Writable_$lt$lt_5, TMP_Writable_print_7, TMP_Writable_puts_9;

      
      
      Opal.defn(self, '$<<', TMP_Writable_$lt$lt_5 = function(string) {
        var self = this;

        
        self.$write(string);
        return self;
      }, TMP_Writable_$lt$lt_5.$$arity = 1);
      
      Opal.defn(self, '$print', TMP_Writable_print_7 = function $$print($a_rest) {
        var TMP_6, self = this, args;
        if ($gvars[","] == null) $gvars[","] = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        self.$write($send(args, 'map', [], (TMP_6 = function(arg){var self = TMP_6.$$s || this;
if (arg == null) arg = nil;
        return self.$String(arg)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)).$join($gvars[","]));
        return nil;
      }, TMP_Writable_print_7.$$arity = -1);
      
      Opal.defn(self, '$puts', TMP_Writable_puts_9 = function $$puts($a_rest) {
        var TMP_8, self = this, args, newline = nil;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        newline = $gvars["/"];
        if ($truthy(args['$empty?']())) {
          self.$write($gvars["/"])
          } else {
          self.$write($send(args, 'map', [], (TMP_8 = function(arg){var self = TMP_8.$$s || this;
if (arg == null) arg = nil;
          return self.$String(arg).$chomp()}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8)).$concat([nil]).$join(newline))
        };
        return nil;
      }, TMP_Writable_puts_9.$$arity = -1);
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var $Readable, self = $Readable = $module($base, 'Readable');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Readable_readbyte_10, TMP_Readable_readchar_11, TMP_Readable_readline_12, TMP_Readable_readpartial_13;

      
      
      Opal.defn(self, '$readbyte', TMP_Readable_readbyte_10 = function $$readbyte() {
        var self = this;

        return self.$getbyte()
      }, TMP_Readable_readbyte_10.$$arity = 0);
      
      Opal.defn(self, '$readchar', TMP_Readable_readchar_11 = function $$readchar() {
        var self = this;

        return self.$getc()
      }, TMP_Readable_readchar_11.$$arity = 0);
      
      Opal.defn(self, '$readline', TMP_Readable_readline_12 = function $$readline(sep) {
        var self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        if (sep == null) {
          sep = $gvars["/"];
        }
        return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))
      }, TMP_Readable_readline_12.$$arity = -1);
      
      Opal.defn(self, '$readpartial', TMP_Readable_readpartial_13 = function $$readpartial(integer, outbuf) {
        var self = this;

        if (outbuf == null) {
          outbuf = nil;
        }
        return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'))
      }, TMP_Readable_readpartial_13.$$arity = -2);
    })($nesting[0], $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = Opal.const_get_relative($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = Opal.const_get_relative($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = Opal.const_get_relative($nesting, 'IO').$new()));
  var console = Opal.global.console;
  
  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];
  $send(Opal.const_get_relative($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];
  $send(Opal.const_get_relative($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  Opal.const_get_relative($nesting, 'STDOUT').$extend(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'Writable'));
  return Opal.const_get_relative($nesting, 'STDERR').$extend(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'Writable'));
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/main"] = function(Opal) {
  var TMP_to_s_1, TMP_include_2, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$include']);
  
  Opal.defs(self, '$to_s', TMP_to_s_1 = function $$to_s() {
    var self = this;

    return "main"
  }, TMP_to_s_1.$$arity = 0);
  return Opal.defs(self, '$include', TMP_include_2 = function $$include(mod) {
    var self = this;

    return Opal.const_get_relative($nesting, 'Object').$include(mod)
  }, TMP_include_2.$$arity = 1);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/dir"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$[]']);
  return (function($base, $super, $parent_nesting) {
    function $Dir(){};
    var self = $Dir = $klass($base, $super, 'Dir', $Dir);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_chdir_1, TMP_pwd_2, TMP_home_3;

      
      
      Opal.defn(self, '$chdir', TMP_chdir_1 = function $$chdir(dir) {
        var self = this, $iter = TMP_chdir_1.$$p, $yield = $iter || nil, prev_cwd = nil;

        if ($iter) TMP_chdir_1.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, TMP_chdir_1.$$arity = 1);
      
      Opal.defn(self, '$pwd', TMP_pwd_2 = function $$pwd() {
        var self = this;

        return Opal.current_dir || '.'
      }, TMP_pwd_2.$$arity = 0);
      Opal.alias(self, "getwd", "pwd");
      return (Opal.defn(self, '$home', TMP_home_3 = function $$home() {
        var $a, self = this;

        return ($truthy($a = Opal.const_get_relative($nesting, 'ENV')['$[]']("HOME")) ? $a : ".")
      }, TMP_home_3.$$arity = 0), nil) && 'home';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/file"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$home', '$raise', '$start_with?', '$+', '$sub', '$pwd', '$split', '$unshift', '$join', '$respond_to?', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$end_with?']);
  return (function($base, $super, $parent_nesting) {
    function $File(){};
    var self = $File = $klass($base, $super, 'File', $File);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', "/"));
    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);
    Opal.const_set($nesting[0], 'PATH_SEPARATOR', ":");
    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_expand_path_1, TMP_dirname_2, TMP_basename_3, TMP_extname_4, TMP_exist$q_5, TMP_directory$q_7, TMP_join_11, TMP_split_12;

      
      
      Opal.defn(self, '$expand_path', TMP_expand_path_1 = function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, new_parts = nil, home = nil, home_path_regexp = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        if (basedir == null) {
          basedir = nil;
        }
        
        sep = Opal.const_get_relative($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = Opal.const_get_relative($nesting, 'Dir').$home();
          if ($truthy(home)) {
            } else {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          if ($truthy(home['$start_with?'](sep))) {
            } else {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = new RegExp("" + "^\\~(?:" + (sep) + "|$)");
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)};};
        if ($truthy(basedir)) {
          } else {
          basedir = Opal.const_get_relative($nesting, 'Dir').$pwd()
        };
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split(new RegExp("" + "[" + (sep_chars) + "]"));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          abs = true;
          } else {
          
          parts = $rb_plus(basedir.$split(new RegExp("" + "[" + (sep_chars) + "]")), path.$split(new RegExp("" + "[" + (sep_chars) + "]")));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)};
        return new_path;
      }, TMP_expand_path_1.$$arity = -2);
      Opal.alias(self, "realpath", "expand_path");
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](path, Opal.const_get_relative($nesting, 'String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if (Opal.const_get_relative($nesting, 'ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp(Opal.const_get_relative($nesting, 'SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus(Opal.const_get_relative($nesting, 'SEPARATOR'), Opal.const_get_relative($nesting, 'ALT_SEPARATOR')));
        }
      }
    ;
      
      Opal.defn(self, '$dirname', TMP_dirname_2 = function $$dirname(path) {
        var self = this, sep_chars = nil;

        
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("" + "^[" + (sep_chars) + "]"));

        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("" + "[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          return absolute ? '/' : '.';
        }

        return path;
      ;
      }, TMP_dirname_2.$$arity = 1);
      
      Opal.defn(self, '$basename', TMP_basename_3 = function $$basename(name, suffix) {
        var self = this, sep_chars = nil;

        if (suffix == null) {
          suffix = nil;
        }
        
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](suffix, Opal.const_get_relative($nesting, 'String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("" + "(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("" + "^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, TMP_basename_3.$$arity = -2);
      
      Opal.defn(self, '$extname', TMP_extname_4 = function $$extname(path) {
        var $a, self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);;
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""};
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if ($truthy(($truthy($a = last_dot_idx['$nil?']()) ? $a : $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))))) {
          return ""
          } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, TMP_extname_4.$$arity = 1);
      
      Opal.defn(self, '$exist?', TMP_exist$q_5 = function(path) {
        var self = this;

        return Opal.modules[path] != null
      }, TMP_exist$q_5.$$arity = 1);
      Opal.alias(self, "exists?", "exist?");
      
      Opal.defn(self, '$directory?', TMP_directory$q_7 = function(path) {
        var TMP_6, self = this, files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub(new RegExp("" + "(^." + (Opal.const_get_relative($nesting, 'SEPARATOR')) + "+|" + (Opal.const_get_relative($nesting, 'SEPARATOR')) + "+$)"));
        file = $send(files, 'find', [], (TMP_6 = function(file){var self = TMP_6.$$s || this;
if (file == null) file = nil;
        return file['$=~'](new RegExp("" + "^" + (path)))}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));
        return file;
      }, TMP_directory$q_7.$$arity = 1);
      
      Opal.defn(self, '$join', TMP_join_11 = function $$join($a_rest) {
        var TMP_8, TMP_9, TMP_10, self = this, paths, result = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        paths = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          paths[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        if (paths.$length()['$=='](0)) {
          return ""};
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], (TMP_8 = function(item, index){var self = TMP_8.$$s || this, $a;
if (item == null) item = nil;if (index == null) index = nil;
        if ($truthy((($a = index['$=='](0)) ? item['$empty?']() : index['$=='](0)))) {
            return Opal.const_get_relative($nesting, 'SEPARATOR')
          } else if ($truthy((($a = paths.$length()['$==']($rb_plus(index, 1))) ? item['$empty?']() : paths.$length()['$==']($rb_plus(index, 1))))) {
            return Opal.const_get_relative($nesting, 'SEPARATOR')
            } else {
            return item
          }}, TMP_8.$$s = self, TMP_8.$$arity = 2, TMP_8));
        paths = $send(paths, 'reject', [], (TMP_9 = function(path){var self = TMP_9.$$s || this;
if (path == null) path = nil;
        return path['$empty?']()}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));
        $send(paths, 'each_with_index', [], (TMP_10 = function(item, index){var self = TMP_10.$$s || this, $a, next_item = nil;
if (item == null) item = nil;if (index == null) index = nil;
        
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
            } else {
            
            if ($truthy(($truthy($a = item['$end_with?'](Opal.const_get_relative($nesting, 'SEPARATOR'))) ? next_item['$start_with?'](Opal.const_get_relative($nesting, 'SEPARATOR')) : $a))) {
              item = item.$sub(new RegExp("" + (Opal.const_get_relative($nesting, 'SEPARATOR')) + "+$"), "")};
            if ($truthy(($truthy($a = item['$end_with?'](Opal.const_get_relative($nesting, 'SEPARATOR'))) ? $a : next_item['$start_with?'](Opal.const_get_relative($nesting, 'SEPARATOR'))))) {
              return (result = "" + (result) + (item))
              } else {
              return (result = "" + (result) + (item) + (Opal.const_get_relative($nesting, 'SEPARATOR')))
            };
          };}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10));
        return result;
      }, TMP_join_11.$$arity = -1);
      return (Opal.defn(self, '$split', TMP_split_12 = function $$split(path) {
        var self = this;

        return path.$split(Opal.const_get_relative($nesting, 'SEPARATOR'))
      }, TMP_split_12.$$arity = 1), nil) && 'split';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], Opal.const_get_relative($nesting, 'IO'), $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/process"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    function $Process(){};
    var self = $Process = $klass($base, $super, 'Process', $Process);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Process___register_clock___1, TMP_Process_pid_2, TMP_Process_times_3, TMP_Process_clock_gettime_4, monotonic = nil;

    
    self.__clocks__ = [];
    Opal.defs(self, '$__register_clock__', TMP_Process___register_clock___1 = function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, TMP_Process___register_clock___1.$$arity = 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)};
    Opal.defs(self, '$pid', TMP_Process_pid_2 = function $$pid() {
      var self = this;

      return 0
    }, TMP_Process_pid_2.$$arity = 0);
    Opal.defs(self, '$times', TMP_Process_times_3 = function $$times() {
      var self = this, t = nil;

      
      t = Opal.const_get_relative($nesting, 'Time').$now().$to_f();
      return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, TMP_Process_times_3.$$arity = 0);
    return Opal.defs(self, '$clock_gettime', TMP_Process_clock_gettime_4 = function $$clock_gettime(clock_id, unit) {
      var $a, self = this, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      if (unit == null) {
        unit = "float_second";
      }
      
      ($truthy($a = (clock = self.__clocks__['$[]'](clock_id))) ? $a : self.$raise(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Errno'), 'EINVAL'), "" + "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id))));
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "unexpected unit: " + (unit))
      }
    ;
    }, TMP_Process_clock_gettime_4.$$arity = -2);
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Signal(){};
    var self = $Signal = $klass($base, $super, 'Signal', $Signal);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Signal_trap_5;

    return Opal.defs(self, '$trap', TMP_Signal_trap_5 = function $$trap($a_rest) {
      var self = this;

      return nil
    }, TMP_Signal_trap_5.$$arity = -1)
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    function $GC(){};
    var self = $GC = $klass($base, $super, 'GC', $GC);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_GC_start_6;

    return Opal.defs(self, '$start', TMP_GC_start_6 = function $$start() {
      var self = this;

      return nil
    }, TMP_GC_start_6.$$arity = 0)
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/random/seedrandom"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass;

  return (function($base, $super, $parent_nesting) {
    function $Random(){};
    var self = $Random = $klass($base, $super, 'Random', $Random);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    
    /* jshint ignore:start */
    /*
    seedrandom.min.js 2.4.1 (original source: https://github.com/davidbau/seedrandom/blob/2.4.1/seedrandom.min.js)
    How to update:
     . Chekout the latest release from GitHub: https://github.com/davidbau/seedrandom
     . Apply the following commits:
     .. Check for hasOwnProperty in flatten(): https://github.com/iliabylich/seedrandom/commit/06a94f59ae3d3956c8b1a2488334cafab6744b04
     .. Add a module id for the RequireJS `define` method: https://github.com/Mogztter/seedrandom/commit/e047540c3d81f955cab9a01d17b8141d439fbd7d
    */
    !function(a,b){function c(c,j,k){var n=[];j=1==j?{entropy:!0}:j||{};var s=g(f(j.entropy?[c,i(a)]:null==c?h():c,3),n),t=new d(n),u=function(){for(var a=t.g(m),b=p,c=0;a<q;)a=(a+c)*l,b*=l,c=t.g(1);for(;a>=r;)a/=2,b/=2,c>>>=1;return(a+c)/b};return u.int32=function(){return 0|t.g(4)},u.quick=function(){return t.g(4)/4294967296},u.double=u,g(i(t.S),a),(j.pass||k||function(a,c,d,f){return f&&(f.S&&e(f,t),a.state=function(){return e(t,{})}),d?(b[o]=a,c):a})(u,s,"global"in j?j.global:this==b,j.state)}function d(a){var b,c=a.length,d=this,e=0,f=d.i=d.j=0,g=d.S=[];for(c||(a=[c++]);e<l;)g[e]=e++;for(e=0;e<l;e++)g[e]=g[f=s&f+a[e%c]+(b=g[e])],g[f]=b;(d.g=function(a){for(var b,c=0,e=d.i,f=d.j,g=d.S;a--;)b=g[e=s&e+1],c=c*l+g[s&(g[e]=g[f=s&f+b])+(g[f]=b)];return d.i=e,d.j=f,c})(l)}function e(a,b){return b.i=a.i,b.j=a.j,b.S=a.S.slice(),b}function f(a,b){var c,d=[],e=typeof a;if(b&&"object"==e)for(c in a)if(a.hasOwnProperty(c))try{d.push(f(a[c],b-1))}catch(a){}return d.length?d:"string"==e?a:a+"\0"}function g(a,b){for(var c,d=a+"",e=0;e<d.length;)b[s&e]=s&(c^=19*b[s&e])+d.charCodeAt(e++);return i(b)}function h(){try{if(j)return i(j.randomBytes(l));var b=new Uint8Array(l);return(k.crypto||k.msCrypto).getRandomValues(b),i(b)}catch(b){var c=k.navigator,d=c&&c.plugins;return[+new Date,k,d,k.screen,i(a)]}}function i(a){return String.fromCharCode.apply(0,a)}var j,k=this,l=256,m=6,n=52,o="random",p=b.pow(l,m),q=b.pow(2,n),r=2*q,s=l-1;if(b["seed"+o]=c,g(b.random(),a),"object"==typeof module&&module.exports){module.exports=c;try{j=require("crypto")}catch(a){}}else"function"==typeof define&&define.amd&&define('seekrandom',function(){return c})}([],Math);
    /* jshint ignore:end */
  
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/random"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$attr_reader', '$coerce_to!', '$reseed', '$new_seed', '$rand', '$seed', '$new', '$===', '$==', '$state', '$encode', '$join', '$map', '$times', '$chr', '$raise']);
  
  self.$require("corelib/random/seedrandom.js");
  return (function($base, $super, $parent_nesting) {
    function $Random(){};
    var self = $Random = $klass($base, $super, 'Random', $Random);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Random_initialize_1, TMP_Random_reseed_2, TMP_Random_new_seed_3, TMP_Random_rand_4, TMP_Random_srand_5, TMP_Random_$eq$eq_6, TMP_Random_bytes_8, TMP_Random_rand_9;

    
    self.$attr_reader("seed", "state");
    
    Opal.defn(self, '$initialize', TMP_Random_initialize_1 = function $$initialize(seed) {
      var self = this;

      if (seed == null) {
        seed = Opal.const_get_relative($nesting, 'Random').$new_seed();
      }
      
      seed = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](seed, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, TMP_Random_initialize_1.$$arity = -1);
    
    Opal.defn(self, '$reseed', TMP_Random_reseed_2 = function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = new Math.seedrandom(seed);;
    }, TMP_Random_reseed_2.$$arity = 1);
    var $seed_generator = new Math.seedrandom('opal', { entropy: true });;
    Opal.defs(self, '$new_seed', TMP_Random_new_seed_3 = function $$new_seed() {
      var self = this;

      
      return Math.abs($seed_generator.int32());
    
    }, TMP_Random_new_seed_3.$$arity = 0);
    Opal.defs(self, '$rand', TMP_Random_rand_4 = function $$rand(limit) {
      var self = this;

      return Opal.const_get_relative($nesting, 'DEFAULT').$rand(limit)
    }, TMP_Random_rand_4.$$arity = -1);
    Opal.defs(self, '$srand', TMP_Random_srand_5 = function $$srand(n) {
      var self = this, previous_seed = nil;

      if (n == null) {
        n = Opal.const_get_relative($nesting, 'Random').$new_seed();
      }
      
      n = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](n, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      previous_seed = Opal.const_get_relative($nesting, 'DEFAULT').$seed();
      Opal.const_get_relative($nesting, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, TMP_Random_srand_5.$$arity = -1);
    Opal.const_set($nesting[0], 'DEFAULT', self.$new(self.$new_seed()));
    
    Opal.defn(self, '$==', TMP_Random_$eq$eq_6 = function(other) {
      var $a, self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Random')['$==='](other))) {
        } else {
        return false
      };
      return (($a = self.$seed()['$=='](other.$seed())) ? self.$state()['$=='](other.$state()) : self.$seed()['$=='](other.$seed()));
    }, TMP_Random_$eq$eq_6.$$arity = 1);
    
    Opal.defn(self, '$bytes', TMP_Random_bytes_8 = function $$bytes(length) {
      var TMP_7, self = this;

      
      length = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](length, Opal.const_get_relative($nesting, 'Integer'), "to_int");
      return $send(length.$times(), 'map', [], (TMP_7 = function(){var self = TMP_7.$$s || this;

      return self.$rand(255).$chr()}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7)).$join().$encode(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'ASCII_8BIT'));
    }, TMP_Random_bytes_8.$$arity = 1);
    return (Opal.defn(self, '$rand', TMP_Random_rand_9 = function $$rand(limit) {
      var self = this;

      
      function randomFloat() {
        self.state++;
        return self.$rng.quick();
      }

      function randomInt() {
        return Math.floor(randomFloat() * limit);
      }

      function randomRange() {
        var min = limit.begin,
            max = limit.end;

        if (min === nil || max === nil) {
          return nil;
        }

        var length = max - min;

        if (length < 0) {
          return nil;
        }

        if (length === 0) {
          return min;
        }

        if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
          length++;
        }

        return self.$rand(length) + min;
      }

      if (limit == null) {
        return randomFloat();
      } else if (limit.$$is_range) {
        return randomRange();
      } else if (limit.$$is_number) {
        if (limit <= 0) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
        }

        if (limit % 1 === 0) {
          // integer
          return randomInt();
        } else {
          return randomFloat() * limit;
        }
      } else {
        limit = Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](limit, Opal.const_get_relative($nesting, 'Integer'), "to_int");

        if (limit <= 0) {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
        }

        return randomInt();
      }
    
    }, TMP_Random_rand_9.$$arity = -1), nil) && 'rand';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["corelib/unsupported"] = function(Opal) {
  var TMP_public_30, TMP_private_31, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module;

  Opal.add_stubs(['$raise', '$warn', '$%']);
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      Opal.const_get_relative($nesting, 'Kernel').$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super, $parent_nesting) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_$lt$lt_1, TMP_String_capitalize$B_2, TMP_String_chomp$B_3, TMP_String_chop$B_4, TMP_String_downcase$B_5, TMP_String_gsub$B_6, TMP_String_lstrip$B_7, TMP_String_next$B_8, TMP_String_reverse$B_9, TMP_String_slice$B_10, TMP_String_squeeze$B_11, TMP_String_strip$B_12, TMP_String_sub$B_13, TMP_String_succ$B_14, TMP_String_swapcase$B_15, TMP_String_tr$B_16, TMP_String_tr_s$B_17, TMP_String_upcase$B_18;

    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";;
    
    Opal.defn(self, '$<<', TMP_String_$lt$lt_1 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("<<"))
    }, TMP_String_$lt$lt_1.$$arity = -1);
    
    Opal.defn(self, '$capitalize!', TMP_String_capitalize$B_2 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("capitalize!"))
    }, TMP_String_capitalize$B_2.$$arity = -1);
    
    Opal.defn(self, '$chomp!', TMP_String_chomp$B_3 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("chomp!"))
    }, TMP_String_chomp$B_3.$$arity = -1);
    
    Opal.defn(self, '$chop!', TMP_String_chop$B_4 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("chop!"))
    }, TMP_String_chop$B_4.$$arity = -1);
    
    Opal.defn(self, '$downcase!', TMP_String_downcase$B_5 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("downcase!"))
    }, TMP_String_downcase$B_5.$$arity = -1);
    
    Opal.defn(self, '$gsub!', TMP_String_gsub$B_6 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("gsub!"))
    }, TMP_String_gsub$B_6.$$arity = -1);
    
    Opal.defn(self, '$lstrip!', TMP_String_lstrip$B_7 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("lstrip!"))
    }, TMP_String_lstrip$B_7.$$arity = -1);
    
    Opal.defn(self, '$next!', TMP_String_next$B_8 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("next!"))
    }, TMP_String_next$B_8.$$arity = -1);
    
    Opal.defn(self, '$reverse!', TMP_String_reverse$B_9 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("reverse!"))
    }, TMP_String_reverse$B_9.$$arity = -1);
    
    Opal.defn(self, '$slice!', TMP_String_slice$B_10 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("slice!"))
    }, TMP_String_slice$B_10.$$arity = -1);
    
    Opal.defn(self, '$squeeze!', TMP_String_squeeze$B_11 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("squeeze!"))
    }, TMP_String_squeeze$B_11.$$arity = -1);
    
    Opal.defn(self, '$strip!', TMP_String_strip$B_12 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("strip!"))
    }, TMP_String_strip$B_12.$$arity = -1);
    
    Opal.defn(self, '$sub!', TMP_String_sub$B_13 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("sub!"))
    }, TMP_String_sub$B_13.$$arity = -1);
    
    Opal.defn(self, '$succ!', TMP_String_succ$B_14 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("succ!"))
    }, TMP_String_succ$B_14.$$arity = -1);
    
    Opal.defn(self, '$swapcase!', TMP_String_swapcase$B_15 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("swapcase!"))
    }, TMP_String_swapcase$B_15.$$arity = -1);
    
    Opal.defn(self, '$tr!', TMP_String_tr$B_16 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("tr!"))
    }, TMP_String_tr$B_16.$$arity = -1);
    
    Opal.defn(self, '$tr_s!', TMP_String_tr_s$B_17 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("tr_s!"))
    }, TMP_String_tr_s$B_17.$$arity = -1);
    return (Opal.defn(self, '$upcase!', TMP_String_upcase$B_18 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), (ERROR)['$%']("upcase!"))
    }, TMP_String_upcase$B_18.$$arity = -1), nil) && 'upcase!';
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var $Kernel, self = $Kernel = $module($base, 'Kernel');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_freeze_19, TMP_Kernel_frozen$q_20;

    
    var ERROR = "Object freezing is not supported by Opal";;
    
    Opal.defn(self, '$freeze', TMP_Kernel_freeze_19 = function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, TMP_Kernel_freeze_19.$$arity = 0);
    
    Opal.defn(self, '$frozen?', TMP_Kernel_frozen$q_20 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, TMP_Kernel_frozen$q_20.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var $Kernel, self = $Kernel = $module($base, 'Kernel');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_taint_21, TMP_Kernel_untaint_22, TMP_Kernel_tainted$q_23;

    
    var ERROR = "Object tainting is not supported by Opal";;
    
    Opal.defn(self, '$taint', TMP_Kernel_taint_21 = function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, TMP_Kernel_taint_21.$$arity = 0);
    
    Opal.defn(self, '$untaint', TMP_Kernel_untaint_22 = function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, TMP_Kernel_untaint_22.$$arity = 0);
    
    Opal.defn(self, '$tainted?', TMP_Kernel_tainted$q_23 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, TMP_Kernel_tainted$q_23.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $Module(){};
    var self = $Module = $klass($base, $super, 'Module', $Module);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Module_public_24, TMP_Module_private_class_method_25, TMP_Module_private_method_defined$q_26, TMP_Module_private_constant_27;

    
    
    Opal.defn(self, '$public', TMP_Module_public_24 = function($a_rest) {
      var self = this, methods;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      methods = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        methods[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      if (methods.length === 0) {
        self.$$module_function = false;
      }

      return nil;
    
    }, TMP_Module_public_24.$$arity = -1);
    Opal.alias(self, "private", "public");
    Opal.alias(self, "protected", "public");
    Opal.alias(self, "nesting", "public");
    
    Opal.defn(self, '$private_class_method', TMP_Module_private_class_method_25 = function $$private_class_method($a_rest) {
      var self = this;

      return self
    }, TMP_Module_private_class_method_25.$$arity = -1);
    Opal.alias(self, "public_class_method", "private_class_method");
    
    Opal.defn(self, '$private_method_defined?', TMP_Module_private_method_defined$q_26 = function(obj) {
      var self = this;

      return false
    }, TMP_Module_private_method_defined$q_26.$$arity = 1);
    
    Opal.defn(self, '$private_constant', TMP_Module_private_constant_27 = function $$private_constant($a_rest) {
      var self = this;

      return nil
    }, TMP_Module_private_constant_27.$$arity = -1);
    Opal.alias(self, "protected_method_defined?", "private_method_defined?");
    Opal.alias(self, "public_instance_methods", "instance_methods");
    return Opal.alias(self, "public_method_defined?", "method_defined?");
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var $Kernel, self = $Kernel = $module($base, 'Kernel');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_private_methods_28;

    
    
    Opal.defn(self, '$private_methods', TMP_Kernel_private_methods_28 = function $$private_methods($a_rest) {
      var self = this;

      return []
    }, TMP_Kernel_private_methods_28.$$arity = -1);
    Opal.alias(self, "private_instance_methods", "private_methods");
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var $Kernel, self = $Kernel = $module($base, 'Kernel');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_eval_29;

    
    Opal.defn(self, '$eval', TMP_Kernel_eval_29 = function($a_rest) {
      var self = this;

      return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), "" + "To use Kernel#eval, you must first require 'opal-parser'. " + ("" + "See https://github.com/opal/opal/blob/" + (Opal.const_get_relative($nesting, 'RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."))
    }, TMP_Kernel_eval_29.$$arity = -1)
  })($nesting[0], $nesting);
  Opal.defs(self, '$public', TMP_public_30 = function($a_rest) {
    var self = this;

    return nil
  }, TMP_public_30.$$arity = -1);
  return Opal.defs(self, '$private', TMP_private_31 = function($a_rest) {
    var self = this;

    return nil
  }, TMP_private_31.$$arity = -1);
};

/* Generated by Opal 0.11.4 */
Opal.modules["opal"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("opal/mini");
  self.$require("corelib/string/inheritance");
  self.$require("corelib/string/encoding");
  self.$require("corelib/math");
  self.$require("corelib/complex");
  self.$require("corelib/rational");
  self.$require("corelib/time");
  self.$require("corelib/struct");
  self.$require("corelib/io");
  self.$require("corelib/main");
  self.$require("corelib/dir");
  self.$require("corelib/file");
  self.$require("corelib/process");
  self.$require("corelib/random");
  return self.$require("corelib/unsupported");
};

/* Generated by Opal 0.11.4 */
Opal.modules["opal-platform"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $truthy = Opal.truthy, browser = nil, node = nil, nashorn = nil, headless_chrome = nil;

  
  browser = typeof(document) !== "undefined";
  node = typeof(process) !== "undefined" && process.versions && process.versions.node;
  nashorn = typeof(Java) !== "undefined" && Java.type;
  headless_chrome = typeof(navigator) !== "undefined" && /\bHeadlessChrome\//.test(navigator.userAgent);
  return (function() {
  if ($truthy(nashorn)) {return Opal.const_set($nesting[0], 'OPAL_PLATFORM', "nashorn")}
  else if ($truthy(node)) {return Opal.const_set($nesting[0], 'OPAL_PLATFORM', "nodejs")}
  else if ($truthy(headless_chrome)) {return Opal.const_set($nesting[0], 'OPAL_PLATFORM', "headless-chrome")}
  else {return Opal.const_set($nesting[0], 'OPAL_PLATFORM', nil)}})();
};

/**
 * this file is updated for zupfnoter-cli such that we have
 *
 * module.exports.Ajv = e();
 */

/* ajv 4.8.2: Another JSON Schema Validator */
!function (e) {
  if ("object" == typeof exports && "undefined" != typeof module) module.exports.Ajv = e(); else if ("function" == typeof define && define.amd) define([], e); else {
    var r;
    r = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, r.Ajv = e()
  }
}(function () {
  var e;
  return function e(r, t, a) {
    function s(i, n) {
      if (!t[i]) {
        if (!r[i]) {
          var l = "function" == typeof require && require;
          if (!n && l) return l(i, !0);
          if (o) return o(i, !0);
          var c = new Error("Cannot find module '" + i + "'");
          throw c.code = "MODULE_NOT_FOUND", c
        }
        var h = t[i] = {exports: {}};
        r[i][0].call(h.exports, function (e) {
          var t = r[i][1][e];
          return s(t ? t : e)
        }, h, h.exports, e, r, t, a)
      }
      return t[i].exports
    }

    for (var o = "function" == typeof require && require, i = 0; i < a.length; i++) s(a[i]);
    return s
  }({
    1: [function (e, r, t) {
      "use strict";

      function a(e, r) {
        r !== !1 && (r = !0);
        var t, s = e.async, o = e.transpile;
        switch (typeof o) {
          case"string":
            var i = m[o];
            if (!i) throw new Error("bad transpiler: " + o);
            return e._transpileFunc = i(e, r);
          case"undefined":
          case"boolean":
            if ("string" == typeof s) {
              if (t = p[s], !t) throw new Error("bad async mode: " + s);
              return e.transpile = t(e, r)
            }
            for (var n = 0; n < v.length; n++) {
              var l = v[n];
              if (a(l, !1)) return d.copy(l, e), e.transpile
            }
            throw new Error("generators, nodent and regenerator are not available");
          case"function":
            return e._transpileFunc = e.transpile;
          default:
            throw new Error("bad transpiler: " + o)
        }
      }

      function s(e, r) {
        try {
          return new Function("(function*(){})()")(), !0
        } catch (e) {
          if (r) throw new Error("generators not supported")
        }
      }

      function o(e, r) {
        try {
          return new Function("(async function(){})()")(), !0
        } catch (e) {
          if (r) throw new Error("es7 async functions not supported")
        }
      }

      function i(r, t) {
        try {
          return u || (u = e("regenerator"), u.runtime()), r.async && r.async !== !0 || (r.async = "es7"), n
        } catch (e) {
          if (t) throw new Error("regenerator not available")
        }
      }

      function n(e) {
        return u.compile(e).code
      }

      function l(r, t) {
        try {
          return f || (f = e("nodent")({
            log: !1,
            dontInstallRequireHook: !0
          })), "es7" != r.async && (r.async && r.async !== !0 && console.warn("nodent transpiles only es7 async functions"), r.async = "es7"), c
        } catch (e) {
          if (t) throw new Error("nodent not available")
        }
      }

      function c(e) {
        return f.compile(e, "", {promises: !0, sourcemap: !1}).code
      }

      function h(e, r) {
        function t(e, r, a) {
          function o(a) {
            function o(a, o) {
              if (a) return r(a);
              if (!s._refs[i] && !s._schemas[i]) try {
                s.addSchema(o, i)
              } catch (e) {
                return void r(e)
              }
              t(e, r)
            }

            var i = a.missingSchema;
            if (s._refs[i] || s._schemas[i]) return r(new Error("Schema " + i + " is loaded but " + a.missingRef + " cannot be resolved"));
            var n = s._loadingSchemas[i];
            n ? "function" == typeof n ? s._loadingSchemas[i] = [n, o] : n[n.length] = o : (s._loadingSchemas[i] = o, s._opts.loadSchema(i, function (e, r) {
              var t = s._loadingSchemas[i];
              if (delete s._loadingSchemas[i], "function" == typeof t) t(e, r); else for (var a = 0; a < t.length; a++) t[a](e, r)
            }))
          }

          function i(e, t) {
            return a ? void setTimeout(function () {
              r(e, t)
            }) : r(e, t)
          }

          var n;
          try {
            n = s.compile(e)
          } catch (e) {
            return void(e.missingSchema ? o(e) : i(e))
          }
          i(null, n)
        }

        var a, s = this;
        try {
          a = this._addSchema(e)
        } catch (e) {
          return void setTimeout(function () {
            r(e)
          })
        }
        if (a.validate) setTimeout(function () {
          r(null, a.validate)
        }); else {
          if ("function" != typeof this._opts.loadSchema) throw new Error("options.loadSchema should be a function");
          t(e, r, !0)
        }
      }

      r.exports = {setup: a, compile: h};
      var u, f, d = e("./compile/util"), p = {"*": s, "co*": s, es7: o}, m = {nodent: l, regenerator: i},
        v = [{async: "co*"}, {async: "es7", transpile: "nodent"}, {async: "co*", transpile: "regenerator"}]
    }, {"./compile/util": 11}], 2: [function (e, r, t) {
      "use strict";
      var a = r.exports = function () {
        this._cache = {}
      };
      a.prototype.put = function (e, r) {
        this._cache[e] = r
      }, a.prototype.get = function (e) {
        return this._cache[e]
      }, a.prototype.del = function (e) {
        delete this._cache[e]
      }, a.prototype.clear = function () {
        this._cache = {}
      }
    }, {}], 3: [function (e, r, t) {
      "use strict";
      r.exports = {
        $ref: e("../dotjs/ref"),
        allOf: e("../dotjs/allOf"),
        anyOf: e("../dotjs/anyOf"),
        dependencies: e("../dotjs/dependencies"),
        enum: e("../dotjs/enum"),
        format: e("../dotjs/format"),
        items: e("../dotjs/items"),
        maximum: e("../dotjs/_limit"),
        minimum: e("../dotjs/_limit"),
        maxItems: e("../dotjs/_limitItems"),
        minItems: e("../dotjs/_limitItems"),
        maxLength: e("../dotjs/_limitLength"),
        minLength: e("../dotjs/_limitLength"),
        maxProperties: e("../dotjs/_limitProperties"),
        minProperties: e("../dotjs/_limitProperties"),
        multipleOf: e("../dotjs/multipleOf"),
        not: e("../dotjs/not"),
        oneOf: e("../dotjs/oneOf"),
        pattern: e("../dotjs/pattern"),
        properties: e("../dotjs/properties"),
        required: e("../dotjs/required"),
        uniqueItems: e("../dotjs/uniqueItems"),
        validate: e("../dotjs/validate")
      }
    }, {
      "../dotjs/_limit": 14,
      "../dotjs/_limitItems": 15,
      "../dotjs/_limitLength": 16,
      "../dotjs/_limitProperties": 17,
      "../dotjs/allOf": 18,
      "../dotjs/anyOf": 19,
      "../dotjs/dependencies": 22,
      "../dotjs/enum": 23,
      "../dotjs/format": 24,
      "../dotjs/items": 25,
      "../dotjs/multipleOf": 26,
      "../dotjs/not": 27,
      "../dotjs/oneOf": 28,
      "../dotjs/pattern": 29,
      "../dotjs/properties": 31,
      "../dotjs/ref": 32,
      "../dotjs/required": 33,
      "../dotjs/uniqueItems": 35,
      "../dotjs/validate": 36
    }], 4: [function (e, r, t) {
      "use strict";
      r.exports = function e(r, t) {
        if (r === t) return !0;
        var a, s = Array.isArray(r), o = Array.isArray(t);
        if (s && o) {
          if (r.length != t.length) return !1;
          for (a = 0; a < r.length; a++) if (!e(r[a], t[a])) return !1;
          return !0
        }
        if (s != o) return !1;
        if (r && t && "object" == typeof r && "object" == typeof t) {
          var i = Object.keys(r);
          if (i.length !== Object.keys(t).length) return !1;
          for (a = 0; a < i.length; a++) if (void 0 === t[i[a]]) return !1;
          for (a = 0; a < i.length; a++) if (!e(r[i[a]], t[i[a]])) return !1;
          return !0
        }
        return !1
      }
    }, {}], 5: [function (e, r, t) {
      "use strict";

      function a(e) {
        e = "full" == e ? "full" : "fast";
        var r = d.copy(a[e]);
        for (var t in a.compare) r[t] = {validate: r[t], compare: a.compare[t]};
        return r
      }

      function s(e) {
        var r = e.match(p);
        if (!r) return !1;
        var t = +r[1], a = +r[2];
        return t >= 1 && t <= 12 && a >= 1 && a <= m[t]
      }

      function o(e, r) {
        var t = e.match(v);
        if (!t) return !1;
        var a = t[1], s = t[2], o = t[3], i = t[5];
        return a <= 23 && s <= 59 && o <= 59 && (!r || i)
      }

      function i(e) {
        var r = e.split(w);
        return 2 == r.length && s(r[0]) && o(r[1], !0)
      }

      function n(e) {
        return e.length <= 255 && y.test(e)
      }

      function l(e) {
        return j.test(e) && g.test(e)
      }

      function c(e) {
        try {
          return new RegExp(e), !0
        } catch (e) {
          return !1
        }
      }

      function h(e, r) {
        if (e && r) return e > r ? 1 : e < r ? -1 : e === r ? 0 : void 0
      }

      function u(e, r) {
        if (e && r && (e = e.match(v), r = r.match(v), e && r)) return e = e[1] + e[2] + e[3] + (e[4] || ""), r = r[1] + r[2] + r[3] + (r[4] || ""), e > r ? 1 : e < r ? -1 : e === r ? 0 : void 0
      }

      function f(e, r) {
        if (e && r) {
          e = e.split(w), r = r.split(w);
          var t = h(e[0], r[0]);
          if (void 0 !== t) return t || u(e[1], r[1])
        }
      }

      var d = e("./util"), p = /^\d\d\d\d-(\d\d)-(\d\d)$/, m = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        v = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i,
        y = /^[0-9a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\.[0-9a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i,
        g = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?(?:\#(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?$/i,
        P = /^(?:urn\:uuid\:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        E = /^(?:\/(?:[^~\/]|~0|~1)+)*(?:\/)?$|^\#(?:\/(?:[a-z0-9_\-\.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)+)*(?:\/)?$/i,
        b = /^(?:0|[1-9][0-9]*)(?:\#|(?:\/(?:[^~\/]|~0|~1)+)*(?:\/)?)$/;
      r.exports = a, a.fast = {
        date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
        time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
        "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
        uri: /^(?:[a-z][a-z0-9+-.]*)?(?:\:|\/)\/?[^\s]*$/i,
        email: /^[a-z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        hostname: y,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: c,
        uuid: P,
        "json-pointer": E,
        "relative-json-pointer": b
      }, a.full = {
        date: s,
        time: o,
        "date-time": i,
        uri: l,
        email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&''*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: n,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: c,
        uuid: P,
        "json-pointer": E,
        "relative-json-pointer": b
      }, a.compare = {date: h, time: u, "date-time": f};
      var w = /t|\s/i, j = /\/|\:/
    }, {"./util": 11}], 6: [function (e, r, t) {
      "use strict";

      function a() {
        if (void 0 === d) try {
          d = e("js-beautify").js_beautify
        } catch (e) {
          d = !1
        }
      }

      function s(e, r, t, n) {
        function j() {
          var e = N.validate, r = e.apply(null, arguments);
          return j.errors = e.errors, r
        }

        function S(e, t, o, i) {
          var n = !t || t && t.schema == e;
          if (t.schema != r.schema) return s.call(k, e, t, o, i);
          var v = e.$async === !0;
          v && !q.transpile && y.setup(q);
          var j = g({
            isTop: !0,
            schema: e,
            isRoot: n,
            baseId: i,
            root: t,
            schemaPath: "",
            errSchemaPath: "#",
            errorPath: '""',
            RULES: H,
            validate: g,
            util: m,
            resolve: p,
            resolveRef: $,
            usePattern: R,
            useDefault: I,
            useCustomRule: A,
            opts: q,
            formats: F,
            self: k
          });
          j = f(L, h) + f(Q, l) + f(U, c) + f(z, u) + j + "return validate;", q.beautify && (a(), d ? j = d(j, q.beautify) : console.error('"npm install js-beautify" to use beautify option'));
          var S, x, _ = q._transpileFunc;
          try {
            x = v && _ ? _(j) : j;
            var O = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "co", "equal", "ucs2length", "ValidationError", x);
            S = O(k, H, F, r, L, U, z, P, b, E, w), L[0] = S
          } catch (e) {
            throw console.error("Error compiling schema, function code:", x), e
          }
          return S.schema = e, S.errors = null, S.refs = D, S.refVal = L, S.root = n ? S : t, v && (S.$async = !0), T && (S.sourceCode = j), q.sourceCode === !0 && (S.source = {
            patterns: Q,
            defaults: U
          }), S
        }

        function $(e, a, o) {
          a = p.url(e, a);
          var i, n, l = D[a];
          if (void 0 !== l) return i = L[l], n = "refVal[" + l + "]", O(i, n);
          if (!o && r.refs) {
            var c = r.refs[a];
            if (void 0 !== c) return i = r.refVal[c], n = x(a, i), O(i, n)
          }
          n = x(a);
          var h = p.call(k, S, r, a);
          if (!h) {
            var u = t && t[a];
            u && (h = p.inlineRef(u, q.inlineRefs) ? u : s.call(k, u, r, t, e))
          }
          return h ? (_(a, h), O(h, n)) : void 0
        }

        function x(e, r) {
          var t = L.length;
          return L[t] = r, D[e] = t, "refVal" + t
        }

        function _(e, r) {
          var t = D[e];
          L[t] = r
        }

        function O(e, r) {
          return "object" == typeof e ? {code: r, schema: e, inline: !0} : {code: r, $async: e && e.$async}
        }

        function R(e) {
          var r = C[e];
          return void 0 === r && (r = C[e] = Q.length, Q[r] = e), "pattern" + r
        }

        function I(e) {
          switch (typeof e) {
            case"boolean":
            case"number":
              return "" + e;
            case"string":
              return m.toQuotedString(e);
            case"object":
              if (null === e) return "null";
              var r = v(e), t = V[r];
              return void 0 === t && (t = V[r] = U.length, U[t] = e), "default" + t
          }
        }

        function A(e, r, t, a) {
          var s = e.definition.validateSchema;
          if (s && k._opts.validateSchema !== !1) {
            var o = s(r);
            if (!o) {
              var i = "keyword schema is invalid: " + k.errorsText(s.errors);
              if ("log" != k._opts.validateSchema) throw new Error(i);
              console.error(i)
            }
          }
          var n, l = e.definition.compile, c = e.definition.inline, h = e.definition.macro;
          l ? n = l.call(k, r, t, a) : h ? (n = h.call(k, r, t, a), q.validateSchema !== !1 && k.validateSchema(n, !0)) : n = c ? c.call(k, a, e.keyword, r, t) : e.definition.validate;
          var u = z.length;
          return z[u] = n, {code: "customRule" + u, validate: n}
        }

        var k = this, q = this._opts, L = [void 0], D = {}, Q = [], C = {}, U = [], V = {}, z = [],
          T = q.sourceCode !== !1;
        r = r || {schema: e, refVal: L, refs: D};
        var M = o.call(this, e, r, n), N = this._compilations[M.index];
        if (M.compiling) return N.callValidate = j;
        var F = this._formats, H = this.RULES;
        try {
          var J = S(e, r, t, n);
          N.validate = J;
          var G = N.callValidate;
          return G && (G.schema = J.schema, G.errors = null, G.refs = J.refs, G.refVal = J.refVal, G.root = J.root, G.$async = J.$async, T && (G.sourceCode = J.sourceCode)), J
        } finally {
          i.call(this, e, r, n)
        }
      }

      function o(e, r, t) {
        var a = n.call(this, e, r, t);
        return a >= 0 ? {index: a, compiling: !0} : (a = this._compilations.length, this._compilations[a] = {
          schema: e,
          root: r,
          baseId: t
        }, {index: a, compiling: !1})
      }

      function i(e, r, t) {
        var a = n.call(this, e, r, t);
        a >= 0 && this._compilations.splice(a, 1)
      }

      function n(e, r, t) {
        for (var a = 0; a < this._compilations.length; a++) {
          var s = this._compilations[a];
          if (s.schema == e && s.root == r && s.baseId == t) return a
        }
        return -1
      }

      function l(e, r) {
        return "var pattern" + e + " = new RegExp(" + m.toQuotedString(r[e]) + ");"
      }

      function c(e) {
        return "var default" + e + " = defaults[" + e + "];"
      }

      function h(e, r) {
        return r[e] ? "var refVal" + e + " = refVal[" + e + "];" : ""
      }

      function u(e) {
        return "var customRule" + e + " = customRules[" + e + "];"
      }

      function f(e, r) {
        if (!e.length) return "";
        for (var t = "", a = 0; a < e.length; a++) t += r(a, e);
        return t
      }

      var d, p = e("./resolve"), m = e("./util"), v = e("json-stable-stringify"), y = e("../async"),
        g = e("../dotjs/validate"), P = e("co"), E = m.ucs2length, b = e("./equal"), w = e("./validation_error");
      r.exports = s
    }, {
      "../async": 1,
      "../dotjs/validate": 36,
      "./equal": 4,
      "./resolve": 7,
      "./util": 11,
      "./validation_error": 12,
      co: 41,
      "json-stable-stringify": 42
    }], 7: [function (e, r, t) {
      "use strict";

      function a(e, r, t) {
        var o = this._refs[t];
        if ("string" == typeof o) {
          if (!this._refs[o]) return a.call(this, e, r, o);
          o = this._refs[o]
        }
        if (o = o || this._schemas[t], o instanceof g) return n(o.schema, this._opts.inlineRefs) ? o.schema : o.validate || this._compile(o);
        var i, l, c, h = s.call(this, r, t);
        return h && (i = h.schema, r = h.root, c = h.baseId), i instanceof g ? l = i.validate || e.call(this, i.schema, r, void 0, c) : i && (l = n(i, this._opts.inlineRefs) ? i : e.call(this, i, r, void 0, c)), l
      }

      function s(e, r) {
        var t = m.parse(r, !1, !0), a = u(t), s = h(e.schema.id);
        if (a !== s) {
          var n = f(a), l = this._refs[n];
          if ("string" == typeof l) return o.call(this, e, l, t);
          if (l instanceof g) l.validate || this._compile(l), e = l; else {
            if (l = this._schemas[n], !(l instanceof g)) return;
            if (l.validate || this._compile(l), n == f(r)) return {schema: l, root: e, baseId: s};
            e = l
          }
          if (!e.schema) return;
          s = h(e.schema.id)
        }
        return i.call(this, t, s, e.schema, e)
      }

      function o(e, r, t) {
        var a = s.call(this, e, r);
        if (a) {
          var o = a.schema, n = a.baseId;
          return e = a.root, o.id && (n = d(n, o.id)), i.call(this, t, n, o, e)
        }
      }

      function i(e, r, t, a) {
        if (e.hash = e.hash || "", "#/" == e.hash.slice(0, 2)) {
          for (var o = e.hash.split("/"), i = 1; i < o.length; i++) {
            var n = o[i];
            if (n) {
              if (n = y.unescapeFragment(n), t = t[n], !t) break;
              if (t.id && !P[n] && (r = d(r, t.id)), t.$ref) {
                var l = d(r, t.$ref), c = s.call(this, a, l);
                c && (t = c.schema, a = c.root, r = c.baseId)
              }
            }
          }
          return t && t != a.schema ? {schema: t, root: a, baseId: r} : void 0
        }
      }

      function n(e, r) {
        return r !== !1 && (void 0 === r || r === !0 ? l(e) : r ? c(e) <= r : void 0)
      }

      function l(e) {
        var r;
        if (Array.isArray(e)) {
          for (var t = 0; t < e.length; t++) if (r = e[t], "object" == typeof r && !l(r)) return !1
        } else for (var a in e) {
          if ("$ref" == a) return !1;
          if (r = e[a], "object" == typeof r && !l(r)) return !1
        }
        return !0
      }

      function c(e) {
        var r, t = 0;
        if (Array.isArray(e)) {
          for (var a = 0; a < e.length; a++) if (r = e[a], "object" == typeof r && (t += c(r)), t == 1 / 0) return 1 / 0
        } else for (var s in e) {
          if ("$ref" == s) return 1 / 0;
          if (E[s]) t++; else if (r = e[s], "object" == typeof r && (t += c(r) + 1), t == 1 / 0) return 1 / 0
        }
        return t
      }

      function h(e, r) {
        r !== !1 && (e = f(e));
        var t = m.parse(e, !1, !0);
        return u(t)
      }

      function u(e) {
        var r = e.protocol || "//" == e.href.slice(0, 2) ? "//" : "";
        return (e.protocol || "") + r + (e.host || "") + (e.path || "") + "#"
      }

      function f(e) {
        return e ? e.replace(b, "") : ""
      }

      function d(e, r) {
        return r = f(r), m.resolve(e, r)
      }

      function p(e) {
        function r(e, t, s) {
          if (Array.isArray(e)) for (var o = 0; o < e.length; o++) r.call(this, e[o], t + "/" + o, s); else if (e && "object" == typeof e) {
            if ("string" == typeof e.id) {
              var i = s = s ? m.resolve(s, e.id) : e.id;
              i = f(i);
              var n = this._refs[i];
              if ("string" == typeof n && (n = this._refs[n]), n && n.schema) {
                if (!v(e, n.schema)) throw new Error('id "' + i + '" resolves to more than one schema')
              } else if (i != f(t)) if ("#" == i[0]) {
                if (a[i] && !v(e, a[i])) throw new Error('id "' + i + '" resolves to more than one schema');
                a[i] = e
              } else this._refs[i] = t
            }
            for (var l in e) r.call(this, e[l], t + "/" + y.escapeFragment(l), s)
          }
        }

        var t = f(e.id), a = {};
        return r.call(this, e, h(t, !1), t), a
      }

      var m = e("url"), v = e("./equal"), y = e("./util"), g = e("./schema_obj");
      r.exports = a, a.normalizeId = f, a.fullPath = h, a.url = d, a.ids = p, a.inlineRef = n, a.schema = s;
      var P = y.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]),
        E = y.toHash(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum"]),
        b = /#\/?$/
    }, {"./equal": 4, "./schema_obj": 9, "./util": 11, url: 50}], 8: [function (e, r, t) {
      "use strict";
      var a = e("./_rules"), s = e("./util").toHash;
      r.exports = function () {
        var e = [{type: "number", rules: ["maximum", "minimum", "multipleOf"]}, {
            type: "string",
            rules: ["maxLength", "minLength", "pattern", "format"]
          }, {type: "array", rules: ["maxItems", "minItems", "uniqueItems", "items"]}, {
            type: "object",
            rules: ["maxProperties", "minProperties", "required", "dependencies", "properties"]
          }, {rules: ["$ref", "enum", "not", "anyOf", "oneOf", "allOf"]}],
          r = ["type", "additionalProperties", "patternProperties"],
          t = ["additionalItems", "$schema", "id", "title", "description", "default"],
          o = ["number", "integer", "string", "array", "object", "boolean", "null"];
        return e.all = s(r), e.forEach(function (t) {
          t.rules = t.rules.map(function (t) {
            r.push(t);
            var s = e.all[t] = {keyword: t, code: a[t]};
            return s
          })
        }), e.keywords = s(r.concat(t)), e.types = s(o), e.custom = {}, e
      }
    }, {"./_rules": 3, "./util": 11}], 9: [function (e, r, t) {
      "use strict";

      function a(e) {
        s.copy(e, this)
      }

      var s = e("./util");
      r.exports = a
    }, {"./util": 11}], 10: [function (e, r, t) {
      "use strict";
      r.exports = function (e) {
        for (var r, t = 0, a = e.length, s = 0; s < a;) t++, r = e.charCodeAt(s++), r >= 55296 && r <= 56319 && s < a && (r = e.charCodeAt(s), 56320 == (64512 & r) && s++);
        return t
      }
    }, {}], 11: [function (e, r, t) {
      "use strict";

      function a(e, r) {
        r = r || {};
        for (var t in e) r[t] = e[t];
        return r
      }

      function s(e, r, t) {
        var a = t ? " !== " : " === ", s = t ? " || " : " && ", o = t ? "!" : "", i = t ? "" : "!";
        switch (e) {
          case"null":
            return r + a + "null";
          case"array":
            return o + "Array.isArray(" + r + ")";
          case"object":
            return "(" + o + r + s + "typeof " + r + a + '"object"' + s + i + "Array.isArray(" + r + "))";
          case"integer":
            return "(typeof " + r + a + '"number"' + s + i + "(" + r + " % 1)" + s + r + a + r + ")";
          default:
            return "typeof " + r + a + '"' + e + '"'
        }
      }

      function o(e, r) {
        switch (e.length) {
          case 1:
            return s(e[0], r, !0);
          default:
            var t = "", a = n(e);
            a.array && a.object && (t = a.null ? "(" : "(!" + r + " || ", t += "typeof " + r + ' !== "object")', delete a.null, delete a.array, delete a.object), a.number && delete a.integer;
            for (var o in a) t += (t ? " && " : "") + s(o, r, !0);
            return t
        }
      }

      function i(e, r) {
        if (Array.isArray(r)) {
          for (var t = [], a = 0; a < r.length; a++) {
            var s = r[a];
            $[s] ? t[t.length] = s : "array" === e && "array" === s && (t[t.length] = s)
          }
          if (t.length) return t
        } else {
          if ($[r]) return [r];
          if ("array" === e && "array" === r) return ["array"]
        }
      }

      function n(e) {
        for (var r = {}, t = 0; t < e.length; t++) r[e[t]] = !0;
        return r
      }

      function l(e) {
        return "number" == typeof e ? "[" + e + "]" : x.test(e) ? "." + e : "['" + c(e) + "']"
      }

      function c(e) {
        return e.replace(_, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t")
      }

      function h(e, r) {
        r += "[^0-9]";
        var t = e.match(new RegExp(r, "g"));
        return t ? t.length : 0
      }

      function u(e, r, t) {
        return r += "([^0-9])", t = t.replace(/\$/g, "$$$$"), e.replace(new RegExp(r, "g"), t + "$1")
      }

      function f(e) {
        return e.replace(O, "").replace(R, "").replace(I, "if (!($1))")
      }

      function d(e, r) {
        var t = e.match(A);
        return t && 2 === t.length ? r ? e.replace(q, "").replace(Q, C) : e.replace(k, "").replace(L, D) : e
      }

      function p(e, r) {
        for (var t in e) if (r[t]) return !0
      }

      function m(e, r, t) {
        for (var a in e) if (a != t && r[a]) return !0
      }

      function v(e) {
        return "'" + c(e) + "'"
      }

      function y(e, r, t, a) {
        var s = t ? "'/' + " + r + (a ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : a ? "'[' + " + r + " + ']'" : "'[\\'' + " + r + " + '\\']'";
        return E(e, s)
      }

      function g(e, r, t) {
        var a = v(t ? "/" + j(r) : l(r));
        return E(e, a)
      }

      function P(e, r, t) {
        var a, s, o, i;
        if ("" === e) return "rootData";
        if ("/" == e[0]) {
          if (!U.test(e)) throw new Error("Invalid JSON-pointer: " + e);
          s = e, o = "rootData"
        } else {
          if (i = e.match(V), !i) throw new Error("Invalid JSON-pointer: " + e);
          if (a = +i[1], s = i[2], "#" == s) {
            if (a >= r) throw new Error("Cannot access property/index " + a + " levels up, current level is " + r);
            return t[r - a]
          }
          if (a > r) throw new Error("Cannot access data " + a + " levels up, current level is " + r);
          if (o = "data" + (r - a || ""), !s) return o
        }
        for (var n = o, c = s.split("/"), h = 0; h < c.length; h++) {
          var u = c[h];
          u && (o += l(S(u)), n += " && " + o)
        }
        return n
      }

      function E(e, r) {
        return '""' == e ? r : (e + " + " + r).replace(/' \+ '/g, "")
      }

      function b(e) {
        return S(decodeURIComponent(e))
      }

      function w(e) {
        return encodeURIComponent(j(e))
      }

      function j(e) {
        return e.replace(/~/g, "~0").replace(/\//g, "~1")
      }

      function S(e) {
        return e.replace(/~1/g, "/").replace(/~0/g, "~")
      }

      r.exports = {
        copy: a,
        checkDataType: s,
        checkDataTypes: o,
        coerceToTypes: i,
        toHash: n,
        getProperty: l,
        escapeQuotes: c,
        ucs2length: e("./ucs2length"),
        varOccurences: h,
        varReplace: u,
        cleanUpCode: f,
        cleanUpVarErrors: d,
        schemaHasRules: p,
        schemaHasRulesExcept: m,
        stableStringify: e("json-stable-stringify"),
        toQuotedString: v,
        getPathExpr: y,
        getPath: g,
        getData: P,
        unescapeFragment: b,
        escapeFragment: w,
        escapeJsonPointer: j
      };
      var $ = n(["string", "number", "integer", "boolean", "null"]), x = /^[a-z$_][a-z$_0-9]*$/i, _ = /'|\\/g,
        O = /else\s*{\s*}/g, R = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g,
        I = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g, A = /[^v\.]errors/g,
        k = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g,
        q = /var errors = 0;|var vErrors = null;/g, L = "return errors === 0;",
        D = "validate.errors = null; return true;",
        Q = /if \(errors === 0\) return true;\s*else throw new ValidationError\(vErrors\);/, C = "return true;",
        U = /^\/(?:[^~]|~0|~1)*$/, V = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/
    }, {"./ucs2length": 10, "json-stable-stringify": 42}], 12: [function (e, r, t) {
      "use strict";

      function a(e) {
        this.message = "validation failed", this.errors = e, this.ajv = this.validation = !0
      }

      r.exports = a, a.prototype = Object.create(Error.prototype), a.prototype.constructor = a
    }, {}], 13: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || ""), u = "valid" + s;
        if (a += "var " + u + " = undefined;", e.opts.format === !1) return a += " " + u + " = true; ";
        var f = e.schema.format, d = e.opts.v5 && f.$data, p = "";
        if (d) {
          var m = e.util.getData(f.$data, o, e.dataPathArr), v = "format" + s, y = "compare" + s;
          a += " var " + v + " = formats[" + m + "] , " + y + " = " + v + " && " + v + ".compare;"
        } else {
          var v = e.formats[f];
          if (!v || !v.compare) return a += "  " + u + " = true; ";
          var y = "formats" + e.util.getProperty(f) + ".compare"
        }
        var g, P = "formatMaximum" == r, E = "formatExclusive" + (P ? "Maximum" : "Minimum"), b = e.schema[E],
          w = e.opts.v5 && b && b.$data, j = P ? "<" : ">", S = "result" + s, $ = e.opts.v5 && i && i.$data;
        if ($ ? (a += " var schema" + s + " = " + e.util.getData(i.$data, o, e.dataPathArr) + "; ", g = "schema" + s) : g = i, w) {
          var x = e.util.getData(b.$data, o, e.dataPathArr), _ = "exclusive" + s, O = "op" + s, R = "' + " + O + " + '";
          a += " var schemaExcl" + s + " = " + x + "; ", x = "schemaExcl" + s, a += " if (typeof " + x + " != 'boolean' && " + x + " !== undefined) { " + u + " = false; ";
          var t = E, I = I || [];
          I.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "_formatExclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: {} ", e.opts.messages !== !1 && (a += " , message: '" + E + " should be boolean' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
          var A = a;
          a = I.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + A + "]); " : " validate.errors = [" + A + "]; return false; " : " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", a += " }  ", c && (p += "}", a += " else { "), $ && (a += " if (" + g + " === undefined) " + u + " = true; else if (typeof " + g + " != 'string') " + u + " = false; else { ", p += "}"), d && (a += " if (!" + y + ") " + u + " = true; else { ", p += "}"), a += " var " + S + " = " + y + "(" + h + ",  ", a += $ ? "" + g : "" + e.util.toQuotedString(i), a += " ); if (" + S + " === undefined) " + u + " = false; var " + _ + " = " + x + " === true; if (" + u + " === undefined) { " + u + " = " + _ + " ? " + S + " " + j + " 0 : " + S + " " + j + "= 0; } if (!" + u + ") var op" + s + " = " + _ + " ? '" + j + "' : '" + j + "=';"
        } else {
          var _ = b === !0, R = j;
          _ || (R += "=");
          var O = "'" + R + "'";
          $ && (a += " if (" + g + " === undefined) " + u + " = true; else if (typeof " + g + " != 'string') " + u + " = false; else { ", p += "}"), d && (a += " if (!" + y + ") " + u + " = true; else { ", p += "}"), a += " var " + S + " = " + y + "(" + h + ",  ", a += $ ? "" + g : "" + e.util.toQuotedString(i), a += " ); if (" + S + " === undefined) " + u + " = false; if (" + u + " === undefined) " + u + " = " + S + " " + j, _ || (a += "="), a += " 0;"
        }
        a += "" + p + "if (!" + u + ") { ";
        var t = r, I = I || [];
        I.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "_formatLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { comparison: " + O + ", limit:  ", a += $ ? "" + g : "" + e.util.toQuotedString(i), a += " , exclusive: " + _ + " } ", e.opts.messages !== !1 && (a += " , message: 'should be " + R + ' "', a += $ ? "' + " + g + " + '" : "" + e.util.escapeQuotes(i), a += "\"' "), e.opts.verbose && (a += " , schema:  ", a += $ ? "validate.schema" + n : "" + e.util.toQuotedString(i), a += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
        var A = a;
        return a = I.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + A + "]); " : " validate.errors = [" + A + "]; return false; " : " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", a += "}"
      }
    }, {}], 14: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = e.opts.v5 && n && n.$data;
        f ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n;
        var d = "maximum" == r, p = d ? "exclusiveMaximum" : "exclusiveMinimum", m = e.schema[p],
          v = e.opts.v5 && m && m.$data, y = d ? "<" : ">", g = d ? ">" : "<";
        if (v) {
          var P = e.util.getData(m.$data, i, e.dataPathArr), E = "exclusive" + o, b = "op" + o, w = "' + " + b + " + '";
          s += " var schemaExcl" + o + " = " + P + "; ", P = "schemaExcl" + o, s += " var exclusive" + o + "; if (typeof " + P + " != 'boolean' && typeof " + P + " != 'undefined') { ";
          var t = p, j = j || [];
          j.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: {} ", e.opts.messages !== !1 && (s += " , message: '" + p + " should be boolean' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
          var S = s;
          s = j.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + S + "]); " : " validate.errors = [" + S + "]; return false; " : " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } else if( ", f && (s += " (" + a + " !== undefined && typeof " + a + " != 'number') || "), s += " ((exclusive" + o + " = " + P + " === true) ? " + u + " " + g + "= " + a + " : " + u + " " + g + " " + a + ") || " + u + " !== " + u + ") { var op" + o + " = exclusive" + o + " ? '" + y + "' : '" + y + "=';"
        } else {
          var E = m === !0, w = y;
          E || (w += "=");
          var b = "'" + w + "'";
          s += " if ( ", f && (s += " (" + a + " !== undefined && typeof " + a + " != 'number') || "), s += " " + u + " " + g, E && (s += "="), s += " " + a + " || " + u + " !== " + u + ") {"
        }
        var t = r, j = j || [];
        j.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "_limit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { comparison: " + b + ", limit: " + a + ", exclusive: " + E + " } ", e.opts.messages !== !1 && (s += " , message: 'should be " + w + " ", s += f ? "' + " + a : "" + n + "'"), e.opts.verbose && (s += " , schema:  ", s += f ? "validate.schema" + l : "" + n, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var S = s;
        return s = j.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + S + "]); " : " validate.errors = [" + S + "]; return false; " : " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } ", h && (s += " else { "), s
      }
    }, {}], 15: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = e.opts.v5 && n && n.$data;
        f ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n;
        var d = "maxItems" == r ? ">" : "<";
        s += "if ( ", f && (s += " (" + a + " !== undefined && typeof " + a + " != 'number') || "), s += " " + u + ".length " + d + " " + a + ") { ";
        var t = r, p = p || [];
        p.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "_limitItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { limit: " + a + " } ", e.opts.messages !== !1 && (s += " , message: 'should NOT have ", s += "maxItems" == r ? "more" : "less", s += " than ", s += f ? "' + " + a + " + '" : "" + n, s += " items' "), e.opts.verbose && (s += " , schema:  ", s += f ? "validate.schema" + l : "" + n, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var m = s;
        return s = p.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + m + "]); " : " validate.errors = [" + m + "]; return false; " : " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", h && (s += " else { "), s
      }
    }, {}], 16: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = e.opts.v5 && n && n.$data;
        f ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n;
        var d = "maxLength" == r ? ">" : "<";
        s += "if ( ", f && (s += " (" + a + " !== undefined && typeof " + a + " != 'number') || "), s += e.opts.unicode === !1 ? " " + u + ".length " : " ucs2length(" + u + ") ", s += " " + d + " " + a + ") { ";
        var t = r, p = p || [];
        p.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "_limitLength") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { limit: " + a + " } ", e.opts.messages !== !1 && (s += " , message: 'should NOT be ", s += "maxLength" == r ? "longer" : "shorter", s += " than ", s += f ? "' + " + a + " + '" : "" + n, s += " characters' "), e.opts.verbose && (s += " , schema:  ", s += f ? "validate.schema" + l : "" + n, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var m = s;
        return s = p.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + m + "]); " : " validate.errors = [" + m + "]; return false; " : " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
          s += "} ", h && (s += " else { "), s
      }
    }, {}], 17: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = e.opts.v5 && n && n.$data;
        f ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n;
        var d = "maxProperties" == r ? ">" : "<";
        s += "if ( ", f && (s += " (" + a + " !== undefined && typeof " + a + " != 'number') || "), s += " Object.keys(" + u + ").length " + d + " " + a + ") { ";
        var t = r, p = p || [];
        p.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { limit: " + a + " } ", e.opts.messages !== !1 && (s += " , message: 'should NOT have ", s += "maxProperties" == r ? "more" : "less", s += " than ", s += f ? "' + " + a + " + '" : "" + n, s += " properties' "), e.opts.verbose && (s += " , schema:  ", s += f ? "validate.schema" + l : "" + n, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var m = s;
        return s = p.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + m + "]); " : " validate.errors = [" + m + "]; return false; " : " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", h && (s += " else { "), s
      }
    }, {}], 18: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t = " ", a = e.schema[r], s = e.schemaPath + "." + r, o = e.errSchemaPath + "/" + r, i = !e.opts.allErrors,
          n = e.util.copy(e), l = "";
        n.level++;
        var c = n.baseId, h = a;
        if (h) for (var u, f = -1, d = h.length - 1; f < d;) u = h[f += 1], e.util.schemaHasRules(u, e.RULES.all) && (n.schema = u, n.schemaPath = s + "[" + f + "]", n.errSchemaPath = o + "/" + f, t += "  " + e.validate(n) + " ", n.baseId = c, i && (t += " if (valid" + n.level + ") { ", l += "}"));
        return i && (t += " " + l.slice(0, -1)), t = e.util.cleanUpCode(t)
      }
    }, {}], 19: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || ""), u = "valid" + s,
          f = "errs__" + s, d = e.util.copy(e), p = "";
        d.level++;
        var m = i.every(function (r) {
          return e.util.schemaHasRules(r, e.RULES.all)
        });
        if (m) {
          var v = d.baseId;
          a += " var " + f + " = errors; var " + u + " = false;  ";
          var y = e.compositeRule;
          e.compositeRule = d.compositeRule = !0;
          var g = i;
          if (g) for (var P, E = -1, b = g.length - 1; E < b;) P = g[E += 1], d.schema = P, d.schemaPath = n + "[" + E + "]", d.errSchemaPath = l + "/" + E, a += "  " + e.validate(d) + " ", d.baseId = v, a += " " + u + " = " + u + " || valid" + d.level + "; if (!" + u + ") { ", p += "}";
          e.compositeRule = d.compositeRule = y, a += " " + p + " if (!" + u + ") {  var err =   ", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "anyOf") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: {} ", e.opts.messages !== !1 && (a += " , message: 'should match some schema in anyOf' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ", a += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else {  errors = " + f + "; if (vErrors !== null) { if (" + f + ") vErrors.length = " + f + "; else vErrors = null; } ", e.opts.allErrors && (a += " } "), a = e.util.cleanUpCode(a)
        } else c && (a += " if (true) { ");
        return a
      }
    }, {}], 20: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = "valid" + o,
          d = e.opts.v5 && n && n.$data;
        d ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n, d || (s += " var schema" + o + " = validate.schema" + l + ";"), s += "var " + f + " = equal(" + u + ", schema" + o + "); if (!" + f + ") {   ";
        var p = p || [];
        p.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "constant") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: {} ", e.opts.messages !== !1 && (s += " , message: 'should be equal to constant' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var m = s;
        return s = p.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + m + "]); " : " validate.errors = [" + m + "]; return false; " : " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " }"
      }
    }, {}], 21: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = "errs__" + o,
          d = e.opts.v5 && n && n.$data;
        d ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n;
        var p, m, v, y, g, P = this, E = "definition" + o, b = P.definition;
        if (d && b.$data) {
          g = "keywordValidate" + o;
          var w = b.validateSchema;
          s += " var " + E + " = RULES.custom['" + r + "'].definition; var " + g + " = " + E + ".validate;"
        } else y = e.useCustomRule(P, n, e.schema, e), a = "validate.schema" + l, g = y.code, p = b.compile, m = b.inline, v = b.macro;
        var j = g + ".errors", S = "i" + o, $ = "ruleErr" + o, x = b.async;
        if (x && !e.async) throw new Error("async keyword in sync schema");
        if (m || v || (s += "" + j + " = null;"), s += "var " + f + " = errors;var valid" + o + ";", m && b.statements) s += " " + y.validate; else if (v) {
          var _ = e.util.copy(e);
          _.level++, _.schema = y.validate, _.schemaPath = "";
          var O = e.compositeRule;
          e.compositeRule = _.compositeRule = !0;
          var R = e.validate(_).replace(/validate\.schema/g, g);
          e.compositeRule = _.compositeRule = O, s += " " + R
        } else if (!m) {
          var I = I || [];
          I.push(s), s = "", s += "  " + g + ".call( ", s += e.opts.passContext ? "this" : "self", s += p || b.schema === !1 ? " , " + u + " " : " , " + a + " , " + u + " , validate.schema" + e.schemaPath + " ", s += " , (dataPath || '')", '""' != e.errorPath && (s += " + " + e.errorPath), s += i ? " , data" + (i - 1 || "") + " , " + e.dataPathArr[i] + " " : " , parentData , parentDataProperty ", s += " , rootData )  ";
          var A = s;
          s = I.pop(), b.errors !== !1 && (x ? (j = "customErrors" + o, s += " var " + j + " = null; try { valid" + o + " = " + e.yieldAwait + A + "; } catch (e) { valid" + o + " = false; if (e instanceof ValidationError) " + j + " = e.errors; else throw e; } ") : s += " " + g + ".errors = null; ")
        }
        s += "if (", w && (s += " !" + E + ".validateSchema(" + a + ") || "), s += " ! ", s += m ? b.statements ? " valid" + o + " " : " (" + y.validate + ") " : v ? " valid" + _.level + " " : x ? b.errors === !1 ? " (" + e.yieldAwait + A + ") " : " valid" + o + " " : " " + A + " ", s += ") { ", t = P.keyword;
        var I = I || [];
        I.push(s), s = "";
        var I = I || [];
        I.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { keyword: '" + P.keyword + "' } ", e.opts.messages !== !1 && (s += " , message: 'should pass \"" + P.keyword + "\" keyword validation' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var k = s;
        s = I.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + k + "]); " : " validate.errors = [" + k + "]; return false; " : " var err = " + k + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        var q = s;
        return s = I.pop(), m ? b.errors ? "full" != b.errors && (s += "  for (var " + S + "=" + f + "; " + S + "<errors; " + S + "++) { var " + $ + " = vErrors[" + S + "]; if (" + $ + ".dataPath === undefined) { " + $ + ".dataPath = (dataPath || '') + " + e.errorPath + "; } if (" + $ + ".schemaPath === undefined) { " + $ + '.schemaPath = "' + c + '"; } ', e.opts.verbose && (s += " " + $ + ".schema = " + a + "; " + $ + ".data = " + u + "; "), s += " } ") : b.errors === !1 ? s += " " + q + " " : (s += " if (" + f + " == errors) { " + q + " } else {  for (var " + S + "=" + f + "; " + S + "<errors; " + S + "++) { var " + $ + " = vErrors[" + S + "]; if (" + $ + ".dataPath === undefined) { " + $ + ".dataPath = (dataPath || '') + " + e.errorPath + "; } if (" + $ + ".schemaPath === undefined) { " + $ + '.schemaPath = "' + c + '"; } ', e.opts.verbose && (s += " " + $ + ".schema = " + a + "; " + $ + ".data = " + u + "; "), s += " } } ") : v ? (s += "   var err =   ", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { keyword: '" + P.keyword + "' } ", e.opts.messages !== !1 && (s += " , message: 'should pass \"" + P.keyword + "\" keyword validation' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && h && (s += e.async ? " throw new ValidationError(vErrors); " : " validate.errors = vErrors; return false ")) : b.errors === !1 ? s += " " + q + " " : (s += " if (Array.isArray(" + j + ")) { if (vErrors === null) vErrors = " + j + "; else vErrors = vErrors.concat(" + j + "); errors = vErrors.length;  for (var " + S + "=" + f + "; " + S + "<errors; " + S + "++) { var " + $ + " = vErrors[" + S + "];  " + $ + ".dataPath = (dataPath || '') + " + e.errorPath + ";   " + $ + '.schemaPath = "' + c + '";  ', e.opts.verbose && (s += " " + $ + ".schema = " + a + "; " + $ + ".data = " + u + "; "), s += " } } else { " + q + " } "), s += " } ", h && (s += " else { "), s
      }
    }, {}], 22: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || ""), u = "errs__" + s,
          f = e.util.copy(e), d = "";
        f.level++;
        var p = {}, m = {};
        for (P in i) {
          var v = i[P], y = Array.isArray(v) ? m : p;
          y[P] = v
        }
        a += "var " + u + " = errors;";
        var g = e.errorPath;
        a += "var missing" + s + ";";
        for (var P in m) {
          if (y = m[P], a += " if (" + h + e.util.getProperty(P) + " !== undefined ", c) {
            a += " && ( ";
            var E = y;
            if (E) for (var b, w = -1, j = E.length - 1; w < j;) {
              b = E[w += 1], w && (a += " || ");
              var S = e.util.getProperty(b);
              a += " ( " + h + S + " === undefined && (missing" + s + " = " + e.util.toQuotedString(e.opts.jsonPointers ? b : S) + ") ) "
            }
            a += ")) {  ";
            var $ = "missing" + s, x = "' + " + $ + " + '";
            e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(g, $, !0) : g + " + " + $);
            var _ = _ || [];
            _.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "dependencies") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { property: '" + e.util.escapeQuotes(P) + "', missingProperty: '" + x + "', depsCount: " + y.length + ", deps: '" + e.util.escapeQuotes(1 == y.length ? y[0] : y.join(", ")) + "' } ", e.opts.messages !== !1 && (a += " , message: 'should have ", a += 1 == y.length ? "property " + e.util.escapeQuotes(y[0]) : "properties " + e.util.escapeQuotes(y.join(", ")), a += " when property " + e.util.escapeQuotes(P) + " is present' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
            var O = a;
            a = _.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + O + "]); " : " validate.errors = [" + O + "]; return false; " : " var err = " + O + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
          } else {
            a += " ) { ";
            var R = y;
            if (R) for (var I, A = -1, k = R.length - 1; A < k;) {
              I = R[A += 1];
              var S = e.util.getProperty(I), x = e.util.escapeQuotes(I);
              e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(g, I, e.opts.jsonPointers)), a += " if (" + h + S + " === undefined) {  var err =   ", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "dependencies") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { property: '" + e.util.escapeQuotes(P) + "', missingProperty: '" + x + "', depsCount: " + y.length + ", deps: '" + e.util.escapeQuotes(1 == y.length ? y[0] : y.join(", ")) + "' } ", e.opts.messages !== !1 && (a += " , message: 'should have ", a += 1 == y.length ? "property " + e.util.escapeQuotes(y[0]) : "properties " + e.util.escapeQuotes(y.join(", ")), a += " when property " + e.util.escapeQuotes(P) + " is present' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ", a += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "
            }
          }
          a += " }   ", c && (d += "}", a += " else { ")
        }
        e.errorPath = g;
        var q = f.baseId;
        for (var P in p) {
          var v = p[P];
          e.util.schemaHasRules(v, e.RULES.all) && (a += " valid" + f.level + " = true; if (" + h + "['" + P + "'] !== undefined) { ", f.schema = v, f.schemaPath = n + e.util.getProperty(P), f.errSchemaPath = l + "/" + e.util.escapeFragment(P), a += "  " + e.validate(f) + " ", f.baseId = q, a += " }  ", c && (a += " if (valid" + f.level + ") { ", d += "}"))
        }
        return c && (a += "   " + d + " if (" + u + " == errors) {"), a = e.util.cleanUpCode(a)
      }
    }, {}], 23: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = "valid" + o,
          d = e.opts.v5 && n && n.$data;
        d ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n;
        var p = "i" + o;
        d || (s += " var schema" + o + " = validate.schema" + l + ";"), s += "var " + f + ";", d && (s += " if (schema" + o + " === undefined) " + f + " = true; else if (!Array.isArray(schema" + o + ")) " + f + " = false; else {"), s += "" + f + " = false;for (var " + p + "=0; " + p + "<schema" + o + ".length; " + p + "++) if (equal(" + u + ", schema" + o + "[" + p + "])) { " + f + " = true; break; }", d && (s += "  }  "), s += " if (!" + f + ") {   ";
        var m = m || [];
        m.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "enum") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { allowedValues: schema" + o + " } ", e.opts.messages !== !1 && (s += " , message: 'should be equal to one of the allowed values' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var v = s;
        return s = m.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + v + "]); " : " validate.errors = [" + v + "]; return false; " : " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " }", h && (s += " else { "), s
      }
    }, {}], 24: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || "");
        if (e.opts.format === !1) return c && (a += " if (true) { "), a;
        var u, f = e.opts.v5 && i && i.$data;
        f ? (a += " var schema" + s + " = " + e.util.getData(i.$data, o, e.dataPathArr) + "; ", u = "schema" + s) : u = i;
        var d = e.opts.unknownFormats, p = Array.isArray(d);
        if (f) {
          var m = "format" + s;
          a += " var " + m + " = formats[" + u + "]; var isObject" + s + " = typeof " + m + " == 'object' && !(" + m + " instanceof RegExp) && " + m + ".validate; if (isObject" + s + ") { ", e.async && (a += " var async" + s + " = " + m + ".async; "), a += " " + m + " = " + m + ".validate; } if (  ", f && (a += " (" + u + " !== undefined && typeof " + u + " != 'string') || "), a += " (", (d === !0 || p) && (a += " (" + u + " && !" + m + " ", p && (a += " && self._opts.unknownFormats.indexOf(" + u + ") == -1 "), a += ") || "), a += " (" + m + " && !(typeof " + m + " == 'function' ? ", a += e.async ? " (async" + s + " ? " + e.yieldAwait + " " + m + "(" + h + ") : " + m + "(" + h + ")) " : " " + m + "(" + h + ") ", a += " : " + m + ".test(" + h + "))))) {"
        } else {
          var m = e.formats[i];
          if (!m) {
            if (d === !0 || p && d.indexOf(i) == -1) throw new Error('unknown format "' + i + '" is used in schema at path "' + e.errSchemaPath + '"');
            return p || (console.warn('unknown format "' + i + '" ignored in schema at path "' + e.errSchemaPath + '"'), "ignore" !== d && console.warn("In the next major version it will throw exception. See option unknownFormats for more information")), c && (a += " if (true) { "), a
          }
          var v = "object" == typeof m && !(m instanceof RegExp) && m.validate;
          if (v) {
            var y = m.async === !0;
            m = m.validate
          }
          if (y) {
            if (!e.async) throw new Error("async format in sync schema");
            var g = "formats" + e.util.getProperty(i) + ".validate";
            a += " if (!(" + e.yieldAwait + " " + g + "(" + h + "))) { "
          } else {
            a += " if (! ";
            var g = "formats" + e.util.getProperty(i);
            v && (g += ".validate"), a += "function" == typeof m ? " " + g + "(" + h + ") " : " " + g + ".test(" + h + ") ", a += ") { "
          }
        }
        var P = P || [];
        P.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "format") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { format:  ", a += f ? "" + u : "" + e.util.toQuotedString(i), a += "  } ", e.opts.messages !== !1 && (a += " , message: 'should match format \"", a += f ? "' + " + u + " + '" : "" + e.util.escapeQuotes(i), a += "\"' "), e.opts.verbose && (a += " , schema:  ", a += f ? "validate.schema" + n : "" + e.util.toQuotedString(i), a += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
        var E = a;
        return a = P.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + E + "]); " : " validate.errors = [" + E + "]; return false; " : " var err = " + E + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", a += " } ", c && (a += " else { "), a
      }
    }, {}], 25: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || ""), u = "valid" + s,
          f = "errs__" + s, d = e.util.copy(e), p = "";
        d.level++;
        var m = d.dataLevel = e.dataLevel + 1, v = "data" + m, y = e.baseId;
        if (a += "var " + f + " = errors;var " + u + ";", Array.isArray(i)) {
          var g = e.schema.additionalItems;
          if (g === !1) {
            a += " " + u + " = " + h + ".length <= " + i.length + "; ";
            var P = l;
            l = e.errSchemaPath + "/additionalItems", a += "  if (!" + u + ") {   ";
            var E = E || [];
            E.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "additionalItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { limit: " + i.length + " } ", e.opts.messages !== !1 && (a += " , message: 'should NOT have more than " + i.length + " items' "), e.opts.verbose && (a += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
            var b = a;
            a = E.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + b + "]); " : " validate.errors = [" + b + "]; return false; " : " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", a += " } ", l = P, c && (p += "}", a += " else { ")
          }
          var w = i;
          if (w) for (var j, S = -1, $ = w.length - 1; S < $;) if (j = w[S += 1], e.util.schemaHasRules(j, e.RULES.all)) {
            a += " valid" + d.level + " = true; if (" + h + ".length > " + S + ") { ";
            var x = h + "[" + S + "]";
            d.schema = j, d.schemaPath = n + "[" + S + "]", d.errSchemaPath = l + "/" + S, d.errorPath = e.util.getPathExpr(e.errorPath, S, e.opts.jsonPointers, !0), d.dataPathArr[m] = S;
            var _ = e.validate(d);
            d.baseId = y, a += e.util.varOccurences(_, v) < 2 ? " " + e.util.varReplace(_, v, x) + " " : " var " + v + " = " + x + "; " + _ + " ", a += " }  ", c && (a += " if (valid" + d.level + ") { ", p += "}")
          }
          if ("object" == typeof g && e.util.schemaHasRules(g, e.RULES.all)) {
            d.schema = g, d.schemaPath = e.schemaPath + ".additionalItems", d.errSchemaPath = e.errSchemaPath + "/additionalItems", a += " valid" + d.level + " = true; if (" + h + ".length > " + i.length + ") {  for (var i" + s + " = " + i.length + "; i" + s + " < " + h + ".length; i" + s + "++) { ", d.errorPath = e.util.getPathExpr(e.errorPath, "i" + s, e.opts.jsonPointers, !0);
            var x = h + "[i" + s + "]";
            d.dataPathArr[m] = "i" + s;
            var _ = e.validate(d);
            d.baseId = y, a += e.util.varOccurences(_, v) < 2 ? " " + e.util.varReplace(_, v, x) + " " : " var " + v + " = " + x + "; " + _ + " ", c && (a += " if (!valid" + d.level + ") break; "), a += " } }  ", c && (a += " if (valid" + d.level + ") { ", p += "}")
          }
        } else if (e.util.schemaHasRules(i, e.RULES.all)) {
          d.schema = i, d.schemaPath = n, d.errSchemaPath = l, a += "  for (var i" + s + " = 0; i" + s + " < " + h + ".length; i" + s + "++) { ", d.errorPath = e.util.getPathExpr(e.errorPath, "i" + s, e.opts.jsonPointers, !0);
          var x = h + "[i" + s + "]";
          d.dataPathArr[m] = "i" + s;
          var _ = e.validate(d);
          d.baseId = y, a += e.util.varOccurences(_, v) < 2 ? " " + e.util.varReplace(_, v, x) + " " : " var " + v + " = " + x + "; " + _ + " ", c && (a += " if (!valid" + d.level + ") break; "), a += " }  ", c && (a += " if (valid" + d.level + ") { ", p += "}")
        }
        return c && (a += " " + p + " if (" + f + " == errors) {"), a = e.util.cleanUpCode(a)
      }
    }, {}], 26: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = e.opts.v5 && n && n.$data;
        f ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n, s += "var division" + o + ";if (", f && (s += " " + a + " !== undefined && ( typeof " + a + " != 'number' || "), s += " (division" + o + " = " + u + " / " + a + ", ", s += e.opts.multipleOfPrecision ? " Math.abs(Math.round(division" + o + ") - division" + o + ") > 1e-" + e.opts.multipleOfPrecision + " " : " division" + o + " !== parseInt(division" + o + ") ", s += " ) ", f && (s += "  )  "), s += " ) {   ";
        var d = d || [];
        d.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "multipleOf") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { multipleOf: " + a + " } ", e.opts.messages !== !1 && (s += " , message: 'should be multiple of ", s += f ? "' + " + a : "" + n + "'"), e.opts.verbose && (s += " , schema:  ", s += f ? "validate.schema" + l : "" + n, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var p = s;
        return s = d.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + p + "]); " : " validate.errors = [" + p + "]; return false; " : " var err = " + p + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", h && (s += " else { "), s
      }
    }, {}], 27: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || ""), u = "errs__" + s,
          f = e.util.copy(e);
        if (f.level++, e.util.schemaHasRules(i, e.RULES.all)) {
          f.schema = i, f.schemaPath = n, f.errSchemaPath = l, a += " var " + u + " = errors;  ";
          var d = e.compositeRule;
          e.compositeRule = f.compositeRule = !0, f.createErrors = !1;
          var p;
          f.opts.allErrors && (p = f.opts.allErrors, f.opts.allErrors = !1), a += " " + e.validate(f) + " ", f.createErrors = !0, p && (f.opts.allErrors = p), e.compositeRule = f.compositeRule = d, a += " if (valid" + f.level + ") {   ";
          var m = m || [];
          m.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "not") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: {} ", e.opts.messages !== !1 && (a += " , message: 'should NOT be valid' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
          var v = a;
          a = m.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + v + "]); " : " validate.errors = [" + v + "]; return false; " : " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", a += " } else {  errors = " + u + "; if (vErrors !== null) { if (" + u + ") vErrors.length = " + u + "; else vErrors = null; } ", e.opts.allErrors && (a += " } ")
        } else a += "  var err =   ", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "not") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: {} ", e.opts.messages !== !1 && (a += " , message: 'should NOT be valid' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ", a += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c && (a += " if (false) { ");
        return a
      }
    }, {}], 28: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || ""), u = "valid" + s,
          f = "errs__" + s, d = e.util.copy(e), p = "";
        d.level++, a += "var " + f + " = errors;var prevValid" + s + " = false;var " + u + " = false;";
        var m = d.baseId, v = e.compositeRule;
        e.compositeRule = d.compositeRule = !0;
        var y = i;
        if (y) for (var g, P = -1, E = y.length - 1; P < E;) g = y[P += 1], e.util.schemaHasRules(g, e.RULES.all) ? (d.schema = g, d.schemaPath = n + "[" + P + "]", d.errSchemaPath = l + "/" + P, a += "  " + e.validate(d) + " ", d.baseId = m) : a += " var valid" + d.level + " = true; ", P && (a += " if (valid" + d.level + " && prevValid" + s + ") " + u + " = false; else { ", p += "}"), a += " if (valid" + d.level + ") " + u + " = prevValid" + s + " = true;";
        e.compositeRule = d.compositeRule = v, a += "" + p + "if (!" + u + ") {   ";
        var b = b || [];
        b.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "oneOf") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: {} ", e.opts.messages !== !1 && (a += " , message: 'should match exactly one schema in oneOf' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
        var w = a;
        return a = b.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + w + "]); " : " validate.errors = [" + w + "]; return false; " : " var err = " + w + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", a += "} else {  errors = " + f + "; if (vErrors !== null) { if (" + f + ") vErrors.length = " + f + "; else vErrors = null; }", e.opts.allErrors && (a += " } "), a
      }
    }, {}], 29: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = e.opts.v5 && n && n.$data;
        f ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n;
        var d = f ? "(new RegExp(" + a + "))" : e.usePattern(n);
        s += "if ( ", f && (s += " (" + a + " !== undefined && typeof " + a + " != 'string') || "), s += " !" + d + ".test(" + u + ") ) {   ";
        var p = p || [];
        p.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "pattern") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { pattern:  ", s += f ? "" + a : "" + e.util.toQuotedString(n), s += "  } ", e.opts.messages !== !1 && (s += " , message: 'should match pattern \"", s += f ? "' + " + a + " + '" : "" + e.util.escapeQuotes(n), s += "\"' "), e.opts.verbose && (s += " , schema:  ", s += f ? "validate.schema" + l : "" + e.util.toQuotedString(n), s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var m = s;
        return s = p.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + m + "]); " : " validate.errors = [" + m + "]; return false; " : " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", h && (s += " else { "), s
      }
    }, {}], 30: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || ""), u = "valid" + s, f = "key" + s,
          d = "patternMatched" + s, p = "", m = e.opts.ownProperties;
        a += "var " + u + " = true;";
        var v = i;
        if (v) for (var y, g = -1, P = v.length - 1; g < P;) {
          y = v[g += 1], a += " var " + d + " = false; for (var " + f + " in " + h + ") {  ", m && (a += " if (!Object.prototype.hasOwnProperty.call(" + h + ", " + f + ")) continue; "), a += " " + d + " = " + e.usePattern(y) + ".test(" + f + "); if (" + d + ") break; } ";
          var E = e.util.escapeQuotes(y);
          a += " if (!" + d + ") { " + u + " = false;  var err =   ", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "patternRequired") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { missingPattern: '" + E + "' } ", e.opts.messages !== !1 && (a += " , message: 'should have property matching pattern \\'" + E + "\\'' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ", a += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ", c && (p += "}", a += " else { ")
        }
        return a += "" + p
      }
    }, {}], 31: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || ""), u = "valid" + s,
          f = "errs__" + s, d = e.util.copy(e), p = "";
        d.level++;
        var m = "key" + s, v = d.dataLevel = e.dataLevel + 1, y = "data" + v, g = Object.keys(i || {}),
          P = e.schema.patternProperties || {}, E = Object.keys(P), b = e.schema.additionalProperties,
          w = g.length || E.length, j = b === !1, S = "object" == typeof b && Object.keys(b).length,
          $ = e.opts.removeAdditional, x = j || S || $, _ = e.opts.ownProperties, O = e.baseId, R = e.schema.required;
        if (R && (!e.opts.v5 || !R.$data) && R.length < e.opts.loopRequired) var I = e.util.toHash(R);
        if (e.opts.v5) var A = e.schema.patternGroups || {}, k = Object.keys(A);
        if (a += "var " + f + " = errors;var valid" + d.level + " = true;", x) {
          if (a += " for (var " + m + " in " + h + ") {  ", _ && (a += " if (!Object.prototype.hasOwnProperty.call(" + h + ", " + m + ")) continue; "), w) {
            if (a += " var isAdditional" + s + " = !(false ", g.length) if (g.length > 5) a += " || validate.schema" + n + "[" + m + "] "; else {
              var q = g;
              if (q) for (var L, D = -1, Q = q.length - 1; D < Q;) L = q[D += 1], a += " || " + m + " == " + e.util.toQuotedString(L) + " "
            }
            if (E.length) {
              var C = E;
              if (C) for (var U, V = -1, z = C.length - 1; V < z;) U = C[V += 1], a += " || " + e.usePattern(U) + ".test(" + m + ") "
            }
            if (e.opts.v5 && k && k.length) {
              var T = k;
              if (T) for (var M, V = -1, N = T.length - 1; V < N;) M = T[V += 1], a += " || " + e.usePattern(M) + ".test(" + m + ") "
            }
            a += " ); if (isAdditional" + s + ") { "
          }
          if ("all" == $) a += " delete " + h + "[" + m + "]; "; else {
            var F = e.errorPath, H = "' + key" + s + " + '";
            if (e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(e.errorPath, "key" + s, e.opts.jsonPointers)), j) if ($) a += " delete " + h + "[" + m + "]; "; else {
              a += " valid" + d.level + " = false; ";
              var J = l;
              l = e.errSchemaPath + "/additionalProperties";
              var G = G || [];
              G.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "additionalProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { additionalProperty: '" + H + "' } ", e.opts.messages !== !1 && (a += " , message: 'should NOT have additional properties' "), e.opts.verbose && (a += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
              var K = a;
              a = G.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + K + "]); " : " validate.errors = [" + K + "]; return false; " : " var err = " + K + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", l = J, c && (a += " break; ")
            } else if (S) if ("failing" == $) {
              a += " var " + f + " = errors;  ";
              var B = e.compositeRule;
              e.compositeRule = d.compositeRule = !0, d.schema = b, d.schemaPath = e.schemaPath + ".additionalProperties", d.errSchemaPath = e.errSchemaPath + "/additionalProperties", d.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, "key" + s, e.opts.jsonPointers);
              var Z = h + "[key" + s + "]";
              d.dataPathArr[v] = "key" + s;
              var Y = e.validate(d);
              d.baseId = O, a += e.util.varOccurences(Y, y) < 2 ? " " + e.util.varReplace(Y, y, Z) + " " : " var " + y + " = " + Z + "; " + Y + " ", a += " if (!valid" + d.level + ") { errors = " + f + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + h + "[" + m + "]; }  ", e.compositeRule = d.compositeRule = B
            } else {
              d.schema = b, d.schemaPath = e.schemaPath + ".additionalProperties", d.errSchemaPath = e.errSchemaPath + "/additionalProperties", d.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, "key" + s, e.opts.jsonPointers);
              var Z = h + "[key" + s + "]";
              d.dataPathArr[v] = "key" + s;
              var Y = e.validate(d);
              d.baseId = O, a += e.util.varOccurences(Y, y) < 2 ? " " + e.util.varReplace(Y, y, Z) + " " : " var " + y + " = " + Z + "; " + Y + " ", c && (a += " if (!valid" + d.level + ") break; ")
            }
            e.errorPath = F
          }
          w && (a += " } "), a += " }  ", c && (a += " if (valid" + d.level + ") { ", p += "}")
        }
        var W = e.opts.useDefaults && !e.compositeRule;
        if (g.length) {
          var X = g;
          if (X) for (var L, ee = -1, re = X.length - 1; ee < re;) {
            L = X[ee += 1];
            var te = i[L];
            if (e.util.schemaHasRules(te, e.RULES.all)) {
              var ae = e.util.getProperty(L), Z = h + ae, se = W && void 0 !== te.default;
              d.schema = te, d.schemaPath = n + ae, d.errSchemaPath = l + "/" + e.util.escapeFragment(L), d.errorPath = e.util.getPath(e.errorPath, L, e.opts.jsonPointers), d.dataPathArr[v] = e.util.toQuotedString(L);
              var Y = e.validate(d);
              if (d.baseId = O, e.util.varOccurences(Y, y) < 2) {
                Y = e.util.varReplace(Y, y, Z);
                var oe = Z
              } else {
                var oe = y;
                a += " var " + y + " = " + Z + "; "
              }
              if (se) a += " " + Y + " "; else {
                if (I && I[L]) {
                  a += " if (" + oe + " === undefined) { valid" + d.level + " = false; ";
                  var F = e.errorPath, J = l, ie = e.util.escapeQuotes(L);
                  e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(F, L, e.opts.jsonPointers)), l = e.errSchemaPath + "/required";
                  var G = G || [];
                  G.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "required") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { missingProperty: '" + ie + "' } ", e.opts.messages !== !1 && (a += " , message: '", a += e.opts._errorDataPathProperty ? "is a required property" : "should have required property \\'" + ie + "\\'", a += "' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
                  var K = a;
                  a = G.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + K + "]); " : " validate.errors = [" + K + "]; return false; " : " var err = " + K + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", l = J, e.errorPath = F, a += " } else { "
                } else a += c ? " if (" + oe + " === undefined) { valid" + d.level + " = true; } else { " : " if (" + oe + " !== undefined) { ";
                a += " " + Y + " } "
              }
            }
            c && (a += " if (valid" + d.level + ") { ", p += "}")
          }
        }
        var ne = E;
        if (ne) for (var U, le = -1, ce = ne.length - 1; le < ce;) {
          U = ne[le += 1];
          var te = P[U];
          if (e.util.schemaHasRules(te, e.RULES.all)) {
            d.schema = te, d.schemaPath = e.schemaPath + ".patternProperties" + e.util.getProperty(U), d.errSchemaPath = e.errSchemaPath + "/patternProperties/" + e.util.escapeFragment(U), a += " for (var " + m + " in " + h + ") {  ", _ && (a += " if (!Object.prototype.hasOwnProperty.call(" + h + ", " + m + ")) continue; "),
              a += " if (" + e.usePattern(U) + ".test(" + m + ")) { ", d.errorPath = e.util.getPathExpr(e.errorPath, "key" + s, e.opts.jsonPointers);
            var Z = h + "[key" + s + "]";
            d.dataPathArr[v] = "key" + s;
            var Y = e.validate(d);
            d.baseId = O, a += e.util.varOccurences(Y, y) < 2 ? " " + e.util.varReplace(Y, y, Z) + " " : " var " + y + " = " + Z + "; " + Y + " ", c && (a += " if (!valid" + d.level + ") break; "), a += " } ", c && (a += " else valid" + d.level + " = true; "), a += " }  ", c && (a += " if (valid" + d.level + ") { ", p += "}")
          }
        }
        if (e.opts.v5) {
          var he = k;
          if (he) for (var M, ue = -1, fe = he.length - 1; ue < fe;) {
            M = he[ue += 1];
            var de = A[M], te = de.schema;
            if (e.util.schemaHasRules(te, e.RULES.all)) {
              d.schema = te, d.schemaPath = e.schemaPath + ".patternGroups" + e.util.getProperty(M) + ".schema", d.errSchemaPath = e.errSchemaPath + "/patternGroups/" + e.util.escapeFragment(M) + "/schema", a += " var pgPropCount" + s + " = 0; for (var " + m + " in " + h + ") {  ", _ && (a += " if (!Object.prototype.hasOwnProperty.call(" + h + ", " + m + ")) continue; "), a += " if (" + e.usePattern(M) + ".test(" + m + ")) { pgPropCount" + s + "++; ", d.errorPath = e.util.getPathExpr(e.errorPath, "key" + s, e.opts.jsonPointers);
              var Z = h + "[key" + s + "]";
              d.dataPathArr[v] = "key" + s;
              var Y = e.validate(d);
              d.baseId = O, a += e.util.varOccurences(Y, y) < 2 ? " " + e.util.varReplace(Y, y, Z) + " " : " var " + y + " = " + Z + "; " + Y + " ", c && (a += " if (!valid" + d.level + ") break; "), a += " } ", c && (a += " else valid" + d.level + " = true; "), a += " }  ", c && (a += " if (valid" + d.level + ") { ", p += "}");
              var pe = de.minimum, me = de.maximum;
              if (void 0 !== pe || void 0 !== me) {
                a += " var " + u + " = true; ";
                var J = l;
                if (void 0 !== pe) {
                  var ve = pe, ye = "minimum", ge = "less";
                  a += " " + u + " = pgPropCount" + s + " >= " + pe + "; ", l = e.errSchemaPath + "/patternGroups/minimum", a += "  if (!" + u + ") {   ";
                  var G = G || [];
                  G.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "patternGroups") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { reason: '" + ye + "', limit: " + ve + ", pattern: '" + e.util.escapeQuotes(M) + "' } ", e.opts.messages !== !1 && (a += " , message: 'should NOT have " + ge + " than " + ve + ' properties matching pattern "' + e.util.escapeQuotes(M) + "\"' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
                  var K = a;
                  a = G.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + K + "]); " : " validate.errors = [" + K + "]; return false; " : " var err = " + K + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", a += " } ", void 0 !== me && (a += " else ")
                }
                if (void 0 !== me) {
                  var ve = me, ye = "maximum", ge = "more";
                  a += " " + u + " = pgPropCount" + s + " <= " + me + "; ", l = e.errSchemaPath + "/patternGroups/maximum", a += "  if (!" + u + ") {   ";
                  var G = G || [];
                  G.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "patternGroups") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { reason: '" + ye + "', limit: " + ve + ", pattern: '" + e.util.escapeQuotes(M) + "' } ", e.opts.messages !== !1 && (a += " , message: 'should NOT have " + ge + " than " + ve + ' properties matching pattern "' + e.util.escapeQuotes(M) + "\"' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
                  var K = a;
                  a = G.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + K + "]); " : " validate.errors = [" + K + "]; return false; " : " var err = " + K + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", a += " } "
                }
                l = J, c && (a += " if (" + u + ") { ", p += "}")
              }
            }
          }
        }
        return c && (a += " " + p + " if (" + f + " == errors) {"), a = e.util.cleanUpCode(a)
      }
    }, {}], 32: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s, o = " ", i = e.level, n = e.dataLevel, l = e.schema[r], c = e.errSchemaPath + "/" + r,
          h = !e.opts.allErrors, u = "data" + (n || ""), f = "valid" + i;
        if ("#" == l || "#/" == l) e.isRoot ? (a = e.async, s = "validate") : (a = e.root.schema.$async === !0, s = "root.refVal[0]"); else {
          var d = e.resolveRef(e.baseId, l, e.isRoot);
          if (void 0 === d) {
            var p = "can't resolve reference " + l + " from id " + e.baseId;
            if ("fail" == e.opts.missingRefs) {
              console.log(p);
              var m = m || [];
              m.push(o), o = "", e.createErrors !== !1 ? (o += " { keyword: '" + (t || "$ref") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { ref: '" + e.util.escapeQuotes(l) + "' } ", e.opts.messages !== !1 && (o += " , message: 'can\\'t resolve reference " + e.util.escapeQuotes(l) + "' "), e.opts.verbose && (o += " , schema: " + e.util.toQuotedString(l) + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), o += " } ") : o += " {} ";
              var v = o;
              o = m.pop(), o += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + v + "]); " : " validate.errors = [" + v + "]; return false; " : " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", h && (o += " if (false) { ")
            } else {
              if ("ignore" != e.opts.missingRefs) {
                var y = new Error(p);
                throw y.missingRef = e.resolve.url(e.baseId, l), y.missingSchema = e.resolve.normalizeId(e.resolve.fullPath(y.missingRef)), y
              }
              console.log(p), h && (o += " if (true) { ")
            }
          } else if (d.inline) {
            var g = e.util.copy(e);
            g.level++, g.schema = d.schema, g.schemaPath = "", g.errSchemaPath = l;
            var P = e.validate(g).replace(/validate\.schema/g, d.code);
            o += " " + P + " ", h && (o += " if (valid" + g.level + ") { ")
          } else a = d.$async === !0, s = d.code
        }
        if (s) {
          var m = m || [];
          m.push(o), o = "", o += e.opts.passContext ? " " + s + ".call(this, " : " " + s + "( ", o += " " + u + ", (dataPath || '')", '""' != e.errorPath && (o += " + " + e.errorPath), o += n ? " , data" + (n - 1 || "") + " , " + e.dataPathArr[n] + " " : " , parentData , parentDataProperty ", o += ", rootData)  ";
          var E = o;
          if (o = m.pop(), a) {
            if (!e.async) throw new Error("async schema referenced by sync schema");
            o += " try { ", h && (o += "var " + f + " ="), o += " " + e.yieldAwait + " " + E + "; } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; } ", h && (o += " if (" + f + ") { ")
          } else o += " if (!" + E + ") { if (vErrors === null) vErrors = " + s + ".errors; else vErrors = vErrors.concat(" + s + ".errors); errors = vErrors.length; } ", h && (o += " else { ")
        }
        return o
      }
    }, {}], 33: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = "valid" + o,
          d = e.opts.v5 && n && n.$data;
        if (d ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n, !d) if (n.length < e.opts.loopRequired && e.schema.properties && Object.keys(e.schema.properties).length) {
          var p = [], m = n;
          if (m) for (var v, y = -1, g = m.length - 1; y < g;) {
            v = m[y += 1];
            var P = e.schema.properties[v];
            P && e.util.schemaHasRules(P, e.RULES.all) || (p[p.length] = v)
          }
        } else var p = n;
        if (d || p.length) {
          var E = e.errorPath, b = d || p.length >= e.opts.loopRequired;
          if (h) if (s += " var missing" + o + "; ", b) {
            d || (s += " var schema" + o + " = validate.schema" + l + "; ");
            var w = "i" + o, j = "schema" + o + "[" + w + "]", S = "' + " + j + " + '";
            e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(E, j, e.opts.jsonPointers)), s += " var " + f + " = true; ", d && (s += " if (schema" + o + " === undefined) " + f + " = true; else if (!Array.isArray(schema" + o + ")) " + f + " = false; else {"), s += " for (var " + w + " = 0; " + w + " < schema" + o + ".length; " + w + "++) { " + f + " = " + u + "[schema" + o + "[" + w + "]] !== undefined; if (!" + f + ") break; } ", d && (s += "  }  "), s += "  if (!" + f + ") {   ";
            var $ = $ || [];
            $.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "required") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + S + "' } ", e.opts.messages !== !1 && (s += " , message: '", s += e.opts._errorDataPathProperty ? "is a required property" : "should have required property \\'" + S + "\\'", s += "' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
            var x = s;
            s = $.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + x + "]); " : " validate.errors = [" + x + "]; return false; " : " var err = " + x + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } else { "
          } else {
            s += " if ( ";
            var _ = p;
            if (_) for (var O, w = -1, R = _.length - 1; w < R;) {
              O = _[w += 1], w && (s += " || ");
              var I = e.util.getProperty(O);
              s += " ( " + u + I + " === undefined && (missing" + o + " = " + e.util.toQuotedString(e.opts.jsonPointers ? O : I) + ") ) "
            }
            s += ") {  ";
            var j = "missing" + o, S = "' + " + j + " + '";
            e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(E, j, !0) : E + " + " + j);
            var $ = $ || [];
            $.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "required") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + S + "' } ", e.opts.messages !== !1 && (s += " , message: '", s += e.opts._errorDataPathProperty ? "is a required property" : "should have required property \\'" + S + "\\'", s += "' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
            var x = s;
            s = $.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + x + "]); " : " validate.errors = [" + x + "]; return false; " : " var err = " + x + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } else { "
          } else if (b) {
            d || (s += " var schema" + o + " = validate.schema" + l + "; ");
            var w = "i" + o, j = "schema" + o + "[" + w + "]", S = "' + " + j + " + '";
            e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(E, j, e.opts.jsonPointers)), d && (s += " if (schema" + o + " && !Array.isArray(schema" + o + ")) {  var err =   ", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "required") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + S + "' } ", e.opts.messages !== !1 && (s += " , message: '", s += e.opts._errorDataPathProperty ? "is a required property" : "should have required property \\'" + S + "\\'", s += "' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (schema" + o + " !== undefined) { "), s += " for (var " + w + " = 0; " + w + " < schema" + o + ".length; " + w + "++) { if (" + u + "[schema" + o + "[" + w + "]] === undefined) {  var err =   ", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "required") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + S + "' } ", e.opts.messages !== !1 && (s += " , message: '", s += e.opts._errorDataPathProperty ? "is a required property" : "should have required property \\'" + S + "\\'", s += "' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", d && (s += "  }  ")
          } else {
            var A = p;
            if (A) for (var k, q = -1, L = A.length - 1; q < L;) {
              k = A[q += 1];
              var I = e.util.getProperty(k), S = e.util.escapeQuotes(k);
              e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(E, k, e.opts.jsonPointers)), s += " if (" + u + I + " === undefined) {  var err =   ", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "required") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + S + "' } ", e.opts.messages !== !1 && (s += " , message: '", s += e.opts._errorDataPathProperty ? "is a required property" : "should have required property \\'" + S + "\\'", s += "' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "
            }
          }
          e.errorPath = E
        } else h && (s += " if (true) {");
        return s
      }
    }, {}], 34: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a = " ", s = e.level, o = e.dataLevel, i = e.schema[r], n = e.schemaPath + "." + r,
          l = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, h = "data" + (o || ""), u = "valid" + s,
          f = "errs__" + s, d = e.util.copy(e), p = "";
        d.level++;
        var m, v = "ifPassed" + e.level, y = d.baseId;
        a += "var " + v + ";";
        var g = i;
        if (g) for (var P, E = -1, b = g.length - 1; E < b;) {
          if (P = g[E += 1], E && !m && (a += " if (!" + v + ") { ", p += "}"), P.if && e.util.schemaHasRules(P.if, e.RULES.all)) {
            a += " var " + f + " = errors;   ";
            var w = e.compositeRule;
            if (e.compositeRule = d.compositeRule = !0, d.createErrors = !1, d.schema = P.if, d.schemaPath = n + "[" + E + "].if", d.errSchemaPath = l + "/" + E + "/if", a += "  " + e.validate(d) + " ", d.baseId = y, d.createErrors = !0, e.compositeRule = d.compositeRule = w, a += " " + v + " = valid" + d.level + "; if (" + v + ") {  ", "boolean" == typeof P.then) {
              if (P.then === !1) {
                var j = j || [];
                j.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "switch") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { caseIndex: " + E + " } ", e.opts.messages !== !1 && (a += " , message: 'should pass \"switch\" keyword validation' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
                var S = a;
                a = j.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + S + "]); " : " validate.errors = [" + S + "]; return false; " : " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
              }
              a += " var valid" + d.level + " = " + P.then + "; "
            } else d.schema = P.then, d.schemaPath = n + "[" + E + "].then", d.errSchemaPath = l + "/" + E + "/then", a += "  " + e.validate(d) + " ", d.baseId = y;
            a += "  } else {  errors = " + f + "; if (vErrors !== null) { if (" + f + ") vErrors.length = " + f + "; else vErrors = null; } } "
          } else if (a += " " + v + " = true;  ", "boolean" == typeof P.then) {
            if (P.then === !1) {
              var j = j || [];
              j.push(a), a = "", e.createErrors !== !1 ? (a += " { keyword: '" + (t || "switch") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { caseIndex: " + E + " } ", e.opts.messages !== !1 && (a += " , message: 'should pass \"switch\" keyword validation' "), e.opts.verbose && (a += " , schema: validate.schema" + n + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), a += " } ") : a += " {} ";
              var S = a;
              a = j.pop(), a += !e.compositeRule && c ? e.async ? " throw new ValidationError([" + S + "]); " : " validate.errors = [" + S + "]; return false; " : " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
            }
            a += " var valid" + d.level + " = " + P.then + "; "
          } else d.schema = P.then, d.schemaPath = n + "[" + E + "].then", d.errSchemaPath = l + "/" + E + "/then", a += "  " + e.validate(d) + " ", d.baseId = y;
          m = P.continue
        }
        return a += "" + p + "var " + u + " = valid" + d.level + "; ", a = e.util.cleanUpCode(a)
      }
    }, {}], 35: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        var t, a, s = " ", o = e.level, i = e.dataLevel, n = e.schema[r], l = e.schemaPath + "." + r,
          c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, u = "data" + (i || ""), f = "valid" + o,
          d = e.opts.v5 && n && n.$data;
        if (d ? (s += " var schema" + o + " = " + e.util.getData(n.$data, i, e.dataPathArr) + "; ", a = "schema" + o) : a = n, (n || d) && e.opts.uniqueItems !== !1) {
          d && (s += " var " + f + "; if (" + a + " === false || " + a + " === undefined) " + f + " = true; else if (typeof " + a + " != 'boolean') " + f + " = false; else { "), s += " var " + f + " = true; if (" + u + ".length > 1) { var i = " + u + ".length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(" + u + "[i], " + u + "[j])) { " + f + " = false; break outer; } } } } ", d && (s += "  }  "), s += " if (!" + f + ") {   ";
          var p = p || [];
          p.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (t || "uniqueItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { i: i, j: j } ", e.opts.messages !== !1 && (s += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), e.opts.verbose && (s += " , schema:  ", s += d ? "validate.schema" + l : "" + n, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
          var m = s;
          s = p.pop(), s += !e.compositeRule && h ? e.async ? " throw new ValidationError([" + m + "]); " : " validate.errors = [" + m + "]; return false; " : " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } ", h && (s += " else { ")
        } else h && (s += " if (true) { ");
        return s
      }
    }, {}], 36: [function (e, r, t) {
      "use strict";
      r.exports = function (e, r) {
        function t(e) {
          for (var r = 0; r < e.rules.length; r++) if (a(e.rules[r])) return !0
        }

        function a(r) {
          return void 0 !== e.schema[r.keyword] || "properties" == r.keyword && (e.schema.additionalProperties === !1 || "object" == typeof e.schema.additionalProperties || e.schema.patternProperties && Object.keys(e.schema.patternProperties).length || e.opts.v5 && e.schema.patternGroups && Object.keys(e.schema.patternGroups).length)
        }

        var s = "", o = e.schema.$async === !0;
        if (e.isTop) {
          var i = e.isTop, n = e.level = 0, l = e.dataLevel = 0, c = "data";
          if (e.rootId = e.resolve.fullPath(e.root.schema.id), e.baseId = e.baseId || e.rootId, o) {
            e.async = !0;
            var h = "es7" == e.opts.async;
            e.yieldAwait = h ? "await" : "yield"
          }
          delete e.isTop, e.dataPathArr = [void 0], s += " var validate = ", o ? h ? s += " (async function " : ("co*" == e.opts.async && (s += "co.wrap"), s += "(function* ") : s += " (function ", s += " (data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; var vErrors = null; ", s += " var errors = 0;     ", s += " if (rootData === undefined) rootData = data;"
        } else {
          var n = e.level, l = e.dataLevel, c = "data" + (l || "");
          if (e.schema.id && (e.baseId = e.resolve.url(e.baseId, e.schema.id)), o && !e.async) throw new Error("async schema in sync schema");
          s += " var errs_" + n + " = errors;"
        }
        var u, f = "valid" + n, d = !e.opts.allErrors, p = "", m = "", v = e.schema.type, y = Array.isArray(v);
        if (v && e.opts.coerceTypes) {
          var g = e.util.coerceToTypes(e.opts.coerceTypes, v);
          if (g) {
            var P = e.schemaPath + ".type", E = e.errSchemaPath + "/type", b = y ? "checkDataTypes" : "checkDataType";
            s += " if (" + e.util[b](v, c, !0) + ") {  ";
            var w = "dataType" + n, j = "coerced" + n;
            s += " var " + w + " = typeof " + c + "; ", "array" == e.opts.coerceTypes && (s += " if (" + w + " == 'object' && Array.isArray(" + c + ")) " + w + " = 'array'; "), s += " var " + j + " = undefined; ";
            var S = "", $ = g;
            if ($) for (var x, _ = -1, O = $.length - 1; _ < O;) x = $[_ += 1], _ && (s += " if (" + j + " === undefined) { ", S += "}"), "array" == e.opts.coerceTypes && "array" != x && (s += " if (" + w + " == 'array' && " + c + ".length == 1) { " + j + " = " + c + " = " + c + "[0]; " + w + " = typeof " + c + ";  } "), "string" == x ? s += " if (" + w + " == 'number' || " + w + " == 'boolean') " + j + " = '' + " + c + "; else if (" + c + " === null) " + j + " = ''; " : "number" == x || "integer" == x ? (s += " if (" + w + " == 'boolean' || " + c + " === null || (" + w + " == 'string' && " + c + " && " + c + " == +" + c + " ", "integer" == x && (s += " && !(" + c + " % 1)"), s += ")) " + j + " = +" + c + "; ") : "boolean" == x ? s += " if (" + c + " === 'false' || " + c + " === 0 || " + c + " === null) " + j + " = false; else if (" + c + " === 'true' || " + c + " === 1) " + j + " = true; " : "null" == x ? s += " if (" + c + " === '' || " + c + " === 0 || " + c + " === false) " + j + " = null; " : "array" == e.opts.coerceTypes && "array" == x && (s += " if (" + w + " == 'string' || " + w + " == 'number' || " + w + " == 'boolean' || " + c + " == null) " + j + " = [" + c + "]; ");
            s += " " + S + " if (" + j + " === undefined) {   ";
            var R = R || [];
            R.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (u || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(E) + " , params: { type: '", s += y ? "" + v.join(",") : "" + v, s += "' } ", e.opts.messages !== !1 && (s += " , message: 'should be ", s += y ? "" + v.join(",") : "" + v, s += "' "), e.opts.verbose && (s += " , schema: validate.schema" + P + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "), s += " } ") : s += " {} ";
            var I = s;
            if (s = R.pop(), s += !e.compositeRule && d ? e.async ? " throw new ValidationError([" + I + "]); " : " validate.errors = [" + I + "]; return false; " : " var err = " + I + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } else { ", l) {
              var A = "data" + (l - 1 || ""), k = e.dataPathArr[l];
              s += " " + c + " = " + A + "[" + k + "] = " + j + "; "
            } else s += " data = " + j + "; if (parentData !== undefined) parentData[parentDataProperty] = " + j + "; ";
            s += " } } "
          }
        }
        var q;
        if (e.schema.$ref && (q = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"))) {
          if ("fail" == e.opts.extendRefs) throw new Error('$ref: validation keywords used in schema at path "' + e.errSchemaPath + '"');
          "ignore" == e.opts.extendRefs ? (q = !1, console.log('$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"')) : e.opts.extendRefs !== !0 && console.log('$ref: all keywords used in schema at path "' + e.errSchemaPath + '". It will change in the next major version, see issue #260. Use option { extendRefs: true } to keep current behaviour')
        }
        if (e.schema.$ref && !q) s += " " + e.RULES.all.$ref.code(e, "$ref") + " ", d && (s += " } if (errors === ", s += i ? "0" : "errs_" + n, s += ") { ", m += "}"); else {
          var L = e.RULES;
          if (L) for (var D, Q = -1, C = L.length - 1; Q < C;) if (D = L[Q += 1], t(D)) {
            if (D.type && (s += " if (" + e.util.checkDataType(D.type, c) + ") { "), e.opts.useDefaults && !e.compositeRule) if ("object" == D.type && e.schema.properties) {
              var U = e.schema.properties, V = Object.keys(U), z = V;
              if (z) for (var T, M = -1, N = z.length - 1; M < N;) {
                T = z[M += 1];
                var F = U[T];
                if (void 0 !== F.default) {
                  var H = c + e.util.getProperty(T);
                  s += "  if (" + H + " === undefined) " + H + " = ", s += "shared" == e.opts.useDefaults ? " " + e.useDefault(F.default) + " " : " " + JSON.stringify(F.default) + " ", s += "; "
                }
              }
            } else if ("array" == D.type && Array.isArray(e.schema.items)) {
              var J = e.schema.items;
              if (J) for (var F, _ = -1, G = J.length - 1; _ < G;) if (F = J[_ += 1], void 0 !== F.default) {
                var H = c + "[" + _ + "]";
                s += "  if (" + H + " === undefined) " + H + " = ", s += "shared" == e.opts.useDefaults ? " " + e.useDefault(F.default) + " " : " " + JSON.stringify(F.default) + " ", s += "; "
              }
            }
            var K = D.rules;
            if (K) for (var B, Z = -1, Y = K.length - 1; Z < Y;) B = K[Z += 1], a(B) && (s += " " + B.code(e, B.keyword) + " ", d && (p += "}"));
            if (d && (s += " " + p + " ", p = ""), D.type && (s += " } ", v && v === D.type)) {
              var W = !0;
              s += " else { ";
              var P = e.schemaPath + ".type", E = e.errSchemaPath + "/type", R = R || [];
              R.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (u || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(E) + " , params: { type: '", s += y ? "" + v.join(",") : "" + v, s += "' } ", e.opts.messages !== !1 && (s += " , message: 'should be ", s += y ? "" + v.join(",") : "" + v, s += "' "), e.opts.verbose && (s += " , schema: validate.schema" + P + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "), s += " } ") : s += " {} ";
              var I = s;
              s = R.pop(), s += !e.compositeRule && d ? e.async ? " throw new ValidationError([" + I + "]); " : " validate.errors = [" + I + "]; return false; " : " var err = " + I + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } "
            }
            d && (s += " if (errors === ", s += i ? "0" : "errs_" + n, s += ") { ", m += "}")
          }
        }
        if (v && !W && (!e.opts.coerceTypes || !g)) {
          var P = e.schemaPath + ".type", E = e.errSchemaPath + "/type", b = y ? "checkDataTypes" : "checkDataType";
          s += " if (" + e.util[b](v, c, !0) + ") {   ";
          var R = R || [];
          R.push(s), s = "", e.createErrors !== !1 ? (s += " { keyword: '" + (u || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(E) + " , params: { type: '", s += y ? "" + v.join(",") : "" + v, s += "' } ", e.opts.messages !== !1 && (s += " , message: 'should be ", s += y ? "" + v.join(",") : "" + v, s += "' "), e.opts.verbose && (s += " , schema: validate.schema" + P + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "), s += " } ") : s += " {} ";
          var I = s;
          s = R.pop(), s += !e.compositeRule && d ? e.async ? " throw new ValidationError([" + I + "]); " : " validate.errors = [" + I + "]; return false; " : " var err = " + I + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " }"
        }
        return d && (s += " " + m + " "), i ? (o ? (s += " if (errors === 0) return true;           ", s += " else throw new ValidationError(vErrors); ") : (s += " validate.errors = vErrors; ", s += " return errors === 0;       "), s += " }); return validate;") : s += " var " + f + " = errors === errs_" + n + ";", s = e.util.cleanUpCode(s), i && d && (s = e.util.cleanUpVarErrors(s, o)), s
      }
    }, {}], 37: [function (e, r, t) {
      "use strict";
      var a = /^[a-z_$][a-z0-9_$]*$/i, s = e("./dotjs/custom");
      r.exports = function (e, r) {
        function t(e, r, t) {
          for (var a, o = 0; o < i.RULES.length; o++) {
            var n = i.RULES[o];
            if (n.type == r) {
              a = n;
              break
            }
          }
          a || (a = {type: r, rules: []}, i.RULES.push(a));
          var l = {keyword: e, definition: t, custom: !0, code: s};
          a.rules.push(l), i.RULES.custom[e] = l
        }

        function o(e) {
          if (!i.RULES.types[e]) throw new Error("Unknown type " + e)
        }

        var i = this;
        if (this.RULES.keywords[e]) throw new Error("Keyword " + e + " is already defined");
        if (!a.test(e)) throw new Error("Keyword " + e + " is not a valid identifier");
        if (r) {
          var n = r.type;
          if (Array.isArray(n)) {
            var l, c = n.length;
            for (l = 0; l < c; l++) o(n[l]);
            for (l = 0; l < c; l++) t(e, n[l], r)
          } else n && o(n), t(e, n, r);
          var h = r.$data === !0 && this._opts.v5;
          if (h && !r.validate) throw new Error('$data support: neither "validate" nor "compile" functions are defined');
          var u = r.metaSchema;
          u && (h && (u = {anyOf: [u, {$ref: "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#/definitions/$data"}]}), r.validateSchema = i.compile(u, !0))
        }
        this.RULES.keywords[e] = this.RULES.all[e] = !0
      }
    }, {"./dotjs/custom": 21}], 38: [function (e, r, t) {
      r.exports = {
        id: "http://json-schema.org/draft-04/schema#",
        $schema: "http://json-schema.org/draft-04/schema#",
        description: "Core schema meta-schema",
        definitions: {
          schemaArray: {type: "array", minItems: 1, items: {$ref: "#"}},
          positiveInteger: {type: "integer", minimum: 0},
          positiveIntegerDefault0: {allOf: [{$ref: "#/definitions/positiveInteger"}, {default: 0}]},
          simpleTypes: {enum: ["array", "boolean", "integer", "null", "number", "object", "string"]},
          stringArray: {type: "array", items: {type: "string"}, minItems: 1, uniqueItems: !0}
        },
        type: "object",
        properties: {
          id: {type: "string", format: "uri"},
          $schema: {type: "string", format: "uri"},
          title: {type: "string"},
          description: {type: "string"},
          default: {},
          multipleOf: {type: "number", minimum: 0, exclusiveMinimum: !0},
          maximum: {type: "number"},
          exclusiveMaximum: {type: "boolean", default: !1},
          minimum: {type: "number"},
          exclusiveMinimum: {type: "boolean", default: !1},
          maxLength: {$ref: "#/definitions/positiveInteger"},
          minLength: {$ref: "#/definitions/positiveIntegerDefault0"},
          pattern: {type: "string", format: "regex"},
          additionalItems: {anyOf: [{type: "boolean"}, {$ref: "#"}], default: {}},
          items: {anyOf: [{$ref: "#"}, {$ref: "#/definitions/schemaArray"}], default: {}},
          maxItems: {$ref: "#/definitions/positiveInteger"},
          minItems: {$ref: "#/definitions/positiveIntegerDefault0"},
          uniqueItems: {type: "boolean", default: !1},
          maxProperties: {$ref: "#/definitions/positiveInteger"},
          minProperties: {$ref: "#/definitions/positiveIntegerDefault0"},
          required: {$ref: "#/definitions/stringArray"},
          additionalProperties: {anyOf: [{type: "boolean"}, {$ref: "#"}], default: {}},
          definitions: {type: "object", additionalProperties: {$ref: "#"}, default: {}},
          properties: {type: "object", additionalProperties: {$ref: "#"}, default: {}},
          patternProperties: {type: "object", additionalProperties: {$ref: "#"}, default: {}},
          dependencies: {
            type: "object",
            additionalProperties: {anyOf: [{$ref: "#"}, {$ref: "#/definitions/stringArray"}]}
          },
          enum: {type: "array", minItems: 1, uniqueItems: !0},
          type: {
            anyOf: [{$ref: "#/definitions/simpleTypes"}, {
              type: "array",
              items: {$ref: "#/definitions/simpleTypes"},
              minItems: 1,
              uniqueItems: !0
            }]
          },
          allOf: {$ref: "#/definitions/schemaArray"},
          anyOf: {$ref: "#/definitions/schemaArray"},
          oneOf: {$ref: "#/definitions/schemaArray"},
          not: {$ref: "#"}
        },
        dependencies: {exclusiveMaximum: ["maximum"], exclusiveMinimum: ["minimum"]},
        default: {}
      }
    }, {}], 39: [function (e, r, t) {
      r.exports = {
        id: "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#",
        $schema: "http://json-schema.org/draft-04/schema#",
        description: "Core schema meta-schema (v5 proposals)",
        definitions: {
          schemaArray: {type: "array", minItems: 1, items: {$ref: "#"}},
          positiveInteger: {type: "integer", minimum: 0},
          positiveIntegerDefault0: {allOf: [{$ref: "#/definitions/positiveInteger"}, {default: 0}]},
          simpleTypes: {enum: ["array", "boolean", "integer", "null", "number", "object", "string"]},
          stringArray: {type: "array", items: {type: "string"}, minItems: 1, uniqueItems: !0},
          $data: {
            type: "object",
            required: ["$data"],
            properties: {$data: {type: "string", anyOf: [{format: "relative-json-pointer"}, {format: "json-pointer"}]}},
            additionalProperties: !1
          }
        },
        type: "object",
        properties: {
          id: {type: "string", format: "uri"},
          $schema: {type: "string", format: "uri"},
          title: {type: "string"},
          description: {type: "string"},
          default: {},
          multipleOf: {anyOf: [{type: "number", minimum: 0, exclusiveMinimum: !0}, {$ref: "#/definitions/$data"}]},
          maximum: {anyOf: [{type: "number"}, {$ref: "#/definitions/$data"}]},
          exclusiveMaximum: {anyOf: [{type: "boolean", default: !1}, {$ref: "#/definitions/$data"}]},
          minimum: {anyOf: [{type: "number"}, {$ref: "#/definitions/$data"}]},
          exclusiveMinimum: {anyOf: [{type: "boolean", default: !1}, {$ref: "#/definitions/$data"}]},
          maxLength: {anyOf: [{$ref: "#/definitions/positiveInteger"}, {$ref: "#/definitions/$data"}]},
          minLength: {anyOf: [{$ref: "#/definitions/positiveIntegerDefault0"}, {$ref: "#/definitions/$data"}]},
          pattern: {anyOf: [{type: "string", format: "regex"}, {$ref: "#/definitions/$data"}]},
          additionalItems: {anyOf: [{type: "boolean"}, {$ref: "#"}, {$ref: "#/definitions/$data"}], default: {}},
          items: {anyOf: [{$ref: "#"}, {$ref: "#/definitions/schemaArray"}], default: {}},
          maxItems: {anyOf: [{$ref: "#/definitions/positiveInteger"}, {$ref: "#/definitions/$data"}]},
          minItems: {anyOf: [{$ref: "#/definitions/positiveIntegerDefault0"}, {$ref: "#/definitions/$data"}]},
          uniqueItems: {anyOf: [{type: "boolean", default: !1}, {$ref: "#/definitions/$data"}]},
          maxProperties: {anyOf: [{$ref: "#/definitions/positiveInteger"}, {$ref: "#/definitions/$data"}]},
          minProperties: {anyOf: [{$ref: "#/definitions/positiveIntegerDefault0"}, {$ref: "#/definitions/$data"}]},
          required: {anyOf: [{$ref: "#/definitions/stringArray"}, {$ref: "#/definitions/$data"}]},
          additionalProperties: {anyOf: [{type: "boolean"}, {$ref: "#"}, {$ref: "#/definitions/$data"}], default: {}},
          definitions: {type: "object", additionalProperties: {$ref: "#"}, default: {}},
          properties: {type: "object", additionalProperties: {$ref: "#"}, default: {}},
          patternProperties: {type: "object", additionalProperties: {$ref: "#"}, default: {}},
          dependencies: {
            type: "object",
            additionalProperties: {anyOf: [{$ref: "#"}, {$ref: "#/definitions/stringArray"}]}
          },
          enum: {anyOf: [{type: "array", minItems: 1, uniqueItems: !0}, {$ref: "#/definitions/$data"}]},
          type: {
            anyOf: [{$ref: "#/definitions/simpleTypes"}, {
              type: "array",
              items: {$ref: "#/definitions/simpleTypes"},
              minItems: 1,
              uniqueItems: !0
            }]
          },
          allOf: {$ref: "#/definitions/schemaArray"},
          anyOf: {$ref: "#/definitions/schemaArray"},
          oneOf: {$ref: "#/definitions/schemaArray"},
          not: {$ref: "#"},
          format: {anyOf: [{type: "string"}, {$ref: "#/definitions/$data"}]},
          formatMaximum: {anyOf: [{type: "string"}, {$ref: "#/definitions/$data"}]},
          formatMinimum: {anyOf: [{type: "string"}, {$ref: "#/definitions/$data"}]},
          formatExclusiveMaximum: {anyOf: [{type: "boolean", default: !1}, {$ref: "#/definitions/$data"}]},
          formatExclusiveMinimum: {anyOf: [{type: "boolean", default: !1}, {$ref: "#/definitions/$data"}]},
          constant: {anyOf: [{}, {$ref: "#/definitions/$data"}]},
          contains: {$ref: "#"},
          patternGroups: {
            type: "object",
            additionalProperties: {
              type: "object",
              required: ["schema"],
              properties: {
                maximum: {anyOf: [{$ref: "#/definitions/positiveInteger"}, {$ref: "#/definitions/$data"}]},
                minimum: {anyOf: [{$ref: "#/definitions/positiveIntegerDefault0"}, {$ref: "#/definitions/$data"}]},
                schema: {$ref: "#"}
              },
              additionalProperties: !1
            },
            default: {}
          },
          switch: {
            type: "array",
            items: {
              required: ["then"],
              properties: {
                if: {$ref: "#"},
                then: {anyOf: [{type: "boolean"}, {$ref: "#"}]},
                continue: {type: "boolean"}
              },
              additionalProperties: !1,
              dependencies: {continue: ["if"]}
            }
          }
        },
        dependencies: {
          exclusiveMaximum: ["maximum"],
          exclusiveMinimum: ["minimum"],
          formatMaximum: ["format"],
          formatMinimum: ["format"],
          formatExclusiveMaximum: ["formatMaximum"],
          formatExclusiveMinimum: ["formatMinimum"]
        },
        default: {}
      }
    }, {}], 40: [function (e, r, t) {
      "use strict";

      function a(r) {
        function t(e, t, s) {
          var o = {inline: s || a[e], statements: !0, errors: "full"};
          t && (o.type = t), r.addKeyword(e, o)
        }

        var a = {
          switch: e("./dotjs/switch"),
          constant: e("./dotjs/constant"),
          _formatLimit: e("./dotjs/_formatLimit"),
          patternRequired: e("./dotjs/patternRequired")
        };
        if (r._opts.meta !== !1) {
          var i = e("./refs/json-schema-v5.json");
          r.addMetaSchema(i, o)
        }
        t("constant"), r.addKeyword("contains", {
          type: "array",
          macro: s
        }), t("formatMaximum", "string", a._formatLimit), t("formatMinimum", "string", a._formatLimit), r.addKeyword("formatExclusiveMaximum"), r.addKeyword("formatExclusiveMinimum"), r.addKeyword("patternGroups"), t("patternRequired", "object"), t("switch")
      }

      function s(e) {
        return {not: {items: {not: e}}}
      }

      var o = "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json";
      r.exports = {enable: a, META_SCHEMA_ID: o}
    }, {
      "./dotjs/_formatLimit": 13,
      "./dotjs/constant": 20,
      "./dotjs/patternRequired": 30,
      "./dotjs/switch": 34,
      "./refs/json-schema-v5.json": 39
    }], 41: [function (e, r, t) {
      function a(e) {
        var r = this, t = f.call(arguments, 1);
        return new Promise(function (a, o) {
          function i(r) {
            var t;
            try {
              t = e.next(r)
            } catch (e) {
              return o(e)
            }
            c(t)
          }

          function n(r) {
            var t;
            try {
              t = e.throw(r)
            } catch (e) {
              return o(e)
            }
            c(t)
          }

          function c(e) {
            if (e.done) return a(e.value);
            var t = s.call(r, e.value);
            return t && l(t) ? t.then(i, n) : n(new TypeError('You may only yield a function, promise, generator, array, or object, but the following object was passed: "' + String(e.value) + '"'))
          }

          return "function" == typeof e && (e = e.apply(r, t)),
            e && "function" == typeof e.next ? void i() : a(e)
        })
      }

      function s(e) {
        return e ? l(e) ? e : h(e) || c(e) ? a.call(this, e) : "function" == typeof e ? o.call(this, e) : Array.isArray(e) ? i.call(this, e) : u(e) ? n.call(this, e) : e : e
      }

      function o(e) {
        var r = this;
        return new Promise(function (t, a) {
          e.call(r, function (e, r) {
            return e ? a(e) : (arguments.length > 2 && (r = f.call(arguments, 1)), void t(r))
          })
        })
      }

      function i(e) {
        return Promise.all(e.map(s, this))
      }

      function n(e) {
        function r(e, r) {
          t[r] = void 0, o.push(e.then(function (e) {
            t[r] = e
          }))
        }

        for (var t = new e.constructor, a = Object.keys(e), o = [], i = 0; i < a.length; i++) {
          var n = a[i], c = s.call(this, e[n]);
          c && l(c) ? r(c, n) : t[n] = e[n]
        }
        return Promise.all(o).then(function () {
          return t
        })
      }

      function l(e) {
        return "function" == typeof e.then
      }

      function c(e) {
        return "function" == typeof e.next && "function" == typeof e.throw
      }

      function h(e) {
        var r = e.constructor;
        return !!r && ("GeneratorFunction" === r.name || "GeneratorFunction" === r.displayName || c(r.prototype))
      }

      function u(e) {
        return Object == e.constructor
      }

      var f = Array.prototype.slice;
      r.exports = a.default = a.co = a, a.wrap = function (e) {
        function r() {
          return a.call(this, e.apply(this, arguments))
        }

        return r.__generatorFunction__ = e, r
      }
    }, {}], 42: [function (e, r, t) {
      var a = "undefined" != typeof JSON ? JSON : e("jsonify");
      r.exports = function (e, r) {
        r || (r = {}), "function" == typeof r && (r = {cmp: r});
        var t = r.space || "";
        "number" == typeof t && (t = Array(t + 1).join(" "));
        var i = "boolean" == typeof r.cycles && r.cycles, n = r.replacer || function (e, r) {
          return r
        }, l = r.cmp && function (e) {
          return function (r) {
            return function (t, a) {
              var s = {key: t, value: r[t]}, o = {key: a, value: r[a]};
              return e(s, o)
            }
          }
        }(r.cmp), c = [];
        return function e(r, h, u, f) {
          var d = t ? "\n" + new Array(f + 1).join(t) : "", p = t ? ": " : ":";
          if (u && u.toJSON && "function" == typeof u.toJSON && (u = u.toJSON()), u = n.call(r, h, u), void 0 !== u) {
            if ("object" != typeof u || null === u) return a.stringify(u);
            if (s(u)) {
              for (var m = [], v = 0; v < u.length; v++) {
                var y = e(u, v, u[v], f + 1) || a.stringify(null);
                m.push(d + t + y)
              }
              return "[" + m.join(",") + d + "]"
            }
            if (c.indexOf(u) !== -1) {
              if (i) return a.stringify("__cycle__");
              throw new TypeError("Converting circular structure to JSON")
            }
            c.push(u);
            for (var g = o(u).sort(l && l(u)), m = [], v = 0; v < g.length; v++) {
              var h = g[v], P = e(u, h, u[h], f + 1);
              if (P) {
                var E = a.stringify(h) + p + P;
                m.push(d + t + E)
              }
            }
            return c.splice(c.indexOf(u), 1), "{" + m.join(",") + d + "}"
          }
        }({"": e}, "", e, 0)
      };
      var s = Array.isArray || function (e) {
        return "[object Array]" === {}.toString.call(e)
      }, o = Object.keys || function (e) {
        var r = Object.prototype.hasOwnProperty || function () {
          return !0
        }, t = [];
        for (var a in e) r.call(e, a) && t.push(a);
        return t
      }
    }, {jsonify: 43}], 43: [function (e, r, t) {
      t.parse = e("./lib/parse"), t.stringify = e("./lib/stringify")
    }, {"./lib/parse": 44, "./lib/stringify": 45}], 44: [function (e, r, t) {
      var a, s, o, i, n = {'"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: "\n", r: "\r", t: "\t"},
        l = function (e) {
          throw{name: "SyntaxError", message: e, at: a, text: o}
        }, c = function (e) {
          return e && e !== s && l("Expected '" + e + "' instead of '" + s + "'"), s = o.charAt(a), a += 1, s
        }, h = function () {
          var e, r = "";
          for ("-" === s && (r = "-", c("-")); s >= "0" && s <= "9";) r += s, c();
          if ("." === s) for (r += "."; c() && s >= "0" && s <= "9";) r += s;
          if ("e" === s || "E" === s) for (r += s, c(), "-" !== s && "+" !== s || (r += s, c()); s >= "0" && s <= "9";) r += s, c();
          return e = +r, isFinite(e) ? e : void l("Bad number")
        }, u = function () {
          var e, r, t, a = "";
          if ('"' === s) for (; c();) {
            if ('"' === s) return c(), a;
            if ("\\" === s) if (c(), "u" === s) {
              for (t = 0, r = 0; r < 4 && (e = parseInt(c(), 16), isFinite(e)); r += 1) t = 16 * t + e;
              a += String.fromCharCode(t)
            } else {
              if ("string" != typeof n[s]) break;
              a += n[s]
            } else a += s
          }
          l("Bad string")
        }, f = function () {
          for (; s && s <= " ";) c()
        }, d = function () {
          switch (s) {
            case"t":
              return c("t"), c("r"), c("u"), c("e"), !0;
            case"f":
              return c("f"), c("a"), c("l"), c("s"), c("e"), !1;
            case"n":
              return c("n"), c("u"), c("l"), c("l"), null
          }
          l("Unexpected '" + s + "'")
        }, p = function () {
          var e = [];
          if ("[" === s) {
            if (c("["), f(), "]" === s) return c("]"), e;
            for (; s;) {
              if (e.push(i()), f(), "]" === s) return c("]"), e;
              c(","), f()
            }
          }
          l("Bad array")
        }, m = function () {
          var e, r = {};
          if ("{" === s) {
            if (c("{"), f(), "}" === s) return c("}"), r;
            for (; s;) {
              if (e = u(), f(), c(":"), Object.hasOwnProperty.call(r, e) && l('Duplicate key "' + e + '"'), r[e] = i(), f(), "}" === s) return c("}"), r;
              c(","), f()
            }
          }
          l("Bad object")
        };
      i = function () {
        switch (f(), s) {
          case"{":
            return m();
          case"[":
            return p();
          case'"':
            return u();
          case"-":
            return h();
          default:
            return s >= "0" && s <= "9" ? h() : d()
        }
      }, r.exports = function (e, r) {
        var t;
        return o = e, a = 0, s = " ", t = i(), f(), s && l("Syntax error"), "function" == typeof r ? function e(t, a) {
          var s, o, i = t[a];
          if (i && "object" == typeof i) for (s in i) Object.prototype.hasOwnProperty.call(i, s) && (o = e(i, s), void 0 !== o ? i[s] = o : delete i[s]);
          return r.call(t, a, i)
        }({"": t}, "") : t
      }
    }, {}], 45: [function (e, r, t) {
      function a(e) {
        return l.lastIndex = 0, l.test(e) ? '"' + e.replace(l, function (e) {
          var r = c[e];
          return "string" == typeof r ? r : "\\u" + ("0000" + e.charCodeAt(0).toString(16)).slice(-4)
        }) + '"' : '"' + e + '"'
      }

      function s(e, r) {
        var t, l, c, h, u, f = o, d = r[e];
        switch (d && "object" == typeof d && "function" == typeof d.toJSON && (d = d.toJSON(e)), "function" == typeof n && (d = n.call(r, e, d)), typeof d) {
          case"string":
            return a(d);
          case"number":
            return isFinite(d) ? String(d) : "null";
          case"boolean":
          case"null":
            return String(d);
          case"object":
            if (!d) return "null";
            if (o += i, u = [], "[object Array]" === Object.prototype.toString.apply(d)) {
              for (h = d.length, t = 0; t < h; t += 1) u[t] = s(t, d) || "null";
              return c = 0 === u.length ? "[]" : o ? "[\n" + o + u.join(",\n" + o) + "\n" + f + "]" : "[" + u.join(",") + "]", o = f, c
            }
            if (n && "object" == typeof n) for (h = n.length, t = 0; t < h; t += 1) l = n[t], "string" == typeof l && (c = s(l, d), c && u.push(a(l) + (o ? ": " : ":") + c)); else for (l in d) Object.prototype.hasOwnProperty.call(d, l) && (c = s(l, d), c && u.push(a(l) + (o ? ": " : ":") + c));
            return c = 0 === u.length ? "{}" : o ? "{\n" + o + u.join(",\n" + o) + "\n" + f + "}" : "{" + u.join(",") + "}", o = f, c
        }
      }

      var o, i, n,
        l = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        c = {"\b": "\\b", "\t": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\"};
      r.exports = function (e, r, t) {
        var a;
        if (o = "", i = "", "number" == typeof t) for (a = 0; a < t; a += 1) i += " "; else "string" == typeof t && (i = t);
        if (n = r, r && "function" != typeof r && ("object" != typeof r || "number" != typeof r.length)) throw new Error("JSON.stringify");
        return s("", {"": e})
      }
    }, {}], 46: [function (r, t, a) {
      (function (r) {
        !function (s) {
          function o(e) {
            throw new RangeError(L[e])
          }

          function i(e, r) {
            for (var t = e.length, a = []; t--;) a[t] = r(e[t]);
            return a
          }

          function n(e, r) {
            var t = e.split("@"), a = "";
            t.length > 1 && (a = t[0] + "@", e = t[1]), e = e.replace(q, ".");
            var s = e.split("."), o = i(s, r).join(".");
            return a + o
          }

          function l(e) {
            for (var r, t, a = [], s = 0, o = e.length; s < o;) r = e.charCodeAt(s++), r >= 55296 && r <= 56319 && s < o ? (t = e.charCodeAt(s++), 56320 == (64512 & t) ? a.push(((1023 & r) << 10) + (1023 & t) + 65536) : (a.push(r), s--)) : a.push(r);
            return a
          }

          function c(e) {
            return i(e, function (e) {
              var r = "";
              return e > 65535 && (e -= 65536, r += C(e >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), r += C(e)
            }).join("")
          }

          function h(e) {
            return e - 48 < 10 ? e - 22 : e - 65 < 26 ? e - 65 : e - 97 < 26 ? e - 97 : j
          }

          function u(e, r) {
            return e + 22 + 75 * (e < 26) - ((0 != r) << 5)
          }

          function f(e, r, t) {
            var a = 0;
            for (e = t ? Q(e / _) : e >> 1, e += Q(e / r); e > D * $ >> 1; a += j) e = Q(e / D);
            return Q(a + (D + 1) * e / (e + x))
          }

          function d(e) {
            var r, t, a, s, i, n, l, u, d, p, m = [], v = e.length, y = 0, g = R, P = O;
            for (t = e.lastIndexOf(I), t < 0 && (t = 0), a = 0; a < t; ++a) e.charCodeAt(a) >= 128 && o("not-basic"), m.push(e.charCodeAt(a));
            for (s = t > 0 ? t + 1 : 0; s < v;) {
              for (i = y, n = 1, l = j; s >= v && o("invalid-input"), u = h(e.charCodeAt(s++)), (u >= j || u > Q((w - y) / n)) && o("overflow"), y += u * n, d = l <= P ? S : l >= P + $ ? $ : l - P, !(u < d); l += j) p = j - d, n > Q(w / p) && o("overflow"), n *= p;
              r = m.length + 1, P = f(y - i, r, 0 == i), Q(y / r) > w - g && o("overflow"), g += Q(y / r), y %= r, m.splice(y++, 0, g)
            }
            return c(m)
          }

          function p(e) {
            var r, t, a, s, i, n, c, h, d, p, m, v, y, g, P, E = [];
            for (e = l(e), v = e.length, r = R, t = 0, i = O, n = 0; n < v; ++n) m = e[n], m < 128 && E.push(C(m));
            for (a = s = E.length, s && E.push(I); a < v;) {
              for (c = w, n = 0; n < v; ++n) m = e[n], m >= r && m < c && (c = m);
              for (y = a + 1, c - r > Q((w - t) / y) && o("overflow"), t += (c - r) * y, r = c, n = 0; n < v; ++n) if (m = e[n], m < r && ++t > w && o("overflow"), m == r) {
                for (h = t, d = j; p = d <= i ? S : d >= i + $ ? $ : d - i, !(h < p); d += j) P = h - p, g = j - p, E.push(C(u(p + P % g, 0))), h = Q(P / g);
                E.push(C(u(h, 0))), i = f(t, y, a == s), t = 0, ++a
              }
              ++t, ++r
            }
            return E.join("")
          }

          function m(e) {
            return n(e, function (e) {
              return A.test(e) ? d(e.slice(4).toLowerCase()) : e
            })
          }

          function v(e) {
            return n(e, function (e) {
              return k.test(e) ? "xn--" + p(e) : e
            })
          }

          var y = "object" == typeof a && a && !a.nodeType && a, g = "object" == typeof t && t && !t.nodeType && t,
            P = "object" == typeof r && r;
          P.global !== P && P.window !== P && P.self !== P || (s = P);
          var E, b, w = 2147483647, j = 36, S = 1, $ = 26, x = 38, _ = 700, O = 72, R = 128, I = "-", A = /^xn--/,
            k = /[^\x20-\x7E]/, q = /[\x2E\u3002\uFF0E\uFF61]/g, L = {
              overflow: "Overflow: input needs wider integers to process",
              "not-basic": "Illegal input >= 0x80 (not a basic code point)",
              "invalid-input": "Invalid input"
            }, D = j - S, Q = Math.floor, C = String.fromCharCode;
          if (E = {
              version: "1.4.1",
              ucs2: {decode: l, encode: c},
              decode: d,
              encode: p,
              toASCII: v,
              toUnicode: m
            }, "function" == typeof e && "object" == typeof e.amd && e.amd) e("punycode", function () {
            return E
          }); else if (y && g) if (t.exports == y) g.exports = E; else for (b in E) E.hasOwnProperty(b) && (y[b] = E[b]); else s.punycode = E
        }(this)
      }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}], 47: [function (e, r, t) {
      "use strict";

      function a(e, r) {
        return Object.prototype.hasOwnProperty.call(e, r)
      }

      r.exports = function (e, r, t, o) {
        r = r || "&", t = t || "=";
        var i = {};
        if ("string" != typeof e || 0 === e.length) return i;
        var n = /\+/g;
        e = e.split(r);
        var l = 1e3;
        o && "number" == typeof o.maxKeys && (l = o.maxKeys);
        var c = e.length;
        l > 0 && c > l && (c = l);
        for (var h = 0; h < c; ++h) {
          var u, f, d, p, m = e[h].replace(n, "%20"), v = m.indexOf(t);
          v >= 0 ? (u = m.substr(0, v), f = m.substr(v + 1)) : (u = m, f = ""), d = decodeURIComponent(u), p = decodeURIComponent(f), a(i, d) ? s(i[d]) ? i[d].push(p) : i[d] = [i[d], p] : i[d] = p
        }
        return i
      };
      var s = Array.isArray || function (e) {
        return "[object Array]" === Object.prototype.toString.call(e)
      }
    }, {}], 48: [function (e, r, t) {
      "use strict";

      function a(e, r) {
        if (e.map) return e.map(r);
        for (var t = [], a = 0; a < e.length; a++) t.push(r(e[a], a));
        return t
      }

      var s = function (e) {
        switch (typeof e) {
          case"string":
            return e;
          case"boolean":
            return e ? "true" : "false";
          case"number":
            return isFinite(e) ? e : "";
          default:
            return ""
        }
      };
      r.exports = function (e, r, t, n) {
        return r = r || "&", t = t || "=", null === e && (e = void 0), "object" == typeof e ? a(i(e), function (i) {
          var n = encodeURIComponent(s(i)) + t;
          return o(e[i]) ? a(e[i], function (e) {
            return n + encodeURIComponent(s(e))
          }).join(r) : n + encodeURIComponent(s(e[i]))
        }).join(r) : n ? encodeURIComponent(s(n)) + t + encodeURIComponent(s(e)) : ""
      };
      var o = Array.isArray || function (e) {
        return "[object Array]" === Object.prototype.toString.call(e)
      }, i = Object.keys || function (e) {
        var r = [];
        for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && r.push(t);
        return r
      }
    }, {}], 49: [function (e, r, t) {
      "use strict";
      t.decode = t.parse = e("./decode"), t.encode = t.stringify = e("./encode")
    }, {"./decode": 47, "./encode": 48}], 50: [function (e, r, t) {
      "use strict";

      function a() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
      }

      function s(e, r, t) {
        if (e && c.isObject(e) && e instanceof a) return e;
        var s = new a;
        return s.parse(e, r, t), s
      }

      function o(e) {
        return c.isString(e) && (e = s(e)), e instanceof a ? e.format() : a.prototype.format.call(e)
      }

      function i(e, r) {
        return s(e, !1, !0).resolve(r)
      }

      function n(e, r) {
        return e ? s(e, !1, !0).resolveObject(r) : r
      }

      var l = e("punycode"), c = e("./util");
      t.parse = s, t.resolve = i, t.resolveObject = n, t.format = o, t.Url = a;
      var h = /^([a-z0-9.+-]+:)/i, u = /:[0-9]*$/, f = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
        d = ["<", ">", '"', "`", " ", "\r", "\n", "\t"], p = ["{", "}", "|", "\\", "^", "`"].concat(d),
        m = ["'"].concat(p), v = ["%", "/", "?", ";", "#"].concat(m), y = ["/", "?", "#"], g = 255,
        P = /^[+a-z0-9A-Z_-]{0,63}$/, E = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, b = {javascript: !0, "javascript:": !0},
        w = {javascript: !0, "javascript:": !0}, j = {
          http: !0,
          https: !0,
          ftp: !0,
          gopher: !0,
          file: !0,
          "http:": !0,
          "https:": !0,
          "ftp:": !0,
          "gopher:": !0,
          "file:": !0
        }, S = e("querystring");
      a.prototype.parse = function (e, r, t) {
        if (!c.isString(e)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
        var a = e.indexOf("?"), s = a !== -1 && a < e.indexOf("#") ? "?" : "#", o = e.split(s), i = /\\/g;
        o[0] = o[0].replace(i, "/"), e = o.join(s);
        var n = e;
        if (n = n.trim(), !t && 1 === e.split("#").length) {
          var u = f.exec(n);
          if (u) return this.path = n, this.href = n, this.pathname = u[1], u[2] ? (this.search = u[2], this.query = r ? S.parse(this.search.substr(1)) : this.search.substr(1)) : r && (this.search = "", this.query = {}), this
        }
        var d = h.exec(n);
        if (d) {
          d = d[0];
          var p = d.toLowerCase();
          this.protocol = p, n = n.substr(d.length)
        }
        if (t || d || n.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var $ = "//" === n.substr(0, 2);
          !$ || d && w[d] || (n = n.substr(2), this.slashes = !0)
        }
        if (!w[d] && ($ || d && !j[d])) {
          for (var x = -1, _ = 0; _ < y.length; _++) {
            var O = n.indexOf(y[_]);
            O !== -1 && (x === -1 || O < x) && (x = O)
          }
          var R, I;
          I = x === -1 ? n.lastIndexOf("@") : n.lastIndexOf("@", x), I !== -1 && (R = n.slice(0, I), n = n.slice(I + 1), this.auth = decodeURIComponent(R)), x = -1;
          for (var _ = 0; _ < v.length; _++) {
            var O = n.indexOf(v[_]);
            O !== -1 && (x === -1 || O < x) && (x = O)
          }
          x === -1 && (x = n.length), this.host = n.slice(0, x), n = n.slice(x), this.parseHost(), this.hostname = this.hostname || "";
          var A = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!A) for (var k = this.hostname.split(/\./), _ = 0, q = k.length; _ < q; _++) {
            var L = k[_];
            if (L && !L.match(P)) {
              for (var D = "", Q = 0, C = L.length; Q < C; Q++) D += L.charCodeAt(Q) > 127 ? "x" : L[Q];
              if (!D.match(P)) {
                var U = k.slice(0, _), V = k.slice(_ + 1), z = L.match(E);
                z && (U.push(z[1]), V.unshift(z[2])), V.length && (n = "/" + V.join(".") + n), this.hostname = U.join(".");
                break
              }
            }
          }
          this.hostname = this.hostname.length > g ? "" : this.hostname.toLowerCase(), A || (this.hostname = l.toASCII(this.hostname));
          var T = this.port ? ":" + this.port : "", M = this.hostname || "";
          this.host = M + T, this.href += this.host, A && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== n[0] && (n = "/" + n))
        }
        if (!b[p]) for (var _ = 0, q = m.length; _ < q; _++) {
          var N = m[_];
          if (n.indexOf(N) !== -1) {
            var F = encodeURIComponent(N);
            F === N && (F = escape(N)), n = n.split(N).join(F)
          }
        }
        var H = n.indexOf("#");
        H !== -1 && (this.hash = n.substr(H), n = n.slice(0, H));
        var J = n.indexOf("?");
        if (J !== -1 ? (this.search = n.substr(J), this.query = n.substr(J + 1), r && (this.query = S.parse(this.query)), n = n.slice(0, J)) : r && (this.search = "", this.query = {}), n && (this.pathname = n), j[p] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          var T = this.pathname || "", G = this.search || "";
          this.path = T + G
        }
        return this.href = this.format(), this
      }, a.prototype.format = function () {
        var e = this.auth || "";
        e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
        var r = this.protocol || "", t = this.pathname || "", a = this.hash || "", s = !1, o = "";
        this.host ? s = e + this.host : this.hostname && (s = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (s += ":" + this.port)), this.query && c.isObject(this.query) && Object.keys(this.query).length && (o = S.stringify(this.query));
        var i = this.search || o && "?" + o || "";
        return r && ":" !== r.substr(-1) && (r += ":"), this.slashes || (!r || j[r]) && s !== !1 ? (s = "//" + (s || ""), t && "/" !== t.charAt(0) && (t = "/" + t)) : s || (s = ""), a && "#" !== a.charAt(0) && (a = "#" + a), i && "?" !== i.charAt(0) && (i = "?" + i), t = t.replace(/[?#]/g, function (e) {
          return encodeURIComponent(e)
        }), i = i.replace("#", "%23"), r + s + t + i + a
      }, a.prototype.resolve = function (e) {
        return this.resolveObject(s(e, !1, !0)).format()
      }, a.prototype.resolveObject = function (e) {
        if (c.isString(e)) {
          var r = new a;
          r.parse(e, !1, !0), e = r
        }
        for (var t = new a, s = Object.keys(this), o = 0; o < s.length; o++) {
          var i = s[o];
          t[i] = this[i]
        }
        if (t.hash = e.hash, "" === e.href) return t.href = t.format(), t;
        if (e.slashes && !e.protocol) {
          for (var n = Object.keys(e), l = 0; l < n.length; l++) {
            var h = n[l];
            "protocol" !== h && (t[h] = e[h])
          }
          return j[t.protocol] && t.hostname && !t.pathname && (t.path = t.pathname = "/"), t.href = t.format(), t
        }
        if (e.protocol && e.protocol !== t.protocol) {
          if (!j[e.protocol]) {
            for (var u = Object.keys(e), f = 0; f < u.length; f++) {
              var d = u[f];
              t[d] = e[d]
            }
            return t.href = t.format(), t
          }
          if (t.protocol = e.protocol, e.host || w[e.protocol]) t.pathname = e.pathname; else {
            for (var p = (e.pathname || "").split("/"); p.length && !(e.host = p.shift());) ;
            e.host || (e.host = ""), e.hostname || (e.hostname = ""), "" !== p[0] && p.unshift(""), p.length < 2 && p.unshift(""), t.pathname = p.join("/")
          }
          if (t.search = e.search, t.query = e.query, t.host = e.host || "", t.auth = e.auth, t.hostname = e.hostname || e.host, t.port = e.port, t.pathname || t.search) {
            var m = t.pathname || "", v = t.search || "";
            t.path = m + v
          }
          return t.slashes = t.slashes || e.slashes, t.href = t.format(), t
        }
        var y = t.pathname && "/" === t.pathname.charAt(0), g = e.host || e.pathname && "/" === e.pathname.charAt(0),
          P = g || y || t.host && e.pathname, E = P, b = t.pathname && t.pathname.split("/") || [],
          p = e.pathname && e.pathname.split("/") || [], S = t.protocol && !j[t.protocol];
        if (S && (t.hostname = "", t.port = null, t.host && ("" === b[0] ? b[0] = t.host : b.unshift(t.host)), t.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ("" === p[0] ? p[0] = e.host : p.unshift(e.host)), e.host = null), P = P && ("" === p[0] || "" === b[0])), g) t.host = e.host || "" === e.host ? e.host : t.host, t.hostname = e.hostname || "" === e.hostname ? e.hostname : t.hostname, t.search = e.search, t.query = e.query, b = p; else if (p.length) b || (b = []), b.pop(), b = b.concat(p), t.search = e.search, t.query = e.query; else if (!c.isNullOrUndefined(e.search)) {
          if (S) {
            t.hostname = t.host = b.shift();
            var $ = !!(t.host && t.host.indexOf("@") > 0) && t.host.split("@");
            $ && (t.auth = $.shift(), t.host = t.hostname = $.shift())
          }
          return t.search = e.search, t.query = e.query, c.isNull(t.pathname) && c.isNull(t.search) || (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.href = t.format(), t
        }
        if (!b.length) return t.pathname = null, t.path = t.search ? "/" + t.search : null, t.href = t.format(), t;
        for (var x = b.slice(-1)[0], _ = (t.host || e.host || b.length > 1) && ("." === x || ".." === x) || "" === x, O = 0, R = b.length; R >= 0; R--) x = b[R], "." === x ? b.splice(R, 1) : ".." === x ? (b.splice(R, 1), O++) : O && (b.splice(R, 1), O--);
        if (!P && !E) for (; O--; O) b.unshift("..");
        !P || "" === b[0] || b[0] && "/" === b[0].charAt(0) || b.unshift(""), _ && "/" !== b.join("/").substr(-1) && b.push("");
        var I = "" === b[0] || b[0] && "/" === b[0].charAt(0);
        if (S) {
          t.hostname = t.host = I ? "" : b.length ? b.shift() : "";
          var $ = !!(t.host && t.host.indexOf("@") > 0) && t.host.split("@");
          $ && (t.auth = $.shift(), t.host = t.hostname = $.shift())
        }
        return P = P || t.host && b.length, P && !I && b.unshift(""), b.length ? t.pathname = b.join("/") : (t.pathname = null, t.path = null), c.isNull(t.pathname) && c.isNull(t.search) || (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.auth = e.auth || t.auth, t.slashes = t.slashes || e.slashes, t.href = t.format(), t
      }, a.prototype.parseHost = function () {
        var e = this.host, r = u.exec(e);
        r && (r = r[0], ":" !== r && (this.port = r.substr(1)), e = e.substr(0, e.length - r.length)), e && (this.hostname = e)
      }
    }, {"./util": 51, punycode: 46, querystring: 49}], 51: [function (e, r, t) {
      "use strict";
      r.exports = {
        isString: function (e) {
          return "string" == typeof e
        }, isObject: function (e) {
          return "object" == typeof e && null !== e
        }, isNull: function (e) {
          return null === e
        }, isNullOrUndefined: function (e) {
          return null == e
        }
      }
    }, {}], ajv: [function (e, r, t) {
      "use strict";

      function a(e) {
        return v.test(e)
      }

      function Ajv(r) {
        function t(e, r) {
          var t;
          if ("string" == typeof e) {
            if (t = j(e), !t) throw new Error('no schema with key or ref "' + e + '"')
          } else {
            var a = O(e);
            t = a.validate || R(a)
          }
          var s = t(r);
          return t.$async === !0 ? "*" == C._opts.async ? p(s) : s : (C.errors = t.errors, s)
        }

        function g(e, r) {
          var t = O(e, void 0, r);
          return t.validate || R(t)
        }

        function P(e, r, t, a) {
          if (Array.isArray(e)) for (var s = 0; s < e.length; s++) P(e[s], void 0, t, a); else r = o.normalizeId(r || e.id), D(r), C._schemas[r] = O(e, t, a, !0)
        }

        function E(e, r, t) {
          P(e, r, t, !0)
        }

        function b(e, r) {
          var s = e.$schema || C._opts.defaultMeta || w(), o = C._formats.uri;
          C._formats.uri = "function" == typeof o ? a : v;
          var i;
          try {
            i = t(s, e)
          } finally {
            C._formats.uri = o
          }
          if (!i && r) {
            var n = "schema is invalid: " + I();
            if ("log" != C._opts.validateSchema) throw new Error(n);
            console.error(n)
          }
          return i
        }

        function w() {
          var e = C._opts.meta;
          return C._opts.defaultMeta = "object" == typeof e ? e.id || e : C._opts.v5 ? u.META_SCHEMA_ID : m
        }

        function j(e) {
          var r = $(e);
          switch (typeof r) {
            case"object":
              return r.validate || R(r);
            case"string":
              return j(r);
            case"undefined":
              return S(e)
          }
        }

        function S(e) {
          var r = o.schema.call(C, {schema: {}}, e);
          if (r) {
            var t = r.schema, a = r.root, i = r.baseId, l = s.call(C, t, a, void 0, i);
            return C._fragments[e] = new n({ref: e, fragment: !0, schema: t, root: a, baseId: i, validate: l}), l
          }
        }

        function $(e) {
          return e = o.normalizeId(e), C._schemas[e] || C._refs[e] || C._fragments[e]
        }

        function x(e) {
          if (e instanceof RegExp) return _(C._schemas, e), void _(C._refs, e);
          switch (typeof e) {
            case"undefined":
              return _(C._schemas), _(C._refs), void C._cache.clear();
            case"string":
              var r = $(e);
              return r && C._cache.del(r.jsonStr), delete C._schemas[e], void delete C._refs[e];
            case"object":
              var t = l(e);
              C._cache.del(t);
              var a = e.id;
              a && (a = o.normalizeId(a), delete C._schemas[a], delete C._refs[a])
          }
        }

        function _(e, r) {
          for (var t in e) {
            var a = e[t];
            a.meta || r && !r.test(t) || (C._cache.del(a.jsonStr), delete e[t])
          }
        }

        function O(e, r, t, a) {
          if ("object" != typeof e) throw new Error("schema should be object");
          var s = l(e), i = C._cache.get(s);
          if (i) return i;
          a = a || C._opts.addUsedSchema !== !1;
          var c = o.normalizeId(e.id);
          c && a && D(c);
          var h, u = C._opts.validateSchema !== !1 && !r;
          u && !(h = e.id && e.id == e.$schema) && b(e, !0);
          var f = o.ids.call(C, e), d = new n({id: c, schema: e, localRefs: f, jsonStr: s, meta: t});
          return "#" != c[0] && a && (C._refs[c] = d), C._cache.put(s, d), u && h && b(e, !0), d
        }

        function R(e, r) {
          function t() {
            var r = e.validate, a = r.apply(null, arguments);
            return t.errors = r.errors, a
          }

          if (e.compiling) return e.validate = t, t.schema = e.schema, t.errors = null, t.root = r ? r : t, e.schema.$async === !0 && (t.$async = !0), t;
          e.compiling = !0;
          var a;
          e.meta && (a = C._opts, C._opts = C._metaOpts);
          var o;
          try {
            o = s.call(C, e.schema, r, e.localRefs)
          } finally {
            e.compiling = !1, e.meta && (C._opts = a)
          }
          return e.validate = o, e.refs = o.refs, e.refVal = o.refVal, e.root = o.root, o
        }

        function I(e, r) {
          if (e = e || C.errors, !e) return "No errors";
          r = r || {};
          for (var t = void 0 === r.separator ? ", " : r.separator, a = void 0 === r.dataVar ? "data" : r.dataVar, s = "", o = 0; o < e.length; o++) {
            var i = e[o];
            i && (s += a + i.dataPath + " " + i.message + t)
          }
          return s.slice(0, -t.length)
        }

        function A(e, r) {
          "string" == typeof r && (r = new RegExp(r)), C._formats[e] = r
        }

        function k() {
          if (C._opts.meta !== !1) {
            var r = e("./refs/json-schema-draft-04.json");
            E(r, m, !0), C._refs["http://json-schema.org/schema"] = m
          }
        }

        function q() {
          var e = C._opts.schemas;
          if (e) if (Array.isArray(e)) P(e); else for (var r in e) P(e[r], r)
        }

        function L() {
          for (var e in C._opts.formats) {
            var r = C._opts.formats[e];
            A(e, r)
          }
        }

        function D(e) {
          if (C._schemas[e] || C._refs[e]) throw new Error('schema with key or id "' + e + '" already exists')
        }

        function Q() {
          for (var e = f.copy(C._opts), r = 0; r < y.length; r++) delete e[y[r]];
          return e
        }

        if (!(this instanceof Ajv)) return new Ajv(r);
        var C = this;
        r = this._opts = f.copy(r) || {}, this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = c(r.format), this._cache = r.cache || new i, this._loadingSchemas = {}, this._compilations = [], this.RULES = h(), this.validate = t, this.compile = g, this.addSchema = P, this.addMetaSchema = E, this.validateSchema = b, this.getSchema = j, this.removeSchema = x, this.addFormat = A, this.errorsText = I, this._addSchema = O, this._compile = R, r.loopRequired = r.loopRequired || 1 / 0, (r.async || r.transpile) && d.setup(r), r.beautify === !0 && (r.beautify = {indent_size: 2}), "property" == r.errorDataPath && (r._errorDataPathProperty = !0), this._metaOpts = Q(), r.formats && L(), k(), r.v5 && u.enable(this), "object" == typeof r.meta && E(r.meta), q()
      }

      var s = e("./compile"), o = e("./compile/resolve"), i = e("./cache"), n = e("./compile/schema_obj"),
        l = e("json-stable-stringify"), c = e("./compile/formats"), h = e("./compile/rules"), u = e("./v5"),
        f = e("./compile/util"), d = e("./async"), p = e("co");
      r.exports = Ajv, Ajv.prototype.compileAsync = d.compile, Ajv.prototype.addKeyword = e("./keyword"), Ajv.ValidationError = e("./compile/validation_error");
      var m = "http://json-schema.org/draft-04/schema", v = /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i,
        y = ["removeAdditional", "useDefaults", "coerceTypes"]
    }, {
      "./async": 1,
      "./cache": 2,
      "./compile": 6,
      "./compile/formats": 5,
      "./compile/resolve": 7,
      "./compile/rules": 8,
      "./compile/schema_obj": 9,
      "./compile/util": 11,
      "./compile/validation_error": 12,
      "./keyword": 37,
      "./refs/json-schema-draft-04.json": 38,
      "./v5": 40,
      co: 41,
      "json-stable-stringify": 42
    }]
  }, {}, [])("ajv")
});
//# sourceMappingURL=dist/ajv.min.js.mapOpal.loaded(["ajv.min"]);
/* Generated by Opal 0.11.4 */
Opal.modules["vector2d/calculations"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$-', '$*', '$x', '$y', '$+', '$normalized?', '$normalize', '$acos', '$dot_product', '$calculate_each', '$sqrt', '$squared_distance', '$coerce', '$class', '$cross_product', '$angle_between', '$private', '$new', '$send']);
  return (function($base, $super, $parent_nesting) {
    function $Vector2d(){};
    var self = $Vector2d = $klass($base, $super, 'Vector2d', $Vector2d);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var $Calculations, self = $Calculations = $module($base, 'Calculations');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Calculations_$_4, TMP_Calculations_$_5, TMP_Calculations_$_6, TMP_Calculations_$_7, TMP_Calculations_distance_8, TMP_Calculations_squared_distance_9, TMP_Calculations_dot_product_10, TMP_Calculations_cross_product_11, TMP_Calculations_angle_between_12, TMP_Calculations_calculate_each_13;

      
      (function($base, $parent_nesting) {
        var $ClassMethods, self = $ClassMethods = $module($base, 'ClassMethods');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ClassMethods_cross_product_1, TMP_ClassMethods_dot_product_2, TMP_ClassMethods_angle_between_3;

        
        
        Opal.defn(self, '$cross_product', TMP_ClassMethods_cross_product_1 = function $$cross_product(vector1, vector2) {
          var self = this;

          return $rb_minus($rb_times(vector1.$x(), vector2.$y()), $rb_times(vector1.$y(), vector2.$x()))
        }, TMP_ClassMethods_cross_product_1.$$arity = 2);
        
        Opal.defn(self, '$dot_product', TMP_ClassMethods_dot_product_2 = function $$dot_product(vector1, vector2) {
          var self = this;

          return $rb_plus($rb_times(vector1.$x(), vector2.$x()), $rb_times(vector1.$y(), vector2.$y()))
        }, TMP_ClassMethods_dot_product_2.$$arity = 2);
        
        Opal.defn(self, '$angle_between', TMP_ClassMethods_angle_between_3 = function $$angle_between(vector1, vector2) {
          var self = this, one = nil, two = nil;

          
          one = (function() {if ($truthy(vector1['$normalized?']())) {
            return vector1
            } else {
            return vector1.$normalize()
          }; return nil; })();
          two = (function() {if ($truthy(vector2['$normalized?']())) {
            return vector2
            } else {
            return vector2.$normalize()
          }; return nil; })();
          return Opal.const_get_relative($nesting, 'Math').$acos(self.$dot_product(one, two));
        }, TMP_ClassMethods_angle_between_3.$$arity = 2);
      })($nesting[0], $nesting);
      
      Opal.defn(self, '$*', TMP_Calculations_$_4 = function(other) {
        var self = this;

        return self.$calculate_each("*", other)
      }, TMP_Calculations_$_4.$$arity = 1);
      
      Opal.defn(self, '$/', TMP_Calculations_$_5 = function(other) {
        var self = this;

        return self.$calculate_each("/", other)
      }, TMP_Calculations_$_5.$$arity = 1);
      
      Opal.defn(self, '$+', TMP_Calculations_$_6 = function(other) {
        var self = this;

        return self.$calculate_each("+", other)
      }, TMP_Calculations_$_6.$$arity = 1);
      
      Opal.defn(self, '$-', TMP_Calculations_$_7 = function(other) {
        var self = this;

        return self.$calculate_each("-", other)
      }, TMP_Calculations_$_7.$$arity = 1);
      
      Opal.defn(self, '$distance', TMP_Calculations_distance_8 = function $$distance(other) {
        var self = this;

        return Opal.const_get_relative($nesting, 'Math').$sqrt(self.$squared_distance(other))
      }, TMP_Calculations_distance_8.$$arity = 1);
      
      Opal.defn(self, '$squared_distance', TMP_Calculations_squared_distance_9 = function $$squared_distance(other) {
        var $a, $b, self = this, v = nil, _ = nil, dx = nil, dy = nil;

        
        $b = self.$coerce(other), $a = Opal.to_ary($b), (v = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $b;
        dx = $rb_minus(v.$x(), self.$x());
        dy = $rb_minus(v.$y(), self.$y());
        return $rb_plus($rb_times(dx, dx), $rb_times(dy, dy));
      }, TMP_Calculations_squared_distance_9.$$arity = 1);
      
      Opal.defn(self, '$dot_product', TMP_Calculations_dot_product_10 = function $$dot_product(other) {
        var $a, $b, self = this, v = nil, _ = nil;

        
        $b = self.$coerce(other), $a = Opal.to_ary($b), (v = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $b;
        return self.$class().$dot_product(self, v);
      }, TMP_Calculations_dot_product_10.$$arity = 1);
      
      Opal.defn(self, '$cross_product', TMP_Calculations_cross_product_11 = function $$cross_product(other) {
        var $a, $b, self = this, v = nil, _ = nil;

        
        $b = self.$coerce(other), $a = Opal.to_ary($b), (v = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $b;
        return self.$class().$cross_product(self, v);
      }, TMP_Calculations_cross_product_11.$$arity = 1);
      
      Opal.defn(self, '$angle_between', TMP_Calculations_angle_between_12 = function $$angle_between(other) {
        var $a, $b, self = this, v = nil, _ = nil;

        
        $b = self.$coerce(other), $a = Opal.to_ary($b), (v = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $b;
        return self.$class().$angle_between(self, v);
      }, TMP_Calculations_angle_between_12.$$arity = 1);
      self.$private();
      
      Opal.defn(self, '$calculate_each', TMP_Calculations_calculate_each_13 = function $$calculate_each(method, other) {
        var $a, $b, self = this, v = nil, _ = nil;

        
        $b = self.$coerce(other), $a = Opal.to_ary($b), (v = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $b;
        return self.$class().$new(self.$x().$send(method, v.$x()), self.$y().$send(method, v.$y()));
      }, TMP_Calculations_calculate_each_13.$$arity = 2);
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["vector2d/coercions"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $hash2 = Opal.hash2;

  Opal.add_stubs(['$===', '$parse', '$raise', '$class', '$x', '$y', '$new', '$to_i', '$to_f']);
  return (function($base, $super, $parent_nesting) {
    function $Vector2d(){};
    var self = $Vector2d = $klass($base, $super, 'Vector2d', $Vector2d);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var $Coercions, self = $Coercions = $module($base, 'Coercions');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Coercions_coerce_1, TMP_Coercions_inspect_2, TMP_Coercions_to_a_3, TMP_Coercions_to_hash_4, TMP_Coercions_to_i_vector_5, TMP_Coercions_to_f_vector_6, TMP_Coercions_to_s_7;

      
      
      Opal.defn(self, '$coerce', TMP_Coercions_coerce_1 = function $$coerce(other) {
        var self = this, $case = nil;

        return (function() {$case = other;
        if (Opal.const_get_relative($nesting, 'Vector2d')['$===']($case)) {return [other, self]}
        else if (Opal.const_get_relative($nesting, 'Array')['$===']($case) || Opal.const_get_relative($nesting, 'Numeric')['$===']($case) || Opal.const_get_relative($nesting, 'String')['$===']($case) || Opal.const_get_relative($nesting, 'Hash')['$===']($case)) {return [Opal.const_get_relative($nesting, 'Vector2d').$parse(other), self]}
        else {return self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + (self.$class()) + " can't be coerced into " + (other.$class()))}})()
      }, TMP_Coercions_coerce_1.$$arity = 1);
      
      Opal.defn(self, '$inspect', TMP_Coercions_inspect_2 = function $$inspect() {
        var self = this;

        return "" + "Vector2d(" + (self.$x()) + "," + (self.$y()) + ")"
      }, TMP_Coercions_inspect_2.$$arity = 0);
      
      Opal.defn(self, '$to_a', TMP_Coercions_to_a_3 = function $$to_a() {
        var self = this;

        return [self.$x(), self.$y()]
      }, TMP_Coercions_to_a_3.$$arity = 0);
      
      Opal.defn(self, '$to_hash', TMP_Coercions_to_hash_4 = function $$to_hash() {
        var self = this;

        return $hash2(["x", "y"], {"x": self.$x(), "y": self.$y()})
      }, TMP_Coercions_to_hash_4.$$arity = 0);
      
      Opal.defn(self, '$to_i_vector', TMP_Coercions_to_i_vector_5 = function $$to_i_vector() {
        var self = this;

        return self.$class().$new(self.$x().$to_i(), self.$y().$to_i())
      }, TMP_Coercions_to_i_vector_5.$$arity = 0);
      
      Opal.defn(self, '$to_f_vector', TMP_Coercions_to_f_vector_6 = function $$to_f_vector() {
        var self = this;

        return self.$class().$new(self.$x().$to_f(), self.$y().$to_f())
      }, TMP_Coercions_to_f_vector_6.$$arity = 0);
      
      Opal.defn(self, '$to_s', TMP_Coercions_to_s_7 = function $$to_s() {
        var self = this;

        return "" + (self.$x()) + "x" + (self.$y())
      }, TMP_Coercions_to_s_7.$$arity = 0);
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["vector2d/fitting"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$coerce', '$>', '$x', '$y', '$fit', '$/', '$to_f_vector', '$*', '$==', '$<', '$alias_method']);
  return (function($base, $super, $parent_nesting) {
    function $Vector2d(){};
    var self = $Vector2d = $klass($base, $super, 'Vector2d', $Vector2d);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var $Fitting, self = $Fitting = $module($base, 'Fitting');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Fitting_contain_1, TMP_Fitting_fit_2, TMP_Fitting_fit_either_3;

      
      
      Opal.defn(self, '$contain', TMP_Fitting_contain_1 = function $$contain(other) {
        var $a, $b, self = this, v = nil, _ = nil;

        
        $b = self.$coerce(other), $a = Opal.to_ary($b), (v = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy(($truthy($a = $rb_gt(v.$x(), self.$x())) ? $a : $rb_gt(v.$y(), self.$y())))) {
          return other.$fit(self)
          } else {
          return other
        };
      }, TMP_Fitting_contain_1.$$arity = 1);
      
      Opal.defn(self, '$fit', TMP_Fitting_fit_2 = function $$fit(other) {
        var $a, $b, self = this, v = nil, _ = nil, scale = nil;

        
        $b = self.$coerce(other), $a = Opal.to_ary($b), (v = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $b;
        scale = $rb_divide(v.$to_f_vector(), self);
        return $rb_times(self, (function() {if ($truthy(($truthy($a = scale.$y()['$=='](0)) ? $a : ($truthy($b = $rb_gt(scale.$x(), 0)) ? $rb_lt(scale.$x(), scale.$y()) : $b)))) {
          return scale.$x()
          } else {
          return scale.$y()
        }; return nil; })());
      }, TMP_Fitting_fit_2.$$arity = 1);
      self.$alias_method("constrain_both", "fit");
      
      Opal.defn(self, '$fit_either', TMP_Fitting_fit_either_3 = function $$fit_either(other) {
        var $a, $b, self = this, v = nil, _ = nil, scale = nil;

        
        $b = self.$coerce(other), $a = Opal.to_ary($b), (v = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $b;
        scale = $rb_divide(v.$to_f_vector(), self);
        if ($truthy(($truthy($a = $rb_gt(scale.$x(), 0)) ? $rb_gt(scale.$y(), 0) : $a))) {
          
          scale = (function() {if ($truthy($rb_lt(scale.$x(), scale.$y()))) {
            return scale.$y()
            } else {
            return scale.$x()
          }; return nil; })();
          return $rb_times(self, scale);
          } else {
          return self.$fit(v)
        };
      }, TMP_Fitting_fit_either_3.$$arity = 1);
      self.$alias_method("constrain_one", "fit_either");
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["vector2d/properties"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module;

  Opal.add_stubs(['$atan2', '$y', '$x', '$abs', '$/', '$to_f', '$sqrt', '$squared_length', '$+', '$*', '$==', '$length']);
  return (function($base, $super, $parent_nesting) {
    function $Vector2d(){};
    var self = $Vector2d = $klass($base, $super, 'Vector2d', $Vector2d);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var $Properties, self = $Properties = $module($base, 'Properties');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Properties_angle_1, TMP_Properties_aspect_ratio_2, TMP_Properties_length_3, TMP_Properties_squared_length_4, TMP_Properties_normalized$q_5;

      
      
      Opal.defn(self, '$angle', TMP_Properties_angle_1 = function $$angle() {
        var self = this;

        return Opal.const_get_relative($nesting, 'Math').$atan2(self.$y(), self.$x())
      }, TMP_Properties_angle_1.$$arity = 0);
      
      Opal.defn(self, '$aspect_ratio', TMP_Properties_aspect_ratio_2 = function $$aspect_ratio() {
        var self = this;

        return $rb_divide(self.$x().$to_f(), self.$y().$to_f()).$abs()
      }, TMP_Properties_aspect_ratio_2.$$arity = 0);
      
      Opal.defn(self, '$length', TMP_Properties_length_3 = function $$length() {
        var self = this;

        return Opal.const_get_relative($nesting, 'Math').$sqrt(self.$squared_length())
      }, TMP_Properties_length_3.$$arity = 0);
      
      Opal.defn(self, '$squared_length', TMP_Properties_squared_length_4 = function $$squared_length() {
        var self = this;

        return $rb_plus($rb_times(self.$x(), self.$x()), $rb_times(self.$y(), self.$y()))
      }, TMP_Properties_squared_length_4.$$arity = 0);
      
      Opal.defn(self, '$normalized?', TMP_Properties_normalized$q_5 = function() {
        var self = this;

        return self.$length().$to_f()['$=='](1.0)
      }, TMP_Properties_normalized$q_5.$$arity = 0);
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["vector2d/transformations"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module;

  Opal.add_stubs(['$new', '$class', '$ceil', '$x', '$y', '$floor', '$resize', '$-@', '$*', '$/', '$length', '$-', '$cos', '$sin', '$+', '$round', '$min']);
  return (function($base, $super, $parent_nesting) {
    function $Vector2d(){};
    var self = $Vector2d = $klass($base, $super, 'Vector2d', $Vector2d);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var $Transformations, self = $Transformations = $module($base, 'Transformations');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Transformations_ceil_1, TMP_Transformations_floor_2, TMP_Transformations_normalize_3, TMP_Transformations_perpendicular_4, TMP_Transformations_resize_5, TMP_Transformations_reverse_6, TMP_Transformations_rotate_7, TMP_Transformations_round_8, TMP_Transformations_truncate_9;

      
      
      Opal.defn(self, '$ceil', TMP_Transformations_ceil_1 = function $$ceil() {
        var self = this;

        return self.$class().$new(self.$x().$ceil(), self.$y().$ceil())
      }, TMP_Transformations_ceil_1.$$arity = 0);
      
      Opal.defn(self, '$floor', TMP_Transformations_floor_2 = function $$floor() {
        var self = this;

        return self.$class().$new(self.$x().$floor(), self.$y().$floor())
      }, TMP_Transformations_floor_2.$$arity = 0);
      
      Opal.defn(self, '$normalize', TMP_Transformations_normalize_3 = function $$normalize() {
        var self = this;

        return self.$resize(1.0)
      }, TMP_Transformations_normalize_3.$$arity = 0);
      
      Opal.defn(self, '$perpendicular', TMP_Transformations_perpendicular_4 = function $$perpendicular() {
        var self = this;

        return Opal.const_get_relative($nesting, 'Vector2d').$new(self.$y()['$-@'](), self.$x())
      }, TMP_Transformations_perpendicular_4.$$arity = 0);
      
      Opal.defn(self, '$resize', TMP_Transformations_resize_5 = function $$resize(new_length) {
        var self = this;

        return $rb_times(self, $rb_divide(new_length, self.$length()))
      }, TMP_Transformations_resize_5.$$arity = 1);
      
      Opal.defn(self, '$reverse', TMP_Transformations_reverse_6 = function $$reverse() {
        var self = this;

        return self.$class().$new(self.$x()['$-@'](), self.$y()['$-@']())
      }, TMP_Transformations_reverse_6.$$arity = 0);
      
      Opal.defn(self, '$rotate', TMP_Transformations_rotate_7 = function $$rotate(angle) {
        var self = this;

        return Opal.const_get_relative($nesting, 'Vector2d').$new($rb_minus($rb_times(self.$x(), Opal.const_get_relative($nesting, 'Math').$cos(angle)), $rb_times(self.$y(), Opal.const_get_relative($nesting, 'Math').$sin(angle))), $rb_plus($rb_times(self.$x(), Opal.const_get_relative($nesting, 'Math').$sin(angle)), $rb_times(self.$y(), Opal.const_get_relative($nesting, 'Math').$cos(angle))))
      }, TMP_Transformations_rotate_7.$$arity = 1);
      
      Opal.defn(self, '$round', TMP_Transformations_round_8 = function $$round(digits) {
        var self = this;

        if (digits == null) {
          digits = 0;
        }
        return self.$class().$new(self.$x().$round(digits), self.$y().$round(digits))
      }, TMP_Transformations_round_8.$$arity = -1);
      
      Opal.defn(self, '$truncate', TMP_Transformations_truncate_9 = function $$truncate(max) {
        var self = this;

        return self.$resize([max, self.$length()].$min())
      }, TMP_Transformations_truncate_9.$$arity = 1);
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["vector2d/version"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass;

  return (function($base, $super, $parent_nesting) {
    function $Vector2d(){};
    var self = $Vector2d = $klass($base, $super, 'Vector2d', $Vector2d);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return Opal.const_set($nesting[0], 'VERSION', "2.1.0")
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["vector2d"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var TMP_Vector2d_7, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$extend', '$include', '$nil?', '$parse_single_arg', '$new', '$private', '$===', '$parse', '$parse_str', '$parse_hash', '$dup', '$has_key?', '$[]', '$[]=', '$-', '$=~', '$map', '$split', '$to_proc', '$raise', '$attr_reader', '$x', '$y']);
  
  self.$require("vector2d/calculations");
  self.$require("vector2d/coercions");
  self.$require("vector2d/fitting");
  self.$require("vector2d/properties");
  self.$require("vector2d/transformations");
  self.$require("vector2d/version");
  (function($base, $super, $parent_nesting) {
    function $Vector2d(){};
    var self = $Vector2d = $klass($base, $super, 'Vector2d', $Vector2d);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Vector2d_initialize_5, TMP_Vector2d_$eq$eq_6;

    
    self.$extend(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Vector2d'), 'Calculations'), 'ClassMethods'));
    self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Vector2d'), 'Calculations'));
    self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Vector2d'), 'Coercions'));
    self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Vector2d'), 'Fitting'));
    self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Vector2d'), 'Properties'));
    self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Vector2d'), 'Transformations'));
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_parse_1, TMP_parse_single_arg_2, TMP_parse_hash_3, TMP_parse_str_4;

      
      
      Opal.defn(self, '$parse', TMP_parse_1 = function $$parse(arg, second_arg) {
        var self = this;

        if (second_arg == null) {
          second_arg = nil;
        }
        if ($truthy(second_arg['$nil?']())) {
          return self.$parse_single_arg(arg)
          } else {
          return self.$new(arg, second_arg)
        }
      }, TMP_parse_1.$$arity = -2);
      self.$private();
      
      Opal.defn(self, '$parse_single_arg', TMP_parse_single_arg_2 = function $$parse_single_arg(arg) {
        var self = this, $case = nil;

        return (function() {$case = arg;
        if (Opal.const_get_relative($nesting, 'Vector2d')['$===']($case)) {return arg}
        else if (Opal.const_get_relative($nesting, 'Array')['$===']($case)) {return $send(self, 'parse', Opal.to_a(arg))}
        else if (Opal.const_get_relative($nesting, 'String')['$===']($case)) {return self.$parse_str(arg)}
        else if (Opal.const_get_relative($nesting, 'Hash')['$===']($case)) {return self.$parse_hash(arg.$dup())}
        else {return self.$new(arg, arg)}})()
      }, TMP_parse_single_arg_2.$$arity = 1);
      
      Opal.defn(self, '$parse_hash', TMP_parse_hash_3 = function $$parse_hash(hash) {
        var $a, self = this, $writer = nil;

        
        if ($truthy(hash['$has_key?']("x"))) {
          ($truthy($a = hash['$[]']("x")) ? $a : (($writer = ["x", hash['$[]']("x")]), $send(hash, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))};
        if ($truthy(hash['$has_key?']("y"))) {
          ($truthy($a = hash['$[]']("y")) ? $a : (($writer = ["y", hash['$[]']("y")]), $send(hash, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))};
        return self.$new(hash['$[]']("x"), hash['$[]']("y"));
      }, TMP_parse_hash_3.$$arity = 1);
      return (Opal.defn(self, '$parse_str', TMP_parse_str_4 = function $$parse_str(str) {
        var self = this;

        if ($truthy(str['$=~'](/^[\s]*[\d\.]*[\s]*x[\s]*[\d\.]*[\s]*$/))) {
          return $send(self, 'new', Opal.to_a($send(str.$split("x"), 'map', [], "to_f".$to_proc())))
          } else {
          return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "not a valid string input")
        }
      }, TMP_parse_str_4.$$arity = 1), nil) && 'parse_str';
    })(Opal.get_singleton_class(self), $nesting);
    self.$attr_reader("x", "y");
    
    Opal.defn(self, '$initialize', TMP_Vector2d_initialize_5 = function $$initialize(x, y) {
      var $a, self = this;

      return $a = [x, y], (self.x = $a[0]), (self.y = $a[1]), $a
    }, TMP_Vector2d_initialize_5.$$arity = 2);
    return (Opal.defn(self, '$==', TMP_Vector2d_$eq$eq_6 = function(comp) {
      var $a, self = this;

      return ($truthy($a = comp.$x()['$==='](self.$x())) ? comp.$y()['$==='](self.$y()) : $a)
    }, TMP_Vector2d_$eq$eq_6.$$arity = 1), nil) && '==';
  })($nesting[0], null, $nesting);
  return (Opal.defn(Opal.Object, '$Vector2d', TMP_Vector2d_7 = function $$Vector2d($a_rest) {
    var self = this, args;

    var $args_len = arguments.length, $rest_len = $args_len - 0;
    if ($rest_len < 0) { $rest_len = 0; }
    args = new Array($rest_len);
    for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
      args[$arg_idx - 0] = arguments[$arg_idx];
    }
    return $send(Opal.const_get_relative($nesting, 'Vector2d'), 'parse', Opal.to_a(args))
  }, TMP_Vector2d_7.$$arity = -1), nil) && 'Vector2d';
};

/* Generated by Opal 0.11.4 */
Opal.modules["opal-ajv"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $gvars = Opal.gvars, $hash2 = Opal.hash2, $hash = Opal.hash;

  Opal.add_stubs(['$==', '$add_schema', '$_schema', '$to_n', '$each', '$start_with?', '$gsub', '$[]', '$push', '$error', '$new', '$strict=', '$-', '$get', '$keys', '$validate', '$validate_filenameparts', '$select', '$include?', '$map', '$keep_if', '$group_by', '$>', '$length', '$empty?', '$+', '$t', '$join']);
  return (function($base, $parent_nesting) {
    var $Ajv, self = $Ajv = $module($base, 'Ajv');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $JsonValidator(){};
      var self = $JsonValidator = $klass($base, $super, 'JsonValidator', $JsonValidator);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JsonValidator_initialize_1, TMP_JsonValidator_add_schema_2, TMP_JsonValidator_validate_4, TMP_JsonValidator_validate_conf_6, TMP_JsonValidator_validate_filenameparts_12, TMP_JsonValidator__schema_13;

      def.root = nil;
      
      
      Opal.defn(self, '$initialize', TMP_JsonValidator_initialize_1 = function $$initialize() {
        var self = this, ajv = nil;

        
        ajv = nil;
        if (Opal.const_get_relative($nesting, 'OPAL_PLATFORM')['$==']("nodejs")) {
          ajv = Ajv
          } else {
          ajv = Ajv
        };
        self.root = ajv({allErrors: true, jsonPointers: true, extendRefs: true});
        return self.$add_schema(self.$_schema(), "zupfnoter");
      }, TMP_JsonValidator_initialize_1.$$arity = 0);
      
      Opal.defn(self, '$add_schema', TMP_JsonValidator_add_schema_2 = function $$add_schema(schema, schemaname) {
        var self = this;

        
        
      self.root.addSchema(schema.$to_n(), schemaname)
      ;
        return nil;
      }, TMP_JsonValidator_add_schema_2.$$arity = 2);
      
      Opal.defn(self, '$validate', TMP_JsonValidator_validate_4 = function $$validate(schemaname, data) {
        var TMP_3, self = this, valid = nil, result = nil, errors = nil;

        
        valid = false;
        
      valid = self.root.validate(schemaname, data.$to_n())
     ;
        result = [];
        if ($truthy(valid)) {
          } else {
          
          errors = self.root.errors;
          $send(errors, 'each', [], (TMP_3 = function(error){var self = TMP_3.$$s || this, path = nil, message = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (error == null) error = nil;
          
            path = error.dataPath;
            if ($truthy(path['$start_with?']("/"))) {
              path = path['$[]']($range(1, -1, false)).$gsub("/", ".")};
            result.$push(path);
            message = path+ ': ' + error.message + "\n" + JSON.stringify(error.params, null, " ");
            return $gvars.log.$error(message);}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3));
        };
        return result;
      }, TMP_JsonValidator_validate_4.$$arity = 2);
      
      Opal.defn(self, '$validate_conf', TMP_JsonValidator_validate_conf_6 = function $$validate_conf(conf) {
        var TMP_5, self = this, resconf = nil, $writer = nil, extract0 = nil, x = nil;

        
        resconf = Opal.const_get_relative($nesting, 'Confstack').$new();
        
        $writer = [false];
        $send(resconf, 'strict=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        resconf.$push(conf.$get());
        extract0 = resconf.$get("extract.0");
        $send(resconf.$get("extract").$keys(), 'each', [], (TMP_5 = function(key){var self = TMP_5.$$s || this;
if (key == null) key = nil;
        return resconf.$push($hash2(["extract"], {"extract": $hash(key, extract0)}))}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
        resconf.$push($hash2(["extract"], {"extract": conf.$get("extract")}));
        x = resconf.$get();
        self.$validate("zupfnoter", resconf.$get());
        return self.$validate_filenameparts(resconf);
      }, TMP_JsonValidator_validate_conf_6.$$arity = 1);
      
      Opal.defn(self, '$validate_filenameparts', TMP_JsonValidator_validate_filenameparts_12 = function $$validate_filenameparts(conf) {
        var TMP_7, TMP_8, TMP_9, TMP_10, TMP_11, self = this, filenamekeys = nil, filenames = nil, duplicate_filenames = nil, message = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        filenamekeys = $send(conf.$keys(), 'select', [], (TMP_7 = function(i){var self = TMP_7.$$s || this;
if (i == null) i = nil;
        return i['$include?']("filenamepart")}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));
        filenames = $send(filenamekeys, 'map', [], (TMP_8 = function(i){var self = TMP_8.$$s || this;
if (i == null) i = nil;
        return conf['$[]'](i)}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));
        duplicate_filenames = $send($send(filenames, 'group_by', [], (TMP_9 = function(e){var self = TMP_9.$$s || this;
if (e == null) e = nil;
        return e}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9)), 'keep_if', [], (TMP_10 = function(_, e){var self = TMP_10.$$s || this;
if (_ == null) _ = nil;if (e == null) e = nil;
        return $rb_gt(e.$length(), 1)}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10)).$keys();
        if ($truthy(duplicate_filenames['$empty?']())) {
          } else {
          
          message = $rb_plus(Opal.const_get_relative($nesting, 'I18n').$t("duplicate filenameparts"), "" + ": " + ($send(duplicate_filenames, 'map', [], (TMP_11 = function(i){var self = TMP_11.$$s || this;
if (i == null) i = nil;
          return "" + "\"" + (i) + "\""}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11)).$join(", ")));
          $gvars.log.$error(message);
        };
        return nil;
      }, TMP_JsonValidator_validate_filenameparts_12.$$arity = 1);
      return (Opal.defn(self, '$_schema', TMP_JsonValidator__schema_13 = function $$_schema() {
        var self = this;

        return $hash2(["$schema", "description", "type", "required", "definitions", "properties"], {"$schema": "http://json-schema.org/draft-04/schema#", "description": "Generated from x.json with shasum 0b1781e0803dc084178858e9fbe2b4e0b65c08e7", "type": "object", "required": ["produce", "abc_parser", "restposition", "wrap", "defaults", "templates", "annotations", "extract", "layout", "neatjson"], "definitions": $hash2(["apanchor", "pos", "notes_entry", "minc_entry", "nconf_entry", "align", "notebound_pos", "notebound_repeat", "annotated_bezier", "extract_layout"], {"apanchor": $hash2(["type", "enum"], {"type": "string", "enum": ["manual", "box", "center"]}), "pos": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 2, "uniqueItems": false, "items": $hash2(["type"], {"type": "number"})}), "notes_entry": $hash2(["type", "required", "properties"], {"type": "object", "required": ["pos", "text", "style"], "properties": $hash2(["pos", "text", "align", "style"], {"pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "text": $hash2(["type"], {"type": "string"}), "align": $hash2(["$ref"], {"$ref": "#/definitions/align"}), "style": $hash2(["type"], {"type": "string"})})}), "minc_entry": $hash2(["type", "required", "additionalProperties", "properties"], {"type": "object", "required": ["minc_f"], "additionalProperties": false, "properties": $hash2(["minc_f"], {"minc_f": $hash2(["type"], {"type": "number"})})}), "nconf_entry": $hash2(["type", "additionalProperties", "patternProperties"], {"type": "object", "additionalProperties": false, "patternProperties": $hash2(["t_d*"], {"t_d*": $hash2(["type", "additionalProperties", "patternProperties"], {"type": "object", "additionalProperties": false, "patternProperties": $hash2(["n_d*"], {"n_d*": $hash2(["type", "additionalProperties", "properties"], {"type": "object", "additionalProperties": false, "properties": $hash2(["nshift"], {"nshift": $hash2(["type"], {"type": "number"})})})})})})}), "align": $hash2(["type", "enum"], {"type": "string", "enum": ["l", "r", "auto"]}), "notebound_pos": $hash2(["type", "additionalProperties", "patternProperties"], {"type": "object", "additionalProperties": false, "patternProperties": $hash2(["v_d*"], {"v_d*": $hash2(["type", "additionalProperties", "patternProperties"], {"type": "object", "additionalProperties": false, "patternProperties": $hash2(["t_d*|d*"], {"t_d*|d*": $hash2(["type", "additionalProperties", "properties"], {"type": "object", "additionalProperties": false, "properties": $hash2(["pos", "align"], {"pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "align": $hash2(["$ref"], {"$ref": "#/definitions/align"})})})})})})}), "notebound_repeat": $hash2(["type", "additionalProperties", "patternProperties"], {"type": "object", "additionalProperties": false, "patternProperties": $hash2(["v_d*"], {"v_d*": $hash2(["text", "style", "pos"], {"text": "integer", "style": $hash2(["type"], {"type": "string"}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"})})})}), "annotated_bezier": $hash2(["type", "properties"], {"type": "object", "properties": $hash2(["cp1", "cp2", "pos", "shape", "show", "style"], {"cp1": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "cp2": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "shape": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 0, "uniqueItems": true, "items": $hash2(["type"], {"type": "string"})}), "show": $hash2(["type"], {"type": "boolean"}), "style": $hash2(["type"], {"type": "string"})})}), "extract_layout": $hash2(["type", "requiredx", "additionalProperties", "properties"], {"type": "object", "requiredx": ["limit_a3", "LINE_THIN", "LINE_MEDIUM", "LINE_THICK", "ELLIPSE_SIZE", "REST_SIZE", "grid"], "additionalProperties": false, "properties": $hash2(["limit_a3", "beams", "bottomup", "jumpline_anchor", "LINE_THIN", "LINE_MEDIUM", "LINE_THICK", "PITCH_OFFSET", "X_SPACING", "X_OFFSET", "instrument", "DRAWING_AREA_SIZE", "ELLIPSE_SIZE", "REST_SIZE", "grid", "color", "packer"], {"limit_a3": $hash2(["type"], {"type": "boolean"}), "beams": $hash2(["type"], {"type": "boolean"}), "bottomup": $hash2(["type"], {"type": "boolean"}), "jumpline_anchor": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "LINE_THIN": $hash2(["type"], {"type": "number"}), "LINE_MEDIUM": $hash2(["type"], {"type": "number"}), "LINE_THICK": $hash2(["type"], {"type": "number"}), "PITCH_OFFSET": $hash2(["type"], {"type": "integer"}), "X_SPACING": $hash2(["type"], {"type": "number"}), "X_OFFSET": $hash2(["type"], {"type": "number"}), "instrument": $hash2(["type"], {"type": "string"}), "DRAWING_AREA_SIZE": $hash2(["type", "minItems", "items"], {"type": "array", "minItems": 2, "items": $hash2(["type"], {"type": "number"})}), "ELLIPSE_SIZE": $hash2(["type", "minItems", "items"], {"type": "array", "minItems": 2, "items": $hash2(["type"], {"type": "number"})}), "REST_SIZE": $hash2(["type", "minItems", "items"], {"type": "array", "minItems": 2, "items": $hash2(["type"], {"type": "number"})}), "grid": $hash2(["type"], {"type": "boolean"}), "color": $hash2(["type", "properties"], {"type": "object", "properties": $hash2(["color_default", "color_variant1", "color_variant2"], {"color_default": $hash2(["type"], {"type": "string"}), "color_variant1": $hash2(["type"], {"type": "string"}), "color_variant2": $hash2(["type"], {"type": "string"})})}), "packer": $hash2(["type", "properties"], {"type": "object", "properties": $hash2(["pack_method", "pack_max_spread_factor", "pack_min_increment"], {"pack_method": $hash2(["type"], {"type": "integer"}), "pack_max_spread_factor": $hash2(["type"], {"type": "number"}), "pack_min_increment": $hash2(["type"], {"type": "number"})})})})})}), "properties": $hash2(["confstack", "produce", "template", "abc_parser", "restposition", "wrap", "defaults", "templates", "annotations", "extract", "layout", "neatjson"], {"confstack": $hash2(["type", "required", "properties"], {"type": "object", "required": ["env"], "properties": $hash2(["env"], {"env": $hash2(["type"], {"type": "string"})})}), "produce": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 0, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})}), "template": $hash2(["type", "additionalProperties", "properties"], {"type": "object", "additionalProperties": false, "properties": $hash2(["filebase", "title"], {"filebase": $hash2(["type"], {"type": "string"}), "title": $hash2(["type"], {"type": "string"})})}), "abc_parser": $hash2(["type"], {"type": "string"}), "restposition": $hash2(["type", "additionalProperties", "required", "properties"], {"type": "object", "additionalProperties": false, "required": ["default", "repeatstart", "repeatend"], "properties": $hash2(["default", "repeatstart", "repeatend"], {"default": $hash2(["type"], {"type": "string"}), "repeatstart": $hash2(["type"], {"type": "string"}), "repeatend": $hash2(["type"], {"type": "string"})})}), "wrap": $hash2(["type"], {"type": "integer"}), "defaults": $hash2(["type", "required", "properties"], {"type": "object", "required": ["notebound"], "properties": $hash2(["notebound"], {"notebound": $hash2(["type", "required", "properties"], {"type": "object", "required": ["annotation", "partname", "variantend", "tuplet"], "properties": $hash2(["annotation", "partname", "variantend", "tuplet"], {"annotation": $hash2(["type", "required", "properties"], {"type": "object", "required": ["pos"], "properties": $hash2(["pos", "style"], {"pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "style": $hash2(["type"], {"type": "string"})})}), "partname": $hash2(["type", "required", "properties"], {"type": "object", "required": ["pos"], "properties": $hash2(["pos", "style"], {"pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "style": $hash2(["type"], {"type": "string"})})}), "variantend": $hash2(["type", "required", "properties"], {"type": "object", "required": ["pos"], "properties": $hash2(["pos", "style"], {"pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "style": $hash2(["type"], {"type": "string"})})}), "tuplet": $hash2(["$ref", "required"], {"$ref": "#/definitions/annotated_bezier", "required": ["cp1", "cp2", "shape"]})})})})}), "templates": $hash2(["type", "required", "properties"], {"type": "object", "required": ["notes", "lyrics", "tuplet", "annotations"], "properties": $hash2(["notes", "lyrics", "tuplet", "annotations"], {"notes": $hash2(["$ref"], {"$ref": "#/definitions/notes_entry"}), "lyrics": $hash2(["type", "required", "properties"], {"type": "object", "required": ["verses", "pos"], "properties": $hash2(["verses", "pos", "style"], {"verses": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "style": $hash2(["type"], {"type": "string"})})}), "tuplet": $hash2(["type", "required", "properties"], {"type": "object", "required": ["cp1", "cp2", "shape"], "properties": $hash2(["cp1", "cp2", "shape"], {"cp1": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "cp2": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "shape": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "string"})})})}), "annotations": $hash2(["type", "required", "properties"], {"type": "object", "required": ["text", "pos"], "properties": $hash2(["text", "pos", "style"], {"text": $hash2(["type"], {"type": "string"}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "style": $hash2(["type"], {"type": "string"})})})})}), "annotations": $hash2(["type", "required", "properties"], {"type": "object", "required": ["vl", "vt", "vr"], "properties": $hash2(["vl", "vt", "vr"], {"vl": $hash2(["type", "required", "properties"], {"type": "object", "required": ["text", "pos"], "properties": $hash2(["text", "pos"], {"text": $hash2(["type"], {"type": "string"}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"})})}), "vt": $hash2(["type", "required", "properties"], {"type": "object", "required": ["text", "pos"], "properties": $hash2(["text", "pos"], {"text": $hash2(["type"], {"type": "string"}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"})})}), "vr": $hash2(["type", "required", "properties"], {"type": "object", "required": ["text", "pos"], "properties": $hash2(["text", "pos"], {"text": $hash2(["type"], {"type": "string"}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"})})})})}), "extract": $hash2(["type", "patternProperties"], {"type": "object", "patternProperties": $hash2(["d*", "4", "5"], {"d*": $hash2(["type", "additionalProperties", "requiredx", "properties"], {"type": "object", "additionalProperties": false, "requiredx": ["title", "filenamepart", "startpos", "voices", "synchlines", "flowlines", "subflowlines", "jumplines", "repeatsigns", "layoutlines", "legend", "lyrics", "layout", "nonflowrest", "notes", "barnumbers", "countnotes", "stringnames", "printer"], "properties": $hash2(["title", "filenamepart", "startpos", "voices", "synchlines", "flowlines", "subflowlines", "jumplines", "repeatsigns", "layoutlines", "legend", "lyrics", "layout", "nonflowrest", "notes", "notebound", "tuplets", "barnumbers", "countnotes", "stringnames", "sortmark", "printer", "images"], {"title": $hash2(["type"], {"type": "string"}), "filenamepart": $hash2([], {}), "startpos": $hash2(["type"], {"type": "integer"}), "voices": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})}), "synchlines": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 0, "uniqueItems": true, "items": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})})}), "flowlines": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})}), "subflowlines": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})}), "jumplines": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})}), "repeatsigns": $hash2(["type", "requiredx", "properties"], {"type": "object", "requiredx": ["voices", "left", "right"], "properties": $hash2(["voices", "left", "right"], {"voices": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 0, "uniqueItems": true, "items": $hash2([], {})}), "left": $hash2(["type", "required", "properties"], {"type": "object", "required": ["pos", "text", "style"], "properties": $hash2(["pos", "text", "style"], {"pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "text": $hash2(["type"], {"type": "string"}), "style": $hash2(["type"], {"type": "string"})})}), "right": $hash2(["type", "required", "properties"], {"type": "object", "required": ["pos", "text", "style"], "properties": $hash2(["pos", "text", "style"], {"pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "text": $hash2(["type"], {"type": "string"}), "style": $hash2(["type"], {"type": "string"})})})})}), "layoutlines": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 0, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})}), "legend": $hash2(["type", "required", "properties"], {"type": "object", "required": ["spos", "pos"], "properties": $hash2(["spos", "pos", "align", "style"], {"spos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "align": $hash2(["$ref"], {"$ref": "#/definitions/align"}), "style": $hash2(["type"], {"type": "string"})})}), "lyrics": $hash2(["type", "patternProperties"], {"type": "object", "patternProperties": $hash2([".*"], {".*": $hash2(["type", "required"], {"type": "object", "required": ["verses", "pos"]})})}), "layout": $hash2(["$ref"], {"$ref": "#/definitions/extract_layout"}), "nonflowrest": $hash2(["type"], {"type": "boolean"}), "notes": $hash2(["patternProperties"], {"patternProperties": $hash2([".*"], {".*": $hash2(["$ref"], {"$ref": "#/definitions/notes_entry"})})}), "notebound": $hash2(["type", "additionalProperties", "properties"], {"type": "object", "additionalProperties": false, "properties": $hash2(["annotation", "barnumber", "c_jumplines", "countnote", "decoration", "flowline", "minc", "nconf", "partname", "repeat_begin", "repeat_end", "tuplet", "variantend"], {"annotation": $hash2(["$ref"], {"$ref": "#/definitions/notebound_pos"}), "barnumber": $hash2(["$ref", "align"], {"$ref": "#/definitions/notebound_pos", "align": $hash2(["$ref"], {"$ref": "#/definitions/align"})}), "c_jumplines": $hash2(["type", "additionalProperties", "patternProperties"], {"type": "object", "additionalProperties": false, "patternProperties": $hash2(["v_d*"], {"v_d*": $hash2(["p_repeat", "p_begin", "p_end", "p_follow"], {"p_repeat": $hash2(["type"], {"type": "number"}), "p_begin": $hash2(["type"], {"type": "number"}), "p_end": $hash2(["type"], {"type": "number"}), "p_follow": $hash2(["type"], {"type": "number"})})})}), "countnote": $hash2(["$ref"], {"$ref": "#/definitions/notebound_pos"}), "decoration": $hash2(["$ref"], {"$ref": "#/definitions/notebound_pos"}), "flowline": $hash2(["type", "patternProperties"], {"type": "object", "patternProperties": $hash2(["v_d+"], {"v_d+": $hash2(["type", "patternProperties"], {"type": "object", "patternProperties": $hash2(["d*"], {"d*": $hash2(["$ref"], {"$ref": "#/definitions/annotated_bezier"})})})})}), "minc": $hash2(["type", "additionalProperties", "patternProperties"], {"type": "object", "additionalProperties": false, "patternProperties": $hash2(["d*"], {"d*": $hash2(["$ref"], {"$ref": "#/definitions/minc_entry"})})}), "nconf": $hash2(["type", "additionalProperties", "patternProperties"], {"type": "object", "additionalProperties": false, "patternProperties": $hash2(["v_d*"], {"v_d*": $hash2(["$ref"], {"$ref": "#/definitions/nconf_entry"})})}), "partname": $hash2(["$ref"], {"$ref": "#/definitions/notebound_pos"}), "repeat_begin": $hash2(["$ref"], {"$ref": "#/definitions/notebound_pos"}), "repeat_end": $hash2(["$ref"], {"$ref": "#/definitions/notebound_repeat"}), "tuplet": $hash2(["type", "patternProperties"], {"type": "object", "patternProperties": $hash2(["v_d*"], {"v_d*": $hash2(["type", "patternProperties"], {"type": "object", "patternProperties": $hash2(["d*"], {"d*": $hash2(["$ref"], {"$ref": "#/definitions/annotated_bezier"})})})})}), "variantend": $hash2(["$ref"], {"$ref": "#/definitions/notebound_pos"})})}), "tuplets": $hash2(["type", "properties"], {"type": "object", "properties": $hash2(["text"], {"text": $hash2(["type"], {"type": "string"})})}), "barnumbers": $hash2(["type", "required", "properties"], {"type": "object", "required": ["voices", "pos", "autopos", "style", "prefix"], "properties": $hash2(["voices", "pos", "autopos", "apanchor", "style", "prefix"], {"voices": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 0, "uniqueItems": true, "items": $hash2([], {})}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "autopos": $hash2(["type"], {"type": "boolean"}), "apanchor": $hash2(["$ref"], {"$ref": "#/definitions/apanchor"}), "style": $hash2(["type"], {"type": "string"}), "prefix": $hash2(["type"], {"type": "string"})})}), "countnotes": $hash2(["type", "required", "properties"], {"type": "object", "required": ["voices", "pos", "autopos", "style"], "properties": $hash2(["voices", "pos", "autopos", "apanchor", "style"], {"voices": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 0, "uniqueItems": true, "items": $hash2([], {})}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "autopos": $hash2(["type"], {"type": "boolean"}), "apanchor": $hash2(["$ref"], {"$ref": "#/definitions/apanchor"}), "style": $hash2(["type"], {"type": "string"})})}), "stringnames": $hash2(["type", "required", "properties"], {"type": "object", "required": ["text", "vpos", "style", "marks"], "properties": $hash2(["text", "vpos", "style", "marks"], {"text": $hash2(["type"], {"type": "string"}), "vpos": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 0, "uniqueItems": true, "items": $hash2([], {})}), "style": $hash2(["type"], {"type": "string"}), "marks": $hash2(["type", "required", "properties"], {"type": "object", "required": ["vpos", "hpos"], "properties": $hash2(["vpos", "hpos"], {"vpos": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})}), "hpos": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})})})})})}), "sortmark": $hash2(["type", "properties"], {"type": "object", "properties": $hash2(["show"], {"show": $hash2(["type"], {"type": "boolean"})})}), "printer": $hash2(["type", "required", "properties"], {"type": "object", "required": ["a3_offset", "a4_offset", "show_border"], "properties": $hash2(["a3_offset", "a4_offset", "show_border"], {"a3_offset": $hash2(["type", "minItems", "axItems", "uniqueItems", "items"], {"type": "array", "minItems": 2, "axItems": 2, "uniqueItems": false, "items": $hash2(["type"], {"type": "integer"})}), "a4_offset": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 2, "uniqueItems": false, "items": $hash2(["type"], {"type": "integer"})}), "show_border": $hash2(["type"], {"type": "boolean"})})}), "images": $hash2(["type", "patternProperties"], {"type": "object", "patternProperties": $hash2(["d*"], {"d*": $hash2(["type", "properties"], {"type": "object", "properties": $hash2(["imagename", "show", "pos", "height"], {"imagename": $hash2(["type"], {"type": "string"}), "show": $hash2(["type"], {"type": "boolean"}), "pos": $hash2(["$ref"], {"$ref": "#/definitions/pos"}), "height": $hash2(["type"], {"type": "number"})})})})})})}), "4": $hash2(["type", "required", "properties"], {"type": "object", "required": ["title", "voices"], "properties": $hash2(["title", "filenamepart", "voices"], {"title": $hash2(["type"], {"type": "string"}), "filenamepart": $hash2([], {}), "voices": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})})})}), "5": $hash2(["type", "required", "properties"], {"type": "object", "required": ["title", "voices"], "properties": $hash2(["title", "filenamepart", "voices"], {"title": $hash2(["type"], {"type": "string"}), "filenamepart": $hash2([], {}), "voices": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})})})})})}), "layout": $hash2(["type", "required", "properties"], {"type": "object", "required": ["grid", "limit_a3", "SHOW_SLUR", "LINE_THIN", "LINE_MEDIUM", "LINE_THICK", "ELLIPSE_SIZE", "REST_SIZE", "X_SPACING", "X_OFFSET", "Y_SCALE", "DRAWING_AREA_SIZE", "BEAT_RESOLUTION", "SHORTEST_NOTE", "BEAT_PER_DURATION", "PITCH_OFFSET", "FONT_STYLE_DEF", "MM_PER_POINT", "DURATION_TO_STYLE", "REST_TO_GLYPH"], "properties": $hash2(["grid", "limit_a3", "SHOW_SLUR", "LINE_THIN", "LINE_MEDIUM", "LINE_THICK", "ELLIPSE_SIZE", "REST_SIZE", "X_SPACING", "X_OFFSET", "Y_SCALE", "DRAWING_AREA_SIZE", "BEAT_RESOLUTION", "SHORTEST_NOTE", "BEAT_PER_DURATION", "PITCH_OFFSET", "FONT_STYLE_DEF", "MM_PER_POINT", "DURATION_TO_STYLE", "REST_TO_GLYPH"], {"grid": $hash2(["type"], {"type": "boolean"}), "limit_a3": $hash2(["type"], {"type": "boolean"}), "SHOW_SLUR": $hash2(["type"], {"type": "boolean"}), "LINE_THIN": $hash2(["type"], {"type": "number"}), "LINE_MEDIUM": $hash2(["type"], {"type": "number"}), "LINE_THICK": $hash2(["type"], {"type": "number"}), "ELLIPSE_SIZE": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "number"})}), "REST_SIZE": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "number"})}), "X_SPACING": $hash2(["type"], {"type": "number"}), "X_OFFSET": $hash2(["type"], {"type": "number"}), "Y_SCALE": $hash2(["type"], {"type": "integer"}), "DRAWING_AREA_SIZE": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": $hash2(["type"], {"type": "integer"})}), "BEAT_RESOLUTION": $hash2(["type"], {"type": "integer"}), "SHORTEST_NOTE": $hash2(["type"], {"type": "integer"}), "BEAT_PER_DURATION": $hash2(["type"], {"type": "integer"}), "PITCH_OFFSET": $hash2(["type"], {"type": "integer"}), "FONT_STYLE_DEF": $hash2(["type", "required", "patternProperties"], {"type": "object", "required": ["bold", "italic", "large", "regular", "small_bold", "small_italic", "small", "smaller"], "patternProperties": $hash2([".*"], {".*": $hash2(["type", "required", "properties"], {"type": "object", "required": ["text_color", "font_size", "font_style"], "properties": $hash2(["text_color", "font_size", "font_style"], {"text_color": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 3, "uniqueItems": false, "items": $hash2(["type"], {"type": "integer"})}), "font_size": $hash2(["type"], {"type": "integer"}), "font_style": $hash2(["type"], {"type": "string"})})})})}), "MM_PER_POINT": $hash2(["type"], {"type": "number"}), "DURATION_TO_STYLE": $hash2(["type", "required", "patternProperties"], {"type": "object", "required": ["err", "d64", "d48", "d32", "d24", "d16", "d12", "d8", "d6", "d4", "d3", "d2", "d1"], "patternProperties": $hash2([".*"], {".*": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 3, "uniqueItems": false, "items": $hash2(["type"], {"type": ["number", "string", "boolean"]})})})}), "REST_TO_GLYPH": $hash2(["type", "patternProperties"], {"type": "object", "patternProperties": $hash2([".*"], {".*": $hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": true, "items": [$hash2(["type", "minItems", "uniqueItems", "items"], {"type": "array", "minItems": 1, "uniqueItems": false, "items": $hash2(["type"], {"type": "number"})}), $hash2(["type"], {"type": "string"}), $hash2(["type"], {"type": "boolean"})]})})})})}), "neatjson": $hash2(["type", "required", "properties"], {"type": "object", "required": ["wrap", "aligned", "after_comma", "after_colon_1", "after_colon_n", "before_colon_n", "explicit_sort"], "properties": $hash2(["wrap", "aligned", "after_comma", "after_colon_1", "after_colon_n", "before_colon_n", "sorted", "explicit_sort"], {"wrap": $hash2(["type"], {"type": "integer"}), "aligned": $hash2(["type"], {"type": "boolean"}), "after_comma": $hash2(["type"], {"type": "integer"}), "after_colon_1": $hash2(["type"], {"type": "integer"}), "after_colon_n": $hash2(["type"], {"type": "integer"}), "before_colon_n": $hash2(["type"], {"type": "integer"}), "sorted": $hash2(["type"], {"type": "boolean"}), "explicit_sort": $hash2(["type"], {"type": "object"})})})})})
      }, TMP_JsonValidator__schema_13.$$arity = 0), nil) && '_schema';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["consolelogger"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $hash2 = Opal.hash2, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$attr_reader', '$[]', '$now', '$clear_errors', '$clear_annotations', '$send', '$push', '$add_annotation', '$==', '$loglevel', '$join', '$write', '$loglevel?', '$info', '$-', '$>', '$count', '$call', '$to_sym', '$message', '$invert', '$<=', '$keys', '$private', '$first', '$+', '$last', '$<<', '$strftime', '$puts', '$write_html']);
  
  Opal.const_set($nesting[0], 'LOGLEVELS', $hash2(["message", "error", "warning", "info", "debug"], {"message": 0, "error": 1, "warning": 2, "info": 3, "debug": 4}));
  Opal.const_set($nesting[0], 'LOGICONS', $hash2(["message", "error", "warning", "info", "debug"], {"message": "icon-info-circled", "error": "icon-error-alt", "warning": "icon-attention", "info": "icon-info-circled", "debug": "icon-minus-squared"}));
  (function($base, $super, $parent_nesting) {
    function $Logger(){};
    var self = $Logger = $klass($base, $super, 'Logger', $Logger);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Logger_clear_annotations_1, TMP_Logger_initialize_2, TMP_Logger_clear_annotations_3, TMP_Logger_log_from_worker_4, TMP_Logger_error_5, TMP_Logger_warning_6, TMP_Logger_info_7, TMP_Logger_debug_8, TMP_Logger_message_9, TMP_Logger_timestamp_10, TMP_Logger_timestamp_start_11, TMP_Logger_clear_errors_12, TMP_Logger_has_errors$q_13, TMP_Logger_get_errors_14, TMP_Logger_get_status_15, TMP_Logger_set_status_16, TMP_Logger_benchmark_17, TMP_Logger_loglevel$eq_18, TMP_Logger_loglevel_19, TMP_Logger_loglevel$q_20, TMP_Logger_loglevels_21, TMP_Logger_add_annotation_22, TMP_Logger_write_23;

    def.captured_errors = def.timestamp = def.annotations = def.loglevel = nil;
    
    self.$attr_reader("annotations");
    
    Opal.defn(self, '$clear_annotations', TMP_Logger_clear_annotations_1 = function $$clear_annotations() {
      var self = this;

      return (self.annotations = [])
    }, TMP_Logger_clear_annotations_1.$$arity = 0);
    
    Opal.defn(self, '$initialize', TMP_Logger_initialize_2 = function $$initialize(element_id) {
      var self = this;

      
      self.console = element_id;
      self.loglevel = Opal.const_get_relative($nesting, 'LOGLEVELS')['$[]']("info");
      self.timestamp = Opal.const_get_relative($nesting, 'Time').$now();
      self.$clear_errors();
      return self.$clear_annotations();
    }, TMP_Logger_initialize_2.$$arity = 1);
    
    Opal.defn(self, '$clear_annotations', TMP_Logger_clear_annotations_3 = function $$clear_annotations() {
      var self = this;

      return (self.annotations = [])
    }, TMP_Logger_clear_annotations_3.$$arity = 0);
    
    Opal.defn(self, '$log_from_worker', TMP_Logger_log_from_worker_4 = function $$log_from_worker(payload) {
      var self = this;

      return $send(self, 'send', [payload['$[]']("type")].concat(Opal.to_a(payload['$[]']("args"))))
    }, TMP_Logger_log_from_worker_4.$$arity = 1);
    
    Opal.defn(self, '$error', TMP_Logger_error_5 = function $$error(msg, start_pos, end_pos, backtrace) {
      var self = this, backtrace_message = nil;

      if (start_pos == null) {
        start_pos = nil;
      }
      if (end_pos == null) {
        end_pos = nil;
      }
      if (backtrace == null) {
        backtrace = [];
      }
      
      self.captured_errors.$push(msg);
      self.$add_annotation(msg, start_pos, end_pos, "error");
      if (self.$loglevel()['$==']("debug")) {
        backtrace_message = backtrace.$join("\n")};
      return self.$write("error", "" + (msg) + (backtrace_message));
    }, TMP_Logger_error_5.$$arity = -2);
    
    Opal.defn(self, '$warning', TMP_Logger_warning_6 = function $$warning(msg, start_pos, end_pos) {
      var self = this;

      if (start_pos == null) {
        start_pos = nil;
      }
      if (end_pos == null) {
        end_pos = nil;
      }
      
      if ($truthy(self['$loglevel?']("warning"))) {
        self.$add_annotation(msg, start_pos, end_pos, "warning")};
      return self.$write("warning", msg);
    }, TMP_Logger_warning_6.$$arity = -2);
    
    Opal.defn(self, '$info', TMP_Logger_info_7 = function $$info(msg, start_pos, end_pos) {
      var self = this;

      if (start_pos == null) {
        start_pos = nil;
      }
      if (end_pos == null) {
        end_pos = nil;
      }
      
      self.$add_annotation(msg, start_pos, end_pos, "info");
      return self.$write("info", msg);
    }, TMP_Logger_info_7.$$arity = -2);
    
    Opal.defn(self, '$debug', TMP_Logger_debug_8 = function $$debug(msg, start_pos, end_pos) {
      var self = this;

      if (start_pos == null) {
        start_pos = nil;
      }
      if (end_pos == null) {
        end_pos = nil;
      }
      
      self.$add_annotation(msg, start_pos, end_pos, "debug");
      return self.$write("debug", msg);
    }, TMP_Logger_debug_8.$$arity = -2);
    
    Opal.defn(self, '$message', TMP_Logger_message_9 = function $$message(msg, start_pos, end_pos) {
      var self = this;

      if (start_pos == null) {
        start_pos = nil;
      }
      if (end_pos == null) {
        end_pos = nil;
      }
      
      self.$add_annotation(msg, start_pos, end_pos, "message");
      return self.$write("message", msg);
    }, TMP_Logger_message_9.$$arity = -2);
    
    Opal.defn(self, '$timestamp', TMP_Logger_timestamp_10 = function $$timestamp(msg, start_pos, end_pos) {
      var self = this;
      if ($gvars.log == null) $gvars.log = nil;

      if (start_pos == null) {
        start_pos = nil;
      }
      if (end_pos == null) {
        end_pos = nil;
      }
      return $gvars.log.$info("" + "Timestamp " + ($rb_minus(Opal.const_get_relative($nesting, 'Time').$now(), self.timestamp)) + " sec: " + (msg))
    }, TMP_Logger_timestamp_10.$$arity = -2);
    
    Opal.defn(self, '$timestamp_start', TMP_Logger_timestamp_start_11 = function $$timestamp_start() {
      var self = this;

      return (self.timestamp = Opal.const_get_relative($nesting, 'Time').$now())
    }, TMP_Logger_timestamp_start_11.$$arity = 0);
    
    Opal.defn(self, '$clear_errors', TMP_Logger_clear_errors_12 = function $$clear_errors() {
      var self = this;

      return (self.captured_errors = [])
    }, TMP_Logger_clear_errors_12.$$arity = 0);
    
    Opal.defn(self, '$has_errors?', TMP_Logger_has_errors$q_13 = function() {
      var self = this;

      return $rb_gt(self.captured_errors.$count(), 0)
    }, TMP_Logger_has_errors$q_13.$$arity = 0);
    
    Opal.defn(self, '$get_errors', TMP_Logger_get_errors_14 = function $$get_errors() {
      var self = this;

      return self.captured_errors
    }, TMP_Logger_get_errors_14.$$arity = 0);
    
    Opal.defn(self, '$get_status', TMP_Logger_get_status_15 = function $$get_status() {
      var self = this;

      return $hash2(["annotations", "captured_errors"], {"annotations": self.annotations, "captured_errors": self.captured_errors})
    }, TMP_Logger_get_status_15.$$arity = 0);
    
    Opal.defn(self, '$set_status', TMP_Logger_set_status_16 = function $$set_status(status) {
      var self = this;

      
      self.annotations = status['$[]']("annotations");
      return (self.captured_errors = status['$[]']("captured_errors"));
    }, TMP_Logger_set_status_16.$$arity = 1);
    
    Opal.defn(self, '$benchmark', TMP_Logger_benchmark_17 = function $$benchmark(msg) {
      var self = this, $iter = TMP_Logger_benchmark_17.$$p, block = $iter || nil, s = nil, result = nil;
      if ($gvars.log == null) $gvars.log = nil;

      if ($iter) TMP_Logger_benchmark_17.$$p = null;
      
      s = Opal.const_get_relative($nesting, 'Time').$now();
      result = block.$call();
      $gvars.log.$info("" + "  elapsed " + ($rb_minus(Opal.const_get_relative($nesting, 'Time').$now(), s)) + " sec for " + (msg));
      return result;
    }, TMP_Logger_benchmark_17.$$arity = 1);
    
    Opal.defn(self, '$loglevel=', TMP_Logger_loglevel$eq_18 = function(level) {
      var $a, self = this;
      if ($gvars.log == null) $gvars.log = nil;

      
      self.loglevel = ($truthy($a = Opal.const_get_relative($nesting, 'LOGLEVELS')['$[]'](level.$to_sym())) ? $a : Opal.const_get_relative($nesting, 'LOGLEVELS')['$[]']("debug"));
      return $gvars.log.$message("" + "logging messages up to " + (Opal.const_get_relative($nesting, 'LOGLEVELS').$invert()['$[]'](self.loglevel)));
    }, TMP_Logger_loglevel$eq_18.$$arity = 1);
    
    Opal.defn(self, '$loglevel', TMP_Logger_loglevel_19 = function $$loglevel() {
      var self = this;

      return Opal.const_get_relative($nesting, 'LOGLEVELS').$invert()['$[]'](self.loglevel)
    }, TMP_Logger_loglevel_19.$$arity = 0);
    
    Opal.defn(self, '$loglevel?', TMP_Logger_loglevel$q_20 = function(type) {
      var $a, self = this;

      return $rb_le(($truthy($a = Opal.const_get_relative($nesting, 'LOGLEVELS')['$[]'](type)) ? $a : Opal.const_get_relative($nesting, 'LOGLEVELS')['$[]']("warning")), self.loglevel)
    }, TMP_Logger_loglevel$q_20.$$arity = 1);
    
    Opal.defn(self, '$loglevels', TMP_Logger_loglevels_21 = function $$loglevels() {
      var self = this;

      return Opal.const_get_relative($nesting, 'LOGLEVELS').$keys()
    }, TMP_Logger_loglevels_21.$$arity = 0);
    self.$private();
    
    Opal.defn(self, '$add_annotation', TMP_Logger_add_annotation_22 = function $$add_annotation(msg, start_pos, end_pos, type) {
      var $a, self = this, the_start = nil, the_end = nil;

      
      if ($truthy(start_pos)) {
        
        the_start = start_pos;
        the_end = ($truthy($a = end_pos) ? $a : [the_start.$first(), $rb_plus(the_start.$last(), 1)]);
        self.annotations['$<<']($hash2(["start_pos", "end_pos", "text", "type"], {"start_pos": the_start, "end_pos": the_end, "text": msg, "type": type}));};
      return nil;
    }, TMP_Logger_add_annotation_22.$$arity = 4);
    return (Opal.defn(self, '$write', TMP_Logger_write_23 = function $$write(type, msg) {
      var self = this, time = nil;

      if ($truthy(self['$loglevel?'](type))) {
        
        time = Opal.const_get_relative($nesting, 'Time').$now().$strftime("%H:%M:%S");
        return self.$puts(msg);
        } else {
        return nil
      }
    }, TMP_Logger_write_23.$$arity = 2), nil) && 'write';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $NodeLogger(){};
    var self = $NodeLogger = $klass($base, $super, 'NodeLogger', $NodeLogger);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NodeLogger_write_24;

    def.loglevel = nil;
    return (Opal.defn(self, '$write', TMP_NodeLogger_write_24 = function $$write(type, msg) {
      var $a, self = this, current_level = nil, time = nil;

      
      current_level = ($truthy($a = Opal.const_get_relative($nesting, 'LOGLEVELS')['$[]'](type)) ? $a : Opal.const_get_relative($nesting, 'LOGLEVELS')['$[]']("warning"));
      if ($truthy($rb_le(current_level, self.loglevel))) {
        
        time = Opal.const_get_relative($nesting, 'Time').$now().$strftime("%H:%M:%S");
        return self.$puts(msg);
        } else {
        return nil
      };
    }, TMP_NodeLogger_write_24.$$arity = 2), nil) && 'write'
  })($nesting[0], Opal.const_get_relative($nesting, 'Logger'), $nesting);
  return (function($base, $super, $parent_nesting) {
    function $ConsoleLogger(){};
    var self = $ConsoleLogger = $klass($base, $super, 'ConsoleLogger', $ConsoleLogger);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ConsoleLogger_initialize_25, TMP_ConsoleLogger_write_26;

    def.loglevel = def.console = nil;
    
    
    Opal.defn(self, '$initialize', TMP_ConsoleLogger_initialize_25 = function $$initialize(element_id) {
      var self = this, $iter = TMP_ConsoleLogger_initialize_25.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_ConsoleLogger_initialize_25.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_ConsoleLogger_initialize_25, false), $zuper, $iter);
      return (self.console = element_id);
    }, TMP_ConsoleLogger_initialize_25.$$arity = 1);
    return (Opal.defn(self, '$write', TMP_ConsoleLogger_write_26 = function $$write(type, msg) {
      var $a, self = this, current_level = nil, time = nil;

      
      current_level = ($truthy($a = Opal.const_get_relative($nesting, 'LOGLEVELS')['$[]'](type)) ? $a : Opal.const_get_relative($nesting, 'LOGLEVELS')['$[]']("warning"));
      if ($truthy($rb_le(current_level, self.loglevel))) {
        
        time = Opal.const_get_relative($nesting, 'Time').$now().$strftime("%H:%M:%S");
        self.console.$write_html("" + "<li class='" + (type) + "'><i class=\"" + (Opal.const_get_relative($nesting, 'LOGICONS')['$[]'](type)) + "\"><span class='time'>" + (time) + "</span><span class='msg'>" + (msg) + "</span></li>");
        return self.$puts(msg);
        } else {
        return nil
      };
    }, TMP_ConsoleLogger_write_26.$$arity = 2), nil) && 'write';
  })($nesting[0], Opal.const_get_relative($nesting, 'Logger'), $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["harpnotes"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $gvars = Opal.gvars, $hash = Opal.hash, $range = Opal.range;

  Opal.add_stubs(['$attr_accessor', '$first', '$last', '$to_json', '$[]', '$+', '$class', '$map', '$-', '$instance_variables', '$instance_variable_get', '$is_a?', '$raise', '$pitch', '$beat', '$duration', '$first_in_part', '$attr_reader', '$nil?', '$uniq', '$flatten', '$measure_start', '$proxy_note', '$alias_method', '$each', '$beat=', '$get_proxy_object', '$variant', '$sheet_drawable', '$prev_playable', '$prev_playable=', '$next_playable', '$next_playable=', '$companion=', '$visible?', '$update_beats', '$<<', '$compact', '$expanded_beat_maps', '$select', '$left', '$right', '$product', '$min_by', '$abs', '$new', '$max', '$keys', '$last_beat', '$private', '$inject', '$index', '$/', '$time', '$floor', '$>', '$start_pos', '$error', '$tuplet', '$[]=', '$index=', '$==', '$reset', '$_check1', '$center', '$size', '$conf_key', '$origin', '$_rect_overlap?', '$empty?', '$warning', '$t', '$count', '$push', '$shapes', '$get', '$clone', '$dotted?', '$dotted', '$gsub', '$length', '$strip', '$*', '$to_f', '$include', '$set_instrument_handlers', '$lambda', '$===', '$each_with_index', '$split', '$to_i', '$line_width=', '$call', '$join', '$tap', '$Vector2d', '$conf_key=', '$conf_value=', '$draginfo=', '$%', '$get_print_options', '$initialize', '$layout_debug_grid', '$layout_images', '$benchmark', '$compute_beat_compression', '$values', '$<', '$min', '$include?', '$build_synch_points', '$synched_notes', '$voices', '$layout_voice', '$loglevel?', '$check_annotations', '$notes', '$compute_color_by_variant_no', '$color=', '$layout_stringnames', '$meta_data', '$align=', '$strftime', '$now', '$checksum', '$harpnote_options', '$squeeze', '$delete', '$layout_sortmark', '$resolve_placeholder', '$message', '$printer_config=', '$pop', '$strict=', '$upcase', '$ord', '$-@', '$make_sheetmark_path', '$to_a', '$<=>', '$!', '$visible=', '$visible', '$layout_playable', '$proxy', '$decorations', '$make_decorations_per_playable', '$more_conf_keys', '$layout_barnumbers_countnotes', '$znid', '$make_annotated_bezier_path', '$first_in_part?', '$tuplet_start?', '$tuplet_end?', '$round', '$to_s', '$tie_end?', '$make_slur_path', '$tie_start?', '$slur_starts', '$slur_ends', '$policy', '$debug', '$from', '$to', '$make_path_from_jumpline', '$make_repeatsign_annotation', '$position', '$style', '$companion', '$text', '$<=', '$next_pitch', '$prev_pitch', '$size_with_dot', '$reverse', '$compute_note_position', '$count_note', '$!=', '$measure_start?', '$measure_count', '$compute_beat_compression_1', '$compute_beat_compression_2', '$compute_beat_compression_10', '$compute_beat_compression_0', '$group_by', '$sort', '$beat_maps', '$duration_to_id', '$get_minc_factor', '$notes_on_beat', '$>=', '$next_first_in_part', '$layout_note', '$layout_accord', '$layout_pause', '$convert_pitch_to_xpos', '$compute_ellipse_properties_from_note', '$layout_note_shift', '$sheet_drawable=', '$layout_note_flags', '$times', '$odd?', '$check_duration', '$shift', '$sort_by', '$unshift', '$x', '$y', '$normalize', '$to_sym', '$start_pos_to_s', '$end_pos', '$rotate', '$angle', '$perpendicular', '$scan']);
  return (function($base, $parent_nesting) {
    var $Harpnotes, self = $Harpnotes = $module($base, 'Harpnotes');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var $Music, self = $Music = $module($base, 'Music');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      
      (function($base, $super, $parent_nesting) {
        function $MusicEntity(){};
        var self = $MusicEntity = $klass($base, $super, 'MusicEntity', $MusicEntity);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MusicEntity_initialize_1, TMP_MusicEntity_visible$q_2, TMP_MusicEntity_start_pos_to_s_3, TMP_MusicEntity_to_json_5;

        def.visible = def.start_pos = nil;
        
        self.$attr_accessor("beat", "conf_key", "count_note", "decorations", "end_pos", "next_pitch", "next_first_in_part", "next_playable", "prev_pitch", "prev_playable", "start_pos", "time", "endtime", "visible", "variant", "znid", "origin", "sheet_drawable");
        
        Opal.defn(self, '$initialize', TMP_MusicEntity_initialize_1 = function $$initialize() {
          var self = this;

          
          self.visible = true;
          return (self.origin = [nil, (self.decorations = [])]);
        }, TMP_MusicEntity_initialize_1.$$arity = 0);
        
        Opal.defn(self, '$visible?', TMP_MusicEntity_visible$q_2 = function() {
          var self = this;

          return self.visible
        }, TMP_MusicEntity_visible$q_2.$$arity = 0);
        
        Opal.defn(self, '$start_pos_to_s', TMP_MusicEntity_start_pos_to_s_3 = function $$start_pos_to_s() {
          var self = this;

          return "" + "[" + (self.start_pos.$first()) + ":" + (self.start_pos.$last()) + "]"
        }, TMP_MusicEntity_start_pos_to_s_3.$$arity = 0);
        return (Opal.defn(self, '$to_json', TMP_MusicEntity_to_json_5 = function $$to_json() {
          var TMP_4, self = this;

          return Opal.const_get_relative($nesting, 'Hash')['$[]']($rb_plus([["class", self.$class()]], $send($rb_minus(self.$instance_variables(), ["@constructor", "@toString"]), 'map', [], (TMP_4 = function(v){var self = TMP_4.$$s || this;
if (v == null) v = nil;
          return [v, self.$instance_variable_get(v)]}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4)))).$to_json()
        }, TMP_MusicEntity_to_json_5.$$arity = 0), nil) && 'to_json';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $NonPlayable(){};
        var self = $NonPlayable = $klass($base, $super, 'NonPlayable', $NonPlayable);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NonPlayable_companion$eq_6, TMP_NonPlayable_pitch_7, TMP_NonPlayable_beat_8, TMP_NonPlayable_duration_9;

        def.companion = nil;
        
        self.$attr_accessor("companion");
        
        Opal.defn(self, '$companion=', TMP_NonPlayable_companion$eq_6 = function(companion) {
          var self = this;

          
          if ($truthy(companion['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable')))) {
            } else {
            self.$raise("Companion must be playable")
          };
          return (self.companion = companion);
        }, TMP_NonPlayable_companion$eq_6.$$arity = 1);
        
        Opal.defn(self, '$pitch', TMP_NonPlayable_pitch_7 = function $$pitch() {
          var self = this;

          try {
            return self.companion.$pitch()
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }
        }, TMP_NonPlayable_pitch_7.$$arity = 0);
        
        Opal.defn(self, '$beat', TMP_NonPlayable_beat_8 = function $$beat() {
          var self = this;

          try {
            return self.companion.$beat()
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }
        }, TMP_NonPlayable_beat_8.$$arity = 0);
        return (Opal.defn(self, '$duration', TMP_NonPlayable_duration_9 = function $$duration() {
          var self = this;

          try {
            return self.companion.$duration()
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }
        }, TMP_NonPlayable_duration_9.$$arity = 0), nil) && 'duration';
      })($nesting[0], Opal.const_get_relative($nesting, 'MusicEntity'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Playable(){};
        var self = $Playable = $klass($base, $super, 'Playable', $Playable);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Playable_initialize_10, TMP_Playable_first_in_part$q_11, TMP_Playable_tie_end$q_12, TMP_Playable_tie_start$q_13, TMP_Playable_tuplet_start$q_14, TMP_Playable_tuplet_end$q_15, TMP_Playable_measure_start$q_16, TMP_Playable_proxy_note_17, TMP_Playable_left_18, TMP_Playable_right_19;

        def.tie_end = def.tie_start = def.tuplet_start = def.tuplet_end = def.measure_start = nil;
        
        self.$attr_accessor("first_in_part", "jump_starts", "jump_ends", "slur_starts", "slur_ends", "tie_start", "tie_end", "duration", "tuplet", "tuplet_start", "tuplet_end", "shift", "count_note", "measure_count", "measure_start");
        
        Opal.defn(self, '$initialize', TMP_Playable_initialize_10 = function $$initialize() {
          var self = this, $iter = TMP_Playable_initialize_10.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) TMP_Playable_initialize_10.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Playable_initialize_10, false), $zuper, $iter);
          self.slur_starts = [];
          self.slur_ends = [];
          self.tie_start = false;
          self.tie_end = false;
          self.tuplet = 1;
          self.tuplet_start = false;
          self.tuplet_end = false;
          return (self.count_note = nil);
        }, TMP_Playable_initialize_10.$$arity = 0);
        
        Opal.defn(self, '$first_in_part?', TMP_Playable_first_in_part$q_11 = function() {
          var self = this;

          return self.$first_in_part()
        }, TMP_Playable_first_in_part$q_11.$$arity = 0);
        
        Opal.defn(self, '$tie_end?', TMP_Playable_tie_end$q_12 = function() {
          var self = this;

          return self.tie_end
        }, TMP_Playable_tie_end$q_12.$$arity = 0);
        
        Opal.defn(self, '$tie_start?', TMP_Playable_tie_start$q_13 = function() {
          var self = this;

          return self.tie_start
        }, TMP_Playable_tie_start$q_13.$$arity = 0);
        
        Opal.defn(self, '$tuplet_start?', TMP_Playable_tuplet_start$q_14 = function() {
          var self = this;

          return self.tuplet_start
        }, TMP_Playable_tuplet_start$q_14.$$arity = 0);
        
        Opal.defn(self, '$tuplet_end?', TMP_Playable_tuplet_end$q_15 = function() {
          var self = this;

          return self.tuplet_end
        }, TMP_Playable_tuplet_end$q_15.$$arity = 0);
        
        Opal.defn(self, '$measure_start?', TMP_Playable_measure_start$q_16 = function() {
          var self = this;

          return self.measure_start
        }, TMP_Playable_measure_start$q_16.$$arity = 0);
        
        Opal.defn(self, '$proxy_note', TMP_Playable_proxy_note_17 = function $$proxy_note() {
          var self = this;

          return self
        }, TMP_Playable_proxy_note_17.$$arity = 0);
        
        Opal.defn(self, '$left', TMP_Playable_left_18 = function $$left() {
          var self = this;

          return self
        }, TMP_Playable_left_18.$$arity = 0);
        return (Opal.defn(self, '$right', TMP_Playable_right_19 = function $$right() {
          var self = this;

          return self
        }, TMP_Playable_right_19.$$arity = 0), nil) && 'right';
      })($nesting[0], Opal.const_get_relative($nesting, 'MusicEntity'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Note(){};
        var self = $Note = $klass($base, $super, 'Note', $Note);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Note_initialize_20;

        
        self.$attr_reader("pitch", "duration");
        return (Opal.defn(self, '$initialize', TMP_Note_initialize_20 = function $$initialize(pitch, duration) {
          var self = this, $iter = TMP_Note_initialize_20.$$p, $yield = $iter || nil;

          if ($iter) TMP_Note_initialize_20.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Note_initialize_20, false), [], null);
          if ($truthy(pitch['$nil?']())) {
            self.$raise("trying to create a note with undefined pitch")};
          self.pitch = pitch;
          self.next_pitch = pitch;
          self.next_playable = self;
          self.prev_pitch = pitch;
          self.prev_playable = self;
          return (self.duration = duration);
        }, TMP_Note_initialize_20.$$arity = 2), nil) && 'initialize';
      })($nesting[0], Opal.const_get_relative($nesting, 'Playable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $SynchPoint(){};
        var self = $SynchPoint = $klass($base, $super, 'SynchPoint', $SynchPoint);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SynchPoint_initialize_21, TMP_SynchPoint_measure_start_22, TMP_SynchPoint_duration_23, TMP_SynchPoint_beat$eq_25, TMP_SynchPoint_pitch_26, TMP_SynchPoint_proxy_note_27, TMP_SynchPoint_variant_28, TMP_SynchPoint_sheet_drawable_29, TMP_SynchPoint_prev_playable_30, TMP_SynchPoint_prev_playable$eq_31, TMP_SynchPoint_next_playable_32, TMP_SynchPoint_next_playable$eq_33, TMP_SynchPoint_get_proxy_object_34, TMP_SynchPoint_left_35, TMP_SynchPoint_right_36;

        def.notes = nil;
        
        self.$attr_reader("notes", "synched_notes");
        
        Opal.defn(self, '$initialize', TMP_SynchPoint_initialize_21 = function $$initialize(notes, synched_notes) {
          var self = this, $iter = TMP_SynchPoint_initialize_21.$$p, $yield = $iter || nil;

          if (synched_notes == null) {
            synched_notes = [];
          }
          if ($iter) TMP_SynchPoint_initialize_21.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_SynchPoint_initialize_21, false), [], null);
          if ($truthy(notes['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
            } else {
            self.$raise("Notes must be an array")
          };
          self.notes = notes;
          return (self.synched_notes = [notes, synched_notes].$flatten().$uniq());
        }, TMP_SynchPoint_initialize_21.$$arity = -2);
        
        Opal.defn(self, '$measure_start', TMP_SynchPoint_measure_start_22 = function $$measure_start() {
          var self = this;

          return self.$proxy_note().$measure_start()
        }, TMP_SynchPoint_measure_start_22.$$arity = 0);
        self.$alias_method("measure_start?", "measure_start");
        
        Opal.defn(self, '$duration', TMP_SynchPoint_duration_23 = function $$duration() {
          var self = this;

          return self.$proxy_note().$duration()
        }, TMP_SynchPoint_duration_23.$$arity = 0);
        
        Opal.defn(self, '$beat=', TMP_SynchPoint_beat$eq_25 = function(value) {
          var TMP_24, self = this;

          
          self.beat = value;
          return $send(self.notes, 'each', [], (TMP_24 = function(n){var self = TMP_24.$$s || this, $writer = nil;
if (n == null) n = nil;
          
            $writer = [value];
            $send(n, 'beat=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_24.$$s = self, TMP_24.$$arity = 1, TMP_24));
        }, TMP_SynchPoint_beat$eq_25.$$arity = 1);
        
        Opal.defn(self, '$pitch', TMP_SynchPoint_pitch_26 = function $$pitch() {
          var self = this;

          return self.$proxy_note().$pitch()
        }, TMP_SynchPoint_pitch_26.$$arity = 0);
        
        Opal.defn(self, '$proxy_note', TMP_SynchPoint_proxy_note_27 = function $$proxy_note() {
          var self = this;

          return self.$get_proxy_object(self.notes)
        }, TMP_SynchPoint_proxy_note_27.$$arity = 0);
        
        Opal.defn(self, '$variant', TMP_SynchPoint_variant_28 = function $$variant() {
          var self = this;

          return self.$proxy_note().$variant()
        }, TMP_SynchPoint_variant_28.$$arity = 0);
        
        Opal.defn(self, '$sheet_drawable', TMP_SynchPoint_sheet_drawable_29 = function $$sheet_drawable() {
          var self = this;

          return self.$proxy_note().$sheet_drawable()
        }, TMP_SynchPoint_sheet_drawable_29.$$arity = 0);
        
        Opal.defn(self, '$prev_playable', TMP_SynchPoint_prev_playable_30 = function $$prev_playable() {
          var self = this;

          return self.$proxy_note().$prev_playable()
        }, TMP_SynchPoint_prev_playable_30.$$arity = 0);
        
        Opal.defn(self, '$prev_playable=', TMP_SynchPoint_prev_playable$eq_31 = function(playable) {
          var self = this, $writer = nil;

          
          $writer = [playable];
          $send(self.$proxy_note(), 'prev_playable=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_SynchPoint_prev_playable$eq_31.$$arity = 1);
        
        Opal.defn(self, '$next_playable', TMP_SynchPoint_next_playable_32 = function $$next_playable() {
          var self = this;

          return self.$proxy_note().$next_playable()
        }, TMP_SynchPoint_next_playable_32.$$arity = 0);
        
        Opal.defn(self, '$next_playable=', TMP_SynchPoint_next_playable$eq_33 = function(playable) {
          var self = this, $writer = nil;

          
          $writer = [playable];
          $send(self.$proxy_note(), 'next_playable=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_SynchPoint_next_playable$eq_33.$$arity = 1);
        
        Opal.defn(self, '$get_proxy_object', TMP_SynchPoint_get_proxy_object_34 = function $$get_proxy_object(objects) {
          var self = this;

          return objects.$last()
        }, TMP_SynchPoint_get_proxy_object_34.$$arity = 1);
        
        Opal.defn(self, '$left', TMP_SynchPoint_left_35 = function $$left() {
          var self = this;

          return self.notes.$first()
        }, TMP_SynchPoint_left_35.$$arity = 0);
        return (Opal.defn(self, '$right', TMP_SynchPoint_right_36 = function $$right() {
          var self = this;

          return self.notes.$last()
        }, TMP_SynchPoint_right_36.$$arity = 0), nil) && 'right';
      })($nesting[0], Opal.const_get_relative($nesting, 'Playable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Pause(){};
        var self = $Pause = $klass($base, $super, 'Pause', $Pause);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Pause_initialize_37, TMP_Pause_visible$eq_38, TMP_Pause_visible$q_39;

        def.visible = nil;
        
        self.$attr_accessor("duration", "pitch");
        
        Opal.defn(self, '$initialize', TMP_Pause_initialize_37 = function $$initialize(pitch, duration) {
          var self = this, $iter = TMP_Pause_initialize_37.$$p, $yield = $iter || nil;

          if ($iter) TMP_Pause_initialize_37.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Pause_initialize_37, false), [], null);
          if ($truthy(pitch['$nil?']())) {
            self.$raise("trying to create a rest with undefined pitch")};
          self.pitch = pitch;
          self.duration = duration;
          self.next_playable = self;
          self.prev_pitch = pitch;
          return (self.prev_playable = self);
        }, TMP_Pause_initialize_37.$$arity = 2);
        
        Opal.defn(self, '$visible=', TMP_Pause_visible$eq_38 = function(visible) {
          var self = this;

          return (self.visible = visible)
        }, TMP_Pause_visible$eq_38.$$arity = 1);
        return (Opal.defn(self, '$visible?', TMP_Pause_visible$q_39 = function() {
          var self = this;

          return self.visible
        }, TMP_Pause_visible$q_39.$$arity = 0), nil) && 'visible?';
      })($nesting[0], Opal.const_get_relative($nesting, 'Playable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $MeasureStart(){};
        var self = $MeasureStart = $klass($base, $super, 'MeasureStart', $MeasureStart);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MeasureStart_initialize_40;

        return (Opal.defn(self, '$initialize', TMP_MeasureStart_initialize_40 = function $$initialize(companion) {
          var self = this, $iter = TMP_MeasureStart_initialize_40.$$p, $yield = $iter || nil, $writer = nil;

          if ($iter) TMP_MeasureStart_initialize_40.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_MeasureStart_initialize_40, false), [], null);
          
          $writer = [companion];
          $send(self, 'companion=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return (self.visible = companion['$visible?']());
        }, TMP_MeasureStart_initialize_40.$$arity = 1), nil) && 'initialize'
      })($nesting[0], Opal.const_get_relative($nesting, 'NonPlayable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $NewPart(){};
        var self = $NewPart = $klass($base, $super, 'NewPart', $NewPart);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NewPart_initialize_41;

        
        self.$attr_reader("name");
        return (Opal.defn(self, '$initialize', TMP_NewPart_initialize_41 = function $$initialize(title, conf_key) {
          var self = this, $iter = TMP_NewPart_initialize_41.$$p, $yield = $iter || nil;

          if (conf_key == null) {
            conf_key = nil;
          }
          if ($iter) TMP_NewPart_initialize_41.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_NewPart_initialize_41, false), [], null);
          self.conf_key = conf_key;
          return (self.name = title);
        }, TMP_NewPart_initialize_41.$$arity = -2), nil) && 'initialize';
      })($nesting[0], Opal.const_get_relative($nesting, 'NonPlayable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $NoteBoundAnnotation(){};
        var self = $NoteBoundAnnotation = $klass($base, $super, 'NoteBoundAnnotation', $NoteBoundAnnotation);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NoteBoundAnnotation_initialize_42, TMP_NoteBoundAnnotation_style_43, TMP_NoteBoundAnnotation_text_44, TMP_NoteBoundAnnotation_position_45, TMP_NoteBoundAnnotation_policy_46;

        def.annotations = nil;
        
        
        Opal.defn(self, '$initialize', TMP_NoteBoundAnnotation_initialize_42 = function $$initialize(companion, annotation, conf_key) {
          var self = this, $iter = TMP_NoteBoundAnnotation_initialize_42.$$p, $yield = $iter || nil, $writer = nil;

          if (conf_key == null) {
            conf_key = nil;
          }
          if ($iter) TMP_NoteBoundAnnotation_initialize_42.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_NoteBoundAnnotation_initialize_42, false), [], null);
          
          $writer = [companion];
          $send(self, 'companion=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          self.conf_key = conf_key;
          return (self.annotations = annotation);
        }, TMP_NoteBoundAnnotation_initialize_42.$$arity = -3);
        
        Opal.defn(self, '$style', TMP_NoteBoundAnnotation_style_43 = function $$style() {
          var $a, self = this;

          return ($truthy($a = self.annotations['$[]']("style")) ? $a : "regular")
        }, TMP_NoteBoundAnnotation_style_43.$$arity = 0);
        
        Opal.defn(self, '$text', TMP_NoteBoundAnnotation_text_44 = function $$text() {
          var self = this;

          return self.annotations['$[]']("text")
        }, TMP_NoteBoundAnnotation_text_44.$$arity = 0);
        
        Opal.defn(self, '$position', TMP_NoteBoundAnnotation_position_45 = function $$position() {
          var self = this;

          return self.annotations['$[]']("pos")
        }, TMP_NoteBoundAnnotation_position_45.$$arity = 0);
        return (Opal.defn(self, '$policy', TMP_NoteBoundAnnotation_policy_46 = function $$policy() {
          var self = this;

          return self.annotations['$[]']("policy")
        }, TMP_NoteBoundAnnotation_policy_46.$$arity = 0), nil) && 'policy';
      })($nesting[0], Opal.const_get_relative($nesting, 'NonPlayable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Goto(){};
        var self = $Goto = $klass($base, $super, 'Goto', $Goto);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Goto_initialize_47;

        
        self.$attr_reader("from", "to", "policy");
        return (Opal.defn(self, '$initialize', TMP_Goto_initialize_47 = function $$initialize(from, to, policy) {
          var self = this, $iter = TMP_Goto_initialize_47.$$p, $yield = $iter || nil;

          if ($iter) TMP_Goto_initialize_47.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Goto_initialize_47, false), [], null);
          if ($truthy(from['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable')))) {
            } else {
            self.$raise("" + "End point of Jump (" + (from.$class()) + ") must be a Playable")
          };
          if ($truthy(to['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable')))) {
            } else {
            self.$raise("" + "Start point of Jump (" + (to.$class()) + ") must be a Playable")
          };
          self.from = from;
          self.to = to;
          self.policy = policy;
          return (self.conf_key = policy['$[]']("conf_key"));
        }, TMP_Goto_initialize_47.$$arity = 3), nil) && 'initialize';
      })($nesting[0], Opal.const_get_relative($nesting, 'MusicEntity'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $BeatMap(){};
        var self = $BeatMap = $klass($base, $super, 'BeatMap', $BeatMap);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BeatMap_initialize_48;

        
        self.$attr_accessor("index");
        return (Opal.defn(self, '$initialize', TMP_BeatMap_initialize_48 = function $$initialize(index) {
          var self = this;

          return (self.index = index)
        }, TMP_BeatMap_initialize_48.$$arity = 1), nil) && 'initialize';
      })($nesting[0], Opal.const_get_relative($nesting, 'Hash'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Song(){};
        var self = $Song = $klass($base, $super, 'Song', $Song);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Song_to_json_49, TMP_Song_initialize_50, TMP_Song_$lt$lt_51, TMP_Song_build_synch_points_55, TMP_Song_last_beat_57, TMP_Song_expanded_beat_maps_60, TMP_Song_update_beats_64;

        def.voices = def.beat_maps = def.meta_data = def.harpnote_options = nil;
        
        self.$attr_reader("voices", "beat_maps");
        self.$attr_accessor("meta_data", "harpnote_options", "checksum");
        
        Opal.defn(self, '$to_json', TMP_Song_to_json_49 = function $$to_json() {
          var self = this;

          return $hash2(["voices", "beat_maps", "meta_data", "harpnote_options"], {"voices": self.voices, "beat_maps": self.beat_maps, "meta_data": self.meta_data, "harpnote_options": self.harpnote_options}).$to_json()
        }, TMP_Song_to_json_49.$$arity = 0);
        
        Opal.defn(self, '$initialize', TMP_Song_initialize_50 = function $$initialize(voices, note_length_in_beats, metadata) {
          var self = this;

          if (voices == null) {
            voices = [];
          }
          if (note_length_in_beats == null) {
            note_length_in_beats = 8;
          }
          if (metadata == null) {
            metadata = $hash2([], {});
          }
          
          self.voices = voices;
          self.note_length_in_beats = note_length_in_beats;
          self.meta_data = metadata;
          self.views = [];
          return self.$update_beats();
        }, TMP_Song_initialize_50.$$arity = -1);
        
        Opal.defn(self, '$<<', TMP_Song_$lt$lt_51 = function(voice) {
          var self = this;

          
          self.voices['$<<'](voice);
          return self.$update_beats();
        }, TMP_Song_$lt$lt_51.$$arity = 1);
        
        Opal.defn(self, '$build_synch_points', TMP_Song_build_synch_points_55 = function $$build_synch_points(selector) {
          var TMP_52, self = this, syncpoints = nil;

          if (selector == null) {
            selector = nil;
          }
          
          syncpoints = $send(self.$expanded_beat_maps(), 'map', [], (TMP_52 = function(beatmap_entry){var self = TMP_52.$$s || this, TMP_53, $a, TMP_54, playables = nil, pfirst = nil, plast = nil, first_left = nil, first_right = nil, last_left = nil, last_right = nil, candidates = nil, synchpoint = nil, result = nil;
if (beatmap_entry == null) beatmap_entry = nil;
          
            playables = $send([beatmap_entry['$[]'](selector.$first()), beatmap_entry['$[]'](selector.$last())].$compact(), 'select', [], (TMP_53 = function(i){var self = TMP_53.$$s || this;
if (i == null) i = nil;
            return i['$visible?']()}, TMP_53.$$s = self, TMP_53.$$arity = 1, TMP_53));
            pfirst = playables['$[]'](0);
            plast = playables['$[]'](1);
            if ($truthy(($truthy($a = pfirst) ? plast : $a))) {
              
              first_left = pfirst.$left();
              first_right = pfirst.$right();
              last_left = plast.$left();
              last_right = plast.$right();
              candidates = [first_left, first_right].$product([last_left, last_right]);};
            if ($truthy(candidates)) {
              
              synchpoint = $send(candidates, 'min_by', [], (TMP_54 = function(i){var self = TMP_54.$$s || this;
if (i == null) i = nil;
              return $rb_minus(i.$last().$pitch(), i.$first().$pitch()).$abs()}, TMP_54.$$s = self, TMP_54.$$arity = 1, TMP_54));
              result = Opal.const_get_relative($nesting, 'SynchPoint').$new(synchpoint, candidates);};
            return result;}, TMP_52.$$s = self, TMP_52.$$arity = 1, TMP_52)).$flatten().$compact();
          return syncpoints;
        }, TMP_Song_build_synch_points_55.$$arity = -1);
        
        Opal.defn(self, '$last_beat', TMP_Song_last_beat_57 = function $$last_beat() {
          var TMP_56, self = this, max_beat = nil;

          return (max_beat = $send(self.beat_maps, 'map', [], (TMP_56 = function(map){var self = TMP_56.$$s || this, $a;
if (map == null) map = nil;
          return ($truthy($a = map.$keys().$max()) ? $a : 0)}, TMP_56.$$s = self, TMP_56.$$arity = 1, TMP_56)).$max())
        }, TMP_Song_last_beat_57.$$arity = 0);
        
        Opal.defn(self, '$expanded_beat_maps', TMP_Song_expanded_beat_maps_60 = function $$expanded_beat_maps() {
          var TMP_58, self = this;

          return $send(Opal.Range.$new(0, self.$last_beat(), false), 'map', [], (TMP_58 = function(beat){var self = TMP_58.$$s || this, TMP_59;
            if (self.beat_maps == null) self.beat_maps = nil;
if (beat == null) beat = nil;
          return $send(self.beat_maps, 'map', [], (TMP_59 = function(map){var self = TMP_59.$$s || this;
if (map == null) map = nil;
            return map['$[]'](beat)}, TMP_59.$$s = self, TMP_59.$$arity = 1, TMP_59))}, TMP_58.$$s = self, TMP_58.$$arity = 1, TMP_58))
        }, TMP_Song_expanded_beat_maps_60.$$arity = 0);
        self.$private();
        return (Opal.defn(self, '$update_beats', TMP_Song_update_beats_64 = function $$update_beats() {
          var TMP_61, self = this;

          
          self.beat_maps = $send(self.voices, 'map', [], (TMP_61 = function(voice){var self = TMP_61.$$s || this, TMP_62, TMP_63, current_beat = nil, voice_map = nil;
if (voice == null) voice = nil;
          
            current_beat = 0;
            voice_map = $send($send(voice, 'select', [], (TMP_62 = function(e){var self = TMP_62.$$s || this;
if (e == null) e = nil;
            return e['$is_a?'](Opal.const_get_relative($nesting, 'Playable'))}, TMP_62.$$s = self, TMP_62.$$arity = 1, TMP_62)), 'inject', [Opal.const_get_relative($nesting, 'BeatMap').$new(voice.$index())], (TMP_63 = function(map, playable){var self = TMP_63.$$s || this, current_beat_floor = nil, beat_error = nil, pos = nil, $writer = nil;
              if ($gvars.log == null) $gvars.log = nil;
if (map == null) map = nil;if (playable == null) playable = nil;
            
              current_beat = $rb_divide(playable.$time(), 8);
              current_beat_floor = current_beat.$floor(0);
              beat_error = $rb_minus(current_beat, current_beat_floor);
              if ($truthy($rb_gt(beat_error, 0))) {
                
                pos = playable.$start_pos();
                $gvars.log.$error("" + "unsupported tuplet " + (playable.$tuplet()) + " " + (beat_error), pos);
                current_beat = current_beat_floor;};
              
              $writer = [current_beat, playable];
              $send(map, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [current_beat];
              $send(playable, 'beat=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [voice.$index()];
              $send(map, 'index=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              return map;}, TMP_63.$$s = self, TMP_63.$$arity = 2, TMP_63));
            return voice_map;}, TMP_61.$$s = self, TMP_61.$$arity = 1, TMP_61));
          return nil;
        }, TMP_Song_update_beats_64.$$arity = 0), nil) && 'update_beats';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $Voice(){};
        var self = $Voice = $klass($base, $super, 'Voice', $Voice);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Voice_initialize_65, TMP_Voice_show_voice$q_66, TMP_Voice_show_flowline$q_67, TMP_Voice_show_jumpline$q_68;

        def.show_voice = def.show_flowline = def.show_jumpline = nil;
        
        self.$attr_accessor("index", "name", "show_voice", "show_flowline", "show_jumpline");
        
        Opal.defn(self, '$initialize', TMP_Voice_initialize_65 = function $$initialize() {
          var self = this, $iter = TMP_Voice_initialize_65.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) TMP_Voice_initialize_65.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          self.show_voice = true;
          self.show_flowline = true;
          self.show_jumpline = true;
          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Voice_initialize_65, false), $zuper, $iter);
        }, TMP_Voice_initialize_65.$$arity = 0);
        
        Opal.defn(self, '$show_voice?', TMP_Voice_show_voice$q_66 = function() {
          var self = this;

          return self.show_voice['$=='](true)
        }, TMP_Voice_show_voice$q_66.$$arity = 0);
        
        Opal.defn(self, '$show_flowline?', TMP_Voice_show_flowline$q_67 = function() {
          var self = this;

          return self.show_flowline['$=='](true)
        }, TMP_Voice_show_flowline$q_67.$$arity = 0);
        return (Opal.defn(self, '$show_jumpline?', TMP_Voice_show_jumpline$q_68 = function() {
          var self = this;

          return self.show_jumpline['$=='](true)
        }, TMP_Voice_show_jumpline$q_68.$$arity = 0), nil) && 'show_jumpline?';
      })($nesting[0], Opal.const_get_relative($nesting, 'Array'), $nesting);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var $Drawing, self = $Drawing = $module($base, 'Drawing');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      
      (function($base, $super, $parent_nesting) {
        function $CollisionDetector(){};
        var self = $CollisionDetector = $klass($base, $super, 'CollisionDetector', $CollisionDetector);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CollisionDetector_initialize_69, TMP_CollisionDetector_check_annotations_72, TMP_CollisionDetector_reset_73, TMP_CollisionDetector__check1_75, TMP_CollisionDetector__rect_overlap$q_76;

        def.coll_stack = nil;
        
        
        Opal.defn(self, '$initialize', TMP_CollisionDetector_initialize_69 = function $$initialize() {
          var self = this;

          return self.$reset()
        }, TMP_CollisionDetector_initialize_69.$$arity = 0);
        
        Opal.defn(self, '$check_annotations', TMP_CollisionDetector_check_annotations_72 = function $$check_annotations(drawables) {
          var TMP_70, TMP_71, self = this;

          return $send($send(drawables, 'select', [], (TMP_70 = function(i){var self = TMP_70.$$s || this;
if (i == null) i = nil;
          return i['$is_a?'](Opal.const_get_relative($nesting, 'Annotation'))}, TMP_70.$$s = self, TMP_70.$$arity = 1, TMP_70)), 'each', [], (TMP_71 = function(drawable){var self = TMP_71.$$s || this;
if (drawable == null) drawable = nil;
          return self.$_check1(drawable.$center(), drawable.$size(), drawable.$conf_key(), drawable.$origin())}, TMP_71.$$s = self, TMP_71.$$arity = 1, TMP_71))
        }, TMP_CollisionDetector_check_annotations_72.$$arity = 1);
        
        Opal.defn(self, '$reset', TMP_CollisionDetector_reset_73 = function $$reset() {
          var self = this;

          return (self.coll_stack = [])
        }, TMP_CollisionDetector_reset_73.$$arity = 0);
        
        Opal.defn(self, '$_check1', TMP_CollisionDetector__check1_75 = function $$_check1(point, size, confkey, playable) {
          var $a, $b, TMP_74, self = this, x = nil, y = nil, xsize = nil, ysize = nil, rect = nil, collision = nil, startpos = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          $b = point, $a = Opal.to_ary($b), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $b;
          $b = size, $a = Opal.to_ary($b), (xsize = ($a[0] == null ? nil : $a[0])), (ysize = ($a[1] == null ? nil : $a[1])), $b;
          rect = [x, y, $rb_plus(x, xsize), $rb_plus(y, ysize)];
          collision = $send(self.coll_stack, 'select', [], (TMP_74 = function(i){var self = TMP_74.$$s || this;
if (i == null) i = nil;
          return self['$_rect_overlap?'](i, rect)}, TMP_74.$$s = self, TMP_74.$$arity = 1, TMP_74));
          startpos = [0, 0];
          if ($truthy(collision['$empty?']())) {
            } else {
            
            
            try {
              startpos = playable['$[]']("start_pos")
            } catch ($err) {
              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
                try {
                  
                  $gvars.log.$error("" + "BUG: Annotation without origin " + ("harpnotes") + " " + (749));
                  [0, 0];
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };;
            $gvars.log.$warning($rb_plus(Opal.const_get_relative($nesting, 'I18n').$t("annotations too close ["), "" + (collision.$count()) + "] " + (confkey)), startpos);
          };
          self.coll_stack.$push(rect);
          return point;
        }, TMP_CollisionDetector__check1_75.$$arity = 4);
        return (Opal.defn(self, '$_rect_overlap?', TMP_CollisionDetector__rect_overlap$q_76 = function(rect1, rect2) {
          var $a, $b, $c, self = this, left1 = nil, top1 = nil, right1 = nil, bottom1 = nil, left2 = nil, top2 = nil, right2 = nil, bottom2 = nil;

          
          $b = rect1, $a = Opal.to_ary($b), (left1 = ($a[0] == null ? nil : $a[0])), (top1 = ($a[1] == null ? nil : $a[1])), (right1 = ($a[2] == null ? nil : $a[2])), (bottom1 = ($a[3] == null ? nil : $a[3])), $b;
          $b = rect2, $a = Opal.to_ary($b), (left2 = ($a[0] == null ? nil : $a[0])), (top2 = ($a[1] == null ? nil : $a[1])), (right2 = ($a[2] == null ? nil : $a[2])), (bottom2 = ($a[3] == null ? nil : $a[3])), $b;
          return ($truthy($a = ($truthy($b = ($truthy($c = $rb_gt(right1, left2)) ? $rb_gt(right2, left1) : $c)) ? $rb_gt(bottom1, top2) : $b)) ? $rb_gt(bottom2, top1) : $a);
        }, TMP_CollisionDetector__rect_overlap$q_76.$$arity = 2), nil) && '_rect_overlap?';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $Sheet(){};
        var self = $Sheet = $klass($base, $super, 'Sheet', $Sheet);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Sheet_initialize_77;

        
        self.$attr_reader("children", "active_voices");
        self.$attr_accessor("printer_config");
        return (Opal.defn(self, '$initialize', TMP_Sheet_initialize_77 = function $$initialize(children, active_voices) {
          var self = this;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          self.children = children;
          self.active_voices = active_voices;
          return (self.printer_config = $gvars.conf['$[]']("printer"));
        }, TMP_Sheet_initialize_77.$$arity = 2), nil) && 'initialize';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $CompoundDrawable(){};
        var self = $CompoundDrawable = $klass($base, $super, 'CompoundDrawable', $CompoundDrawable);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CompoundDrawable_initialize_78, TMP_CompoundDrawable_push_79, TMP_CompoundDrawable_merge_80;

        def.shapes = nil;
        
        self.$attr_accessor("shapes", "proxy");
        
        Opal.defn(self, '$initialize', TMP_CompoundDrawable_initialize_78 = function $$initialize(shapes, proxy) {
          var self = this;

          
          self.shapes = shapes;
          return (self.proxy = proxy);
        }, TMP_CompoundDrawable_initialize_78.$$arity = 2);
        
        Opal.defn(self, '$push', TMP_CompoundDrawable_push_79 = function $$push(drawable) {
          var self = this;

          return self.shapes['$<<'](drawable)
        }, TMP_CompoundDrawable_push_79.$$arity = 1);
        return (Opal.defn(self, '$merge', TMP_CompoundDrawable_merge_80 = function $$merge(compound_drawable) {
          var self = this;

          return (self.shapes = $rb_plus(self.shapes, compound_drawable.$shapes()))
        }, TMP_CompoundDrawable_merge_80.$$arity = 1), nil) && 'merge';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $Drawable(){};
        var self = $Drawable = $klass($base, $super, 'Drawable', $Drawable);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Drawable_initialize_81, TMP_Drawable_center_82, TMP_Drawable_visible$q_83, TMP_Drawable_visible$eq_84, TMP_Drawable_line_width$eq_85, TMP_Drawable_line_width_86, TMP_Drawable_color$eq_87, TMP_Drawable_color_88, TMP_Drawable_size_with_dot_89;

        def.visible = def.line_width = def.color = def.size = nil;
        
        self.$attr_accessor("conf_key", "conf_value", "draginfo", "color", "size", "more_conf_keys");
        
        Opal.defn(self, '$initialize', TMP_Drawable_initialize_81 = function $$initialize() {
          var self = this;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          self.visible = true;
          self.line_width = $gvars.conf.$get("layout.LINE_THIN");
          self.conf_key = nil;
          self.more_conf_keys = [];
          self.color = $gvars.conf.$get("layout.color.color_default");
          return (self.size = [1, 1]);
        }, TMP_Drawable_initialize_81.$$arity = 0);
        
        Opal.defn(self, '$center', TMP_Drawable_center_82 = function $$center() {
          var self = this;

          return self.$raise("" + "center not implemented for " + (self.$class()))
        }, TMP_Drawable_center_82.$$arity = 0);
        
        Opal.defn(self, '$visible?', TMP_Drawable_visible$q_83 = function() {
          var self = this;

          return self.visible
        }, TMP_Drawable_visible$q_83.$$arity = 0);
        
        Opal.defn(self, '$visible=', TMP_Drawable_visible$eq_84 = function(v) {
          var self = this;

          return (self.visible = v)
        }, TMP_Drawable_visible$eq_84.$$arity = 1);
        
        Opal.defn(self, '$line_width=', TMP_Drawable_line_width$eq_85 = function(v) {
          var self = this;

          return (self.line_width = v)
        }, TMP_Drawable_line_width$eq_85.$$arity = 1);
        
        Opal.defn(self, '$line_width', TMP_Drawable_line_width_86 = function $$line_width() {
          var self = this;

          return self.line_width
        }, TMP_Drawable_line_width_86.$$arity = 0);
        
        Opal.defn(self, '$color=', TMP_Drawable_color$eq_87 = function(v) {
          var self = this;

          return (self.color = v)
        }, TMP_Drawable_color$eq_87.$$arity = 1);
        
        Opal.defn(self, '$color', TMP_Drawable_color_88 = function $$color() {
          var self = this;

          return self.color
        }, TMP_Drawable_color_88.$$arity = 0);
        return (Opal.defn(self, '$size_with_dot', TMP_Drawable_size_with_dot_89 = function $$size_with_dot() {
          var self = this, result = nil, $writer = nil;

          
          result = self.size.$clone();
          if ($truthy(self['$dotted?']())) {
            
            $writer = [0, $rb_plus(result['$[]'](0), 1)];
            $send(result, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          return result;
        }, TMP_Drawable_size_with_dot_89.$$arity = 0), nil) && 'size_with_dot';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $Symbol(){};
        var self = $Symbol = $klass($base, $super, 'Symbol', $Symbol);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Symbol_iniitalize_90, TMP_Symbol_dotted$q_91, TMP_Symbol_hasbarover$q_92;

        def.dotted = def.hasbarover = nil;
        
        self.$attr_accessor("dotted", "hasbarover");
        
        Opal.defn(self, '$iniitalize', TMP_Symbol_iniitalize_90 = function $$iniitalize() {
          var self = this, $iter = TMP_Symbol_iniitalize_90.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) TMP_Symbol_iniitalize_90.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          return $send(self, Opal.find_super_dispatcher(self, 'iniitalize', TMP_Symbol_iniitalize_90, false), $zuper, $iter)
        }, TMP_Symbol_iniitalize_90.$$arity = 0);
        
        Opal.defn(self, '$dotted?', TMP_Symbol_dotted$q_91 = function() {
          var self = this;

          return self.dotted
        }, TMP_Symbol_dotted$q_91.$$arity = 0);
        return (Opal.defn(self, '$hasbarover?', TMP_Symbol_hasbarover$q_92 = function() {
          var self = this;

          return self.hasbarover
        }, TMP_Symbol_hasbarover$q_92.$$arity = 0), nil) && 'hasbarover?';
      })($nesting[0], Opal.const_get_relative($nesting, 'Drawable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $FlowLine(){};
        var self = $FlowLine = $klass($base, $super, 'FlowLine', $FlowLine);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_FlowLine_initialize_93, TMP_FlowLine_dashed$q_94, TMP_FlowLine_dotted$q_95;

        def.style = nil;
        
        self.$attr_reader("from", "to", "style");
        
        Opal.defn(self, '$initialize', TMP_FlowLine_initialize_93 = function $$initialize(from, to, style) {
          var self = this, $iter = TMP_FlowLine_initialize_93.$$p, $yield = $iter || nil;

          if (style == null) {
            style = "solid";
          }
          if ($iter) TMP_FlowLine_initialize_93.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_FlowLine_initialize_93, false), [], null);
          self.from = from;
          self.to = to;
          return (self.style = style);
        }, TMP_FlowLine_initialize_93.$$arity = -3);
        
        Opal.defn(self, '$dashed?', TMP_FlowLine_dashed$q_94 = function() {
          var self = this;

          return self.style['$==']("dashed")
        }, TMP_FlowLine_dashed$q_94.$$arity = 0);
        return (Opal.defn(self, '$dotted?', TMP_FlowLine_dotted$q_95 = function() {
          var self = this;

          return self.style['$==']("dotted")
        }, TMP_FlowLine_dotted$q_95.$$arity = 0), nil) && 'dotted?';
      })($nesting[0], Opal.const_get_relative($nesting, 'Drawable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Image(){};
        var self = $Image = $klass($base, $super, 'Image', $Image);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Image_initialize_96;

        
        self.$attr_reader("url", "llpos", "height", "opacity", "origin");
        return (Opal.defn(self, '$initialize', TMP_Image_initialize_96 = function $$initialize(url, llpos, height, origin) {
          var self = this;

          if (origin == null) {
            origin = nil;
          }
          
          self.url = url;
          self.llpos = llpos;
          self.height = height;
          return (self.origin = nil);
        }, TMP_Image_initialize_96.$$arity = -4), nil) && 'initialize';
      })($nesting[0], Opal.const_get_relative($nesting, 'Drawable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Path(){};
        var self = $Path = $klass($base, $super, 'Path', $Path);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Path_initialize_97, TMP_Path_filled$q_98;

        def.fill = nil;
        
        self.$attr_reader("path", "style", "origin");
        
        Opal.defn(self, '$initialize', TMP_Path_initialize_97 = function $$initialize(path, fill, origin) {
          var self = this, $iter = TMP_Path_initialize_97.$$p, $yield = $iter || nil;

          if (fill == null) {
            fill = nil;
          }
          if (origin == null) {
            origin = nil;
          }
          if ($iter) TMP_Path_initialize_97.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Path_initialize_97, false), [], null);
          self.path = path;
          self.fill = fill;
          return (self.origin = origin);
        }, TMP_Path_initialize_97.$$arity = -2);
        return (Opal.defn(self, '$filled?', TMP_Path_filled$q_98 = function() {
          var self = this;

          return self.fill['$==']("filled")
        }, TMP_Path_filled$q_98.$$arity = 0), nil) && 'filled?';
      })($nesting[0], Opal.const_get_relative($nesting, 'Drawable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Ellipse(){};
        var self = $Ellipse = $klass($base, $super, 'Ellipse', $Ellipse);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Ellipse_initialize_99, TMP_Ellipse_height_100, TMP_Ellipse_dotted$q_101, TMP_Ellipse_filled$q_102, TMP_Ellipse_rect$q_103;

        def.size = def.fill = def.rect = nil;
        
        self.$attr_reader("center", "size", "fill", "origin", "color");
        
        Opal.defn(self, '$initialize', TMP_Ellipse_initialize_99 = function $$initialize(center, radii, fill, dotted, origin, rect) {
          var self = this, $iter = TMP_Ellipse_initialize_99.$$p, $yield = $iter || nil;

          if (fill == null) {
            fill = "filled";
          }
          if (dotted == null) {
            dotted = false;
          }
          if (origin == null) {
            origin = nil;
          }
          if (rect == null) {
            rect = false;
          }
          if ($iter) TMP_Ellipse_initialize_99.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Ellipse_initialize_99, false), [], null);
          self.center = center;
          self.size = radii;
          self.fill = fill;
          self.dotted = dotted;
          self.rect = rect;
          return (self.origin = origin);
        }, TMP_Ellipse_initialize_99.$$arity = -3);
        
        Opal.defn(self, '$height', TMP_Ellipse_height_100 = function $$height() {
          var self = this;

          return self.size.$last()
        }, TMP_Ellipse_height_100.$$arity = 0);
        
        Opal.defn(self, '$dotted?', TMP_Ellipse_dotted$q_101 = function() {
          var self = this;

          return self.$dotted()
        }, TMP_Ellipse_dotted$q_101.$$arity = 0);
        
        Opal.defn(self, '$filled?', TMP_Ellipse_filled$q_102 = function() {
          var self = this;

          return self.fill['$==']("filled")
        }, TMP_Ellipse_filled$q_102.$$arity = 0);
        return (Opal.defn(self, '$rect?', TMP_Ellipse_rect$q_103 = function() {
          var self = this;

          return self.rect['$=='](true)
        }, TMP_Ellipse_rect$q_103.$$arity = 0), nil) && 'rect?';
      })($nesting[0], Opal.const_get_relative($nesting, 'Symbol'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Annotation(){};
        var self = $Annotation = $klass($base, $super, 'Annotation', $Annotation);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Annotation_initialize_104, TMP_Annotation_size_105;

        def.text = def.style = nil;
        
        self.$attr_reader("center", "text", "style", "origin");
        self.$attr_accessor("conf_key", "conf_value", "align", "baseline");
        
        Opal.defn(self, '$initialize', TMP_Annotation_initialize_104 = function $$initialize(center, text, style, origin, conf_key, conf_value) {
          var self = this, $iter = TMP_Annotation_initialize_104.$$p, $yield = $iter || nil, _text = nil;

          if (style == null) {
            style = "regular";
          }
          if (origin == null) {
            origin = nil;
          }
          if (conf_key == null) {
            conf_key = nil;
          }
          if (conf_value == null) {
            conf_value = $hash2([], {});
          }
          if ($iter) TMP_Annotation_initialize_104.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Annotation_initialize_104, false), [], null);
          _text = text.$gsub(/[„“‚’—–]/, $hash2(["„", "“", "‚", "’", "—", "–"], {"„": "\"", "“": "\"", "‚": "'", "’": "'", "—": "-", "–": "-"}));
          self.center = center;
          self.text = _text;
          self.style = style;
          self.align = "left";
          self.baseline = "alphabetic";
          self.origin = origin;
          self.conf_key = conf_key;
          return (self.conf_value = conf_value);
        }, TMP_Annotation_initialize_104.$$arity = -3);
        return (Opal.defn(self, '$size', TMP_Annotation_size_105 = function $$size() {
          var $a, self = this, font_size = nil, ysize = nil, xsize = nil;
          if ($gvars.conf == null) $gvars.conf = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          if ($truthy(($truthy($a = self.text) ? $rb_gt(self.text.$strip().$length(), 0) : $a))) {
            
            font_size = $gvars.conf.$get("" + "layout.FONT_STYLE_DEF." + (self.style) + ".font_size");
            if ($truthy(font_size)) {
              } else {
              
              font_size = 10;
              $gvars.log.$error("" + "unsupported style for annotation: " + (self.style));
            };
            ysize = $rb_times(font_size, $gvars.conf.$get("layout.MM_PER_POINT").$to_f());
            xsize = $rb_times(self.text.$length(), ysize);
            } else {
            $a = [1.5, 2], (xsize = $a[0]), (ysize = $a[1]), $a
          };
          return [xsize, ysize];
        }, TMP_Annotation_size_105.$$arity = 0), nil) && 'size';
      })($nesting[0], Opal.const_get_relative($nesting, 'Drawable'), $nesting);
      (function($base, $super, $parent_nesting) {
        function $Glyph(){};
        var self = $Glyph = $klass($base, $super, 'Glyph', $Glyph);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Glyph_initialize_106, TMP_Glyph_height_107, TMP_Glyph_dotted$q_108, TMP_Glyph_filled$q_109;

        def.size = def.fill = nil;
        
        self.$attr_reader("center", "size", "glyph", "origin");
        Opal.const_set($nesting[0], 'GLYPHS', $hash2(["rest_1", "rest_4", "rest_8", "rest_16", "fermata", "emphasis", "error"], {"rest_1": $hash2(["d", "w", "h"], {"d": [["M", -10, -5], ["l", 20, 0], ["l", 0, 10], ["l", -20, 0], ["l", 0, -10], ["z"]], "w": 20, "h": 10}), "rest_4": $hash2(["d", "w", "h"], {"d": [["M", -1, -10], ["c", 0.12, -0.06, 0.24, -0.06, 0.36, -0.03], ["c", 0.09, 0.06, 4.74, 5.58, 4.86, 5.82], ["c", 0.21, 0.39, 0.15, 0.78, -0.15, 1.26], ["c", -0.24, 0.33, -0.72, 0.81, -1.62, 1.56], ["c", -0.45, 0.36, -0.87, 0.75, -0.96, 0.84], ["c", -0.93, 0.99, -1.14, 2.49, -0.6, 3.63], ["c", 0.18, 0.39, 0.27, 0.48, 1.32, 1.68], ["c", 1.92, 2.25, 1.83, 2.16, 1.83, 2.34], ["c", 0, 0.18, -0.18, 0.36, -0.36, 0.39], ["c", -0.15, 0, -0.27, -0.06, -0.48, -0.27], ["c", -0.75, -0.75, -2.46, -1.29, -3.39, -1.08], ["c", -0.45, 0.09, -0.69, 0.27, -0.9, 0.69], ["c", -0.12, 0.3, -0.21, 0.66, -0.24, 1.14], ["c", -0.03, 0.66, 0.09, 1.35, 0.3, 2.01], ["c", 0.15, 0.42, 0.24, 0.66, 0.45, 0.96], ["c", 0.18, 0.24, 0.18, 0.33, 0.03, 0.42], ["c", -0.12, 0.06, -0.18, 0.03, -0.45, -0.3], ["c", -1.08, -1.38, -2.07, -3.36, -2.4, -4.83], ["c", -0.27, -1.05, -0.15, -1.77, 0.27, -2.07], ["c", 0.21, -0.12, 0.42, -0.15, 0.87, -0.15], ["c", 0.87, 0.06, 2.1, 0.39, 3.3, 0.9], ["l", 0.39, 0.18], ["l", -1.65, -1.95], ["c", -2.52, -2.97, -2.61, -3.09, -2.7, -3.27], ["c", -0.09, -0.24, -0.12, -0.48, -0.03, -0.75], ["c", 0.15, -0.48, 0.57, -0.96, 1.83, -2.01], ["c", 0.45, -0.36, 0.84, -0.72, 0.93, -0.78], ["c", 0.69, -0.75, 1.02, -1.8, 0.9, -2.79], ["c", -0.06, -0.33, -0.21, -0.84, -0.39, -1.11], ["c", -0.09, -0.15, -0.45, -0.6, -0.81, -1.05], ["c", -0.36, -0.42, -0.69, -0.81, -0.72, -0.87], ["c", -0.09, -0.18, 0, -0.42, 0.21, -0.51], ["z"]], "w": 7.888, "h": 21.435}), "rest_8": $hash2(["d", "w", "h"], {"d": [["M", -2, -6.7], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.12, 0, 0.18, 0, 0.33, -0.09], ["c", 0.39, -0.18, 1.32, -1.29, 1.68, -1.98], ["c", 0.09, -0.21, 0.24, -0.3, 0.39, -0.3], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.27, 1.11, -1.86, 6.42], ["c", -1.02, 3.48, -1.89, 6.39, -1.92, 6.42], ["c", 0, 0.03, -0.12, 0.12, -0.24, 0.15], ["c", -0.18, 0.09, -0.21, 0.09, -0.45, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.15, -0.57, 1.68, -4.92], ["c", 0.96, -2.67, 1.74, -4.89, 1.71, -4.89], ["l", -0.51, 0.15], ["c", -1.08, 0.36, -1.74, 0.48, -2.55, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], "w": 7.534, "h": 13.883}), "rest_16": $hash2(["d", "w", "h"], {"d": [["M", -1.33, -11.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.15, 0.39, 0.57, 0.57, 0.87, 0.42], ["c", 0.39, -0.18, 1.2, -1.23, 1.62, -2.07], ["c", 0.06, -0.15, 0.24, -0.24, 0.36, -0.24], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.45, 1.86, -2.67, 10.17], ["c", -1.5, 5.55, -2.73, 10.14, -2.76, 10.17], ["c", -0.03, 0.03, -0.12, 0.12, -0.24, 0.15], ["c", -0.18, 0.09, -0.21, 0.09, -0.45, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.12, -0.57, 1.44, -4.92], ["c", 0.81, -2.67, 1.47, -4.86, 1.47, -4.89], ["c", -0.03, 0, -0.27, 0.06, -0.54, 0.15], ["c", -1.08, 0.36, -1.77, 0.48, -2.58, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.09, 0.09, 0.27, 0.18, 0.45, 0.21], ["c", 0.12, 0, 0.18, 0, 0.33, -0.09], ["c", 0.33, -0.15, 1.02, -0.93, 1.41, -1.59], ["c", 0.12, -0.21, 0.18, -0.39, 0.39, -1.08], ["c", 0.66, -2.1, 1.17, -3.84, 1.17, -3.87], ["c", 0, 0, -0.21, 0.06, -0.42, 0.15], ["c", -0.51, 0.15, -1.2, 0.33, -1.68, 0.42], ["c", -0.33, 0.06, -0.51, 0.06, -0.96, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], "w": 9.724, "h": 21.383}), "fermata": $hash2(["d", "w", "h"], {"d": [["M", -0.75, -5.34], ["c", 0.12, 0, 0.45, -0.03, 0.69, -0.03], ["c", 2.91, -0.03, 5.55, 1.53, 7.41, 4.35], ["c", 1.17, 1.71, 1.95, 3.72, 2.43, 6.03], ["c", 0.12, 0.51, 0.12, 0.57, 0.03, 0.69], ["c", -0.12, 0.21, -0.48, 0.27, -0.69, 0.12], ["c", -0.12, -0.09, -0.18, -0.24, -0.27, -0.69], ["c", -0.78, -3.63, -3.42, -6.54, -6.78, -7.38], ["c", -0.78, -0.21, -1.2, -0.24, -2.07, -0.24], ["c", -0.63, 0, -0.84, 0, -1.2, 0.06], ["c", -1.83, 0.27, -3.42, 1.08, -4.8, 2.37], ["c", -1.41, 1.35, -2.4, 3.21, -2.85, 5.19], ["c", -0.09, 0.45, -0.15, 0.6, -0.27, 0.69], ["c", -0.21, 0.15, -0.57, 0.09, -0.69, -0.12], ["c", -0.09, -0.12, -0.09, -0.18, 0.03, -0.69], ["c", 0.33, -1.62, 0.78, -3, 1.47, -4.38], ["c", 1.77, -3.54, 4.44, -5.67, 7.56, -5.97], ["z"], ["M", -0.5, 1.5], ["c", 1.38, -0.3, 2.58, 0.9, 2.31, 2.25], ["c", -0.15, 0.72, -0.78, 1.35, -1.47, 1.5], ["c", -1.38, 0.27, -2.58, -0.93, -2.31, -2.31], ["c", 0.15, -0.69, 0.78, -1.29, 1.47, -1.44], ["z"]], "w": 19.748, "h": 11.289}), "emphasis": $hash2(["d", "w", "h"], {"d": [["M", -6.45, -3.69], ["c", 0.06, -0.03, 0.15, -0.06, 0.18, -0.06], ["c", 0.06, 0, 2.85, 0.72, 6.24, 1.59], ["l", 6.33, 1.65], ["c", 0.33, 0.06, 0.45, 0.21, 0.45, 0.51], ["c", 0, 0.3, -0.12, 0.45, -0.45, 0.51], ["l", -6.33, 1.65], ["c", -3.39, 0.87, -6.18, 1.59, -6.21, 1.59], ["c", -0.21, 0, -0.48, -0.24, -0.51, -0.45], ["c", 0, -0.15, 0.06, -0.36, 0.18, -0.45], ["c", 0.09, -0.06, 0.87, -0.27, 3.84, -1.05], ["c", 2.04, -0.54, 3.84, -0.99, 4.02, -1.02], ["c", 0.15, -0.06, 1.14, -0.24, 2.22, -0.42], ["c", 1.05, -0.18, 1.92, -0.36, 1.92, -0.36], ["c", 0, 0, -0.87, -0.18, -1.92, -0.36], ["c", -1.08, -0.18, -2.07, -0.36, -2.22, -0.42], ["c", -0.18, -0.03, -1.98, -0.48, -4.02, -1.02], ["c", -2.97, -0.78, -3.75, -0.99, -3.84, -1.05], ["c", -0.12, -0.09, -0.18, -0.3, -0.18, -0.45], ["c", 0.03, -0.15, 0.15, -0.3, 0.3, -0.39], ["z"]], "w": 13.5, "h": 7.5}), "error": $hash2(["d", "w", "h"], {"d": [["M", -10, -5], ["l", 0, 10], ["l", 20, -10], ["l", 0, 10], ["z"]], "w": 20, "h": 10})}));
        
        Opal.defn(self, '$initialize', TMP_Glyph_initialize_106 = function $$initialize(center, size, glyph_name, dotted, origin, conf_key, conf_value) {
          var self = this, $iter = TMP_Glyph_initialize_106.$$p, $yield = $iter || nil, glyph = nil;
          if ($gvars.log == null) $gvars.log = nil;

          if (dotted == null) {
            dotted = Opal.const_get_relative($nesting, 'FALSE');
          }
          if (origin == null) {
            origin = nil;
          }
          if (conf_key == null) {
            conf_key = nil;
          }
          if (conf_value == null) {
            conf_value = $hash2([], {});
          }
          if ($iter) TMP_Glyph_initialize_106.$$p = null;
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Glyph_initialize_106, false), [], null);
          glyph = Opal.const_get_relative($nesting, 'GLYPHS')['$[]'](glyph_name);
          if ($truthy(glyph)) {
            } else {
            
            if ($truthy(glyph)) {
              } else {
              $gvars.log.$error("" + "BUG: unsuppoerted glyph " + (glyph_name))
            };
            glyph = Opal.const_get_relative($nesting, 'GLYPHS')['$[]']("error");
          };
          self.center = center;
          self.glyph_name = glyph_name;
          self.glyph = glyph;
          self.size = size;
          self.dotted = dotted;
          self.origin = origin;
          self.filled = true;
          self.conf_key = conf_key;
          self.conf_value = conf_value;
          return (self.coll_stack = []);
        }, TMP_Glyph_initialize_106.$$arity = -4);
        
        Opal.defn(self, '$height', TMP_Glyph_height_107 = function $$height() {
          var self = this;

          return self.size.$last()
        }, TMP_Glyph_height_107.$$arity = 0);
        
        Opal.defn(self, '$dotted?', TMP_Glyph_dotted$q_108 = function() {
          var self = this;

          return self.$dotted()
        }, TMP_Glyph_dotted$q_108.$$arity = 0);
        return (Opal.defn(self, '$filled?', TMP_Glyph_filled$q_109 = function() {
          var self = this;

          return self.fill['$==']("filled")
        }, TMP_Glyph_filled$q_109.$$arity = 0), nil) && 'filled?';
      })($nesting[0], Opal.const_get_relative($nesting, 'Symbol'), $nesting);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var $Layout, self = $Layout = $module($base, 'Layout');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Default(){};
        var self = $Default = $klass($base, $super, 'Default', $Default);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Default_initialize_110, TMP_Default_set_instrument_handlers_122, TMP_Default_layout_images_125, TMP_Default_layout_debug_grid_130, TMP_Default_layout_153, TMP_Default_get_print_options_154, TMP_Default_layout_sortmark_156, TMP_Default_layout_stringnames_161, TMP_Default_compute_note_position_162, TMP_Default_layout_voice_193, TMP_Default_make_decorations_per_playable_197, TMP_Default_make_repeatsign_annotation_199, TMP_Default_layout_barnumbers_countnotes_204, TMP_Default_compute_beat_compression_205, TMP_Default_compute_beat_compression_2_213, TMP_Default_compute_beat_compression_10_222, TMP_Default_get_minc_factor_223, TMP_Default_compute_beat_compression_0_234, TMP_Default_compute_beat_compression_1_248, TMP_Default_layout_playable_249, TMP_Default_layout_note_250, TMP_Default_layout_note_flags_253, TMP_Default_convert_pitch_to_xpos_254, TMP_Default_compute_color_by_variant_no_255, TMP_Default_compute_ellipse_properties_from_note_257, TMP_Default_layout_note_shift_258, TMP_Default_layout_accord_263, TMP_Default_layout_pause_264, TMP_Default_make_path_from_jumpline_265, TMP_Default_duration_to_id_266, TMP_Default_check_duration_267, TMP_Default_make_sheetmark_path_269, TMP_Default_make_slur_path_270, TMP_Default_make_annotated_bezier_path_271, TMP_Default_resolve_placeholder_273;

        def.placeholders = def.y_offset = def.beat_spacing = def.print_options_raw = def.bottom_annotation_positions = def.uri = def.draw_instrument = def.slur_index = def.color_default = def.layout_minc = def.conf_beat_resolution = def.instrument_orientation = def.pitch_to_xpos = def.color_variant1 = def.color_variant2 = def.print_options_keys = nil;
        
        self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'));
        self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'));
        self.$attr_accessor("uri", "placeholders");
        Opal.const_set($nesting[0], 'MM_PER_POINT', 0.3);
        
        Opal.defn(self, '$initialize', TMP_Default_initialize_110 = function $$initialize() {
          var self = this;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          self.beat_spacing = $rb_divide($rb_times($gvars.conf.$get("layout.Y_SCALE"), 1.0), $gvars.conf.$get("layout.BEAT_RESOLUTION"));
          self.slur_index = $hash2([], {});
          self.y_offset = 5;
          self.conf_beat_resolution = $gvars.conf.$get("layout.BEAT_RESOLUTION");
          self.layout_minc = $hash2([], {});
          self.color_default = $gvars.conf.$get("layout.color.color_default");
          self.color_variant1 = $gvars.conf.$get("layout.color.color_variant1");
          self.color_variant2 = $gvars.conf.$get("layout.color.color_variant2");
          self.draw_instrument = nil;
          if ($truthy(self.placeholders)) {
            } else {
            self.placeholders = $hash2([], {})
          };
          return self.$set_instrument_handlers();
        }, TMP_Default_initialize_110.$$arity = 0);
        
        Opal.defn(self, '$set_instrument_handlers', TMP_Default_set_instrument_handlers_122 = function $$set_instrument_handlers() {
          var TMP_111, TMP_112, TMP_113, TMP_114, TMP_115, TMP_116, TMP_117, TMP_118, TMP_119, TMP_120, self = this, xoffset = nil, xspacing = nil, pitchoffset = nil, $case = nil, pitches = nil, string_by_pitch = nil, flaps = nil, flaps_y = nil, flaps_by_pitch = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          xoffset = $gvars.conf['$[]']("layout.X_OFFSET");
          xspacing = $gvars.conf['$[]']("layout.X_SPACING");
          pitchoffset = $gvars.conf.$get("layout.PITCH_OFFSET");
          self.bottom_annotation_positions = [[150, 289], [325, 289], [380, 289]];
          self.pitch_to_xpos = $send(self, 'lambda', [], (TMP_111 = function(pitch){var self = TMP_111.$$s || this;
if (pitch == null) pitch = nil;
          return $rb_plus($rb_times($rb_plus(pitchoffset, pitch), xspacing), xoffset)}, TMP_111.$$s = self, TMP_111.$$arity = 1, TMP_111));
          return (function() {$case = $gvars.conf['$[]']("layout.instrument");
          if ("Zipino"['$===']($case)) {
          pitches = "54 55 57 59 60 62 64 66 67 69 71 72 74 76 78";
          string_by_pitch = Opal.const_get_relative($nesting, 'Hash')['$[]']($send(pitches.$split(" ").$each_with_index(), 'map', [], (TMP_112 = function(i, k){var self = TMP_112.$$s || this;
if (i == null) i = nil;if (k == null) k = nil;
          return [i.$to_i(), k]}, TMP_112.$$s = self, TMP_112.$$arity = 2, TMP_112)));
          self.pitch_to_xpos = $send(self, 'lambda', [], (TMP_113 = function(pitch){var self = TMP_113.$$s || this, pitch_to_stringpos = nil, result = nil;
if (pitch == null) pitch = nil;
          
            pitch_to_stringpos = string_by_pitch['$[]']($rb_plus(pitch, pitchoffset));
            result = 0;
            if ($truthy(pitch_to_stringpos['$nil?']())) {
              } else {
              result = $rb_plus($rb_times(pitch_to_stringpos, xspacing), xoffset)
            };
            return result;}, TMP_113.$$s = self, TMP_113.$$arity = 1, TMP_113));
          self.bottom_annotation_positions = [[xoffset, 287], [xoffset, 290], [$rb_plus(xoffset, 100), 290]];
          self.draw_instrument = $send(self, 'lambda', [], (TMP_114 = function(){var self = TMP_114.$$s || this, res = nil, $writer = nil;
            if ($gvars.conf == null) $gvars.conf = nil;

          
            res = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new([["M", $rb_plus(xoffset, 30), 20], ["L", $rb_plus(xoffset, 190), 100], ["M", $rb_plus(xoffset, 190), 200], ["L", $rb_plus(xoffset, 30), 281]], "open");
            
            $writer = [$gvars.conf.$get("layout.LINE_MEDIUM")];
            $send(res, 'line_width=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return [res];}, TMP_114.$$s = self, TMP_114.$$arity = 0, TMP_114));
          return (self.instrument_orientation = "horizontal");}
          else if ("saitenspiel"['$===']($case)) {
          self.pitch_to_xpos = $send(self, 'lambda', [], (TMP_115 = function(pitch){var self = TMP_115.$$s || this, pitch_to_stringpos = nil, result = nil;
if (pitch == null) pitch = nil;
          
            pitch_to_stringpos = Opal.const_get_relative($nesting, 'Hash')['$[]']([[31, 0], [36, 1], [38, 2], [40, 3], [41, 4], [43, 5], [45, 6], [47, 7], [48, 8], [50, 9]]);
            pitch_to_stringpos = pitch_to_stringpos['$[]']($rb_plus(pitch, pitchoffset));
            result = 0;
            if ($truthy(pitch_to_stringpos)) {
              result = $rb_plus($rb_times(pitch_to_stringpos, xspacing), xoffset)};
            return result;}, TMP_115.$$s = self, TMP_115.$$arity = 1, TMP_115));
          self.bottom_annotation_positions = [[xoffset, 287], [xoffset, 290], [$rb_plus(xoffset, 100), 290]];
          return (self.draw_instrument = $send(self, 'lambda', [], (TMP_116 = function(){var self = TMP_116.$$s || this, res = nil, $writer = nil;
            if ($gvars.conf == null) $gvars.conf = nil;

          
            res = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new([["M", $rb_plus(xoffset, 30), 6], ["L", $rb_plus(xoffset, 180), 81], ["L", $rb_plus(xoffset, 180), 216], ["L", $rb_plus(xoffset, 30), 291]], "open");
            
            $writer = [$gvars.conf.$get("layout.LINE_MEDIUM")];
            $send(res, 'line_width=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return [res];}, TMP_116.$$s = self, TMP_116.$$arity = 0, TMP_116)));}
          else if ("okon-f"['$===']($case) || "okon-g"['$===']($case) || "okon-c"['$===']($case) || "okon-d"['$===']($case)) {
          flaps = "";
          pitches = "";
          $case = $gvars.conf['$[]']("layout.instrument");
          if ("okon-f"['$===']($case)) {
          pitches = "55 57 58 60 62 64 65 67 69 70 72 74 76 77 79 81 82 84";
          flaps = "";}
          else if ("okon-g"['$===']($case)) {
          pitches = "55 57 59 60 62 64 66 67 69 71 72 74 76 78 79 81 83 84";
          flaps = "      59          66       71          78       83 ";}
          else if ("okon-c"['$===']($case)) {
          pitches = "55 57 59 60 62 64 65 67 69 71 72 74 76 77 79 81 83 84";
          flaps = "      59                   71                   83";}
          else if ("okon-d"['$===']($case)) {
          pitches = "55 57 59 61 62 64 66 67 69 71 73 74 76 78 79 81 83 85";
          flaps = "      59 61       66       71 73       78       83";};
          flaps_y = $hash(59, 7, 61, 7, 66, 7, 71, 7, 73, 20, 78, 65, 83, 110);
          string_by_pitch = Opal.const_get_relative($nesting, 'Hash')['$[]']($send(pitches.$split(" ").$each_with_index(), 'map', [], (TMP_117 = function(i, k){var self = TMP_117.$$s || this;
if (i == null) i = nil;if (k == null) k = nil;
          return [i.$to_i(), k]}, TMP_117.$$s = self, TMP_117.$$arity = 2, TMP_117)));
          flaps_by_pitch = $send(flaps.$split(" "), 'map', [], (TMP_118 = function(i){var self = TMP_118.$$s || this;
if (i == null) i = nil;
          return i.$to_i()}, TMP_118.$$s = self, TMP_118.$$arity = 1, TMP_118));
          self.pitch_to_xpos = $send(self, 'lambda', [], (TMP_119 = function(pitch){var self = TMP_119.$$s || this, pitch_to_stringpos = nil, result = nil;
if (pitch == null) pitch = nil;
          
            pitch_to_stringpos = string_by_pitch['$[]']($rb_plus(pitch, pitchoffset));
            result = 0;
            if ($truthy(pitch_to_stringpos)) {
              result = $rb_plus($rb_times(pitch_to_stringpos, xspacing), xoffset)};
            return result;}, TMP_119.$$s = self, TMP_119.$$arity = 1, TMP_119));
          self.bottom_annotation_positions = [[xoffset, 290], [$rb_plus(xoffset, 200), 290], [$rb_plus(xoffset, 270), 290]];
          return (self.draw_instrument = $send(self, 'lambda', [], (TMP_120 = function(){var self = TMP_120.$$s || this, TMP_121, result = nil, res = nil, $writer = nil;
            if ($gvars.conf == null) $gvars.conf = nil;

          
            result = [];
            $send(flaps_by_pitch, 'each', [], (TMP_121 = function(f){var self = TMP_121.$$s || this;
              if (self.pitch_to_xpos == null) self.pitch_to_xpos = nil;
if (f == null) f = nil;
            return result.$push(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new([self.pitch_to_xpos.$call(f), flaps_y['$[]'](f)], "*", "large"))}, TMP_121.$$s = self, TMP_121.$$arity = 1, TMP_121));
            res = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new([["M", $rb_minus(xoffset, 15), 280], ["L", $rb_minus(xoffset, 15), 0], ["M", $rb_plus(xoffset, 135), 0], ["L", $rb_plus(xoffset, 290), 157], ["L", $rb_plus(xoffset, 290), 280]], "open");
            
            $writer = [$gvars.conf.$get("layout.LINE_MEDIUM")];
            $send(res, 'line_width=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return result.$push(res);}, TMP_120.$$s = self, TMP_120.$$arity = 0, TMP_120)));}
          else if ("21-strings-a-f"['$===']($case)) {return (self.bottom_annotation_positions = [[190, 287], [190, 290], [250, 290]])}
          else if ("18-strings-b-e"['$===']($case)) {return (self.bottom_annotation_positions = [[210, 287], [210, 290], [280, 290]])}
          else { return nil }})();
        }, TMP_Default_set_instrument_handlers_122.$$arity = 0);
        
        Opal.defn(self, '$layout_images', TMP_Default_layout_images_125 = function $$layout_images(print_options_raw, print_variant_nr) {
          var TMP_123, self = this, result = nil, images = nil;

          
          result = [];
          images = print_options_raw['$[]']("images");
          if ($truthy(images['$nil?']())) {
            } else {
            $send(images, 'each', [], (TMP_123 = function(number, image){var self = TMP_123.$$s || this, TMP_124, datauri = nil;
              if ($gvars.resources == null) $gvars.resources = nil;
if (number == null) number = nil;if (image == null) image = nil;
            if (image['$[]']("show")['$=='](true)) {
                
                datauri = $gvars.resources['$[]'](image['$[]']("imagename"));
                if ($truthy(datauri['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
                  datauri = datauri.$join()};
                if ($truthy(datauri)) {
                  return result.$push($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Image').$new(datauri, $rb_minus(self.$Vector2d(image['$[]']("pos")), [0, image['$[]']("height")]), image['$[]']("height")), 'tap', [], (TMP_124 = function(s){var self = TMP_124.$$s || this, $writer = nil;
if (s == null) s = nil;
                  
                    
                    $writer = ["" + "extract." + (print_variant_nr) + ".images." + (number) + ".pos"];
                    $send(s, 'conf_key=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];;
                    
                    $writer = [image['$[]']("pos")];
                    $send(s, 'conf_value=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];;
                    
                    $writer = [$hash2(["handler"], {"handler": "annotation"})];
                    $send(s, 'draginfo=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];;}, TMP_124.$$s = self, TMP_124.$$arity = 1, TMP_124)))
                  } else {
                  return nil
                };
                } else {
                return nil
              }}, TMP_123.$$s = self, TMP_123.$$arity = 2, TMP_123))
          };
          return result;
        }, TMP_Default_layout_images_125.$$arity = 2);
        
        Opal.defn(self, '$layout_debug_grid', TMP_Default_layout_debug_grid_130 = function $$layout_debug_grid() {
          var TMP_126, TMP_127, TMP_128, TMP_129, self = this, the_options = nil, gridsize = nil, emphasis = nil, sheetsize = nil, result = nil;

          
          the_options = $hash2(["size", "emphasis", "line", "emphline"], {"size": 1, "emphasis": 10, "line": 0.02, "emphline": 0.2});
          gridsize = the_options['$[]']("size");
          emphasis = $rb_times(the_options['$[]']("emphasis"), gridsize);
          sheetsize = [420, 297];
          result = [];
          $send($send(Opal.Range.$new(0, $rb_divide(sheetsize.$first(), gridsize), false), 'map', [], (TMP_126 = function(g){var self = TMP_126.$$s || this;
if (g == null) g = nil;
          return $rb_times(g, gridsize)}, TMP_126.$$s = self, TMP_126.$$arity = 1, TMP_126)), 'each', [], (TMP_127 = function(g){var self = TMP_127.$$s || this, e = nil, $writer = nil;
if (g == null) g = nil;
          
            e = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new([["M", g, 0], ["l", 0, sheetsize.$last()]]);
            
            $writer = [the_options['$[]']("line")];
            $send(e, 'line_width=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if (g['$%'](emphasis)['$=='](0)) {
              
              $writer = [the_options['$[]']("emphline")];
              $send(e, 'line_width=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            return result['$<<'](e);}, TMP_127.$$s = self, TMP_127.$$arity = 1, TMP_127));
          $send($send(Opal.Range.$new(0, $rb_divide(sheetsize.$last(), gridsize), false), 'map', [], (TMP_128 = function(g){var self = TMP_128.$$s || this;
if (g == null) g = nil;
          return $rb_times(g, gridsize)}, TMP_128.$$s = self, TMP_128.$$arity = 1, TMP_128)), 'each', [], (TMP_129 = function(g){var self = TMP_129.$$s || this, e = nil, $writer = nil;
if (g == null) g = nil;
          
            e = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new([["M", 0, g], ["l", sheetsize.$first(), 0]]);
            
            $writer = [the_options['$[]']("line")];
            $send(e, 'line_width=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if (g['$%'](emphasis)['$=='](0)) {
              
              $writer = [the_options['$[]']("emphline")];
              $send(e, 'line_width=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            return result['$<<'](e);}, TMP_129.$$s = self, TMP_129.$$arity = 1, TMP_129));
          return result;
        }, TMP_Default_layout_debug_grid_130.$$arity = 0);
        
        Opal.defn(self, '$layout', TMP_Default_layout_153 = function $$layout(music, beat_layout, print_variant_nr, page_format) {
          var $a, TMP_131, TMP_132, TMP_133, TMP_134, TMP_135, TMP_136, TMP_139, TMP_140, TMP_142, TMP_144, TMP_145, TMP_146, TMP_147, TMP_150, TMP_152, self = this, print_options_raw = nil, print_options_hash = nil, layout_options = nil, debug_grid = nil, res_images = nil, beat_compression_map = nil, maximal_beat = nil, full_beat_spacing = nil, factor = nil, compressed_beat_layout_proc = nil, required_synchlines = nil, synched_notes = nil, active_voices = nil, voice_elements = nil, collisiondetector = nil, synch_lines = nil, sheet_marks = nil, delta = nil, annotations = nil, title = nil, filename = nil, meter = nil, key = nil, composer = nil, tempo = nil, print_variant_title = nil, title_pos = nil, title_align = nil, legend_pos = nil, legend = nil, style = nil, datestring = nil, lyrics = nil, lyric_text = nil, text = nil, verses = nil, sortmark_options = nil, e = nil, sheet_elements = nil, result = nil, $writer = nil;
          if ($gvars.conf == null) $gvars.conf = nil;
          if ($gvars.log == null) $gvars.log = nil;

          if (beat_layout == null) {
            beat_layout = nil;
          }
          if (print_variant_nr == null) {
            print_variant_nr = 0;
          }
          if (page_format == null) {
            page_format = "A4";
          }
          
          print_options_raw = self.$get_print_options(print_variant_nr);
          self.print_options_raw = print_options_raw;
          print_options_hash = print_options_raw.$get();
          layout_options = ($truthy($a = print_options_hash['$[]']("layout")) ? $a : $hash2([], {}));
          $gvars.conf.$push($hash2(["layout"], {"layout": layout_options}));
          $gvars.conf.$push($hash2(["printer"], {"printer": ($truthy($a = print_options_hash['$[]']("printer")) ? $a : $hash2([], {}))}));
          self.$initialize();
          debug_grid = [];
          if ($truthy($gvars.conf['$[]']("layout.grid"))) {
            debug_grid = self.$layout_debug_grid()};
          res_images = self.$layout_images(print_options_hash, print_variant_nr);
          self.layout_minc = ($truthy($a = print_options_raw['$[]']("notebound.minc")) ? $a : $hash2([], {}));
          self.y_offset = print_options_hash['$[]']("startpos");
          self.y_size = $gvars.conf.$get("layout.DRAWING_AREA_SIZE").$last();
          beat_compression_map = nil;
          $send($gvars.log, 'benchmark', ["compute beat compression map"], (TMP_131 = function(){var self = TMP_131.$$s || this, layoutlines = nil;

          
            layoutlines = $rb_plus(print_options_hash['$[]']("voices"), print_options_hash['$[]']("layoutlines").$uniq());
            return (beat_compression_map = self.$compute_beat_compression(music, layoutlines));}, TMP_131.$$s = self, TMP_131.$$arity = 0, TMP_131));
          maximal_beat = ($truthy($a = beat_compression_map.$values().$max()) ? $a : 0);
          full_beat_spacing = $rb_divide($rb_minus($gvars.conf.$get("layout.DRAWING_AREA_SIZE").$last(), self.y_offset), maximal_beat);
          if ($truthy($rb_lt(full_beat_spacing, self.beat_spacing))) {
            
            factor = $rb_divide(self.beat_spacing, full_beat_spacing);
            $gvars.log.$warning("" + "note distance too small (factor " + (factor) + ")");};
          self.beat_spacing = [full_beat_spacing, $rb_times($gvars.conf.$get("layout.packer.pack_max_spreadfactor"), self.beat_spacing)].$min();
          if ($truthy($gvars.conf.$get("layout.bottomup"))) {
            beat_layout = ($truthy($a = beat_layout) ? $a : $send(Opal.const_get_relative($nesting, 'Proc'), 'new', [], (TMP_132 = function(beat){var self = TMP_132.$$s || this, r = nil;
              if (self.y_size == null) self.y_size = nil;
              if (self.beat_spacing == null) self.beat_spacing = nil;
if (beat == null) beat = nil;
            return (r = self.y_size - beat * self.beat_spacing)}, TMP_132.$$s = self, TMP_132.$$arity = 1, TMP_132)))
            } else {
            beat_layout = ($truthy($a = beat_layout) ? $a : $send(Opal.const_get_relative($nesting, 'Proc'), 'new', [], (TMP_133 = function(beat){var self = TMP_133.$$s || this, r = nil;
              if (self.beat_spacing == null) self.beat_spacing = nil;
              if (self.y_offset == null) self.y_offset = nil;
if (beat == null) beat = nil;
            return (r = beat * self.beat_spacing + self.y_offset)}, TMP_133.$$s = self, TMP_133.$$arity = 1, TMP_133)))
          };
          compressed_beat_layout_proc = $send(Opal.const_get_relative($nesting, 'Proc'), 'new', [], (TMP_134 = function(beat){var self = TMP_134.$$s || this;
if (beat == null) beat = nil;
          return beat_layout.$call(beat_compression_map['$[]'](beat))}, TMP_134.$$s = self, TMP_134.$$arity = 1, TMP_134));
          required_synchlines = $send(print_options_hash['$[]']("synchlines"), 'select', [], (TMP_135 = function(sl){var self = TMP_135.$$s || this, $b;
if (sl == null) sl = nil;
          return ($truthy($b = print_options_hash['$[]']("voices")['$include?'](sl.$first())) ? print_options_hash['$[]']("voices")['$include?'](sl.$last()) : $b)}, TMP_135.$$s = self, TMP_135.$$arity = 1, TMP_135));
          synched_notes = [];
          $send($gvars.log, 'benchmark', ["build_syncpoints"], (TMP_136 = function(){var self = TMP_136.$$s || this, TMP_137;

          return (synched_notes = $send(required_synchlines, 'map', [], (TMP_137 = function(selector){var self = TMP_137.$$s || this, TMP_138, synch_points_to_show = nil;
if (selector == null) selector = nil;
            
              synch_points_to_show = music.$build_synch_points(selector);
              return $send(synch_points_to_show, 'map', [], (TMP_138 = function(sp){var self = TMP_138.$$s || this;
if (sp == null) sp = nil;
              return sp.$synched_notes()}, TMP_138.$$s = self, TMP_138.$$arity = 1, TMP_138));}, TMP_137.$$s = self, TMP_137.$$arity = 1, TMP_137)).$flatten())}, TMP_136.$$s = self, TMP_136.$$arity = 0, TMP_136));
          active_voices = print_options_hash['$[]']("voices");
          voice_elements = $send(music.$voices().$each_with_index(), 'map', [], (TMP_139 = function(v, index){var self = TMP_139.$$s || this, countnotes_options = nil, barnumbers_options = nil;
if (v == null) v = nil;if (index == null) index = nil;
          if ($truthy(active_voices['$include?'](index))) {
              
              countnotes_options = print_options_hash['$[]']("countnotes");
              if ($truthy(countnotes_options['$[]']("voices")['$include?'](index))) {
                } else {
                countnotes_options = nil
              };
              barnumbers_options = print_options_hash['$[]']("barnumbers");
              if ($truthy(barnumbers_options['$[]']("voices")['$include?'](index))) {
                } else {
                barnumbers_options = nil
              };
              return self.$layout_voice(v, compressed_beat_layout_proc, print_variant_nr, $hash2(["voice_nr", "nonflowrest", "flowline", "subflowline", "jumpline", "repeatsigns", "synched_notes", "countnotes", "barnumbers", "print_options_raw"], {"voice_nr": index, "nonflowrest": print_options_hash['$[]']("nonflowrest"), "flowline": print_options_hash['$[]']("flowlines")['$include?'](index), "subflowline": print_options_hash['$[]']("subflowlines")['$include?'](index), "jumpline": print_options_hash['$[]']("jumplines")['$include?'](index), "repeatsigns": print_options_hash['$[]']("repeatsigns"), "synched_notes": synched_notes, "countnotes": countnotes_options, "barnumbers": barnumbers_options, "print_options_raw": print_options_raw}));
              } else {
              return nil
            }}, TMP_139.$$s = self, TMP_139.$$arity = 2, TMP_139)).$flatten().$compact();
          if ($truthy($gvars.log['$loglevel?']("warning"))) {
            
            collisiondetector = Opal.const_get_relative($nesting, 'CollisionDetector').$new();
            collisiondetector.$check_annotations(voice_elements);};
          synch_lines = $send(required_synchlines, 'map', [], (TMP_140 = function(selector){var self = TMP_140.$$s || this, TMP_141, synch_points_to_show = nil;
if (selector == null) selector = nil;
          
            synch_points_to_show = music.$build_synch_points(selector);
            return $send(synch_points_to_show, 'map', [], (TMP_141 = function(sp){var self = TMP_141.$$s || this, res = nil, $writer = nil;
if (sp == null) sp = nil;
            
              res = Opal.const_get_relative($nesting, 'FlowLine').$new(sp.$notes().$first().$sheet_drawable(), sp.$notes().$last().$sheet_drawable(), "dashed");
              
              $writer = [self.$compute_color_by_variant_no(sp.$notes().$first().$variant())];
              $send(res, 'color=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              return res;}, TMP_141.$$s = self, TMP_141.$$arity = 1, TMP_141));}, TMP_140.$$s = self, TMP_140.$$arity = 1, TMP_140)).$flatten();
          sheet_marks = self.$layout_stringnames(print_options_hash, print_variant_nr);
          if ($truthy((($a = page_format['$==']("A4")) ? $rb_gt($gvars.conf['$[]']("printer.a4_pages").$length(), 1) : page_format['$==']("A4")))) {
            
            delta = $rb_times(12.0, $gvars.conf.$get("layout.X_SPACING"));
            $send($range(1, 2, false), 'each', [], (TMP_142 = function(i){var self = TMP_142.$$s || this, TMP_143;
if (i == null) i = nil;
            return $send([4, 290], 'each', [], (TMP_143 = function(y){var self = TMP_143.$$s || this;
                if ($gvars.conf == null) $gvars.conf = nil;
if (y == null) y = nil;
              return sheet_marks['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new([$rb_plus($rb_plus($rb_times(0.25, $gvars.conf.$get("layout.X_SPACING")), $gvars.conf.$get("layout.X_OFFSET")), $rb_times(delta, i)), y], "x", "small", nil))}, TMP_143.$$s = self, TMP_143.$$arity = 1, TMP_143))}, TMP_142.$$s = self, TMP_142.$$arity = 1, TMP_142));};
          annotations = [];
          title = ($truthy($a = music.$meta_data()['$[]']("title")) ? $a : "untitled");
          filename = music.$meta_data()['$[]']("filename");
          meter = music.$meta_data()['$[]']("meter");
          if ($truthy(meter)) {
            meter = meter.$last().$split("=").$first()};
          key = music.$meta_data()['$[]']("key");
          composer = music.$meta_data()['$[]']("composer");
          tempo = music.$meta_data()['$[]']("tempo_display");
          print_variant_title = print_options_hash['$[]']("title");
          title_pos = print_options_hash['$[]']("legend")['$[]']("pos");
          title_align = ($truthy($a = self.print_options_raw.$get("legend.align")) ? $a : "r");
          title_align = (function() {if ($truthy(title_align['$==']("l"))) {
            return "right"
            } else {
            return "left"
          }; return nil; })();
          legend_pos = print_options_hash['$[]']("legend")['$[]']("spos");
          legend = "" + (print_variant_title) + "\n" + (composer) + "\nTakt: " + (meter) + " (" + (tempo) + ")\nTonart: " + (key);
          style = ($truthy($a = self.print_options_raw.$get("legend.style")) ? $a : "regular");
          annotations['$<<']($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(title_pos, title, "large", nil, "" + "extract." + (print_variant_nr) + ".legend.pos", title_pos), 'tap', [], (TMP_144 = function(s){var self = TMP_144.$$s || this, $writer = nil;
if (s == null) s = nil;
          
            
            $writer = [$hash2(["handler"], {"handler": "annotation"})];
            $send(s, 'draginfo=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [title_align];
            $send(s, 'align=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}, TMP_144.$$s = self, TMP_144.$$arity = 1, TMP_144)));
          if ($truthy(print_options_raw['$[]']("notes.T06_legend")['$nil?']())) {
            annotations['$<<']($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(legend_pos, legend, style, nil, "" + "extract." + (print_variant_nr) + ".legend.spos", legend_pos), 'tap', [], (TMP_145 = function(s){var self = TMP_145.$$s || this, $writer = nil;
if (s == null) s = nil;
            
              $writer = [$hash2(["handler"], {"handler": "annotation"})];
              $send(s, 'draginfo=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, TMP_145.$$s = self, TMP_145.$$arity = 1, TMP_145)))};
          datestring = Opal.const_get_relative($nesting, 'Time').$now().$strftime("%Y-%m-%d %H:%M:%S");
          annotations['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(self.bottom_annotation_positions['$[]'](0), "" + (filename) + " - created " + (datestring) + " by Zupfnoter " + (Opal.const_get_relative($nesting, 'VERSION')) + " [" + (self.uri['$[]']("hostname")) + "]", "smaller"));
          annotations['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(self.bottom_annotation_positions['$[]'](1), "Zupfnoter: https://www.zupfnoter.de", "smaller"));
          annotations['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(self.bottom_annotation_positions['$[]'](2), music.$checksum(), "smaller"));
          lyrics = print_options_hash['$[]']("lyrics");
          lyric_text = music.$harpnote_options()['$[]']("lyrics")['$[]']("text");
          if ($truthy(lyric_text)) {
            
            text = lyric_text.$join("\n");
            if ($truthy(lyrics)) {
              
              verses = $send(text.$gsub("\t", " ").$squeeze(" ").$split(/\n\n+/), 'map', [], (TMP_146 = function(i){var self = TMP_146.$$s || this;
if (i == null) i = nil;
              return i.$strip()}, TMP_146.$$s = self, TMP_146.$$arity = 1, TMP_146));
              lyrics.$delete("versepos");
              $send(lyrics, 'each', [], (TMP_147 = function(key, entry){var self = TMP_147.$$s || this, $b, TMP_148, TMP_149, pos = nil, the_text = nil, conf_key = nil, conf_base = nil;
                if (self.print_options_raw == null) self.print_options_raw = nil;
if (key == null) key = nil;if (entry == null) entry = nil;
              
                pos = entry['$[]']("pos");
                the_text = $send(($truthy($b = entry['$[]']("verses")) ? $b : []), 'map', [], (TMP_148 = function(i){var self = TMP_148.$$s || this, j = nil;
if (i == null) i = nil;
                
                  if (i['$=='](0)) {
                    j = 9999};
                  if ($truthy($rb_lt(i, 0))) {
                    j = i};
                  if ($truthy($rb_gt(i, 0))) {
                    j = $rb_minus(i, 1)};
                  return verses['$[]'](j);}, TMP_148.$$s = self, TMP_148.$$arity = 1, TMP_148)).$join("\n\n");
                conf_key = "" + "lyrics." + (key);
                conf_base = "" + "extract." + (print_variant_nr) + "." + (conf_key);
                style = ($truthy($b = self.print_options_raw.$get("" + (conf_key) + ".style")) ? $b : "regular");
                return annotations['$<<']($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(pos, the_text, style, nil, "" + (conf_base) + ".pos", pos), 'tap', [], (TMP_149 = function(s){var self = TMP_149.$$s || this, $writer = nil;
if (s == null) s = nil;
                
                  $writer = [$hash2(["handler"], {"handler": "annotation"})];
                  $send(s, 'draginfo=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];}, TMP_149.$$s = self, TMP_149.$$arity = 1, TMP_149)));}, TMP_147.$$s = self, TMP_147.$$arity = 2, TMP_147));};};
          sortmark_options = print_options_hash['$[]']("sortmark");
          if ($truthy(sortmark_options['$[]']("show"))) {
            sheet_marks['$<<'](self.$layout_sortmark(title, sortmark_options))};
          
          try {
            $send(print_options_hash['$[]']("notes"), 'each', [], (TMP_150 = function(k, note){var self = TMP_150.$$s || this, $b, TMP_151, conf_key = nil, align = nil;
if (k == null) k = nil;if (note == null) note = nil;
            
              conf_key = "" + "extract." + (print_variant_nr) + ".notes." + (k);
              align = ($truthy($b = note['$[]']("align")) ? $b : "r");
              align = (function() {if ($truthy(align['$==']("r"))) {
                return "left"
                } else {
                return "right"
              }; return nil; })();
              if ($truthy(note['$[]']("pos"))) {
                } else {
                self.$raise("" + (Opal.const_get_relative($nesting, 'I18n').$t("missing pos")) + " in " + (conf_key))
              };
              if ($truthy(note['$[]']("text"))) {
                } else {
                self.$raise("" + (Opal.const_get_relative($nesting, 'I18n').$t("missing text")) + " in " + (conf_key))
              };
              return annotations['$<<']($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(note['$[]']("pos"), self.$resolve_placeholder(note['$[]']("text"), conf_key), note['$[]']("style"), nil, "" + (conf_key) + ".pos", note['$[]']("pos")), 'tap', [], (TMP_151 = function(s){var self = TMP_151.$$s || this, $writer = nil;
if (s == null) s = nil;
              
                
                $writer = [align];
                $send(s, 'align=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                
                $writer = [$hash2(["handler"], {"handler": "annotation"})];
                $send(s, 'draginfo=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];;}, TMP_151.$$s = self, TMP_151.$$arity = 1, TMP_151)));}, TMP_150.$$s = self, TMP_150.$$arity = 2, TMP_150))
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
              try {
                $gvars.log.$error(e.$message())
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };;
          if ($truthy(self.draw_instrument)) {
            $send(self.draw_instrument.$call(), 'each', [], (TMP_152 = function(r){var self = TMP_152.$$s || this;
if (r == null) r = nil;
            return sheet_marks.$push(r)}, TMP_152.$$s = self, TMP_152.$$arity = 1, TMP_152))};
          sheet_elements = $rb_plus($rb_plus($rb_plus($rb_plus($rb_plus(res_images, debug_grid), synch_lines), voice_elements), annotations), sheet_marks);
          result = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Sheet').$new(sheet_elements, active_voices);
          
          $writer = [$gvars.conf['$[]']("printer")];
          $send(result, 'printer_config=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          $gvars.conf.$pop();
          $gvars.conf.$pop();
          return result;
        }, TMP_Default_layout_153.$$arity = -2);
        
        Opal.defn(self, '$get_print_options', TMP_Default_get_print_options_154 = function $$get_print_options(print_variant_nr) {
          var self = this, print_options_raw = nil, $writer = nil, song_print_options = nil;
          if ($gvars.conf == null) $gvars.conf = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          print_options_raw = Opal.const_get_relative($nesting, 'Confstack').$new();
          
          $writer = [false];
          $send(print_options_raw, 'strict=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          print_options_raw.$push($gvars.conf.$get("extract.0"));
          song_print_options = $gvars.conf.$get("" + "extract." + (print_variant_nr));
          if ($truthy(song_print_options)) {
            print_options_raw.$push(song_print_options)
            } else {
            $gvars.log.$warning("" + "selected print variant [" + (print_variant_nr) + "] not available using [0]: '" + (print_options_raw.$get("title")) + "'")
          };
          if ($truthy(print_options_raw['$[]']("layout.beams"))) {
            print_options_raw.$push($hash2(["layout"], {"layout": $hash2(["DURATION_TO_STYLE"], {"DURATION_TO_STYLE": $gvars.conf['$[]']("layout.DURATION_TO_BEAMS")})}))};
          return print_options_raw;
        }, TMP_Default_get_print_options_154.$$arity = 1);
        
        Opal.defn(self, '$layout_sortmark', TMP_Default_layout_sortmark_156 = function $$layout_sortmark(title, options) {
          var TMP_155, $a, $b, self = this, sortname = nil, b = nil, a = nil, w = nil, h = nil, fill = nil, markpos = nil, markpath = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          sortname = title.$upcase().$gsub(/[ÄÖÜYZß]/, $hash2(["Ä", "Ö", "Ü", "ß", "Y", "Z"], {"Ä": "AE", "Ö": "OE", "Ü": "UE", "ß": "ss", "Y": "X", "Z": "X"})).$gsub(/[^A-Za-z]/, "");
          b = $send($rb_plus(sortname, "AAAA").$split(""), 'map', [], (TMP_155 = function(i){var self = TMP_155.$$s || this;
if (i == null) i = nil;
          return $rb_minus(i.$ord(), "A".$ord())}, TMP_155.$$s = self, TMP_155.$$arity = 1, TMP_155));
          a = $rb_plus(b['$[]'](0), $rb_divide($rb_times($rb_plus($rb_plus($rb_times(0.1, b['$[]'](1)), $rb_times(0.01, b['$[]'](2))), $rb_times(0.001, b['$[]'](3))), 0.5), 2.4));
          $b = options['$[]']("size"), $a = Opal.to_ary($b), (w = ($a[0] == null ? nil : $a[0])), (h = ($a[1] == null ? nil : $a[1])), $b;
          fill = (function() {if ($truthy(options['$[]']("fill"))) {
            return "filled"
            } else {
            return "open"
          }; return nil; })();
          markpos = $rb_times($rb_plus(12.5, a), $gvars.conf.$get("layout.X_SPACING"));
          markpath = [["M", markpos, 0], ["l", $rb_divide(w['$-@'](), 2), h], ["l", w, 0], ["l", $rb_divide(w['$-@'](), 2), h['$-@']()], ["l", 0, h], ["l", 0, h['$-@']()], ["z"]];
          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(markpath, fill);
        }, TMP_Default_layout_sortmark_156.$$arity = 2);
        
        Opal.defn(self, '$layout_stringnames', TMP_Default_layout_stringnames_161 = function $$layout_stringnames(print_options_hash, print_variant_nr) {
          var TMP_157, TMP_159, self = this, vpos = nil, marks = nil, conf_key = nil, sheet_marks = nil, no_of_names = nil, scale = nil, start_scale = nil, end_scale = nil, style = nil, x_spacing = nil, x_offset = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          vpos = print_options_hash['$[]']("stringnames")['$[]']("vpos");
          marks = print_options_hash['$[]']("stringnames")['$[]']("marks")['$[]']("hpos");
          conf_key = "stringnames";
          sheet_marks = [];
          if ($truthy(marks['$empty?']())) {
            } else {
            sheet_marks = $rb_plus(sheet_marks, $send(marks, 'inject', [[]], (TMP_157 = function(result, pitch){var self = TMP_157.$$s || this, TMP_158;
if (result == null) result = nil;if (pitch == null) pitch = nil;
            
              $send(print_options_hash['$[]']("stringnames")['$[]']("marks")['$[]']("vpos"), 'each', [], (TMP_158 = function(mark_vpos){var self = TMP_158.$$s || this, markpath = nil;
                if (self.pitch_to_xpos == null) self.pitch_to_xpos = nil;
if (mark_vpos == null) mark_vpos = nil;
              
                markpath = self.$make_sheetmark_path([self.pitch_to_xpos.$call(pitch), mark_vpos]);
                return result['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(markpath, "filled"));}, TMP_158.$$s = self, TMP_158.$$arity = 1, TMP_158));
              return result;}, TMP_157.$$s = self, TMP_157.$$arity = 2, TMP_157)))
          };
          if ($truthy(vpos['$empty?']())) {
            } else {
            
            no_of_names = 37;
            scale = print_options_hash['$[]']("stringnames")['$[]']("text").$split(" ");
            scale = $rb_times(scale, $rb_plus($rb_divide(no_of_names, scale.$length()), 1));
            start_scale = $gvars.conf.$get("layout.PITCH_OFFSET")['$-@']();
            end_scale = $rb_minus($rb_plus(start_scale, no_of_names), 1);
            vpos = print_options_hash['$[]']("stringnames")['$[]']("vpos");
            style = print_options_hash['$[]']("stringnames")['$[]']("style");
            x_spacing = $gvars.conf.$get("layout.X_SPACING");
            x_offset = $rb_minus($gvars.conf.$get("layout.X_OFFSET"), 1);
            sheet_marks = $rb_plus(sheet_marks, $send(Opal.Range.$new(start_scale, end_scale, false).$to_a(), 'inject', [[]], (TMP_159 = function(result, pitch){var self = TMP_159.$$s || this, TMP_160, x = nil;
if (result == null) result = nil;if (pitch == null) pitch = nil;
            
              x = $rb_plus($rb_times($rb_plus(start_scale['$-@'](), pitch), x_spacing), x_offset);
              $send(vpos, 'each', [], (TMP_160 = function(vpos){var self = TMP_160.$$s || this;
if (vpos == null) vpos = nil;
              return result['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new([x, vpos], scale['$[]']($rb_minus(pitch, start_scale)), style, nil, conf_key))}, TMP_160.$$s = self, TMP_160.$$arity = 1, TMP_160));
              return result;}, TMP_159.$$s = self, TMP_159.$$arity = 2, TMP_159)));
          };
          return sheet_marks;
        }, TMP_Default_layout_stringnames_161.$$arity = 2);
        Opal.const_set($nesting[0], 'NOTE_POSITION_LOOKUP', $hash2(["11", "12", "13", "21", "22", "23", "31", "32", "33"], {"11": ["r", "r"], "12": ["r", "l"], "13": ["r", "l"], "21": ["r", "r"], "22": ["r", "l"], "23": ["l", "l"], "31": ["l", "r"], "32": ["l", "r"], "33": ["l", "l"]}));
        
        Opal.defn(self, '$compute_note_position', TMP_Default_compute_note_position_162 = function $$compute_note_position(xp, x, xn, limit_a3) {
          var $a, self = this, a = nil, b = nil;

          
          a = $rb_plus(xp['$<=>'](x), 2);
          b = $rb_plus(xn['$<=>'](x), 2);
          if ($truthy(($truthy($a = limit_a3) ? $rb_lt(x, 10) : $a))) {
            return ["r", "r"]
          } else if ($truthy(($truthy($a = limit_a3) ? $rb_gt(x, 410) : $a))) {
            return ["l", "l"]
            } else {
            return Opal.const_get_relative($nesting, 'NOTE_POSITION_LOOKUP')['$[]']("" + (a) + (b))
          };
        }, TMP_Default_compute_note_position_162.$$arity = 4);
        
        Opal.defn(self, '$layout_voice', TMP_Default_layout_voice_193 = function $$layout_voice(voice, beat_layout, print_variant_nr, show_options) {
          var TMP_163, TMP_164, TMP_165, $a, $b, TMP_166, TMP_167, TMP_168, TMP_170, TMP_171, TMP_172, TMP_177, TMP_184, TMP_185, TMP_187, TMP_188, TMP_189, TMP_190, TMP_191, self = this, voice_nr = nil, playables = nil, previous_note = nil, res_decorations = nil, res_playables = nil, res_barnumbers = nil, res_countnotes = nil, do_flowconf = nil, default_tuplet_options = nil, flowlines_conf_key = nil, flowlines_conf = nil, res_flow = nil, res_sub_flow = nil, tuplet_start = nil, tuplet_notes = nil, res_tuplets = nil, $writer = nil, tie_start = nil, res_slurs = nil, res_gotos = nil, color_default = nil, res_repeatmarks = nil, res_annotations = nil;
          if ($gvars.log == null) $gvars.log = nil;
          if ($gvars.settings == null) $gvars.settings = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          self.print_options_keys = self.print_options_raw.$keys();
          voice_nr = show_options['$[]']("voice_nr");
          playables = $send(voice, 'select', [], (TMP_163 = function(c){var self = TMP_163.$$s || this;
if (c == null) c = nil;
          return c['$is_a?'](Opal.const_get_relative($nesting, 'Playable'))}, TMP_163.$$s = self, TMP_163.$$arity = 1, TMP_163));
          if ($truthy(show_options['$[]']("nonflowrest"))) {
            } else {
            
            previous_note = nil;
            $send(playables, 'each', [], (TMP_164 = function(c){var self = TMP_164.$$s || this, $a, $b, $writer = nil;
if (c == null) c = nil;
            
              if ($truthy(($truthy($a = c['$is_a?'](Opal.const_get_relative($nesting, 'Pause'))) ? show_options['$[]']("flowline")['$!']() : $a))) {
                
                $writer = [false];
                $send(c, 'visible=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
              if ($truthy(($truthy($a = ($truthy($b = c['$is_a?'](Opal.const_get_relative($nesting, 'Pause'))) ? show_options['$[]']("subflowline")['$!']() : $b)) ? show_options['$[]']("flowline")['$!']() : $a))) {
                
                $writer = [false];
                $send(c, 'visible=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
              if ($truthy(($truthy($a = ($truthy($b = show_options['$[]']("flowline")['$!']()) ? c.$visible() : $b)) ? show_options['$[]']("synched_notes")['$include?'](c.$proxy_note())['$!']() : $a))) {
                if ($truthy(previous_note['$nil?']())) {
                  } else {
                  
                  $writer = [true];
                  $send(previous_note, 'visible=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];
                }};
              return (previous_note = c);}, TMP_164.$$s = self, TMP_164.$$arity = 1, TMP_164));
          };
          res_decorations = [];
          res_playables = $send(playables, 'map', [], (TMP_165 = function(playable){var self = TMP_165.$$s || this, note_conf_base_tail = nil, note_conf_base = nil, result = nil, decoration_root = nil;
if (playable == null) playable = nil;
          
            note_conf_base_tail = "" + "notebound.nconf.v_" + (voice_nr) + ".t_" + (playable.$time());
            note_conf_base = "" + "extract." + (print_variant_nr) + "." + (note_conf_base_tail);
            result = self.$layout_playable(playable, beat_layout, note_conf_base);
            decoration_root = result.$proxy();
            res_decorations.$push((function() {if ($truthy(playable.$decorations()['$empty?']())) {
              return []
              } else {
              return self.$make_decorations_per_playable(playable, decoration_root, print_variant_nr, show_options, voice_nr)
            }; return nil; })());
            decoration_root.$more_conf_keys().$push($hash2(["conf_key", "text", "icon", "value"], {"conf_key": "" + (decoration_root.$conf_key().$gsub(/\.[^\.]+$/, "")) + ".nshift", "text": Opal.const_get_relative($nesting, 'I18n').$t("shift left"), "icon": "fa fa-arrow-left", "value": -0.5}));
            decoration_root.$more_conf_keys().$push($hash2(["conf_key", "text", "icon", "value"], {"conf_key": "" + (decoration_root.$conf_key().$gsub(/\.[^\.]+$/, "")) + ".nshift", "text": Opal.const_get_relative($nesting, 'I18n').$t("shift right"), "icon": "fa fa-arrow-right", "value": 0.5}));
            decoration_root.$more_conf_keys().$push($hash2(["text", "icon", "value"], {"text": "---", "icon": "fa fa-arrows-v", "value": 0.5}));
            decoration_root.$more_conf_keys().$push($hash2(["conf_key", "text", "icon"], {"conf_key": "" + "extract." + (print_variant_nr) + ".notebound.minc." + (playable.$time()) + ".minc_f", "text": Opal.const_get_relative($nesting, 'I18n').$t("Edit Minc"), "icon": "fa fa-arrows-v"}));
            decoration_root.$more_conf_keys().$push($hash2(["conf_key", "text", "icon", "value"], {"conf_key": "" + "extract." + (print_variant_nr) + ".notebound.minc." + (playable.$time()) + ".minc_f", "text": Opal.const_get_relative($nesting, 'I18n').$t("increase Minc"), "icon": "fa fa-arrow-down", "value": 0.5}));
            decoration_root.$more_conf_keys().$push($hash2(["conf_key", "text", "icon", "value"], {"conf_key": "" + "extract." + (print_variant_nr) + ".notebound.minc." + (playable.$time()) + ".minc_f", "text": Opal.const_get_relative($nesting, 'I18n').$t("decrease Minc"), "icon": "fa fa-arrow-up", "value": -0.5}));
            return result.$shapes();}, TMP_165.$$s = self, TMP_165.$$arity = 1, TMP_165)).$flatten().$compact();
          res_decorations = res_decorations.$flatten().$compact();
          $b = $send($gvars.log, 'benchmark', ["countnotes / barnumbers"], (TMP_166 = function(){var self = TMP_166.$$s || this;

          return self.$layout_barnumbers_countnotes(playables, print_variant_nr, show_options, voice_nr)}, TMP_166.$$s = self, TMP_166.$$arity = 0, TMP_166)), $a = Opal.to_ary($b), (res_barnumbers = ($a[0] == null ? nil : $a[0])), (res_countnotes = ($a[1] == null ? nil : $a[1])), $b;
          previous_note = nil;
          do_flowconf = $gvars.settings['$[]']("flowconf")['$==']("true");
          default_tuplet_options = $gvars.conf['$[]']("defaults.notebound.flowline");
          flowlines_conf_key = "" + "notebound.flowline.v_" + (voice_nr);
          flowlines_conf = ($truthy($a = show_options['$[]']("print_options_raw")['$[]'](flowlines_conf_key)) ? $a : $hash2([], {}));
          res_flow = $send($send(voice, 'select', [], (TMP_167 = function(c){var self = TMP_167.$$s || this;
if (c == null) c = nil;
          return c['$is_a?'](Opal.const_get_relative($nesting, 'Playable'))}, TMP_167.$$s = self, TMP_167.$$arity = 1, TMP_167)), 'map', [], (TMP_168 = function(playable){var self = TMP_168.$$s || this, $c, $d, TMP_169, res = nil, flowline_conf_key = nil, conf_from_options = nil, conf_key = nil, conf_key_edit = nil, p1 = nil, p2 = nil, tuplet_options = nil, tiepath = nil, bezier_anchor = nil, cp1 = nil, cp2 = nil, draginfo = nil, $writer = nil;
            if ($gvars.conf == null) $gvars.conf = nil;
if (playable == null) playable = nil;
          
            res = nil;
            if ($truthy(previous_note['$nil?']())) {
              } else {
              
              if ($truthy(true)) {
                
                flowline_conf_key = "" + (playable.$znid());
                conf_from_options = flowlines_conf['$[]'](flowline_conf_key);
                if ($truthy(($truthy($c = conf_from_options) ? $c : do_flowconf['$=='](true)))) {
                  
                  conf_key = "" + "extract." + (print_variant_nr) + "." + (flowlines_conf_key) + "." + (flowline_conf_key);
                  conf_key_edit = $rb_plus(conf_key, ".*");
                  p1 = self.$Vector2d(previous_note.$sheet_drawable().$center());
                  p2 = self.$Vector2d(playable.$sheet_drawable().$center());
                  tuplet_options = Opal.const_get_relative($nesting, 'Confstack').$new();
                  tuplet_options.$push(default_tuplet_options);
                  try {
                    tuplet_options.$push(conf_from_options)
                  } catch ($err) {
                    if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
                      try {
                        nil
                      } finally { Opal.pop_exception() }
                    } else { throw $err; }
                  };
                  $d = self.$make_annotated_bezier_path([p1, p2], tuplet_options), $c = Opal.to_ary($d), (tiepath = ($c[0] == null ? nil : $c[0])), (bezier_anchor = ($c[1] == null ? nil : $c[1])), (cp1 = ($c[2] == null ? nil : $c[2])), (cp2 = ($c[3] == null ? nil : $c[3])), $d;
                  if (do_flowconf['$=='](true)) {
                    draginfo = $hash2(["handler", "p1", "p2", "cp1", "cp2", "mp", "tuplet_options", "conf_key", "callback"], {"handler": "tuplet", "p1": p1.$to_a(), "p2": p2.$to_a(), "cp1": cp1.$to_a(), "cp2": cp2.$to_a(), "mp": bezier_anchor, "tuplet_options": tuplet_options, "conf_key": conf_key, "callback": nil})
                    } else {
                    draginfo = nil
                  };
                  res = $send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(tiepath), 'tap', [], (TMP_169 = function(d){var self = TMP_169.$$s || this, $writer = nil;
if (d == null) d = nil;
                  
                    
                    $writer = [conf_key_edit];
                    $send(d, 'conf_key=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];;
                    
                    $writer = [draginfo];
                    $send(d, 'draginfo=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];;}, TMP_169.$$s = self, TMP_169.$$arity = 1, TMP_169));
                  } else {
                  res = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'FlowLine').$new(previous_note.$sheet_drawable(), playable.$sheet_drawable())
                };};
              
              $writer = [$gvars.conf.$get("layout.LINE_MEDIUM")];
              $send(res, 'line_width=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              if ($truthy(previous_note['$visible?']())) {
                } else {
                res = nil
              };
            };
            if ($truthy(playable['$first_in_part?']())) {
              res = nil};
            if ($truthy(playable['$visible?']())) {
              } else {
              res = nil
            };
            previous_note = playable;
            return res;}, TMP_168.$$s = self, TMP_168.$$arity = 1, TMP_168)).$compact();
          previous_note = nil;
          res_sub_flow = $send($send(voice, 'select', [], (TMP_170 = function(c){var self = TMP_170.$$s || this, $c;
if (c == null) c = nil;
          return ($truthy($c = c['$is_a?'](Opal.const_get_relative($nesting, 'Playable'))) ? $c : c['$is_a?'](Opal.const_get_relative($nesting, 'SynchPoint')))}, TMP_170.$$s = self, TMP_170.$$arity = 1, TMP_170)), 'map', [], (TMP_171 = function(playable){var self = TMP_171.$$s || this, $c, $d, res = nil;
if (playable == null) playable = nil;
          
            if ($truthy(show_options['$[]']("synched_notes")['$include?'](playable.$proxy_note()))) {
              } else {
              
              res = nil;
              if ($truthy(($truthy($c = ($truthy($d = previous_note['$nil?']()['$!']()) ? previous_note.$visible() : $d)) ? playable.$visible() : $c))) {
                res = Opal.const_get_relative($nesting, 'FlowLine').$new(previous_note.$sheet_drawable(), playable.$sheet_drawable(), "dotted")};
              if ($truthy(playable['$first_in_part?']())) {
                res = nil};
            };
            previous_note = playable;
            return res;}, TMP_171.$$s = self, TMP_171.$$arity = 1, TMP_171)).$compact();
          if ($truthy(show_options['$[]']("subflowline"))) {
            } else {
            res_sub_flow = []
          };
          if ($truthy(show_options['$[]']("flowline"))) {
            } else {
            res_flow = []
          };
          if ($truthy(show_options['$[]']("countnotes"))) {
            } else {
            res_countnotes = []
          };
          if ($truthy(show_options['$[]']("barnumbers"))) {
            } else {
            res_barnumbers = []
          };
          tuplet_start = playables.$first();
          tuplet_notes = [];
          res_tuplets = $send(playables, 'inject', [[]], (TMP_172 = function(result, playable){var self = TMP_172.$$s || this, $c, $d, TMP_173, TMP_174, TMP_175, TMP_176, tuplet_conf_key = nil, conf_key = nil, conf_key_pos = nil, tuplet_options = nil, p1 = nil, p2 = nil, tiepath = nil, bezier_anchor = nil, cp1 = nil, cp2 = nil, pos_from_conf = nil, configured_anchor = nil, conf_value = nil, shape_drag_callback = nil, conf_key_edit = nil, style = nil, draginfo = nil, text = nil;
            if ($gvars.conf == null) $gvars.conf = nil;
if (result == null) result = nil;if (playable == null) playable = nil;
          
            if ($truthy(playable['$tuplet_start?']())) {
              tuplet_start = playable};
            if ($truthy(tuplet_start)) {
              tuplet_notes.$push(playable.$time())};
            if ($truthy(playable['$tuplet_end?']())) {
              
              tuplet_conf_key = "" + "notebound.tuplet.v_" + (voice_nr) + "." + (tuplet_start.$znid());
              conf_key = "" + "extract." + (print_variant_nr) + "." + (tuplet_conf_key);
              conf_key_pos = "pos";
              tuplet_options = Opal.const_get_relative($nesting, 'Confstack').$new();
              tuplet_options.$push($gvars.conf['$[]']("defaults.notebound.tuplet"));
              try {
                tuplet_options.$push(show_options['$[]']("print_options_raw")['$[]'](tuplet_conf_key))
              } catch ($err) {
                if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
                  try {
                    nil
                  } finally { Opal.pop_exception() }
                } else { throw $err; }
              };
              p1 = self.$Vector2d(tuplet_start.$sheet_drawable().$center());
              p2 = self.$Vector2d(playable.$sheet_drawable().$center());
              $d = self.$make_annotated_bezier_path([p1, p2], tuplet_options), $c = Opal.to_ary($d), (tiepath = ($c[0] == null ? nil : $c[0])), (bezier_anchor = ($c[1] == null ? nil : $c[1])), (cp1 = ($c[2] == null ? nil : $c[2])), (cp2 = ($c[3] == null ? nil : $c[3])), $d;
              pos_from_conf = (function() { try {
                return tuplet_options['$[]']("pos")
              } catch ($err) {
                if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
                  try {
                    return [0, 0]
                  } finally { Opal.pop_exception() }
                } else { throw $err; }
              }})();
              configured_anchor = $rb_plus(bezier_anchor, pos_from_conf);
              conf_value = $send($rb_minus(configured_anchor, bezier_anchor).$to_a(), 'map', [], (TMP_173 = function(i){var self = TMP_173.$$s || this;
if (i == null) i = nil;
              return i.$round(0)}, TMP_173.$$s = self, TMP_173.$$arity = 1, TMP_173));
              shape_drag_callback = $send(self, 'lambda', [], (TMP_174 = function(the_tuplet_options){var self = TMP_174.$$s || this;
if (the_tuplet_options == null) the_tuplet_options = nil;
              return nil}, TMP_174.$$s = self, TMP_174.$$arity = 1, TMP_174));
              if (tuplet_options['$[]']("show")['$=='](false)) {
                } else {
                
                conf_key_edit = $rb_plus(conf_key, ".*");
                style = ($truthy($c = show_options['$[]']("print_options_raw")['$[]']("tuplets.style")) ? $c : "small");
                draginfo = $hash2(["handler", "p1", "p2", "cp1", "cp2", "mp", "tuplet_options", "conf_key", "callback"], {"handler": "tuplet", "p1": p1.$to_a(), "p2": p2.$to_a(), "cp1": cp1.$to_a(), "cp2": cp2.$to_a(), "mp": bezier_anchor, "tuplet_options": tuplet_options, "conf_key": conf_key, "callback": shape_drag_callback});
                text = ($truthy($c = show_options['$[]']("print_options_raw")['$[]']("tuplets.text")) ? $c : playable.$tuplet().$to_s());
                text = text.$gsub("{{tuplet}}", playable.$tuplet().$to_s());
                result.$push($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(tiepath), 'tap', [], (TMP_175 = function(d){var self = TMP_175.$$s || this, $writer = nil;
                  if ($gvars.conf == null) $gvars.conf = nil;
if (d == null) d = nil;
                
                  
                  $writer = [conf_key_edit];
                  $send(d, 'conf_key=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = [$gvars.conf.$get("layout.LINE_THIN")];
                  $send(d, 'line_width=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = [draginfo];
                  $send(d, 'draginfo=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];;}, TMP_175.$$s = self, TMP_175.$$arity = 1, TMP_175)));
                result.$push($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(configured_anchor.$to_a(), text, style, tuplet_start.$origin(), $rb_plus(conf_key, "" + "." + (conf_key_pos)), conf_value.$to_a()), 'tap', [], (TMP_176 = function(s){var self = TMP_176.$$s || this, $writer = nil;
if (s == null) s = nil;
                
                  $writer = [$hash2(["handler"], {"handler": "annotation"})];
                  $send(s, 'draginfo=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];}, TMP_176.$$s = self, TMP_176.$$arity = 1, TMP_176)));
              };
              tuplet_notes = [];
              tuplet_start = nil;};
            return result;}, TMP_172.$$s = self, TMP_172.$$arity = 2, TMP_172));
          
          $writer = ["first_playable", playables.$first()];
          $send(self.slur_index, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          tie_start = playables.$first();
          res_slurs = $send(playables, 'inject', [[]], (TMP_177 = function(result, playable){var self = TMP_177.$$s || this, TMP_178, TMP_179, TMP_181, TMP_182, p1 = nil, p2 = nil, tiepath = nil;
            if (self.slur_index == null) self.slur_index = nil;
            if ($gvars.conf == null) $gvars.conf = nil;
if (result == null) result = nil;if (playable == null) playable = nil;
          
            if ($truthy(playable['$tie_end?']())) {
              
              p1 = $rb_plus(self.$Vector2d(tie_start.$sheet_drawable().$center()), [3, 0]);
              p2 = $rb_plus(self.$Vector2d(playable.$sheet_drawable().$center()), [3, 0]);
              tiepath = (function() {if ($truthy($gvars.conf['$[]']("layout.bottomup"))) {
                return self.$make_slur_path(p2, p1)
                } else {
                return self.$make_slur_path(p1, p2)
              }; return nil; })();
              result.$push($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(tiepath), 'tap', [], (TMP_178 = function(d){var self = TMP_178.$$s || this;
                if ($gvars.conf == null) $gvars.conf = nil;
if (d == null) d = nil;
              
                $writer = [$gvars.conf.$get("layout.LINE_MEDIUM")];
                $send(d, 'line_width=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];}, TMP_178.$$s = self, TMP_178.$$arity = 1, TMP_178)));
              if ($truthy(playable['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'SynchPoint')))) {
                $send(playable.$notes(), 'each_with_index', [], (TMP_179 = function(n, index){var self = TMP_179.$$s || this, TMP_180, e = nil;
                  if ($gvars.log == null) $gvars.log = nil;
if (n == null) n = nil;if (index == null) index = nil;
                
                  try {
                    
                    p1 = tie_start.$notes()['$[]'](index);
                    p1 = $rb_plus(self.$Vector2d(p1.$sheet_drawable().$center()), [3, 0]);
                    p2 = $rb_plus(self.$Vector2d(n.$sheet_drawable().$center()), [3, 0]);
                    tiepath = self.$make_slur_path(p1, p2);
                    return result.$push($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(tiepath), 'tap', [], (TMP_180 = function(d){var self = TMP_180.$$s || this;
                      if ($gvars.conf == null) $gvars.conf = nil;
if (d == null) d = nil;
                    
                      $writer = [$gvars.conf.$get("layout.LINE_MEDIUM")];
                      $send(d, 'line_width=', Opal.to_a($writer));
                      return $writer[$rb_minus($writer["length"], 1)];}, TMP_180.$$s = self, TMP_180.$$arity = 1, TMP_180)));
                  } catch ($err) {
                    if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
                      try {
                        return $gvars.log.$error("tied chords which doesn't have same number of notes", n.$start_pos())
                      } finally { Opal.pop_exception() }
                    } else { throw $err; }
                  };}, TMP_179.$$s = self, TMP_179.$$arity = 2, TMP_179))};};
            if ($truthy(playable['$tie_start?']())) {
              tie_start = playable};
            $send(playable.$slur_starts(), 'each', [], (TMP_181 = function(s){var self = TMP_181.$$s || this;
              if (self.slur_index == null) self.slur_index = nil;
if (s == null) s = nil;
            
              $writer = [s, playable];
              $send(self.slur_index, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, TMP_181.$$s = self, TMP_181.$$arity = 1, TMP_181));
            
            $writer = [playable.$slur_starts().$first(), playable];
            $send(self.slur_index, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            $send(playable.$slur_ends(), 'each', [], (TMP_182 = function(id){var self = TMP_182.$$s || this, $c, TMP_183, begin_slur = nil, slurpath = nil;
              if (self.slur_index == null) self.slur_index = nil;
              if ($gvars.conf == null) $gvars.conf = nil;
if (id == null) id = nil;
            
              begin_slur = ($truthy($c = self.slur_index['$[]'](id)) ? $c : self.slur_index['$[]']("first_playable"));
              p1 = $rb_plus(self.$Vector2d(begin_slur.$sheet_drawable().$center()), [3, 0]);
              p2 = $rb_plus(self.$Vector2d(playable.$sheet_drawable().$center()), [3, 0]);
              slurpath = self.$make_slur_path(p1, p2);
              if ($truthy($gvars.conf.$get("layout.SHOW_SLUR"))) {
                return result.$push($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(slurpath), 'tap', [], (TMP_183 = function(d){var self = TMP_183.$$s || this;
                  if ($gvars.conf == null) $gvars.conf = nil;
if (d == null) d = nil;
                
                  $writer = [$gvars.conf.$get("layout.LINE_MEDIUM")];
                  $send(d, 'line_width=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];}, TMP_183.$$s = self, TMP_183.$$arity = 1, TMP_183)))
                } else {
                return nil
              };}, TMP_182.$$s = self, TMP_182.$$arity = 1, TMP_182));
            return result;}, TMP_177.$$s = self, TMP_177.$$arity = 2, TMP_177));
          res_gotos = $send($send(voice, 'select', [], (TMP_184 = function(c){var self = TMP_184.$$s || this;
if (c == null) c = nil;
          return c['$is_a?'](Opal.const_get_relative($nesting, 'Goto'))}, TMP_184.$$s = self, TMP_184.$$arity = 1, TMP_184)), 'map', [], (TMP_185 = function(goto$){var self = TMP_185.$$s || this, $c, TMP_186, conf_key = nil, distance = nil, old_conf_key = nil, is_visible = nil, from_anchor = nil, to_anchor = nil, vertical_anchor = nil, vertical = nil, from = nil, to = nil, swap = nil, jumpline_info = nil, path = nil, draginfo = nil;
            if ($gvars.log == null) $gvars.log = nil;
            if ($gvars.conf == null) $gvars.conf = nil;
if (goto$ == null) goto$ = nil;
          
            if ($truthy(goto$.$conf_key())) {
              
              conf_key = "" + "extract." + (print_variant_nr) + "." + (goto$.$conf_key());
              distance = show_options['$[]']("print_options_raw")['$[]'](goto$.$conf_key());
              if ($truthy(distance)) {
                } else {
                
                old_conf_key = conf_key.$gsub(/(.*)\.(\d+)\.(\d+)\.(\w+)/, "\\1.\\2.\\4");
                distance = show_options['$[]']("print_options_raw")['$[]'](old_conf_key);
              };};
            if ($truthy(distance)) {
              } else {
              distance = goto$.$policy()['$[]']("distance")
            };
            if ($truthy(distance)) {
              } else {
              distance = 1
            };
            is_visible = (function() {if (distance['$=='](0)) {
              return false
              } else {
              return true
            }; return nil; })();
            if ($truthy($rb_gt(distance, 0))) {
              distance = $rb_minus(distance, 1)};
            from_anchor = ($truthy($c = goto$.$policy()['$[]']("from_anchor")) ? $c : "after");
            to_anchor = ($truthy($c = goto$.$policy()['$[]']("to_anchor")) ? $c : "before");
            vertical_anchor = ($truthy($c = goto$.$policy()['$[]']("vertical_anchor")) ? $c : "from");
            $gvars.log.$debug("" + "vertical line x offset: " + (distance) + " " + ("harpnotes") + ":" + (2130));
            vertical = $rb_times($rb_plus(distance, 0.5), $gvars.conf.$get("layout.X_SPACING"));
            from = goto$.$from().$sheet_drawable();
            to = goto$.$to().$sheet_drawable();
            if ($truthy($gvars.conf['$[]']("layout.bottomup"))) {
              
              swap = $hash2(["before", "after"], {"before": "after", "after": "before"});
              from_anchor = swap['$[]'](from_anchor);
              to_anchor = swap['$[]'](to_anchor);};
            jumpline_info = $hash2(["from", "to", "vertical", "vertical_anchor", "padding", "xspacing", "jumpline_anchor"], {"from": $hash2(["center", "size", "anchor"], {"center": from.$center(), "size": from.$size(), "anchor": from_anchor}), "to": $hash2(["center", "size", "anchor"], {"center": to.$center(), "size": to.$size(), "anchor": to_anchor}), "vertical": vertical, "vertical_anchor": vertical_anchor, "padding": goto$.$policy()['$[]']("padding"), "xspacing": $gvars.conf['$[]']("layout.X_SPACING"), "jumpline_anchor": $gvars.conf['$[]']("layout.jumpline_anchor")});
            path = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Layout'), 'Default').$make_path_from_jumpline(jumpline_info);
            draginfo = $hash2(["handler", "jumpline", "xspacing"], {"handler": "jumpline", "jumpline": jumpline_info, "xspacing": $gvars.conf.$get("layout.X_SPACING")});
            if ($truthy(is_visible)) {
              if ($truthy(($truthy($c = goto$.$policy()['$[]']("is_repeat")) ? show_options['$[]']("repeatsigns")['$[]']("voices")['$include?'](show_options['$[]']("voice_nr")) : $c))) {
                return nil
                } else {
                return [$send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(path['$[]'](0), nil, goto$.$from()), 'tap', [], (TMP_186 = function(s){var self = TMP_186.$$s || this;
                  if ($gvars.conf == null) $gvars.conf = nil;
if (s == null) s = nil;
                
                  
                  $writer = [conf_key];
                  $send(s, 'conf_key=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = [distance];
                  $send(s, 'conf_value=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = [$gvars.conf.$get("layout.LINE_THICK")];
                  $send(s, 'line_width=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = [draginfo];
                  $send(s, 'draginfo=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];;}, TMP_186.$$s = self, TMP_186.$$arity = 1, TMP_186)), Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(path['$[]'](1), "filled", goto$.$from())]
              }
              } else {
              return nil
            };}, TMP_185.$$s = self, TMP_185.$$arity = 1, TMP_185)).$flatten().$compact();
          if ($truthy(show_options['$[]']("jumpline"))) {
            } else {
            res_gotos = []
          };
          color_default = self.color_default;
          $send(res_gotos, 'each', [], (TMP_187 = function(the_goto){var self = TMP_187.$$s || this;
if (the_goto == null) the_goto = nil;
          
            $writer = [color_default];
            $send(the_goto, 'color=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_187.$$s = self, TMP_187.$$arity = 1, TMP_187));
          res_repeatmarks = [];
          if ($truthy(show_options['$[]']("repeatsigns")['$[]']("voices")['$include?'](show_options['$[]']("voice_nr")))) {
            res_repeatmarks = $send($send(voice, 'select', [], (TMP_188 = function(c){var self = TMP_188.$$s || this, $c;
if (c == null) c = nil;
            return ($truthy($c = c['$is_a?'](Opal.const_get_relative($nesting, 'Goto'))) ? c.$policy()['$[]']("is_repeat") : $c)}, TMP_188.$$s = self, TMP_188.$$arity = 1, TMP_188)), 'map', [], (TMP_189 = function(goto$){var self = TMP_189.$$s || this, startbar = nil, endbar = nil;
if (goto$ == null) goto$ = nil;
            
              startbar = self.$make_repeatsign_annotation(goto$, "begin", print_variant_nr, show_options, voice_nr);
              endbar = self.$make_repeatsign_annotation(goto$, "end", print_variant_nr, show_options, voice_nr);
              return [endbar, startbar];}, TMP_189.$$s = self, TMP_189.$$arity = 1, TMP_189)).$flatten()};
          res_annotations = $send($send(voice, 'select', [], (TMP_190 = function(c){var self = TMP_190.$$s || this;
if (c == null) c = nil;
          return c['$is_a?'](Opal.const_get_relative($nesting, 'NoteBoundAnnotation'))}, TMP_190.$$s = self, TMP_190.$$arity = 1, TMP_190)), 'map', [], (TMP_191 = function(annotation){var self = TMP_191.$$s || this, $c, TMP_192, notebound_pos_key = nil, show = nil, conf_key = nil, annotationoffset = nil, style = nil, position = nil, result = nil;
if (annotation == null) annotation = nil;
          
            notebound_pos_key = $rb_plus(annotation.$conf_key(), ".pos");
            show = ($truthy($c = show_options['$[]']("print_options_raw").$get($rb_plus(annotation.$conf_key(), ".show"))) ? $c : true);
            if ($truthy(notebound_pos_key)) {
              
              conf_key = "" + "extract." + (print_variant_nr) + "." + (notebound_pos_key);
              annotationoffset = (function() { try {
                return show_options['$[]']("print_options_raw").$get(notebound_pos_key)
              } catch ($err) {
                if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
                  try {
                    return nil
                  } finally { Opal.pop_exception() }
                } else { throw $err; }
              }})();
              if ($truthy(annotationoffset)) {
                } else {
                annotationoffset = annotation.$position()
              };
              } else {
              
              annotationoffset = annotation.$position();
              conf_key = nil;
            };
            style = ($truthy($c = show_options['$[]']("print_options_raw").$get($rb_plus(annotation.$conf_key(), ".style"))) ? $c : annotation.$style());
            position = $rb_plus(self.$Vector2d(annotation.$companion().$sheet_drawable().$center()), annotationoffset);
            result = $send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(position.$to_a(), annotation.$text(), style, annotation.$companion().$origin(), conf_key, annotationoffset), 'tap', [], (TMP_192 = function(s){var self = TMP_192.$$s || this;
if (s == null) s = nil;
            
              $writer = [$hash2(["handler"], {"handler": "annotation"})];
              $send(s, 'draginfo=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, TMP_192.$$s = self, TMP_192.$$arity = 1, TMP_192));
            if ($truthy((($c = annotation.$policy()['$==']("Goto")) ? show_options['$[]']("jumpline")['$!']() : annotation.$policy()['$==']("Goto")))) {
              result = nil};
            if (show['$=='](false)) {
              result = nil};
            return result;}, TMP_191.$$s = self, TMP_191.$$arity = 1, TMP_191));
          return $rb_plus($rb_plus($rb_plus($rb_plus($rb_plus($rb_plus($rb_plus($rb_plus($rb_plus($rb_plus(res_flow, res_sub_flow), res_slurs), res_tuplets), res_playables), res_countnotes), res_barnumbers), res_decorations), res_gotos), res_annotations), res_repeatmarks).$compact();
        }, TMP_Default_layout_voice_193.$$arity = 4);
        
        Opal.defn(self, '$make_decorations_per_playable', TMP_Default_make_decorations_per_playable_197 = function $$make_decorations_per_playable(playable, decoration_root, print_variant_nr, show_options, voice_nr) {
          var TMP_194, TMP_195, self = this, decorations = nil, decoration_distance = nil, decoration_scale = nil, decoration_size = nil, decoration_result = nil;

          
          decorations = nil;
          decorations = playable.$decorations();
          if ($truthy(decorations['$empty?']())) {
            } else {
            
            decoration_distance = (function() {if ($truthy(playable.$measure_start())) {
              return 2
              } else {
              return 1
            }; return nil; })();
            decoration_scale = 0.8;
            decoration_size = $send(decoration_root.$size(), 'map', [], (TMP_194 = function(i){var self = TMP_194.$$s || this;
if (i == null) i = nil;
            return $rb_times(i, decoration_scale)}, TMP_194.$$s = self, TMP_194.$$arity = 1, TMP_194));
            decoration_result = [];
            $send(decorations, 'each_with_index', [], (TMP_195 = function(decoration, index){var self = TMP_195.$$s || this, TMP_196, notebound_pos_key = nil, conf_key = nil, annotationoffset = nil, decoration_center = nil, r = nil;
if (decoration == null) decoration = nil;if (index == null) index = nil;
            
              notebound_pos_key = "" + "notebound.decoration.v_" + (voice_nr) + ".t_" + (playable.$znid()) + "." + (index) + ".pos";
              conf_key = "" + "extract." + (print_variant_nr) + "." + (notebound_pos_key);
              annotationoffset = (function() { try {
                return show_options['$[]']("print_options_raw")['$[]'](notebound_pos_key)
              } catch ($err) {
                if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
                  try {
                    return nil
                  } finally { Opal.pop_exception() }
                } else { throw $err; }
              }})();
              if ($truthy(annotationoffset)) {
                } else {
                annotationoffset = [0, $rb_minus($rb_divide(decoration_root.$size().$last()['$-@'](), decoration_scale), decoration_distance).$round()]
              };
              decoration_center = [$rb_plus(decoration_root.$center().$first(), annotationoffset.$first()), $rb_plus(decoration_root.$center().$last(), annotationoffset.$last())];
              r = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Glyph').$new(decoration_center, decoration_size, decoration, false, nil, conf_key, annotationoffset);
              $send(r, 'tap', [], (TMP_196 = function(s){var self = TMP_196.$$s || this, $writer = nil;
if (s == null) s = nil;
              
                $writer = [$hash2(["handler"], {"handler": "annotation"})];
                $send(s, 'draginfo=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];}, TMP_196.$$s = self, TMP_196.$$arity = 1, TMP_196));
              return decoration_result.$push([r]);}, TMP_195.$$s = self, TMP_195.$$arity = 2, TMP_195));
          };
          return decoration_result;
        }, TMP_Default_make_decorations_per_playable_197.$$arity = 5);
        
        Opal.defn(self, '$make_repeatsign_annotation', TMP_Default_make_repeatsign_annotation_199 = function $$make_repeatsign_annotation(goto$, point_role, print_variant_nr, show_options, voice_nr) {
          var $a, TMP_198, self = this, from_anchor = nil, to_anchor = nil, companion_note = nil, attach_side = nil, repeat_key = nil, pos_key = nil, conf_key = nil, repeatsign_options = nil, annotationoffset = nil, text = nil, style = nil, position = nil;

          
          from_anchor = ($truthy($a = goto$.$policy()['$[]']("from_anchor")) ? $a : "after");
          to_anchor = ($truthy($a = goto$.$policy()['$[]']("to_anchor")) ? $a : "before");
          if (point_role['$==']("begin")) {
            
            companion_note = goto$.$to();
            if (goto$.$to()['$=='](goto$.$from())) {
              attach_side = "left"
              } else {
              attach_side = (function() {if ($truthy($rb_le(companion_note.$pitch(), companion_note.$next_pitch()))) {
                return "left"
                } else {
                return "right"
              }; return nil; })()
            };
            } else {
            
            companion_note = goto$.$from();
            if (goto$.$to()['$=='](goto$.$from())) {
              attach_side = "right"
              } else {
              attach_side = (function() {if ($truthy($rb_le(companion_note.$prev_pitch(), companion_note.$pitch()))) {
                return "right"
                } else {
                return "left"
              }; return nil; })()
            };
          };
          repeat_key = "" + "notebound.repeat_" + (point_role.$to_s()) + ".v_" + (voice_nr) + "." + (companion_note.$znid());
          pos_key = "" + (repeat_key) + ".pos";
          conf_key = "" + "extract." + (print_variant_nr) + "." + (pos_key);
          repeatsign_options = show_options['$[]']("repeatsigns")['$[]'](attach_side);
          annotationoffset = (function() { try {
            return show_options['$[]']("print_options_raw")['$[]'](pos_key)
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }})();
          if ($truthy(annotationoffset)) {
            } else {
            annotationoffset = repeatsign_options['$[]']("pos")
          };
          text = ($truthy($a = show_options['$[]']("print_options_raw")['$[]']("" + (repeat_key) + ".text")) ? $a : repeatsign_options['$[]']("text"));
          style = ($truthy($a = show_options['$[]']("print_options_raw")['$[]']("" + (repeat_key) + ".style")) ? $a : repeatsign_options['$[]']("style"));
          position = $rb_plus(self.$Vector2d(companion_note.$sheet_drawable().$center()), annotationoffset);
          return $send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(position.$to_a(), text, style, companion_note.$origin(), conf_key, annotationoffset), 'tap', [], (TMP_198 = function(s){var self = TMP_198.$$s || this, $writer = nil;
if (s == null) s = nil;
          
            $writer = [$hash2(["handler"], {"handler": "annotation"})];
            $send(s, 'draginfo=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_198.$$s = self, TMP_198.$$arity = 1, TMP_198));
        }, TMP_Default_make_repeatsign_annotation_199.$$arity = 5);
        self.$private();
        
        Opal.defn(self, '$layout_barnumbers_countnotes', TMP_Default_layout_barnumbers_countnotes_204 = function $$layout_barnumbers_countnotes(playables, print_variant_nr, show_options, voice_nr) {
          var $a, TMP_200, $b, TMP_201, self = this, limit_a3 = nil, bottomup = nil, cn_options = nil, bn_options = nil, res_countnotes = nil, res_barnumbers = nil, visible_playables = nil, cn_style = nil, cn_fontsize_x = nil, cn_fontsize_y = nil, cn_apanchor = nil, cn_autopos = nil, cn_fixedpos = nil, cn_apbase_x = nil, cn_apbase_y = nil, bn_style = nil, bn_fontsize_x = nil, bn_fontsize_y = nil, bn_apanchor = nil, bn_autopos = nil, bn_fixedpos = nil, bn_apbase_x = nil, bn_apbase_y = nil, bn_prefix = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          limit_a3 = $gvars.conf['$[]']("layout.limit_a3")['$=='](true);
          bottomup = $gvars.conf['$[]']("layout.bottomup")['$=='](true);
          cn_options = show_options['$[]']("countnotes");
          bn_options = show_options['$[]']("barnumbers");
          res_countnotes = [];
          res_barnumbers = [];
          if ($truthy(($truthy($a = cn_options) ? $a : bn_options))) {
            
            visible_playables = $send(playables, 'select', [], (TMP_200 = function(playable){var self = TMP_200.$$s || this;
if (playable == null) playable = nil;
            return playable['$visible?']()}, TMP_200.$$s = self, TMP_200.$$arity = 1, TMP_200));
            if ($truthy(cn_options)) {
              
              cn_style = cn_options['$[]']("style");
              $a = [1, 1], (cn_fontsize_x = $a[0]), (cn_fontsize_y = $a[1]), $a;
              cn_apanchor = cn_options['$[]']("apanchor");
              cn_autopos = cn_options['$[]']("autopos");
              cn_fixedpos = cn_options['$[]']("pos");
              $b = cn_options['$[]']("apbase"), $a = Opal.to_ary($b), (cn_apbase_x = ($a[0] == null ? nil : $a[0])), (cn_apbase_y = ($a[1] == null ? nil : $a[1])), $b;};
            if ($truthy(bn_options)) {
              
              bn_style = bn_options['$[]']("style");
              $a = [2.7, 2.7], (bn_fontsize_x = $a[0]), (bn_fontsize_y = $a[1]), $a;
              bn_apanchor = bn_options['$[]']("apanchor");
              bn_autopos = bn_options['$[]']("autopos");
              bn_fixedpos = bn_options['$[]']("pos");
              $b = bn_options['$[]']("apbase"), $a = Opal.to_ary($b), (bn_apbase_x = ($a[0] == null ? nil : $a[0])), (bn_apbase_y = ($a[1] == null ? nil : $a[1])), $b;
              bn_prefix = bn_options['$[]']("prefix");};
            $send(visible_playables, 'each', [], (TMP_201 = function(playable){var self = TMP_201.$$s || this, $c, $d, TMP_202, TMP_203, the_drawable = nil, dcenter = nil, x = nil, y = nil, dsize_x = nil, dsize_y = nil, dsize_d_x = nil, dsize_d_y = nil, xp = nil, yp = nil, xn = nil, yn = nil, bn_side = nil, cn_side = nil, cn_base_key = nil, cn_pos_key = nil, cn_align_key = nil, count_note = nil, cn_dsize_y = nil, cn_offset = nil, cn_align = nil, cn_tie_x = nil, auto_x = nil, auto_y = nil, cn_position = nil, cn_conf_base = nil, bn_base_key = nil, bn_pos_key = nil, bn_align_key = nil, bn_conf_key = nil, barnumber = nil, bn_dsize_y = nil, bn_offset = nil, bn_align = nil, bn_tie_x = nil, bn_auto_x = nil, bn_auto_y = nil, bn_position = nil;
              if (self.print_options_keys == null) self.print_options_keys = nil;
              if (self.print_options_raw == null) self.print_options_raw = nil;
if (playable == null) playable = nil;
            
              the_drawable = playable.$sheet_drawable();
              dcenter = the_drawable.$center();
              $d = dcenter, $c = Opal.to_ary($d), (x = ($c[0] == null ? nil : $c[0])), (y = ($c[1] == null ? nil : $c[1])), $d;
              $d = the_drawable.$size(), $c = Opal.to_ary($d), (dsize_x = ($c[0] == null ? nil : $c[0])), (dsize_y = ($c[1] == null ? nil : $c[1])), $d;
              $d = the_drawable.$size_with_dot(), $c = Opal.to_ary($d), (dsize_d_x = ($c[0] == null ? nil : $c[0])), (dsize_d_y = ($c[1] == null ? nil : $c[1])), $d;
              $d = playable.$prev_playable().$sheet_drawable().$center(), $c = Opal.to_ary($d), (xp = ($c[0] == null ? nil : $c[0])), (yp = ($c[1] == null ? nil : $c[1])), $d;
              $d = playable.$next_playable().$sheet_drawable().$center(), $c = Opal.to_ary($d), (xn = ($c[0] == null ? nil : $c[0])), (yn = ($c[1] == null ? nil : $c[1])), $d;
              $d = (function() {if ($truthy(bottomup)) {
                return self.$compute_note_position(xn, x, xp, limit_a3).$reverse()
                } else {
                return self.$compute_note_position(xp, x, xn, limit_a3)
              }; return nil; })(), $c = Opal.to_ary($d), (bn_side = ($c[0] == null ? nil : $c[0])), (cn_side = ($c[1] == null ? nil : $c[1])), $d;
              if ($truthy(cn_options)) {
                
                cn_base_key = "" + "notebound.countnote.v_" + (voice_nr) + ".t_" + (playable.$time());
                cn_pos_key = "" + (cn_base_key) + ".pos";
                cn_align_key = "" + (cn_base_key) + ".align";
                count_note = ($truthy($c = playable.$count_note()) ? $c : "");
                cn_dsize_y = (function() {if ($truthy("center"['$=='](cn_apanchor))) {
                  return 0
                  } else {
                  return dsize_y
                }; return nil; })();
                if ($truthy(self.print_options_keys['$include?'](cn_pos_key))) {
                  cn_offset = self.print_options_raw['$[]'](cn_pos_key)};
                if ($truthy(($truthy($c = self.print_options_keys['$include?'](cn_align_key)) ? self.print_options_raw['$[]'](cn_align_key)['$!=']("auto") : $c))) {
                  cn_side = self.print_options_raw['$[]'](cn_align_key)};
                cn_align = (function() {if (cn_autopos['$=='](true)) {
                  
                  if ($truthy(cn_side['$==']("l"))) {
                    return "right"
                    } else {
                    return "left"
                  };
                  } else {
                  return "left"
                }; return nil; })();
                if ($truthy(cn_offset)) {
                } else if (cn_autopos['$=='](true)) {
                  
                  cn_tie_x = (function() {if ($truthy((($c = cn_side['$==']("r")) ? playable['$tie_start?']() : cn_side['$==']("r")))) {
                    return 1.5
                    } else {
                    return 0
                  }; return nil; })();
                  auto_x = $rb_plus(cn_tie_x, (function() {if (cn_side['$==']("l")) {
                    return $rb_plus(dsize_x, cn_apbase_x)['$-@']()
                    } else {
                    return $rb_plus(dsize_d_x, cn_apbase_x)
                  }; return nil; })());
                  auto_y = (function() {if ($truthy(bottomup)) {
                    return $rb_plus($rb_plus(cn_dsize_y, cn_apbase_y), cn_fontsize_y)['$-@']()
                    } else {
                    return $rb_plus(cn_dsize_y, cn_apbase_y)
                  }; return nil; })();
                  cn_offset = [auto_x, auto_y];
                  } else {
                  cn_offset = cn_fixedpos
                };
                cn_position = $rb_plus(self.$Vector2d(dcenter), cn_offset);
                res_countnotes.$push($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(cn_position.$to_a(), count_note, cn_style, playable.$origin(), "" + "extract." + (print_variant_nr) + "." + (cn_pos_key), cn_offset), 'tap', [], (TMP_202 = function(s){var self = TMP_202.$$s || this, $writer = nil;
if (s == null) s = nil;
                
                  
                  $writer = [cn_align];
                  $send(s, 'align=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = [$hash2(["handler"], {"handler": "annotation"})];
                  $send(s, 'draginfo=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  s.$more_conf_keys().$push($hash2(["conf_key", "text", "icon", "value"], {"conf_key": "" + "extract." + (print_variant_nr) + "." + (cn_align_key), "text": Opal.const_get_relative($nesting, 'I18n').$t("countnote left"), "icon": "fa fa-arrow-left", "value": "l"}));
                  return s.$more_conf_keys().$push($hash2(["conf_key", "text", "icon", "value"], {"conf_key": "" + "extract." + (print_variant_nr) + "." + (cn_align_key), "text": Opal.const_get_relative($nesting, 'I18n').$t("countnote right"), "icon": "fa fa-arrow-right", "value": "r"}));}, TMP_202.$$s = self, TMP_202.$$arity = 1, TMP_202)));};
              if ($truthy(($truthy($c = bn_options) ? playable['$measure_start?']() : $c))) {
                
                cn_base_key = "" + "notebound.countnote.v_" + (voice_nr) + ".t_" + (playable.$time());
                cn_pos_key = "" + (cn_base_key) + ".pos";
                cn_align_key = "" + (cn_base_key) + ".align";
                cn_conf_base = "" + "extract." + (print_variant_nr) + "." + (cn_base_key);
                count_note = ($truthy($c = playable.$count_note()) ? $c : "");
                bn_base_key = "" + "notebound.barnumber.v_" + (voice_nr) + ".t_" + (playable.$time());
                bn_pos_key = "" + (bn_base_key) + ".pos";
                bn_align_key = "" + (bn_base_key) + ".align";
                bn_conf_key = "" + "extract." + (print_variant_nr) + "." + (bn_pos_key);
                barnumber = ($truthy($c = "" + (bn_prefix) + (playable.$measure_count().$to_s())) ? $c : "");
                bn_dsize_y = (function() {if ($truthy("center"['$=='](bn_apanchor))) {
                  return 0
                  } else {
                  return dsize_y
                }; return nil; })();
                if ($truthy(self.print_options_keys['$include?'](bn_pos_key))) {
                  bn_offset = self.print_options_raw['$[]'](bn_pos_key)};
                if ($truthy(($truthy($c = self.print_options_keys['$include?'](bn_align_key)) ? self.print_options_raw['$[]'](bn_align_key)['$!=']("auto") : $c))) {
                  bn_side = self.print_options_raw['$[]'](bn_align_key)};
                bn_align = (function() {if (bn_autopos['$=='](true)) {
                  
                  if ($truthy(bn_side['$==']("l"))) {
                    return "right"
                    } else {
                    return "left"
                  };
                  } else {
                  return "left"
                }; return nil; })();
                if ($truthy(bn_offset)) {
                } else if (bn_autopos['$=='](true)) {
                  
                  bn_tie_x = (function() {if ($truthy((($c = bn_side['$==']("r")) ? playable['$tie_start?']() : bn_side['$==']("r")))) {
                    return 1
                    } else {
                    return 0
                  }; return nil; })();
                  bn_auto_x = $rb_plus(bn_tie_x, (function() {if (bn_side['$==']("l")) {
                    return $rb_plus(dsize_x, bn_apbase_x)['$-@']()
                    } else {
                    return $rb_plus(dsize_d_x, bn_apbase_x)
                  }; return nil; })());
                  bn_auto_y = (function() {if ($truthy(bottomup)) {
                    return $rb_plus(bn_dsize_y, bn_apbase_y)
                    } else {
                    return $rb_plus($rb_plus(bn_dsize_y, bn_apbase_y), bn_fontsize_y)['$-@']()
                  }; return nil; })();
                  bn_offset = [bn_auto_x, bn_auto_y];
                  } else {
                  bn_offset = bn_fixedpos
                };
                bn_position = $rb_plus(self.$Vector2d(dcenter), bn_offset);
                return res_barnumbers.$push($send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation').$new(bn_position.$to_a(), barnumber, bn_style, playable.$origin(), "" + "extract." + (print_variant_nr) + "." + (bn_pos_key), bn_offset), 'tap', [], (TMP_203 = function(s){var self = TMP_203.$$s || this, $writer = nil;
if (s == null) s = nil;
                
                  
                  $writer = [bn_align];
                  $send(s, 'align=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = [$hash2(["handler"], {"handler": "annotation"})];
                  $send(s, 'draginfo=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  s.$more_conf_keys().$push($hash2(["conf_key", "text", "icon", "value"], {"conf_key": "" + "extract." + (print_variant_nr) + "." + (bn_align_key), "text": Opal.const_get_relative($nesting, 'I18n').$t("barnumber left"), "icon": "fa fa-arrow-left", "value": "l"}));
                  return s.$more_conf_keys().$push($hash2(["conf_key", "text", "icon", "value"], {"conf_key": "" + "extract." + (print_variant_nr) + "." + (bn_align_key), "text": Opal.const_get_relative($nesting, 'I18n').$t("barnumber right"), "icon": "fa fa-arrow-right", "value": "r"}));}, TMP_203.$$s = self, TMP_203.$$arity = 1, TMP_203)));
                } else {
                return nil
              };}, TMP_201.$$s = self, TMP_201.$$arity = 1, TMP_201));};
          return [res_barnumbers, res_countnotes];
        }, TMP_Default_layout_barnumbers_countnotes_204.$$arity = 4);
        
        Opal.defn(self, '$compute_beat_compression', TMP_Default_compute_beat_compression_205 = function $$compute_beat_compression(music, layout_lines) {
          var $a, self = this, result = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          if ($gvars.conf.$get("layout.packer.pack_method")['$=='](1)) {
            result = self.$compute_beat_compression_1(music, layout_lines)};
          if ($gvars.conf.$get("layout.packer.pack_method")['$=='](2)) {
            result = self.$compute_beat_compression_2(music, layout_lines)};
          if ($gvars.conf.$get("layout.packer.pack_method")['$=='](10)) {
            result = self.$compute_beat_compression_10(music, layout_lines)};
          if (($truthy($a = $gvars.conf.$get("layout.packer.pack_method")) ? $a : 0)['$=='](0)) {
            result = self.$compute_beat_compression_0(music, layout_lines)};
          return result;
        }, TMP_Default_compute_beat_compression_205.$$arity = 2);
        
        Opal.defn(self, '$compute_beat_compression_2', TMP_Default_compute_beat_compression_2_213 = function $$compute_beat_compression_2(music, layout_lines) {
          var TMP_206, TMP_207, TMP_208, TMP_209, TMP_210, TMP_211, TMP_212, self = this, compression_map = nil, relevant_notes = nil, relevant_sp = nil, relevant_beats = nil;

          
          compression_map = $hash2([], {});
          relevant_notes = $send($send($send(layout_lines, 'map', [], (TMP_206 = function(voice_id){var self = TMP_206.$$s || this;
if (voice_id == null) voice_id = nil;
          return music.$voices()['$[]'](voice_id)}, TMP_206.$$s = self, TMP_206.$$arity = 1, TMP_206)), 'inject', [[]], (TMP_207 = function(result, voice){var self = TMP_207.$$s || this;
if (result == null) result = nil;if (voice == null) voice = nil;
          return result.$push(voice)}, TMP_207.$$s = self, TMP_207.$$arity = 2, TMP_207)).$flatten(), 'select', [], (TMP_208 = function(note){var self = TMP_208.$$s || this;
if (note == null) note = nil;
          return note['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable'))}, TMP_208.$$s = self, TMP_208.$$arity = 1, TMP_208));
          relevant_sp = $send($send(relevant_notes, 'select', [], (TMP_209 = function(note){var self = TMP_209.$$s || this;
if (note == null) note = nil;
          return note['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'SynchPoint'))}, TMP_209.$$s = self, TMP_209.$$arity = 1, TMP_209)), 'map', [], (TMP_210 = function(sp){var self = TMP_210.$$s || this;
if (sp == null) sp = nil;
          return sp.$notes()}, TMP_210.$$s = self, TMP_210.$$arity = 1, TMP_210));
          relevant_notes = relevant_notes.$push(relevant_sp).$flatten();
          relevant_beats = $send(relevant_notes, 'group_by', [], (TMP_211 = function(playable){var self = TMP_211.$$s || this;
if (playable == null) playable = nil;
          return playable.$beat()}, TMP_211.$$s = self, TMP_211.$$arity = 1, TMP_211));
          $send(relevant_beats.$keys().$sort(), 'each', [], (TMP_212 = function(beat){var self = TMP_212.$$s || this, $writer = nil;
if (beat == null) beat = nil;
          
            $writer = [beat, $rb_times(beat, 8)];
            $send(compression_map, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_212.$$s = self, TMP_212.$$arity = 1, TMP_212));
          return compression_map;
        }, TMP_Default_compute_beat_compression_2_213.$$arity = 2);
        
        Opal.defn(self, '$compute_beat_compression_10', TMP_Default_compute_beat_compression_10_222 = function $$compute_beat_compression_10(music, layout_lines) {
          var TMP_214, TMP_215, TMP_216, TMP_217, self = this, max_beat = nil, current_beat = nil, last_size = nil, relevant_beat_maps = nil, relevant_keys = nil, duration_to_style = nil, result = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          max_beat = $send(music.$beat_maps(), 'map', [], (TMP_214 = function(map){var self = TMP_214.$$s || this;
if (map == null) map = nil;
          return map.$keys().$max()}, TMP_214.$$s = self, TMP_214.$$arity = 1, TMP_214)).$max();
          current_beat = 0;
          last_size = 0;
          relevant_beat_maps = $send(layout_lines, 'inject', [[]], (TMP_215 = function(r, i){var self = TMP_215.$$s || this;
if (r == null) r = nil;if (i == null) i = nil;
          return r.$push(music.$beat_maps()['$[]'](i))}, TMP_215.$$s = self, TMP_215.$$arity = 2, TMP_215)).$compact();
          relevant_keys = $send(music.$beat_maps(), 'inject', [[]], (TMP_216 = function(r, a){var self = TMP_216.$$s || this;
if (r == null) r = nil;if (a == null) a = nil;
          
            r.$push(a.$keys());
            return r;}, TMP_216.$$s = self, TMP_216.$$arity = 2, TMP_216)).$flatten().$uniq().$sort();
          duration_to_style = $gvars.conf.$get("layout.DURATION_TO_STYLE");
          result = Opal.const_get_relative($nesting, 'Hash')['$[]']($send(relevant_keys, 'map', [], (TMP_217 = function(beat){var self = TMP_217.$$s || this, TMP_218, TMP_219, TMP_220, TMP_221, notes_on_beat = nil, max_duration_on_beat = nil, has_no_notes_on_beat = nil, is_new_part = nil, measure_start = nil, size = nil, e = nil, increment = nil;
            if (self.conf_beat_resolution == null) self.conf_beat_resolution = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (beat == null) beat = nil;
          
            notes_on_beat = $send(relevant_beat_maps, 'map', [], (TMP_218 = function(bm){var self = TMP_218.$$s || this;
if (bm == null) bm = nil;
            return bm['$[]'](beat)}, TMP_218.$$s = self, TMP_218.$$arity = 1, TMP_218)).$flatten().$compact();
            max_duration_on_beat = $send(notes_on_beat, 'map', [], (TMP_219 = function(n){var self = TMP_219.$$s || this;
if (n == null) n = nil;
            return n.$duration()}, TMP_219.$$s = self, TMP_219.$$arity = 1, TMP_219)).$max();
            has_no_notes_on_beat = notes_on_beat['$empty?']();
            is_new_part = $send(notes_on_beat, 'select', [], (TMP_220 = function(n){var self = TMP_220.$$s || this;
if (n == null) n = nil;
            return n['$first_in_part?']()}, TMP_220.$$s = self, TMP_220.$$arity = 1, TMP_220));
            measure_start = $send(notes_on_beat, 'select', [], (TMP_221 = function(n){var self = TMP_221.$$s || this;
if (n == null) n = nil;
            return n['$measure_start?']()}, TMP_221.$$s = self, TMP_221.$$arity = 1, TMP_221)).$first();
            if ($truthy(has_no_notes_on_beat)) {
              } else {
              
              
              try {
                size = self.conf_beat_resolution * duration_to_style['$[]'](self.$duration_to_id(max_duration_on_beat)).$first()
              } catch ($err) {
                if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
                  try {
                    $gvars.log.$error("" + "BUG: unsupported duration: " + (max_duration_on_beat) + " on beat " + (beat) + ",  " + (notes_on_beat.$to_json()))
                  } finally { Opal.pop_exception() }
                } else { throw $err; }
              };;
              increment = $rb_divide($rb_plus(size, last_size), 2);
              last_size = size;
              if ($truthy(measure_start)) {
                increment = $rb_plus(increment, $rb_divide(increment, 4))};
              if ($truthy(is_new_part['$empty?']())) {
                } else {
                increment = $rb_plus(increment, increment)
              };
              increment = $rb_plus(increment, self.$get_minc_factor(notes_on_beat.$first().$time(), increment));
              current_beat = $rb_plus(current_beat, increment);
            };
            return [beat, current_beat];}, TMP_217.$$s = self, TMP_217.$$arity = 1, TMP_217)));
          return result;
        }, TMP_Default_compute_beat_compression_10_222.$$arity = 2);
        
        Opal.defn(self, '$get_minc_factor', TMP_Default_get_minc_factor_223 = function $$get_minc_factor(time, increment) {
          var self = this, minc = nil;

          if (increment == null) {
            increment = self.conf_beat_resolution;
          }
          
          minc = self.layout_minc['$[]'](time.$to_s());
          if ($truthy(minc)) {
            try {
              return $rb_times(minc['$[]']("minc_f"), increment)
            } catch ($err) {
              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
                try {
                  return 0
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            }
            } else {
            return 0
          };
        }, TMP_Default_get_minc_factor_223.$$arity = -2);
        
        Opal.defn(self, '$compute_beat_compression_0', TMP_Default_compute_beat_compression_0_234 = function $$compute_beat_compression_0(music, layout_lines) {
          var $a, TMP_224, TMP_225, TMP_226, TMP_227, TMP_228, TMP_229, TMP_230, self = this, duration_to_style = nil, conf_min_increment = nil, newbeat = nil, compression_map = nil, last_size = nil, relevant_notes = nil, relevant_sp = nil, relevant_beats = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          duration_to_style = $gvars.conf.$get("layout.DURATION_TO_STYLE");
          conf_min_increment = $rb_times(($truthy($a = $gvars.conf.$get("layout.packer.pack_min_increment")) ? $a : 0), self.conf_beat_resolution);
          newbeat = 0;
          compression_map = $hash2([], {});
          last_size = 0;
          relevant_notes = $send($send($send(layout_lines, 'map', [], (TMP_224 = function(voice_id){var self = TMP_224.$$s || this;
if (voice_id == null) voice_id = nil;
          return music.$voices()['$[]'](voice_id)}, TMP_224.$$s = self, TMP_224.$$arity = 1, TMP_224)), 'inject', [[]], (TMP_225 = function(result, voice){var self = TMP_225.$$s || this;
if (result == null) result = nil;if (voice == null) voice = nil;
          return result.$push(voice)}, TMP_225.$$s = self, TMP_225.$$arity = 2, TMP_225)).$flatten(), 'select', [], (TMP_226 = function(note){var self = TMP_226.$$s || this;
if (note == null) note = nil;
          return note['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable'))}, TMP_226.$$s = self, TMP_226.$$arity = 1, TMP_226));
          relevant_sp = $send($send(relevant_notes, 'select', [], (TMP_227 = function(note){var self = TMP_227.$$s || this;
if (note == null) note = nil;
          return note['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'SynchPoint'))}, TMP_227.$$s = self, TMP_227.$$arity = 1, TMP_227)), 'map', [], (TMP_228 = function(sp){var self = TMP_228.$$s || this;
if (sp == null) sp = nil;
          return sp.$notes()}, TMP_228.$$s = self, TMP_228.$$arity = 1, TMP_228));
          relevant_notes = relevant_notes.$push(relevant_sp).$flatten();
          relevant_beats = $send(relevant_notes, 'group_by', [], (TMP_229 = function(playable){var self = TMP_229.$$s || this;
if (playable == null) playable = nil;
          return playable.$beat()}, TMP_229.$$s = self, TMP_229.$$arity = 1, TMP_229));
          $send(relevant_beats.$keys().$sort(), 'each', [], (TMP_230 = function(beat){var self = TMP_230.$$s || this, TMP_231, TMP_232, TMP_233, notes = nil, max_duration_on_beat = nil, is_new_part = nil, measure_start = nil, size = nil, e = nil, defaultincrement = nil, increment = nil, $writer = nil;
            if (self.conf_beat_resolution == null) self.conf_beat_resolution = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (beat == null) beat = nil;
          
            notes = relevant_beats['$[]'](beat);
            max_duration_on_beat = $send(notes, 'map', [], (TMP_231 = function(n){var self = TMP_231.$$s || this;
if (n == null) n = nil;
            return n.$duration()}, TMP_231.$$s = self, TMP_231.$$arity = 1, TMP_231)).$max();
            is_new_part = $send(notes, 'select', [], (TMP_232 = function(n){var self = TMP_232.$$s || this;
if (n == null) n = nil;
            return n['$first_in_part?']()}, TMP_232.$$s = self, TMP_232.$$arity = 1, TMP_232));
            measure_start = $send(notes, 'select', [], (TMP_233 = function(n){var self = TMP_233.$$s || this;
if (n == null) n = nil;
            return n['$measure_start?']()}, TMP_233.$$s = self, TMP_233.$$arity = 1, TMP_233));
            
            try {
              size = self.conf_beat_resolution * duration_to_style['$[]'](self.$duration_to_id(max_duration_on_beat)).$first()
            } catch ($err) {
              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
                try {
                  $gvars.log.$error("" + "BUG: unsupported duration: " + (max_duration_on_beat) + " on beat " + (beat) + ",  " + (self.$notes_on_beat().$to_json()))
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };;
            defaultincrement = $rb_divide($rb_plus(size, last_size), 2);
            last_size = size;
            increment = defaultincrement;
            if ($truthy(is_new_part['$empty?']())) {
              } else {
              increment = $rb_plus(increment, defaultincrement)
            };
            if ($truthy(measure_start['$empty?']())) {
              } else {
              increment = $rb_plus(increment, $rb_divide(increment, 4))
            };
            increment = $rb_plus(increment, self.$get_minc_factor(notes.$first().$time(), defaultincrement));
            newbeat = $rb_plus(newbeat, increment);
            
            $writer = [beat, newbeat];
            $send(compression_map, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}, TMP_230.$$s = self, TMP_230.$$arity = 1, TMP_230));
          return compression_map;
        }, TMP_Default_compute_beat_compression_0_234.$$arity = 2);
        
        Opal.defn(self, '$compute_beat_compression_1', TMP_Default_compute_beat_compression_1_248 = function $$compute_beat_compression_1(music, layout_lines) {
          var $a, TMP_235, TMP_236, TMP_237, TMP_238, TMP_239, TMP_240, TMP_241, self = this, duration_to_style = nil, conf_min_increment = nil, collision_stack = nil, compression_map = nil, newbeat = nil, nextincrement = nil, last_size = nil, relevant_notes = nil, relevant_sp = nil, relevant_beats = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          duration_to_style = $gvars.conf.$get("layout.DURATION_TO_STYLE");
          conf_min_increment = $rb_times(($truthy($a = $gvars.conf.$get("layout.packer.pack_min_increment")) ? $a : 0), self.conf_beat_resolution);
          collision_stack = $hash2([], {});
          compression_map = $hash2([], {});
          newbeat = 0;
          nextincrement = 0;
          last_size = 0;
          relevant_notes = $send($send($send(layout_lines, 'map', [], (TMP_235 = function(voice_id){var self = TMP_235.$$s || this;
if (voice_id == null) voice_id = nil;
          return music.$voices()['$[]'](voice_id)}, TMP_235.$$s = self, TMP_235.$$arity = 1, TMP_235)), 'inject', [[]], (TMP_236 = function(result, voice){var self = TMP_236.$$s || this;
if (result == null) result = nil;if (voice == null) voice = nil;
          return result.$push(voice)}, TMP_236.$$s = self, TMP_236.$$arity = 2, TMP_236)).$flatten(), 'select', [], (TMP_237 = function(note){var self = TMP_237.$$s || this;
if (note == null) note = nil;
          return note['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable'))}, TMP_237.$$s = self, TMP_237.$$arity = 1, TMP_237));
          relevant_sp = $send($send(relevant_notes, 'select', [], (TMP_238 = function(note){var self = TMP_238.$$s || this;
if (note == null) note = nil;
          return note['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'SynchPoint'))}, TMP_238.$$s = self, TMP_238.$$arity = 1, TMP_238)), 'map', [], (TMP_239 = function(sp){var self = TMP_239.$$s || this;
if (sp == null) sp = nil;
          return sp.$notes()}, TMP_239.$$s = self, TMP_239.$$arity = 1, TMP_239));
          relevant_notes = relevant_notes.$push(relevant_sp).$flatten();
          relevant_beats = $send(relevant_notes, 'group_by', [], (TMP_240 = function(playable){var self = TMP_240.$$s || this;
if (playable == null) playable = nil;
          return playable.$beat()}, TMP_240.$$s = self, TMP_240.$$arity = 1, TMP_240));
          $send(relevant_beats.$keys().$sort(), 'each', [], (TMP_241 = function(beat){var self = TMP_241.$$s || this, TMP_242, TMP_243, TMP_244, TMP_245, TMP_246, TMP_247, notes = nil, max_duration_on_beat = nil, size = nil, e = nil, defaultincrement = nil, collisions = nil, inversions = nil, is_new_part = nil, measure_start = nil, increment = nil, $writer = nil;
            if (self.conf_beat_resolution == null) self.conf_beat_resolution = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (beat == null) beat = nil;
          
            notes = relevant_beats['$[]'](beat);
            max_duration_on_beat = $send(notes, 'map', [], (TMP_242 = function(n){var self = TMP_242.$$s || this;
if (n == null) n = nil;
            return n.$duration()}, TMP_242.$$s = self, TMP_242.$$arity = 1, TMP_242)).$max();
            
            try {
              size = self.conf_beat_resolution * duration_to_style['$[]'](self.$duration_to_id(max_duration_on_beat)).$first()
            } catch ($err) {
              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
                try {
                  $gvars.log.$error("" + "BUG: unsupported duration: " + (max_duration_on_beat) + " on beat " + (beat) + ",  " + (self.$notes_on_beat().$to_json()))
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };;
            defaultincrement = $rb_divide($rb_plus(size, last_size), 2);
            last_size = size;
            collisions = $send(notes, 'select', [], (TMP_243 = function(note){var self = TMP_243.$$s || this, $b;
if (note == null) note = nil;
            
              return $rb_ge(($truthy($b = collision_stack['$[]'](note.$pitch())) ? $b : -1), $rb_minus(newbeat, conf_min_increment));}, TMP_243.$$s = self, TMP_243.$$arity = 1, TMP_243));
            inversions = $send(notes, 'select', [], (TMP_244 = function(note){var self = TMP_244.$$s || this, $b, a = nil, result = nil;
if (note == null) note = nil;
            
              a = [($truthy($b = note.$prev_pitch()) ? $b : note.$pitch()), note.$pitch(), ($truthy($b = note.$next_pitch()) ? $b : note.$pitch())];
              result = ($truthy($b = a.$sort().$reverse()['$=='](a)) ? $b : a.$sort()['$=='](a))['$!']();
              if ($truthy(note.$next_first_in_part())) {
                result = false};
              return result;}, TMP_244.$$s = self, TMP_244.$$arity = 1, TMP_244));
            is_new_part = $send(notes, 'select', [], (TMP_245 = function(n){var self = TMP_245.$$s || this;
if (n == null) n = nil;
            return n['$first_in_part?']()}, TMP_245.$$s = self, TMP_245.$$arity = 1, TMP_245));
            measure_start = $send(notes, 'select', [], (TMP_246 = function(n){var self = TMP_246.$$s || this;
if (n == null) n = nil;
            return n['$measure_start?']()}, TMP_246.$$s = self, TMP_246.$$arity = 1, TMP_246));
            increment = nextincrement;
            nextincrement = conf_min_increment;
            if ($truthy(collisions['$empty?']()['$!']())) {
              increment = defaultincrement
            } else if ($truthy(inversions['$empty?']()['$!']())) {
              
              nextincrement = $rb_divide(defaultincrement, 2);
              increment = nextincrement;};
            if ($truthy(is_new_part['$empty?']())) {
              } else {
              
              increment = $rb_plus(increment, defaultincrement);
              nextincrement = conf_min_increment;
            };
            if ($truthy(measure_start['$empty?']())) {
              } else {
              increment = $rb_plus(increment, $rb_divide(increment, 4))
            };
            increment = $rb_plus(increment, self.$get_minc_factor(notes.$first().$time(), defaultincrement));
            newbeat = $rb_plus(newbeat, increment);
            $send(notes, 'each', [], (TMP_247 = function(note){var self = TMP_247.$$s || this, $writer = nil;
if (note == null) note = nil;
            
              $writer = [note.$pitch(), newbeat];
              $send(collision_stack, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, TMP_247.$$s = self, TMP_247.$$arity = 1, TMP_247));
            
            $writer = [beat, newbeat];
            $send(compression_map, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}, TMP_241.$$s = self, TMP_241.$$arity = 1, TMP_241));
          return compression_map;
        }, TMP_Default_compute_beat_compression_1_248.$$arity = 2);
        
        Opal.defn(self, '$layout_playable', TMP_Default_layout_playable_249 = function $$layout_playable(root, beat_layout, note_conf_base) {
          var self = this, result = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          result = (function() {if ($truthy(root['$is_a?'](Opal.const_get_relative($nesting, 'Note')))) {
            return self.$layout_note(root, beat_layout, "" + (note_conf_base) + ".n_0")
          } else if ($truthy(root['$is_a?'](Opal.const_get_relative($nesting, 'SynchPoint')))) {
            return self.$layout_accord(root, beat_layout, note_conf_base)
          } else if ($truthy(root['$is_a?'](Opal.const_get_relative($nesting, 'Pause')))) {
            return self.$layout_pause(root, beat_layout, "" + (note_conf_base) + ".n_0")
            } else {
            return $gvars.log.$error("" + "BUG: Missing Music -> Sheet transform: " + (root))
          }; return nil; })();
          return result;
        }, TMP_Default_layout_playable_249.$$arity = 3);
        
        Opal.defn(self, '$layout_note', TMP_Default_layout_note_250 = function $$layout_note(root, beat_layout, note_conf_base) {
          var $a, $b, self = this, x_offset = nil, y_offset = nil, dotted = nil, fill = nil, size = nil, flag = nil, shift = nil, color = nil, res = nil, $writer = nil, result = nil, barover_y = nil, reducer = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          x_offset = self.$convert_pitch_to_xpos(root);
          y_offset = beat_layout.$call(root.$beat());
          $b = self.$compute_ellipse_properties_from_note(root), $a = Opal.to_ary($b), (dotted = ($a[0] == null ? nil : $a[0])), (fill = ($a[1] == null ? nil : $a[1])), (size = ($a[2] == null ? nil : $a[2])), (flag = ($a[3] == null ? nil : $a[3])), $b;
          shift = self.$layout_note_shift(root, size, x_offset, dotted, note_conf_base);
          color = self.$compute_color_by_variant_no(root.$variant());
          res = Opal.const_get_relative($nesting, 'Ellipse').$new([$rb_plus(x_offset, shift), y_offset], size, fill, dotted, root);
          
          $writer = [$rb_plus(note_conf_base, ".***")];
          $send(res, 'conf_key=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [res];
          $send(root, 'sheet_drawable=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [color];
          $send(res, 'color=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [$gvars.conf.$get("layout.LINE_THICK")];
          $send(res, 'line_width=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          result = Opal.const_get_relative($nesting, 'CompoundDrawable').$new([res], res);
          if ($truthy(flag)) {
            result.$push(self.$layout_note_flags(x_offset, y_offset, size, shift, color, flag))};
          if ($truthy(root.$measure_start())) {
            
            barover_y = $rb_plus(size.$last(), $gvars.conf.$get("layout.LINE_THICK"));
            if ($truthy($gvars.conf.$get("layout.bottomup"))) {
              barover_y = barover_y['$-@']()};
            reducer = (function() {if ($truthy(($truthy($a = flag) ? $gvars.conf.$get("layout.bottomup")['$!']() : $a))) {
              return $gvars.conf.$get("layout.LINE_THICK")
              } else {
              return 0
            }; return nil; })();
            res = Opal.const_get_relative($nesting, 'Ellipse').$new([$rb_minus($rb_plus(x_offset, shift), reducer), $rb_minus(y_offset, barover_y)], [$rb_minus(size.$first(), reducer), $rb_divide($gvars.conf.$get("layout.LINE_THICK"), 2)], "filled", false, nil, true);
            
            $writer = [color];
            $send(res, 'color=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [$gvars.conf.$get("layout.LINE_THIN")];
            $send(res, 'line_width=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            result.$push(res);};
          return result;
        }, TMP_Default_layout_note_250.$$arity = 3);
        
        Opal.defn(self, '$layout_note_flags', TMP_Default_layout_note_flags_253 = function $$layout_note_flags(x_offset, y_offset, size, shift, color, flag) {
          var $a, TMP_251, TMP_252, self = this, p_beam_x = nil, p_beam_y = nil, linewidth = nil, f_x = nil, f_y = nil, path = nil, p_flag_x = nil, p_flag_y = nil, f_delta_x = nil, f_delta_y = nil, flagpath = nil, res = nil, $writer = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          if (self.instrument_orientation['$==']("horizontal")) {
            
            $a = [$rb_times(2, size['$[]'](1)), 0.1], (p_beam_x = $a[0]), (p_beam_y = $a[1]), $a;
            linewidth = $gvars.conf.$get("layout.LINE_MEDIUM");
            f_x = $rb_plus(x_offset, $rb_divide(shift, 2));
            f_y = $rb_minus($rb_plus(y_offset, size['$[]'](1)), $rb_divide(linewidth, 2));
            path = [["M", f_x, f_y], ["l", p_beam_x, p_beam_y]];
            $a = [$rb_times(-0.6, size['$[]'](0)), $rb_times(0.6, size['$[]'](1))], (p_flag_x = $a[0]), (p_flag_y = $a[1]), $a;
            f_delta_x = p_flag_x;
            f_delta_y = (function() { try {
              return $rb_divide($rb_times(p_beam_y, f_delta_x), p_beam_x)
            } catch ($err) {
              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
                try {
                  return 0
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            }})();
            flagpath = ["l", p_flag_x, p_flag_y];
            $send(flag, 'times', [], (TMP_251 = function(i){var self = TMP_251.$$s || this;
if (i == null) i = nil;
            return (path = $rb_plus(path, [["M", $rb_plus($rb_plus(f_x, p_beam_x), $rb_times(i, f_delta_x)), $rb_plus(f_y, p_beam_y)], flagpath]))}, TMP_251.$$s = self, TMP_251.$$arity = 1, TMP_251));
            } else {
            
            $a = [0.1, $rb_times(2, size['$[]'](1))], (p_beam_x = $a[0]), (p_beam_y = $a[1]), $a;
            linewidth = $gvars.conf.$get("layout.LINE_MEDIUM");
            f_x = $rb_minus($rb_plus($rb_plus(x_offset, shift), size['$[]'](0)), $rb_divide(linewidth, 2));
            f_y = y_offset;
            path = [["M", f_x, f_y], ["l", p_beam_x, p_beam_y['$-@']()]];
            $a = [$rb_times(1.3, size['$[]'](1)), $rb_times(0.6, size['$[]'](1))], (p_flag_x = $a[0]), (p_flag_y = $a[1]), $a;
            f_delta_y = p_flag_y;
            f_delta_x = (function() { try {
              return $rb_divide($rb_times(p_beam_x, f_delta_y), p_beam_y)
            } catch ($err) {
              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
                try {
                  return 0
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            }})();
            flagpath = ["l", p_flag_x, p_flag_y];
            $send(flag, 'times', [], (TMP_252 = function(i){var self = TMP_252.$$s || this;
if (i == null) i = nil;
            return (path = $rb_plus(path, [["M", $rb_minus($rb_plus(f_x, p_beam_x), $rb_times(i, f_delta_x)), $rb_plus($rb_minus(y_offset, p_beam_y), $rb_times(i, f_delta_y))], flagpath]))}, TMP_252.$$s = self, TMP_252.$$arity = 1, TMP_252));
          };
          res = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path').$new(path, "open");
          
          $writer = [linewidth];
          $send(res, 'line_width=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [color];
          $send(res, 'color=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return res;
        }, TMP_Default_layout_note_flags_253.$$arity = 6);
        
        Opal.defn(self, '$convert_pitch_to_xpos', TMP_Default_convert_pitch_to_xpos_254 = function $$convert_pitch_to_xpos(root) {
          var self = this;

          return self.pitch_to_xpos.$call(root.$pitch())
        }, TMP_Default_convert_pitch_to_xpos_254.$$arity = 1);
        
        Opal.defn(self, '$compute_color_by_variant_no', TMP_Default_compute_color_by_variant_no_255 = function $$compute_color_by_variant_no(variant_no) {
          var self = this, result = nil;

          
          if (variant_no['$=='](0)) {
            result = self.color_default
            } else {
            result = (function() {if ($truthy(variant_no['$odd?']())) {
              return self.color_variant1
              } else {
              return self.color_variant2
            }; return nil; })()
          };
          return result;
        }, TMP_Default_compute_color_by_variant_no_255.$$arity = 1);
        
        Opal.defn(self, '$compute_ellipse_properties_from_note', TMP_Default_compute_ellipse_properties_from_note_257 = function $$compute_ellipse_properties_from_note(root) {
          var $a, $b, TMP_256, self = this, scale = nil, fill = nil, dotted = nil, flag = nil, size = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          $b = $gvars.conf.$get("layout.DURATION_TO_STYLE")['$[]'](self.$check_duration(root)), $a = Opal.to_ary($b), (scale = ($a[0] == null ? nil : $a[0])), (fill = ($a[1] == null ? nil : $a[1])), (dotted = ($a[2] == null ? nil : $a[2])), (flag = ($a[3] == null ? nil : $a[3])), $b;
          size = $send($gvars.conf.$get("layout.ELLIPSE_SIZE"), 'map', [], (TMP_256 = function(e){var self = TMP_256.$$s || this;
if (e == null) e = nil;
          return $rb_times(e, scale)}, TMP_256.$$s = self, TMP_256.$$arity = 1, TMP_256));
          return [dotted, fill, size, flag];
        }, TMP_Default_compute_ellipse_properties_from_note_257.$$arity = 1);
        
        Opal.defn(self, '$layout_note_shift', TMP_Default_layout_note_shift_258 = function $$layout_note_shift(root, size, x_offset, dotted, note_conf_base) {
          var self = this, shift = nil, local_key = nil, nshift = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          shift = 0;
          if ($truthy($gvars.conf.$get("layout.limit_a3"))) {
            
            if ($truthy($rb_lt(x_offset, 5))) {
              shift = $rb_plus(shift, size.$first())};
            if ($truthy($rb_gt(x_offset, 415))) {
              
              shift = $rb_plus(shift, size.$first()['$-@']());
              if ($truthy(dotted)) {
                shift = $rb_minus(shift, 1.5)};};};
          if ($truthy(root.$shift())) {
            if (root.$shift()['$[]']("dir")['$=='](-1)) {
              shift = $rb_plus(shift, size.$first()['$-@']())
              } else {
              shift = $rb_plus(shift, size.$first())
            }};
          if ($truthy(note_conf_base)) {
            
            local_key = note_conf_base.$gsub(/extract\.(\d+)\./, "");
            if ($truthy(self.print_options_keys['$include?']("" + (local_key) + ".nshift"))) {
              
              nshift = self.print_options_raw['$[]']("" + (local_key) + ".nshift");
              shift = $rb_times($rb_times(size.$first(), 2), nshift);};};
          return shift;
        }, TMP_Default_layout_note_shift_258.$$arity = 5);
        
        Opal.defn(self, '$layout_accord', TMP_Default_layout_accord_263 = function $$layout_accord(root, beat_layout, note_conf_base) {
          var TMP_259, TMP_260, TMP_261, TMP_262, self = this, res = nil, proxy_drawable = nil, resnotes_sorted = nil;

          
          res = $send(root.$notes().$reverse().$each_with_index(), 'map', [], (TMP_259 = function(c, i){var self = TMP_259.$$s || this;
if (c == null) c = nil;if (i == null) i = nil;
          return self.$layout_note(c, beat_layout, "" + (note_conf_base) + ".n_" + (i))}, TMP_259.$$s = self, TMP_259.$$arity = 2, TMP_259)).$reverse();
          proxy_drawable = root.$get_proxy_object(res).$proxy();
          resnotes_sorted = $send($send(res, 'map', [], (TMP_260 = function(n){var self = TMP_260.$$s || this;
if (n == null) n = nil;
          return n.$proxy()}, TMP_260.$$s = self, TMP_260.$$arity = 1, TMP_260)), 'sort_by', [], (TMP_261 = function(n){var self = TMP_261.$$s || this;
if (n == null) n = nil;
          return n.$center().$first()}, TMP_261.$$s = self, TMP_261.$$arity = 1, TMP_261));
          res = $send(res, 'map', [], (TMP_262 = function(n){var self = TMP_262.$$s || this;
if (n == null) n = nil;
          return n.$shapes()}, TMP_262.$$s = self, TMP_262.$$arity = 1, TMP_262));
          res.$unshift(Opal.const_get_relative($nesting, 'FlowLine').$new(resnotes_sorted.$first(), resnotes_sorted.$last(), "dashed"));
          return Opal.const_get_relative($nesting, 'CompoundDrawable').$new(res, proxy_drawable);
        }, TMP_Default_layout_accord_263.$$arity = 3);
        
        Opal.defn(self, '$layout_pause', TMP_Default_layout_pause_264 = function $$layout_pause(root, beat_layout, note_conf_base) {
          var $a, $b, self = this, x_offset = nil, y_offset = nil, scale = nil, glyph = nil, dotted = nil, rest_size = nil, size = nil, shift = nil, color = nil, res = nil, $writer = nil, result = nil, barover_y = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          x_offset = self.$convert_pitch_to_xpos(root);
          y_offset = beat_layout.$call(root.$beat());
          $b = $gvars.conf.$get("layout.REST_TO_GLYPH")['$[]'](self.$check_duration(root)), $a = Opal.to_ary($b), (scale = ($a[0] == null ? nil : $a[0])), (glyph = ($a[1] == null ? nil : $a[1])), (dotted = ($a[2] == null ? nil : $a[2])), $b;
          rest_size = $gvars.conf.$get("layout.REST_SIZE");
          size = [$rb_times(rest_size.$first(), scale.$first()), $rb_times(rest_size.$last(), scale.$last())];
          shift = self.$layout_note_shift(root, size, x_offset, dotted, note_conf_base);
          color = self.$compute_color_by_variant_no(root.$variant());
          res = nil;
          res = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Glyph').$new([$rb_plus(x_offset, shift), y_offset], size, glyph, dotted, root);
          
          $writer = [$rb_plus(note_conf_base, ".***")];
          $send(res, 'conf_key=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [res];
          $send(root, 'sheet_drawable=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [color];
          $send(res, 'color=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [$gvars.conf.$get("layout.LINE_THICK")];
          $send(res, 'line_width=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(root['$visible?']())) {
            } else {
            
            $writer = [false];
            $send(res, 'visible=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          result = Opal.const_get_relative($nesting, 'CompoundDrawable').$new([res], res);
          if ($truthy(root.$measure_start())) {
            
            barover_y = $rb_plus(size.$last(), $gvars.conf.$get("layout.LINE_THICK"));
            if ($truthy($gvars.conf.$get("layout.bottomup"))) {
              barover_y = barover_y['$-@']()};
            res = Opal.const_get_relative($nesting, 'Ellipse').$new([$rb_plus(x_offset, shift), $rb_minus(y_offset, barover_y)], [size.$first(), $rb_divide($gvars.conf.$get("layout.LINE_THICK"), 2)], "filled", false, nil, true);
            
            $writer = [color];
            $send(res, 'color=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [$gvars.conf.$get("layout.LINE_THIN")];
            $send(res, 'line_width=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if ($truthy(root['$visible?']())) {
              } else {
              
              $writer = [false];
              $send(res, 'visible=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
            result.$push(res);};
          return result;
        }, TMP_Default_layout_pause_264.$$arity = 3);
        Opal.defs(self, '$make_path_from_jumpline', TMP_Default_make_path_from_jumpline_265 = function $$make_path_from_jumpline(arg) {
          var $a, $b, self = this, anchorx = nil, anchory = nil, from = nil, from_offset = nil, from_anchor = nil, to = nil, to_offset = nil, to_anchor = nil, verticalpos = nil, vertical_anchor = nil, start_of_vertical = nil, end_of_vertical = nil, start_orientation = nil, end_orientation = nil, start_offset = nil, end_offset = nil, p1 = nil, p2 = nil, p3 = nil, p4 = nil, p4_line = nil, a1 = nil, a2 = nil, a3 = nil, rp2 = nil, rp3 = nil, rp4 = nil, ra1 = nil, ra2 = nil, ra3 = nil, path = nil;

          
          $b = arg['$[]']("jumpline_anchor"), $a = Opal.to_ary($b), (anchorx = ($a[0] == null ? nil : $a[0])), (anchory = ($a[1] == null ? nil : $a[1])), $b;
          from = self.$Vector2d(arg['$[]']("from")['$[]']("center"));
          from_offset = $rb_plus(self.$Vector2d(arg['$[]']("from")['$[]']("size")), [anchorx, anchory]);
          from_anchor = (function() {if (arg['$[]']("from")['$[]']("anchor")['$==']("before")) {
            return -1
            } else {
            return 1
          }; return nil; })();
          to = self.$Vector2d(arg['$[]']("to")['$[]']("center"));
          to_offset = $rb_plus(self.$Vector2d(arg['$[]']("to")['$[]']("size")), [anchorx, anchory]);
          to_anchor = (function() {if (arg['$[]']("to")['$[]']("anchor")['$==']("before")) {
            return -1
            } else {
            return 1
          }; return nil; })();
          verticalpos = arg['$[]']("vertical");
          vertical_anchor = from;
          if (arg['$[]']("vertical_anchor")['$==']("to")) {
            vertical_anchor = to};
          start_of_vertical = self.$Vector2d($rb_plus(vertical_anchor.$x(), verticalpos), from.$y());
          end_of_vertical = self.$Vector2d($rb_plus(vertical_anchor.$x(), verticalpos), to.$y());
          start_orientation = self.$Vector2d($rb_times($rb_minus(start_of_vertical, from), [1, 0]).$normalize().$x(), 0);
          end_orientation = self.$Vector2d($rb_times($rb_minus(end_of_vertical, to), [1, 0]).$normalize().$x(), 0);
          start_offset = $rb_times(from_offset, [start_orientation.$x(), from_anchor]);
          end_offset = $rb_times(to_offset, [end_orientation.$x(), to_anchor]);
          start_of_vertical = $rb_plus(start_of_vertical, $rb_times(start_offset, [0, 1]));
          end_of_vertical = $rb_plus(end_of_vertical, $rb_times(end_offset, [0, 1]));
          p1 = $rb_plus(from, start_offset);
          p2 = start_of_vertical;
          p3 = end_of_vertical;
          p4 = $rb_plus(to, end_offset);
          p4_line = $rb_plus($rb_plus(to, end_offset), $rb_times(end_orientation, [2, 0]));
          a1 = $rb_plus($rb_plus(p4, $rb_times(end_orientation, 2.5)), [0, 1]);
          a2 = $rb_minus($rb_plus(p4, $rb_times(end_orientation, 2.5)), [0, 1]);
          a3 = p4;
          rp2 = $rb_minus(p2, p1);
          rp3 = $rb_minus(p3, p2);
          rp4 = $rb_minus(p4_line, p3);
          ra1 = $rb_minus(a1, p4);
          ra2 = $rb_minus(a2, a1);
          ra3 = $rb_minus(p4, a2);
          path = [[["M", p1.$x(), p1.$y()], ["l", rp2.$x(), rp2.$y()], ["l", rp3.$x(), rp3.$y()], ["l", rp4.$x(), rp4.$y()]], [["M", p4.$x(), p4.$y()], ["l", ra1.$x(), ra1.$y()], ["l", ra2.$x(), ra2.$y()], ["l", ra3.$x(), ra3.$y()], ["z"]]];
          return path;
        }, TMP_Default_make_path_from_jumpline_265.$$arity = 1);
        
        Opal.defn(self, '$duration_to_id', TMP_Default_duration_to_id_266 = function $$duration_to_id(duration) {
          var self = this, result = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          result = (("" + "d") + (duration)).$to_sym();
          if ($truthy($gvars.conf.$get("layout.DURATION_TO_STYLE")['$[]'](result)['$nil?']())) {
            result = "err"};
          return result;
        }, TMP_Default_duration_to_id_266.$$arity = 1);
        
        Opal.defn(self, '$check_duration', TMP_Default_check_duration_267 = function $$check_duration(root) {
          var self = this, result = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          result = self.$duration_to_id(root.$duration());
          if ($truthy(result['$===']("err"))) {
            $gvars.log.$error("" + "unsupported duration at " + (root.$start_pos_to_s()), root.$start_pos(), root.$end_pos())};
          return result;
        }, TMP_Default_check_duration_267.$$arity = 1);
        
        Opal.defn(self, '$make_sheetmark_path', TMP_Default_make_sheetmark_path_269 = function $$make_sheetmark_path(note) {
          var TMP_268, self = this, w = nil, h = nil, base = nil, vpath = nil, path = nil;

          
          w = 0.5;
          h = 5;
          base = $rb_minus(self.$Vector2d(note), [w, $rb_divide(h, 2)]);
          vpath = [self.$Vector2d(w, $rb_times(2, w)['$-@']()), self.$Vector2d(w, $rb_times(2, w)), self.$Vector2d(0, h), self.$Vector2d(w['$-@'](), $rb_times(2, w)), self.$Vector2d(w['$-@'](), $rb_times(-2, w)), self.$Vector2d(0, h['$-@']())];
          path = [["M", base.$x(), base.$y()]];
          $send(vpath, 'each', [], (TMP_268 = function(p){var self = TMP_268.$$s || this;
if (p == null) p = nil;
          return path['$<<'](["l", p.$x(), p.$y()])}, TMP_268.$$s = self, TMP_268.$$arity = 1, TMP_268));
          return path;
        }, TMP_Default_make_sheetmark_path_269.$$arity = 1);
        
        Opal.defn(self, '$make_slur_path', TMP_Default_make_slur_path_270 = function $$make_slur_path(p1, p2) {
          var self = this, deltap = nil, cp_template = nil, cp1 = nil, cp2 = nil, slurpath = nil;

          
          deltap = $rb_minus(p2, p1);
          cp_template = self.$Vector2d($rb_times(0.3, deltap.$length()), 0).$rotate(deltap.$angle());
          cp1 = cp_template.$rotate(-0.4);
          cp2 = $rb_plus(deltap, cp_template.$reverse().$rotate(0.4));
          slurpath = [["M", p1.$x(), p1.$y()], ["c", cp1.$x(), cp1.$y(), cp2.$x(), cp2.$y(), deltap.$x(), deltap.$y()]];
          return slurpath;
        }, TMP_Default_make_slur_path_270.$$arity = 2);
        
        Opal.defn(self, '$make_annotated_bezier_path', TMP_Default_make_annotated_bezier_path_271 = function $$make_annotated_bezier_path(points, tuplet_options) {
          var $a, self = this, p1 = nil, p2 = nil, deltap = nil, cp_template1 = nil, cp_template2 = nil, rotate_by = nil, cp1 = nil, cp2 = nil, cpa1 = nil, cpa2 = nil, cpm1 = nil, cpm2 = nil, cpmm = nil, cpmm1 = nil, cpmm2 = nil, annotation_normal = nil, annotation_anchor = nil, start = nil, curve = nil, line = nil, slurpath = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          p1 = points.$first();
          p2 = points.$last();
          deltap = $rb_minus(p2, p1);
          cp_template1 = self.$Vector2d(tuplet_options['$[]']("cp1"));
          cp_template2 = self.$Vector2d(tuplet_options['$[]']("cp2"));
          rotate_by = $rb_times(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Math'), 'PI'), -0.5);
          cp1 = cp_template1.$rotate(deltap.$angle()).$rotate(rotate_by);
          cp2 = cp_template2.$rotate(deltap.$angle()).$rotate(rotate_by);
          cp2 = $rb_plus(deltap, cp2);
          $gvars.log.$debug("" + (cp1.$to_s()) + " - " + (cp2.$to_s()));
          cpa1 = $rb_plus(p1, cp1);
          cpa2 = $rb_plus(p1, cp2);
          cpm1 = $rb_divide($rb_plus(p1, cpa1), 2);
          cpm2 = $rb_divide($rb_plus(p2, cpa2), 2);
          cpmm = $rb_divide($rb_plus(cpa1, cpa2), 2);
          cpmm1 = $rb_divide($rb_plus(cpm1, cpmm), 2);
          cpmm2 = $rb_divide($rb_plus(cpm2, cpmm), 2);
          if (cpmm1['$=='](cpmm2)) {
            annotation_normal = self.$Vector2d([0, 0])
            } else {
            annotation_normal = $rb_minus(cpmm1, cpmm2).$perpendicular().$normalize()
          };
          if ($truthy(($truthy($a = $rb_le(cpa1.$x(), p1.$x())) ? $rb_le(p1.$x(), p2.$x()) : $a))) {
            annotation_anchor = $rb_minus($rb_plus($rb_divide($rb_plus(cpmm1, cpmm2), 2), $rb_times(annotation_normal, -2)), [2, 0])
            } else {
            annotation_anchor = $rb_plus($rb_divide($rb_plus(cpmm1, cpmm2), 2), $rb_times(annotation_normal, 2))
          };
          annotation_anchor = $rb_plus(annotation_anchor, [0, -2]);
          start = [["M", p1.$x(), p1.$y()]];
          curve = [["c", cp1.$x(), cp1.$y(), cp2.$x(), cp2.$y(), deltap.$x(), deltap.$y()]];
          line = [["l", cp1.$x(), cp1.$y()], ["L", cpa2.$x(), cpa2.$y()], ["L", p2.$x(), p2.$y()]];
          slurpath = [];
          if ($truthy(tuplet_options['$[]']("shape")['$include?']("c"))) {
            slurpath = $rb_plus(slurpath, $rb_plus(start, curve))};
          if ($truthy(tuplet_options['$[]']("shape")['$include?']("l"))) {
            slurpath = $rb_plus(slurpath, $rb_plus(start, line))};
          return [slurpath, annotation_anchor, cpa1, cpa2];
        }, TMP_Default_make_annotated_bezier_path_271.$$arity = 2);
        return (Opal.defn(self, '$resolve_placeholder', TMP_Default_resolve_placeholder_273 = function $$resolve_placeholder(text, parameter) {
          var TMP_272, self = this, result = nil, keys = nil;

          
          result = text;
          keys = result.$scan(/\{\{([^\}]+)\}\}/);
          $send(keys, 'each', [], (TMP_272 = function(key){var self = TMP_272.$$s || this, value = nil;
            if (self.placeholders == null) self.placeholders = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (key == null) key = nil;
          
            value = self.placeholders['$[]'](key.$first());
            if ($truthy(value)) {
              
              text = value.$call();
              if ($truthy(text)) {
                } else {
                
                $gvars.log.$error("" + (Opal.const_get_relative($nesting, 'I18n').$t("no placeholder value found in ")) + " in '" + (parameter) + "': '" + (key.$first()) + "'");
                text = "";
              };
              return (result = result.$gsub("" + "{{" + (key) + "}}", text));
              } else {
              return $gvars.log.$error("" + (Opal.const_get_relative($nesting, 'I18n').$t("wrong placeholder: ")) + " in '" + (parameter) + "': '" + (key.$first()) + "'")
            };}, TMP_272.$$s = self, TMP_272.$$arity = 1, TMP_272));
          return result;
        }, TMP_Default_resolve_placeholder_273.$$arity = 2), nil) && 'resolve_placeholder';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["abc_to_harpnotes_factory"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$===', '$new', '$error', '$split', '$[]', '$count', '$length', '$last', '$each', '$match', '$parse', '$[]=', '$-', '$first', '$<<', '$message', '$+', '$inject', '$each_with_index', '$include?', '$t', '$strip', '$==', '$get_metadata', '$map', '$select', '$nil?', '$join', '$compact', '$flatten']);
  return (function($base, $parent_nesting) {
    var $Harpnotes, self = $Harpnotes = $module($base, 'Harpnotes');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Input, self = $Input = $module($base, 'Input');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      
      (function($base, $super, $parent_nesting) {
        function $ABCToHarpnotesFactory(){};
        var self = $ABCToHarpnotesFactory = $klass($base, $super, 'ABCToHarpnotesFactory', $ABCToHarpnotesFactory);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ABCToHarpnotesFactory_create_engine_1;

        return Opal.defs(self, '$create_engine', TMP_ABCToHarpnotesFactory_create_engine_1 = function $$create_engine(engine) {
          var self = this, $case = nil, result = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          $case = engine;
          if ("ABC2SVG"['$===']($case)) {result = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Input'), 'Abc2svgToHarpnotes').$new()}
          else {
          $gvars.log.$error("" + "Undefined abc parser: " + (engine));
          result = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Input'), 'Abc2svgToHarpnotes').$new();};
          return result;
        }, TMP_ABCToHarpnotesFactory_create_engine_1.$$arity = 1)
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $AbstractAbcToHarpnotes(){};
        var self = $AbstractAbcToHarpnotes = $klass($base, $super, 'AbstractAbcToHarpnotes', $AbstractAbcToHarpnotes);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_AbstractAbcToHarpnotes_initialize_2, TMP_AbstractAbcToHarpnotes_charpos_to_line_column_3, TMP_AbstractAbcToHarpnotes_parse_harpnote_config_6, TMP_AbstractAbcToHarpnotes_get_metadata_9, TMP_AbstractAbcToHarpnotes_add_metadata_12;

        def.abc_code = nil;
        
        
        Opal.defn(self, '$initialize', TMP_AbstractAbcToHarpnotes_initialize_2 = function $$initialize() {
          var self = this;

          
          self.abc_code = nil;
          return (self.previous_new_part = []);
        }, TMP_AbstractAbcToHarpnotes_initialize_2.$$arity = 0);
        
        Opal.defn(self, '$charpos_to_line_column', TMP_AbstractAbcToHarpnotes_charpos_to_line_column_3 = function $$charpos_to_line_column(charpos) {
          var $a, self = this, cleancharpos = nil, lines = nil, line_no = nil, char_pos = nil;

          
          cleancharpos = ($truthy($a = charpos) ? $a : 1);
          lines = self.abc_code['$[]'](1, cleancharpos).$split("\n");
          line_no = lines.$count();
          char_pos = lines.$last().$length();
          return [line_no, char_pos];
        }, TMP_AbstractAbcToHarpnotes_charpos_to_line_column_3.$$arity = 1);
        
        Opal.defn(self, '$parse_harpnote_config', TMP_AbstractAbcToHarpnotes_parse_harpnote_config_6 = function $$parse_harpnote_config(abc_code) {
          var TMP_4, self = this, hn_config_from_song = nil, line_no = nil, $writer = nil;

          
          hn_config_from_song = $hash2([], {});
          line_no = 1;
          $send(abc_code.$split("\n"), 'each', [], (TMP_4 = function(line){var self = TMP_4.$$s || this, TMP_5, $a, entry = nil, parsed_entry = nil, $writer = nil, e = nil, message = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (line == null) line = nil;
          
            entry = $send(line, 'match', [/^%%%%hn\.(print|legend|note|annotation|lyrics) (.*)/], (TMP_5 = function(m){var self = TMP_5.$$s || this;
if (m == null) m = nil;
            return [m['$[]'](1), m['$[]'](2)]}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
            if ($truthy(entry)) {
              
              try {
                
                parsed_entry = Opal.const_get_relative($nesting, 'JSON').$parse(entry.$last());
                
                $writer = ["line_no", line_no];
                $send(parsed_entry, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                ($truthy($a = hn_config_from_song['$[]'](entry.$first())) ? $a : (($writer = [entry.$first(), []]), $send(hn_config_from_song, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
                hn_config_from_song['$[]'](entry.$first())['$<<'](parsed_entry);
              } catch ($err) {
                if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
                  try {
                    
                    message = "" + "error in harpnote commands: " + (e.$message()) + " [" + (line_no) + ":" + (entry) + "]";
                    $gvars.log.$error(message, [line_no, 1], [line_no, 2]);
                  } finally { Opal.pop_exception() }
                } else { throw $err; }
              };};
            return (line_no = $rb_plus(line_no, 1));}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));
          if ($truthy(hn_config_from_song['$[]']("legend"))) {
            
            $writer = ["legend", hn_config_from_song['$[]']("legend").$first()];
            $send(hn_config_from_song, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy(hn_config_from_song['$[]']("lyrics"))) {
            
            $writer = ["lyrics", hn_config_from_song['$[]']("lyrics").$first()];
            $send(hn_config_from_song, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          return hn_config_from_song;
        }, TMP_AbstractAbcToHarpnotes_parse_harpnote_config_6.$$arity = 1);
        
        Opal.defn(self, '$get_metadata', TMP_AbstractAbcToHarpnotes_get_metadata_9 = function $$get_metadata(abc_code) {
          var TMP_7, self = this, retval = nil;

          
          retval = $send(abc_code.$split("\n").$each_with_index(), 'inject', [$hash2([], {})], (TMP_7 = function(result, $a){var self = TMP_7.$$s || this, $a_args, line, index, TMP_8, entry = nil, key = nil, filename = nil, $writer = nil;
            if ($gvars.log == null) $gvars.log = nil;

            if ($a == null) {
              $a = nil;
            }
            $a = Opal.to_ary($a);
            $a_args = Opal.slice.call($a, 0, $a.length);
            line = $a_args.splice(0,1)[0];
            if (line == null) {
              line = nil;
            }
            index = $a_args.splice(0,1)[0];
            if (index == null) {
              index = nil;
            }if (result == null) result = nil;
          
            entry = $send(line, 'match', [/^([A-Z]):\s*(.*)/], (TMP_8 = function(m){var self = TMP_8.$$s || this;
if (m == null) m = nil;
            return [m['$[]'](1), m['$[]'](2)]}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));
            if ($truthy(entry)) {
              
              key = entry.$first();
              if ($truthy(result['$[]'](key))) {
                
                if ($truthy(["F", "X"]['$include?'](key))) {
                  $gvars.log.$error("" + (Opal.const_get_relative($nesting, 'I18n').$t("more than one line found for ")) + " ':" + (key) + "'", [$rb_plus(index, 1), 1])};
                result['$[]'](key)['$<<'](entry.$last().$strip());
                } else {
                
                if (key['$==']("F")) {
                  
                  filename = entry.$last().$strip();
                  if ($truthy(filename['$include?']("{{"))) {
                  } else if ($truthy(filename.$match(/^[a-zA-z0-9_\-\.]+$/))) {
                    } else {
                    $gvars.log.$error("" + "\"" + (filename) + "\": " + (Opal.const_get_relative($nesting, 'I18n').$t("bad characters in filename")), [$rb_plus(index, 1), 1])
                  };};
                
                $writer = [key, [entry.$last().$strip()]];
                $send(result, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
              };};
            return result;}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7.$$has_top_level_mlhs_arg = true, TMP_7));
          return retval;
        }, TMP_AbstractAbcToHarpnotes_get_metadata_9.$$arity = 1);
        return (Opal.defn(self, '$add_metadata', TMP_AbstractAbcToHarpnotes_add_metadata_12 = function $$add_metadata(abc_code, new_metadata) {
          var TMP_10, TMP_11, self = this, old_metadata = nil, more_metadata = nil;

          
          old_metadata = self.$get_metadata(abc_code);
          more_metadata = $send($send(new_metadata, 'select', [], (TMP_10 = function(k, v){var self = TMP_10.$$s || this;
if (k == null) k = nil;if (v == null) v = nil;
          return old_metadata['$[]'](k)['$nil?']()}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10)), 'map', [], (TMP_11 = function(k, v){var self = TMP_11.$$s || this;
if (k == null) k = nil;if (v == null) v = nil;
          return "" + (k) + ":" + (v)}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11));
          return [more_metadata, abc_code].$flatten().$compact().$join("\n");
        }, TMP_AbstractAbcToHarpnotes_add_metadata_12.$$arity = 2), nil) && 'add_metadata';
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["native"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2, $klass = Opal.klass, $gvars = Opal.gvars;

  Opal.add_stubs(['$try_convert', '$native?', '$respond_to?', '$to_n', '$raise', '$inspect', '$Native', '$proc', '$map!', '$end_with?', '$define_method', '$[]', '$convert', '$call', '$to_proc', '$new', '$each', '$native_reader', '$native_writer', '$extend', '$is_a?', '$map', '$alias_method', '$to_a', '$_Array', '$include', '$method_missing', '$bind', '$instance_method', '$slice', '$-', '$length', '$[]=', '$enum_for', '$===', '$>=', '$<<', '$each_pair', '$_initialize', '$name', '$exiting_mid', '$native_module']);
  
  (function($base, $parent_nesting) {
    var $Native, self = $Native = $module($base, 'Native');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Native_is_a$q_1, TMP_Native_try_convert_2, TMP_Native_convert_3, TMP_Native_call_4, TMP_Native_proc_5, TMP_Native_included_19, TMP_Native_initialize_20, TMP_Native_to_n_21;

    
    Opal.defs(self, '$is_a?', TMP_Native_is_a$q_1 = function(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    }, TMP_Native_is_a$q_1.$$arity = 2);
    Opal.defs(self, '$try_convert', TMP_Native_try_convert_2 = function $$try_convert(value, default$) {
      var self = this;

      if (default$ == null) {
        default$ = nil;
      }
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    
    }, TMP_Native_try_convert_2.$$arity = -2);
    Opal.defs(self, '$convert', TMP_Native_convert_3 = function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    }, TMP_Native_convert_3.$$arity = 1);
    Opal.defs(self, '$call', TMP_Native_call_4 = function $$call(obj, key, $a_rest) {
      var self = this, args, $iter = TMP_Native_call_4.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 2;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 2; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 2] = arguments[$arg_idx];
      }
      if ($iter) TMP_Native_call_4.$$p = null;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    
    }, TMP_Native_call_4.$$arity = -3);
    Opal.defs(self, '$proc', TMP_Native_proc_5 = function $$proc() {
      var TMP_6, self = this, $iter = TMP_Native_proc_5.$$p, block = $iter || nil;

      if ($iter) TMP_Native_proc_5.$$p = null;
      
      if ($truthy(block)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'LocalJumpError'), "no block given")
      };
      return $send(Opal.const_get_qualified('::', 'Kernel'), 'proc', [], (TMP_6 = function($a_rest){var self = TMP_6.$$s || this, args, TMP_7, instance = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
      
        $send(args, 'map!', [], (TMP_7 = function(arg){var self = TMP_7.$$s || this;
if (arg == null) arg = nil;
        return self.$Native(arg)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, TMP_6.$$s = self, TMP_6.$$arity = -1, TMP_6));
    }, TMP_Native_proc_5.$$arity = 0);
    (function($base, $parent_nesting) {
      var $Helpers, self = $Helpers = $module($base, 'Helpers');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Helpers_alias_native_11, TMP_Helpers_native_reader_14, TMP_Helpers_native_writer_17, TMP_Helpers_native_accessor_18;

      
      
      Opal.defn(self, '$alias_native', TMP_Helpers_alias_native_11 = function $$alias_native(new$, $old, $kwargs) {
        var TMP_8, TMP_9, TMP_10, self = this, $post_args, as, old;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        $kwargs = Opal.extract_kwargs($post_args);
        if ($kwargs == null || !$kwargs.$$is_hash) {
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else {
            throw Opal.ArgumentError.$new('expected kwargs');
          }
        }
        as = $kwargs.$$smap["as"];
        if (as == null) {
          as = nil
        }
        if (0 < $post_args.length) {
          old = $post_args.splice(0,1)[0];
        }
        if (old == null) {
          old = new$;
        }
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], (TMP_8 = function(value){var self = TMP_8.$$s || this;
            if (self["native"] == null) self["native"] = nil;
if (value == null) value = nil;
          
            self["native"][old['$[]']($range(0, -2, false))] = Opal.const_get_relative($nesting, 'Native').$convert(value);
            return value;}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], (TMP_9 = function($a_rest){var self = TMP_9.$$s || this, block, args, value = nil;
            if (self["native"] == null) self["native"] = nil;

            block = TMP_9.$$p || nil;
            if (block) TMP_9.$$p = null;
            var $args_len = arguments.length, $rest_len = $args_len - 0;
            if ($rest_len < 0) { $rest_len = 0; }
            args = new Array($rest_len);
            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
              args[$arg_idx - 0] = arguments[$arg_idx];
            }
          if ($truthy((value = $send(Opal.const_get_relative($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc())))) {
              return as.$new(value.$to_n())
              } else {
              return nil
            }}, TMP_9.$$s = self, TMP_9.$$arity = -1, TMP_9))
          } else {
          return $send(self, 'define_method', [new$], (TMP_10 = function($a_rest){var self = TMP_10.$$s || this, block, args;
            if (self["native"] == null) self["native"] = nil;

            block = TMP_10.$$p || nil;
            if (block) TMP_10.$$p = null;
            var $args_len = arguments.length, $rest_len = $args_len - 0;
            if ($rest_len < 0) { $rest_len = 0; }
            args = new Array($rest_len);
            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
              args[$arg_idx - 0] = arguments[$arg_idx];
            }
          return $send(Opal.const_get_relative($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc())}, TMP_10.$$s = self, TMP_10.$$arity = -1, TMP_10))
        }
      }, TMP_Helpers_alias_native_11.$$arity = -2);
      
      Opal.defn(self, '$native_reader', TMP_Helpers_native_reader_14 = function $$native_reader($a_rest) {
        var TMP_12, self = this, names;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        names = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          names[$arg_idx - 0] = arguments[$arg_idx];
        }
        return $send(names, 'each', [], (TMP_12 = function(name){var self = TMP_12.$$s || this, TMP_13;
if (name == null) name = nil;
        return $send(self, 'define_method', [name], (TMP_13 = function(){var self = TMP_13.$$s || this;
            if (self["native"] == null) self["native"] = nil;

          return self.$Native(self["native"][name])}, TMP_13.$$s = self, TMP_13.$$arity = 0, TMP_13))}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12))
      }, TMP_Helpers_native_reader_14.$$arity = -1);
      
      Opal.defn(self, '$native_writer', TMP_Helpers_native_writer_17 = function $$native_writer($a_rest) {
        var TMP_15, self = this, names;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        names = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          names[$arg_idx - 0] = arguments[$arg_idx];
        }
        return $send(names, 'each', [], (TMP_15 = function(name){var self = TMP_15.$$s || this, TMP_16;
if (name == null) name = nil;
        return $send(self, 'define_method', ["" + (name) + "="], (TMP_16 = function(value){var self = TMP_16.$$s || this;
            if (self["native"] == null) self["native"] = nil;
if (value == null) value = nil;
          return self.$Native(self["native"][name] = value)}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16))}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15))
      }, TMP_Helpers_native_writer_17.$$arity = -1);
      
      Opal.defn(self, '$native_accessor', TMP_Helpers_native_accessor_18 = function $$native_accessor($a_rest) {
        var self = this, names;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        names = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          names[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        $send(self, 'native_reader', Opal.to_a(names));
        return $send(self, 'native_writer', Opal.to_a(names));
      }, TMP_Helpers_native_accessor_18.$$arity = -1);
    })($nesting[0], $nesting);
    Opal.defs(self, '$included', TMP_Native_included_19 = function $$included(klass) {
      var self = this;

      return klass.$extend(Opal.const_get_relative($nesting, 'Helpers'))
    }, TMP_Native_included_19.$$arity = 1);
    
    Opal.defn(self, '$initialize', TMP_Native_initialize_20 = function $$initialize(native$) {
      var self = this;

      
      if ($truthy(Opal.const_get_qualified('::', 'Kernel')['$native?'](native$))) {
        } else {
        Opal.const_get_qualified('::', 'Kernel').$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + (native$.$inspect()) + " isn't native")
      };
      return (self["native"] = native$);
    }, TMP_Native_initialize_20.$$arity = 1);
    
    Opal.defn(self, '$to_n', TMP_Native_to_n_21 = function $$to_n() {
      var self = this;
      if (self["native"] == null) self["native"] = nil;

      return self["native"]
    }, TMP_Native_to_n_21.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var $Kernel, self = $Kernel = $module($base, 'Kernel');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_native$q_22, TMP_Kernel_Native_25, TMP_Kernel_Array_26;

    
    
    Opal.defn(self, '$native?', TMP_Kernel_native$q_22 = function(value) {
      var self = this;

      return value == null || !value.$$class
    }, TMP_Kernel_native$q_22.$$arity = 1);
    
    Opal.defn(self, '$Native', TMP_Kernel_Native_25 = function $$Native(obj) {
      var TMP_23, TMP_24, self = this;

      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
        return $send(obj, 'map', [], (TMP_23 = function(o){var self = TMP_23.$$s || this;
if (o == null) o = nil;
        return self.$Native(o)}, TMP_23.$$s = self, TMP_23.$$arity = 1, TMP_23))
      } else if ($truthy(obj['$is_a?'](Opal.const_get_relative($nesting, 'Proc')))) {
        return $send(self, 'proc', [], (TMP_24 = function($a_rest){var self = TMP_24.$$s || this, block, args;

          block = TMP_24.$$p || nil;
          if (block) TMP_24.$$p = null;
          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
        return self.$Native($send(obj, 'call', Opal.to_a(args), block.$to_proc()))}, TMP_24.$$s = self, TMP_24.$$arity = -1, TMP_24))
        } else {
        return obj
      }
    }, TMP_Kernel_Native_25.$$arity = 1);
    self.$alias_method("_Array", "Array");
    
    Opal.defn(self, '$Array', TMP_Kernel_Array_26 = function $$Array(object, $a_rest) {
      var self = this, args, $iter = TMP_Kernel_Array_26.$$p, block = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      if ($iter) TMP_Kernel_Array_26.$$p = null;
      
      if ($truthy(self['$native?'](object))) {
        return $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Native'), 'Array'), 'new', [object].concat(Opal.to_a(args)), block.$to_proc()).$to_a()};
      return self.$_Array(object);
    }, TMP_Kernel_Array_26.$$arity = -2);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $Object(){};
    var self = $Object = $klass($base, $super, 'Object', $Object);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Object_$eq$eq_27, TMP_Object_has_key$q_28, TMP_Object_each_29, TMP_Object_$$_30, TMP_Object_$$$eq_31, TMP_Object_merge$B_32, TMP_Object_respond_to$q_33, TMP_Object_respond_to_missing$q_34, TMP_Object_method_missing_35, TMP_Object_nil$q_36, TMP_Object_is_a$q_37, TMP_Object_instance_of$q_38, TMP_Object_class_39, TMP_Object_to_a_40, TMP_Object_inspect_41;

    def["native"] = nil;
    
    self.$include(Opal.const_get_qualified('::', 'Native'));
    
    Opal.defn(self, '$==', TMP_Object_$eq$eq_27 = function(other) {
      var self = this;

      return self["native"] === Opal.const_get_qualified('::', 'Native').$try_convert(other)
    }, TMP_Object_$eq$eq_27.$$arity = 1);
    
    Opal.defn(self, '$has_key?', TMP_Object_has_key$q_28 = function(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    }, TMP_Object_has_key$q_28.$$arity = 1);
    Opal.alias(self, "key?", "has_key?");
    Opal.alias(self, "include?", "has_key?");
    Opal.alias(self, "member?", "has_key?");
    
    Opal.defn(self, '$each', TMP_Object_each_29 = function $$each($a_rest) {
      var self = this, args, $iter = TMP_Object_each_29.$$p, $yield = $iter || nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      if ($iter) TMP_Object_each_29.$$p = null;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
        } else {
        return $send(self, 'method_missing', ["each"].concat(Opal.to_a(args)))
      }
    }, TMP_Object_each_29.$$arity = -1);
    
    Opal.defn(self, '$[]', TMP_Object_$$_30 = function(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return Opal.const_get_qualified('::', 'Native').$call(self["native"], key)
      }
    
    }, TMP_Object_$$_30.$$arity = 1);
    
    Opal.defn(self, '$[]=', TMP_Object_$$$eq_31 = function(key, value) {
      var self = this, native$ = nil;

      
      native$ = Opal.const_get_qualified('::', 'Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
        } else {
        return self["native"][key] = native$
      };
    }, TMP_Object_$$$eq_31.$$arity = 2);
    
    Opal.defn(self, '$merge!', TMP_Object_merge$B_32 = function(other) {
      var self = this;

      
      
      other = Opal.const_get_qualified('::', 'Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    }, TMP_Object_merge$B_32.$$arity = 1);
    
    Opal.defn(self, '$respond_to?', TMP_Object_respond_to$q_33 = function(name, include_all) {
      var self = this;

      if (include_all == null) {
        include_all = false;
      }
      return Opal.const_get_qualified('::', 'Kernel').$instance_method("respond_to?").$bind(self).$call(name, include_all)
    }, TMP_Object_respond_to$q_33.$$arity = -2);
    
    Opal.defn(self, '$respond_to_missing?', TMP_Object_respond_to_missing$q_34 = function(name, include_all) {
      var self = this;

      if (include_all == null) {
        include_all = false;
      }
      return Opal.hasOwnProperty.call(self["native"], name)
    }, TMP_Object_respond_to_missing$q_34.$$arity = -2);
    
    Opal.defn(self, '$method_missing', TMP_Object_method_missing_35 = function $$method_missing(mid, $a_rest) {
      var self = this, args, $iter = TMP_Object_method_missing_35.$$p, block = $iter || nil, $writer = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      if ($iter) TMP_Object_method_missing_35.$$p = null;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return (($writer = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)]), $send(self, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
      }
      else {
        return $send(Opal.const_get_qualified('::', 'Native'), 'call', [self["native"], mid].concat(Opal.to_a(args)), block.$to_proc());
      }
    
    }, TMP_Object_method_missing_35.$$arity = -2);
    
    Opal.defn(self, '$nil?', TMP_Object_nil$q_36 = function() {
      var self = this;

      return false
    }, TMP_Object_nil$q_36.$$arity = 0);
    
    Opal.defn(self, '$is_a?', TMP_Object_is_a$q_37 = function(klass) {
      var self = this;

      return Opal.is_a(self, klass)
    }, TMP_Object_is_a$q_37.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.defn(self, '$instance_of?', TMP_Object_instance_of$q_38 = function(klass) {
      var self = this;

      return self.$$class === klass
    }, TMP_Object_instance_of$q_38.$$arity = 1);
    
    Opal.defn(self, '$class', TMP_Object_class_39 = function() {
      var self = this;

      return self.$$class
    }, TMP_Object_class_39.$$arity = 0);
    
    Opal.defn(self, '$to_a', TMP_Object_to_a_40 = function $$to_a(options) {
      var self = this, $iter = TMP_Object_to_a_40.$$p, block = $iter || nil;

      if (options == null) {
        options = $hash2([], {});
      }
      if ($iter) TMP_Object_to_a_40.$$p = null;
      return $send(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a()
    }, TMP_Object_to_a_40.$$arity = -1);
    return (Opal.defn(self, '$inspect', TMP_Object_inspect_41 = function $$inspect() {
      var self = this;

      return "" + "#<Native:" + (String(self["native"])) + ">"
    }, TMP_Object_inspect_41.$$arity = 0), nil) && 'inspect';
  })(Opal.const_get_relative($nesting, 'Native'), Opal.const_get_relative($nesting, 'BasicObject'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $Array(){};
    var self = $Array = $klass($base, $super, 'Array', $Array);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_initialize_42, TMP_Array_each_43, TMP_Array_$$_44, TMP_Array_$$$eq_45, TMP_Array_last_46, TMP_Array_length_47, TMP_Array_inspect_48;

    def.named = def["native"] = def.get = def.block = def.set = def.length = nil;
    
    self.$include(Opal.const_get_relative($nesting, 'Native'));
    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
    
    Opal.defn(self, '$initialize', TMP_Array_initialize_42 = function $$initialize(native$, options) {
      var $a, self = this, $iter = TMP_Array_initialize_42.$$p, block = $iter || nil;

      if (options == null) {
        options = $hash2([], {});
      }
      if ($iter) TMP_Array_initialize_42.$$p = null;
      
      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Array_initialize_42, false), [native$], null);
      self.get = ($truthy($a = options['$[]']("get")) ? $a : options['$[]']("access"));
      self.named = options['$[]']("named");
      self.set = ($truthy($a = options['$[]']("set")) ? $a : options['$[]']("access"));
      self.length = ($truthy($a = options['$[]']("length")) ? $a : "length");
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "no length found on the array-like object")
        } else {
        return nil
      };
    }, TMP_Array_initialize_42.$$arity = -2);
    
    Opal.defn(self, '$each', TMP_Array_each_43 = function $$each() {
      var self = this, $iter = TMP_Array_each_43.$$p, block = $iter || nil;

      if ($iter) TMP_Array_each_43.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    }, TMP_Array_each_43.$$arity = 0);
    
    Opal.defn(self, '$[]', TMP_Array_$$_44 = function(index) {
      var self = this, result = nil, $case = nil;

      
      result = (function() {$case = index;
      if (Opal.const_get_relative($nesting, 'String')['$===']($case) || Opal.const_get_relative($nesting, 'Symbol')['$===']($case)) {if ($truthy(self.named)) {
        return self["native"][self.named](index)
        } else {
        return self["native"][index]
      }}
      else if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {if ($truthy(self.get)) {
        return self["native"][self.get](index)
        } else {
        return self["native"][index]
      }}
      else { return nil }})();
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
          } else {
          return self.$Native(result)
        }
        } else {
        return nil
      };
    }, TMP_Array_$$_44.$$arity = 1);
    
    Opal.defn(self, '$[]=', TMP_Array_$$$eq_45 = function(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, Opal.const_get_relative($nesting, 'Native').$convert(value))
        } else {
        return self["native"][index] = Opal.const_get_relative($nesting, 'Native').$convert(value)
      }
    }, TMP_Array_$$$eq_45.$$arity = 2);
    
    Opal.defn(self, '$last', TMP_Array_last_46 = function $$last(count) {
      var $a, self = this, index = nil, result = nil;

      if (count == null) {
        count = nil;
      }
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
          
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
        } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      }
    }, TMP_Array_last_46.$$arity = -1);
    
    Opal.defn(self, '$length', TMP_Array_length_47 = function $$length() {
      var self = this;

      return self["native"][self.length]
    }, TMP_Array_length_47.$$arity = 0);
    Opal.alias(self, "to_ary", "to_a");
    return (Opal.defn(self, '$inspect', TMP_Array_inspect_48 = function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    }, TMP_Array_inspect_48.$$arity = 0), nil) && 'inspect';
  })(Opal.const_get_relative($nesting, 'Native'), null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Numeric(){};
    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numeric_to_n_49;

    return (Opal.defn(self, '$to_n', TMP_Numeric_to_n_49 = function $$to_n() {
      var self = this;

      return self.valueOf()
    }, TMP_Numeric_to_n_49.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Proc(){};
    var self = $Proc = $klass($base, $super, 'Proc', $Proc);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Proc_to_n_50;

    return (Opal.defn(self, '$to_n', TMP_Proc_to_n_50 = function $$to_n() {
      var self = this;

      return self
    }, TMP_Proc_to_n_50.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_to_n_51;

    return (Opal.defn(self, '$to_n', TMP_String_to_n_51 = function $$to_n() {
      var self = this;

      return self.valueOf()
    }, TMP_String_to_n_51.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Regexp(){};
    var self = $Regexp = $klass($base, $super, 'Regexp', $Regexp);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Regexp_to_n_52;

    return (Opal.defn(self, '$to_n', TMP_Regexp_to_n_52 = function $$to_n() {
      var self = this;

      return self.valueOf()
    }, TMP_Regexp_to_n_52.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $MatchData(){};
    var self = $MatchData = $klass($base, $super, 'MatchData', $MatchData);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MatchData_to_n_53;

    def.matches = nil;
    return (Opal.defn(self, '$to_n', TMP_MatchData_to_n_53 = function $$to_n() {
      var self = this;

      return self.matches
    }, TMP_MatchData_to_n_53.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Struct(){};
    var self = $Struct = $klass($base, $super, 'Struct', $Struct);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Struct_to_n_55;

    return (Opal.defn(self, '$to_n', TMP_Struct_to_n_55 = function $$to_n() {
      var TMP_54, self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], (TMP_54 = function(name, value){var self = TMP_54.$$s || this;
if (name == null) name = nil;if (value == null) value = nil;
      return result[name] = Opal.const_get_relative($nesting, 'Native').$try_convert(value, value)}, TMP_54.$$s = self, TMP_54.$$arity = 2, TMP_54));
      return result;
    }, TMP_Struct_to_n_55.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Array(){};
    var self = $Array = $klass($base, $super, 'Array', $Array);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_to_n_56;

    return (Opal.defn(self, '$to_n', TMP_Array_to_n_56 = function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push(Opal.const_get_relative($nesting, 'Native').$try_convert(obj, obj));
      }

      return result;
    
    }, TMP_Array_to_n_56.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Boolean(){};
    var self = $Boolean = $klass($base, $super, 'Boolean', $Boolean);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Boolean_to_n_57;

    return (Opal.defn(self, '$to_n', TMP_Boolean_to_n_57 = function $$to_n() {
      var self = this;

      return self.valueOf()
    }, TMP_Boolean_to_n_57.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Time(){};
    var self = $Time = $klass($base, $super, 'Time', $Time);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Time_to_n_58;

    return (Opal.defn(self, '$to_n', TMP_Time_to_n_58 = function $$to_n() {
      var self = this;

      return self
    }, TMP_Time_to_n_58.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $NilClass(){};
    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NilClass_to_n_59;

    return (Opal.defn(self, '$to_n', TMP_NilClass_to_n_59 = function $$to_n() {
      var self = this;

      return null
    }, TMP_NilClass_to_n_59.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Hash(){};
    var self = $Hash = $klass($base, $super, 'Hash', $Hash);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_initialize_60, TMP_Hash_to_n_61;

    
    self.$alias_method("_initialize", "initialize");
    
    Opal.defn(self, '$initialize', TMP_Hash_initialize_60 = function $$initialize(defaults) {
      var self = this, $iter = TMP_Hash_initialize_60.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_initialize_60.$$p = null;
      
      if (defaults != null &&
           (defaults.constructor === undefined ||
             defaults.constructor === Object)) {
        var smap = self.$$smap,
            keys = self.$$keys,
            key, value;

        for (key in defaults) {
          value = defaults[key];

          if (value &&
               (value.constructor === undefined ||
                 value.constructor === Object)) {
            smap[key] = Opal.const_get_relative($nesting, 'Hash').$new(value);
          } else if (value && value.$$is_array) {
            value = value.map(function(item) {
              if (item &&
                   (item.constructor === undefined ||
                     item.constructor === Object)) {
                return Opal.const_get_relative($nesting, 'Hash').$new(item);
              }

              return self.$Native(item);
            });
            smap[key] = value
          } else {
            smap[key] = self.$Native(value);
          }

          keys.push(key);
        }

        return self;
      }

      return $send(self, '_initialize', [defaults], block.$to_proc());
    
    }, TMP_Hash_initialize_60.$$arity = -1);
    return (Opal.defn(self, '$to_n', TMP_Hash_to_n_61 = function $$to_n() {
      var self = this;

      
      var result = {},
          keys = self.$$keys,
          smap = self.$$smap,
          key, value;

      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = smap[key];
        } else {
          key = key.key;
          value = key.value;
        }

        result[key] = Opal.const_get_relative($nesting, 'Native').$try_convert(value, value);
      }

      return result;
    
    }, TMP_Hash_to_n_61.$$arity = 0), nil) && 'to_n';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Module(){};
    var self = $Module = $klass($base, $super, 'Module', $Module);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Module_native_module_62;

    return (Opal.defn(self, '$native_module', TMP_Module_native_module_62 = function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    }, TMP_Module_native_module_62.$$arity = 0), nil) && 'native_module'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Class(){};
    var self = $Class = $klass($base, $super, 'Class', $Class);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Class_native_alias_63, TMP_Class_native_class_64;

    
    
    Opal.defn(self, '$native_alias', TMP_Class_native_alias_63 = function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.$$proto['$' + existing_mid];
      if (!aliased) {
        self.$raise(Opal.const_get_relative($nesting, 'NameError').$new("" + "undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", self.$exiting_mid()));
      }
      self.$$proto[new_jsid] = aliased;
    
    }, TMP_Class_native_alias_63.$$arity = 2);
    return (Opal.defn(self, '$native_class', TMP_Class_native_class_64 = function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    }, TMP_Class_native_class_64.$$arity = 0), nil) && 'native_class';
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

/* Generated by Opal 0.11.4 */
Opal.modules["abc2svg_to_harpnotes"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $gvars = Opal.gvars, $truthy = Opal.truthy, $hash = Opal.hash, $range = Opal.range;

  Opal.add_stubs(['$require', '$attr_reader', '$get', '$_reset_state', '$get_metadata', '$new', '$abcplay=', '$-', '$get_abcmodel', '$nil?', '$raise', '$t', '$_make_metadata', '$_transform_voices', '$meta_data=', '$_make_harpnote_options', '$harpnote_options=', '$[]', '$meta_data', '$empty?', '$error', '$[]=', '$compact', '$map', '$gsub', '$strip', '$+', '$_get_key_by_accidentals', '$first', '$==', '$/', '$to_i', '$join', '$>=', '$private', '$match', '$charpos_to_line_column', '$flatten', '$to_a', '$each_with_index', '$_transform_voice', '$_make_variant_ending_jumps', '$unshift', '$to_s', '$_investigate_first_bar', '$each', '$send', '$inject', '$<<', '$_make_jumplines', '$_make_notebound_annotations', '$count', '$last', '$select', '$!', '$=~', '$_extract_goto_info_from_bar', '$!=', '$length', '$push', '$_bar_is_repetition_end?', '$>', '$pop', '$_transform_bar_repeat_end', '$include?', '$_parse_origin', '$_parse_tuplet_info', '$_parse_decorations', '$_transform_measure_start', '$_convert_duration', '$decorations=', '$measure_count=', '$_transform_count_note', '$count_note=', '$time=', '$_mkznid', '$znid=', '$origin=', '$start_pos=', '$end_pos=', '$tuplet=', '$tuplet_start=', '$tuplet_end=', '$variant=', '$time', '$duration', '$duration=', '$origin', '$start_pos', '$end_pos', '$tuplet', '$tuplet_start', '$tuplet_end', '$tie_end=', '$tie_start=', '$_parse_slur', '$_push_slur', '$slur_starts=', '$_pop_slur', '$slur_ends=', '$measure_start=', '$_make_repeats_jumps_annotations', '$*', '$%', '$ceil', '$split', '$zip', '$min', '$round', '$floor', '$visible=', '$is_a?', '$prev_pitch', '$pitch=', '$znid', '$warning', '$start_pos_to_s', '$_extract_chord_lines', '$===', '$shift=', '$notes', '$to_f', '$pitch', '$next_pitch=', '$next_playable=', '$next_first_in_part=', '$prev_pitch=', '$prev_playable=', '$first_in_part=', '$<', '$start_with?', '$to_sym', '$&', '$>>']);
  
  self.$require("native");
  return (function($base, $parent_nesting) {
    var $Harpnotes, self = $Harpnotes = $module($base, 'Harpnotes');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Input, self = $Input = $module($base, 'Input');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Abc2svgToHarpnotes(){};
        var self = $Abc2svgToHarpnotes = $klass($base, $super, 'Abc2svgToHarpnotes', $Abc2svgToHarpnotes);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Abc2svgToHarpnotes_initialize_1, TMP_Abc2svgToHarpnotes_transform_2, TMP_Abc2svgToHarpnotes__make_harpnote_options_4, TMP_Abc2svgToHarpnotes__get_key_by_accidentals_5, TMP_Abc2svgToHarpnotes__make_metadata_7, TMP_Abc2svgToHarpnotes__mkznid_8, TMP_Abc2svgToHarpnotes__reset_state_10, TMP_Abc2svgToHarpnotes__transform_voices_12, TMP_Abc2svgToHarpnotes__transform_voice_18, TMP_Abc2svgToHarpnotes__investigate_first_bar_20, TMP_Abc2svgToHarpnotes__bar_is_repetition_end$q_21, TMP_Abc2svgToHarpnotes__transform_bar_22, TMP_Abc2svgToHarpnotes__transform_part_23, TMP_Abc2svgToHarpnotes__transform_remark_24, TMP_Abc2svgToHarpnotes__transform_note_29, TMP_Abc2svgToHarpnotes__transform_measure_start_30, TMP_Abc2svgToHarpnotes__transform_count_note_34, TMP_Abc2svgToHarpnotes__convert_duration_35, TMP_Abc2svgToHarpnotes__transform_staves_36, TMP_Abc2svgToHarpnotes__transform_rest_38, TMP_Abc2svgToHarpnotes__transform_tempo_39, TMP_Abc2svgToHarpnotes__transform_yspace_40, TMP_Abc2svgToHarpnotes__transform_bar_repeat_end_41, TMP_Abc2svgToHarpnotes__transform_grace_42, TMP_Abc2svgToHarpnotes__transform_format_43, TMP_Abc2svgToHarpnotes__transform_key_44, TMP_Abc2svgToHarpnotes__transform_meter_45, TMP_Abc2svgToHarpnotes__transform_block_46, TMP_Abc2svgToHarpnotes__transform_clef_47, TMP_Abc2svgToHarpnotes__make_variant_ending_jumps_51, TMP_Abc2svgToHarpnotes__make_jumplines_53, TMP_Abc2svgToHarpnotes__make_notebound_annotations_58, TMP_Abc2svgToHarpnotes__make_repeats_jumps_annotations_62, TMP_Abc2svgToHarpnotes__get_extra_64, TMP_Abc2svgToHarpnotes__push_slur_65, TMP_Abc2svgToHarpnotes__pop_slur_66, TMP_Abc2svgToHarpnotes__extract_chord_lines_69, TMP_Abc2svgToHarpnotes__extract_goto_info_from_bar_72, TMP_Abc2svgToHarpnotes__parse_decorations_75, TMP_Abc2svgToHarpnotes__parse_origin_76, TMP_Abc2svgToHarpnotes__parse_slur_77, TMP_Abc2svgToHarpnotes__parse_tuplet_info_78;

        def.abc_code = def.abcplay = def.abc_model = def.meta_data = def.info_fields = def.remark_table = def.score_statements = def.wmeasure = def.measure_start_time = def.next_note_marks = def.variant_no = def.variant_endings = def.previous_note = def.repetition_stack = def.pushed_variant_ending_repeat = def.part_table = def.measure_count = def.tie_started = def.countby = def._shortest_note = def.pitch_providers = def.slurstack = def.tuplet_p = nil;
        
        Opal.const_set($nesting[0], 'ABC2SVG_DURATION_FACTOR', 1536);
        self.$attr_reader("abc_model");
        
        Opal.defn(self, '$initialize', TMP_Abc2svgToHarpnotes_initialize_1 = function $$initialize() {
          var self = this, $iter = TMP_Abc2svgToHarpnotes_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          if ($iter) TMP_Abc2svgToHarpnotes_initialize_1.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Abc2svgToHarpnotes_initialize_1, false), $zuper, $iter);
          self.abcplay = nil;
          self.abc_code = nil;
          self.previous_new_part = [];
          self.score_statements = [];
          self.part_table = $hash2([], {});
          self.abc_model = $hash2([], {});
          self._shortest_note = $gvars.conf.$get("layout.SHORTEST_NOTE");
          return self.$_reset_state();
        }, TMP_Abc2svgToHarpnotes_initialize_1.$$arity = 0);
        
        Opal.defn(self, '$transform', TMP_Abc2svgToHarpnotes_transform_2 = function $$transform(zupfnoter_abc) {
          var $a, $b, self = this, abc_parser = nil, $writer = nil, player_model_abc = nil, result = nil, filebase = nil;
          if ($gvars.conf == null) $gvars.conf = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          self.abc_code = zupfnoter_abc;
          self.annotations = $gvars.conf.$get("annotations");
          self.info_fields = self.$get_metadata(self.abc_code);
          abc_parser = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'ABC2SVG'), 'Abc2Svg').$new(nil, $hash2(["mode"], {"mode": "model"}));
          if ($truthy(self.abcplay)) {
            
            $writer = [self.abcplay];
            $send(abc_parser, 'abcplay=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          $b = abc_parser.$get_abcmodel(zupfnoter_abc), $a = Opal.to_ary($b), (self.abc_model = ($a[0] == null ? nil : $a[0])), (player_model_abc = ($a[1] == null ? nil : $a[1])), $b;
          if ($truthy(self.abc_model['$nil?']())) {
            self.$raise(Opal.const_get_relative($nesting, 'I18n').$t("no suitable ABC found"))};
          self.$_make_metadata();
          result = self.$_transform_voices();
          
          $writer = [self.meta_data];
          $send(result, 'meta_data=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [self.$_make_harpnote_options()];
          $send(result, 'harpnote_options=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          filebase = result.$meta_data()['$[]']("filename");
          if ($truthy(filebase['$empty?']())) {
            $gvars.log.$error(Opal.const_get_relative($nesting, 'I18n').$t("Filename not specified in song add an F: instruction"), [1, 1])};
          return [result, player_model_abc];
        }, TMP_Abc2svgToHarpnotes_transform_2.$$arity = 1);
        
        Opal.defn(self, '$_make_harpnote_options', TMP_Abc2svgToHarpnotes__make_harpnote_options_4 = function $$_make_harpnote_options() {
          var TMP_3, self = this, result = nil, $writer = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          result = $hash2(["lyrics"], {"lyrics": $hash2(["text"], {"text": self.info_fields['$[]']("W")})});
          
          $writer = ["template", $gvars.conf.$get("template")];
          $send(result, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["print", $send($gvars.conf.$get("produce"), 'map', [], (TMP_3 = function(i){var self = TMP_3.$$s || this, $a, title = nil, filenamepart = nil;
            if ($gvars.conf == null) $gvars.conf = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (i == null) i = nil;
          
            title = $gvars.conf.$get("" + "extract." + (i) + ".title");
            if ($truthy(title)) {
              
              filenamepart = ($truthy($a = $gvars.conf.$get("" + "extract." + (i) + ".filenamepart")) ? $a : title).$strip().$gsub(/[^a-zA-Z0-9\-\_]/, "_");
              return $hash2(["title", "view_id", "filenamepart"], {"title": title, "view_id": i, "filenamepart": filenamepart});
              } else {
              
              $gvars.log.$error($rb_plus(Opal.const_get_relative($nesting, 'I18n').$t("could not find extract with number"), "" + " " + (i)), [1, 1], [1000, 1000]);
              return nil;
            };}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3)).$compact()];
          $send(result, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return result;
        }, TMP_Abc2svgToHarpnotes__make_harpnote_options_4.$$arity = 0);
        
        Opal.defn(self, '$_get_key_by_accidentals', TMP_Abc2svgToHarpnotes__get_key_by_accidentals_5 = function $$_get_key_by_accidentals(key_model) {
          var self = this;

          return $hash(7, ["C#", "D#Dor", "E#Phr", "F#Lyd", "G#Mix", "A#m", "B#Loc"], 6, ["F#", "G#Dor", "A#Phr", "BLyd", "C#Mix", "D#m", "E#Loc"], 5, ["B", "C#Dor", "D#Phr", "ELyd", "F#Mix", "G#m", "A#Loc"], 4, ["E", "F#Dor", "G#Phr", "ALyd", "BMix", "C#m", "D#Loc"], 3, ["A", "BDor", "C#Phr", "DLyd", "EMix", "F#m", "G#Loc"], 2, ["D", "EDor", "F#Phr", "GLyd", "AMix", "Bm", "C#Loc"], 1, ["G", "ADor", "BPhr", "CLyd", "DMix", "Em", "F#Loc"], 0, ["C", "DDor", "EPhr", "FLyd", "GMix", "Am", "BLoc"], -1, ["F", "GDor", "APhr", "BbLyd", "CMix", "Dm", "ELoc"], -2, ["Bb", "CDor", "DPhr", "EbLyd", "FMix", "Gm", "ALoc"], -3, ["Eb", "FDor", "GPhr", "AbLyd", "BbMix", "Cm", "DLoc"], -4, ["Ab", "BbDor", "CPhr", "DbLyd", "EbMix", "Fm", "GLoc"], -5, ["Db", "EbDor", "FPhr", "GbLyd", "AbMix", "Bbm", "CLoc"], -6, ["Gb", "AbDor", "" + "BbPhr" + "CbLyd", "DbMix", "Ebm", "FLoc"], -7, ["" + "Cb" + "DbDor", "" + "EbPhr" + "FbLyd", "GbMix", "Abm", "BbLoc"])['$[]'](key_model['$[]']("k_sf"))['$[]'](key_model['$[]']("k_mode"))
        }, TMP_Abc2svgToHarpnotes__get_key_by_accidentals_5.$$arity = 1);
        
        Opal.defn(self, '$_make_metadata', TMP_Abc2svgToHarpnotes__make_metadata_7 = function $$_make_metadata() {
          var $a, TMP_6, self = this, key = nil, o_key = nil, o_key_display = nil, tempo_note = nil, duration = nil, bpm = nil, tempo_display = nil;

          
          key = self.$_get_key_by_accidentals(self.abc_model['$[]']("voices").$first()['$[]']("voice_properties")['$[]']("key"));
          o_key = self.$_get_key_by_accidentals(self.abc_model['$[]']("voices").$first()['$[]']("voice_properties")['$[]']("okey"));
          o_key_display = "";
          if (key['$=='](o_key)) {
            } else {
            o_key_display = "" + "(Original in " + (o_key) + ")"
          };
          tempo_note = (function() { try {
            return self.abc_model['$[]']("voices").$first()['$[]']("voice_properties")['$[]']("sym")
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }})();
          if ($truthy(($truthy($a = tempo_note) ? tempo_note['$[]']("tempo_notes") : $a))) {
            
            duration = $send(tempo_note['$[]']("tempo_notes"), 'map', [], (TMP_6 = function(i){var self = TMP_6.$$s || this;
if (i == null) i = nil;
            return $rb_divide(i, Opal.const_get_relative($nesting, 'ABC2SVG_DURATION_FACTOR'))}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));
            bpm = tempo_note['$[]']("tempo").$to_i();
            tempo_display = self.info_fields['$[]']("Q").$join(" ");
            } else {
            
            duration = [0.25];
            bpm = 120;
            tempo_display = "1/4=120";
          };
          if ($truthy($rb_ge(bpm, 1))) {
            } else {
            bpm = 120
          };
          return (self.meta_data = $hash2(["number", "composer", "title", "filename", "tempo", "tempo_display", "meter", "key", "o_key"], {"number": self.info_fields['$[]']("X").$first(), "composer": ($truthy($a = self.info_fields['$[]']("C")) ? $a : []).$join("\n"), "title": ($truthy($a = self.info_fields['$[]']("T")) ? $a : []).$join("\n"), "filename": ($truthy($a = self.info_fields['$[]']("F")) ? $a : []).$join("\n"), "tempo": $hash2(["duration", "bpm", "sym"], {"duration": duration, "bpm": bpm, "sym": tempo_note}), "tempo_display": tempo_display, "meter": self.info_fields['$[]']("M"), "key": key, "o_key": o_key_display}));
        }, TMP_Abc2svgToHarpnotes__make_metadata_7.$$arity = 0);
        self.$private();
        
        Opal.defn(self, '$_mkznid', TMP_Abc2svgToHarpnotes__mkznid_8 = function $$_mkznid(voice_element) {
          var self = this, result = nil, start_pos = nil, end_pos = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          result = self.remark_table['$[]'](voice_element['$[]']("time"));
          if ($truthy(result)) {
            if ($truthy(result.$match(/[a-z][a-zA-Z0-9_]*/))) {
              } else {
              
              start_pos = self.$charpos_to_line_column(voice_element['$[]']("istart"));
              end_pos = self.$charpos_to_line_column(voice_element['$[]']("iend"));
              $gvars.log.$error("illegal character in of [r:] (must be of [a-z][a-z0.9_])", start_pos, end_pos);
              result = nil;
            }
          } else if ($truthy(result)) {
            } else {
            result = "" + (voice_element['$[]']("time"))
          };
          return result;
        }, TMP_Abc2svgToHarpnotes__mkznid_8.$$arity = 1);
        
        Opal.defn(self, '$_reset_state', TMP_Abc2svgToHarpnotes__reset_state_10 = function $$_reset_state() {
          var TMP_9, self = this;

          
          self.countnames = $send($range(1, 32, false).$to_a(), 'map', [], (TMP_9 = function(i){var self = TMP_9.$$s || this;
if (i == null) i = nil;
          return [i, "e", "u", "e"]}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9)).$flatten();
          self.jumptargets = $hash2([], {});
          self.is_first_measure = true;
          self.measure_start_time = 0;
          self.measure_count = 0;
          self.next_note_marks = $hash2(["measure", "repeat_start", "variant_ending", "variant_followup"], {"measure": false, "repeat_start": false, "variant_ending": false, "variant_followup": false});
          self.previous_new_part = [];
          self.previous_note = nil;
          self.remark_table = $hash2([], {});
          self.repetition_stack = [];
          self.variant_endings = [[]];
          self.tie_started = false;
          self.variant_no = 0;
          self.slurstack = 0;
          self.tuplet_count = 1;
          self.tuplet_down_count = 1;
          self.countby = nil;
          return (self.wmeasure = 0);
        }, TMP_Abc2svgToHarpnotes__reset_state_10.$$arity = 0);
        
        Opal.defn(self, '$_transform_voices', TMP_Abc2svgToHarpnotes__transform_voices_12 = function $$_transform_voices() {
          var TMP_11, self = this, hn_voices = nil;

          
          hn_voices = $send(self.abc_model['$[]']("voices").$each_with_index(), 'map', [], (TMP_11 = function(voice_model, voice_index){var self = TMP_11.$$s || this, voice_id = nil, result = nil;
if (voice_model == null) voice_model = nil;if (voice_index == null) voice_index = nil;
          
            voice_id = "" + "v_" + ($rb_plus(voice_index, 1));
            result = self.$_transform_voice(voice_model, voice_id);
            if ($truthy(result['$empty?']())) {
              } else {
              result = $rb_plus(result, self.$_make_variant_ending_jumps(voice_id))
            };
            return result;}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11)).$compact();
          hn_voices.$unshift(hn_voices.$first());
          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Song').$new(hn_voices);
        }, TMP_Abc2svgToHarpnotes__transform_voices_12.$$arity = 0);
        
        Opal.defn(self, '$_transform_voice', TMP_Abc2svgToHarpnotes__transform_voice_18 = function $$_transform_voice(voice_model, voice_index) {
          var TMP_13, TMP_14, TMP_15, TMP_16, TMP_17, $a, self = this, note_id = nil, result = nil, jumplines = nil, notebound_annotations = nil, num_voice_index = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          note_id = self.abc_model['$[]']("music_type_ids")['$[]']("note").$to_s();
          self.$_reset_state();
          self.wmeasure = voice_model['$[]']("voice_properties")['$[]']("meter")['$[]']("wmeasure");
          self.countby = (function() { try {
            return voice_model['$[]']("voice_properties")['$[]']("meter")['$[]']("a_meter").$first()['$[]']("bot").$to_i()
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }})();
          self.$_investigate_first_bar(voice_model);
          $send(voice_model['$[]']("symbols"), 'each', [], (TMP_13 = function(voice_model_element){var self = TMP_13.$$s || this, $writer = nil;
if (voice_model_element == null) voice_model_element = nil;
          
            
            $writer = ["start_pos", self.$charpos_to_line_column(voice_model_element['$[]']("istart"))];
            $send(voice_model_element, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["end_pos", self.$charpos_to_line_column(voice_model_element['$[]']("iend"))];
            $send(voice_model_element, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13));
          self.pitch_providers = $send(voice_model['$[]']("symbols"), 'map', [], (TMP_14 = function(voice_model_element){var self = TMP_14.$$s || this;
if (voice_model_element == null) voice_model_element = nil;
          if (voice_model_element['$[]']("type").$to_s()['$=='](note_id)) {
              return voice_model_element
              } else {
              return nil
            }}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));
          result = $send(voice_model['$[]']("symbols").$each_with_index(), 'map', [], (TMP_15 = function(voice_model_element, index){var self = TMP_15.$$s || this, type = nil, e = nil;
            if (self.abc_model == null) self.abc_model = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (voice_model_element == null) voice_model_element = nil;if (index == null) index = nil;
          
            type = self.abc_model['$[]']("music_types")['$[]'](voice_model_element['$[]']("type"));
            
            try {
              result = self.$send("" + "_transform_" + (type), voice_model_element, index, voice_index)
            } catch ($err) {
              if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
                try {
                  
                  $gvars.log.$error("" + "Bug: " + (e), self.$charpos_to_line_column(voice_model_element['$[]']("istart")));
                  nil;
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };;
            return result;}, TMP_15.$$s = self, TMP_15.$$arity = 2, TMP_15));
          result = result.$flatten();
          jumplines = $send(result, 'inject', [[]], (TMP_16 = function(jumplines, element){var self = TMP_16.$$s || this;
if (jumplines == null) jumplines = nil;if (element == null) element = nil;
          
            jumplines['$<<'](self.$_make_jumplines(element, voice_index));
            return jumplines;}, TMP_16.$$s = self, TMP_16.$$arity = 2, TMP_16));
          notebound_annotations = $send(result, 'inject', [[]], (TMP_17 = function(notebound_annotations, element){var self = TMP_17.$$s || this;
if (notebound_annotations == null) notebound_annotations = nil;if (element == null) element = nil;
          return notebound_annotations['$<<'](self.$_make_notebound_annotations(element, voice_index))}, TMP_17.$$s = self, TMP_17.$$arity = 2, TMP_17));
          result = $rb_plus(result, $rb_plus(jumplines, notebound_annotations));
          result = result.$flatten().$compact();
          if ($truthy(result.$count()['$=='](0))) {
            
            num_voice_index = voice_index.$gsub("v_", "").$to_i();
            if ($truthy(($truthy($a = self.score_statements.$last()) ? self.score_statements.$last()['$[]']("sy")['$[]']("voices")['$[]']($rb_minus(num_voice_index, 1))['$[]']("range")['$=='](-1) : $a))) {
              } else {
              $gvars.log.$error("" + (Opal.const_get_relative($nesting, 'I18n').$t("Empty voice")) + " " + (num_voice_index) + ":  V:" + (voice_model['$[]']("voice_properties")['$[]']("id")))
            };};
          return result;
        }, TMP_Abc2svgToHarpnotes__transform_voice_18.$$arity = 2);
        
        Opal.defn(self, '$_investigate_first_bar', TMP_Abc2svgToHarpnotes__investigate_first_bar_20 = function $$_investigate_first_bar(voice_model) {
          var TMP_19, $a, self = this, symbol_bar_typeid = nil, bars = nil, $writer = nil;

          
          symbol_bar_typeid = self.abc_model['$[]']("music_type_ids")['$[]']("bar").$to_s();
          bars = $send(voice_model['$[]']("symbols"), 'select', [], (TMP_19 = function(voice_model_element){var self = TMP_19.$$s || this, $a;
if (voice_model_element == null) voice_model_element = nil;
          return (($a = voice_model_element['$[]']("type").$to_s()['$=='](symbol_bar_typeid)) ? voice_model_element['$[]']("invisible")['$!']() : voice_model_element['$[]']("type").$to_s()['$=='](symbol_bar_typeid))}, TMP_19.$$s = self, TMP_19.$$arity = 1, TMP_19)).$compact();
          self.measure_start_time = 0;
          if ($truthy(bars.$first())) {
            
            self.measure_start_time = $rb_minus(bars.$first()['$[]']("time"), self.wmeasure);
            if ($truthy(($truthy($a = bars.$first()) ? self.measure_start_time['$=='](0) : $a))) {
              
              $writer = ["measure", true];
              $send(self.next_note_marks, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
              } else {
              return nil
            };
            } else {
            return nil
          };
        }, TMP_Abc2svgToHarpnotes__investigate_first_bar_20.$$arity = 1);
        
        Opal.defn(self, '$_bar_is_repetition_end?', TMP_Abc2svgToHarpnotes__bar_is_repetition_end$q_21 = function(type) {
          var self = this;

          return type['$=~'](/^:.*$/)
        }, TMP_Abc2svgToHarpnotes__bar_is_repetition_end$q_21.$$arity = 1);
        
        Opal.defn(self, '$_transform_bar', TMP_Abc2svgToHarpnotes__transform_bar_22 = function $$_transform_bar(voice_element, index, voice_index) {
          var $a, $b, self = this, result = nil, type = nil, text = nil, distance = nil, $writer = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          result = [];
          type = voice_element['$[]']("bar_type");
          text = voice_element['$[]']("text");
          distance = (function() { try {
            return self.$_extract_goto_info_from_bar(voice_element).$last()['$[]']("distance")
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return [-10, 10, 15]
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }})();
          if ($truthy(($truthy($a = voice_element['$[]']("invisible")) ? $a : type['$=~'](/^\:?([\[\]]+)$/)))) {
            } else {
            
            $writer = ["measure", true];
            $send(self.next_note_marks, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          if ($truthy(type['$=~'](/^.*:$/))) {
            
            $writer = ["repeat_start", true];
            $send(self.next_note_marks, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if (voice_element['$[]']("rbstart")['$=='](2)) {
            
            self.variant_no = $rb_plus(self.variant_no, 1);
            
            $writer = ["variant_ending", $hash2(["text"], {"text": text})];
            $send(self.next_note_marks, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          if ($truthy((($a = voice_element['$[]']("rbstart")['$=='](2)) ? self.variant_endings.$last()['$empty?']() : voice_element['$[]']("rbstart")['$=='](2)))) {
            
            if ($truthy(distance.$length()['$!='](3))) {
              
              $gvars.log.$error("" + "you need to specify 3 values: " + (distance), self.$charpos_to_line_column(voice_element['$[]']("istart")), self.$charpos_to_line_column(voice_element['$[]']("iend")));
              distance = [-10, 10, 15];};
            self.variant_endings.$last().$push($hash2(["rbstop", "distance"], {"rbstop": self.previous_note, "distance": distance}));};
          if ($truthy(($truthy($a = ($truthy($b = voice_element['$[]']("rbstop")['$=='](2)) ? self.variant_endings.$last().$last()['$nil?']()['$!']() : $b)) ? self.variant_endings.$last().$last()['$[]']("rbstart") : $a))) {
            
            
            $writer = ["rbstop", self.previous_note];
            $send(self.variant_endings.$last().$last(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if ($truthy(self['$_bar_is_repetition_end?'](type))) {
              
              $writer = ["repeat_end", true];
              $send(self.variant_endings.$last().$last(), '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(self['$_bar_is_repetition_end?'](type))) {
              
              self.pushed_variant_ending_repeat = true;
              self.repetition_stack.$push(self.repetition_stack.$last());
            } else if ($truthy(($truthy($a = self.pushed_variant_ending_repeat) ? $rb_gt(self.repetition_stack.$count(), 1) : $a))) {
              self.repetition_stack.$pop()};
            if (voice_element['$[]']("rbstart")['$=='](2)) {
              } else {
              
              
              $writer = ["variant_followup", true];
              $send(self.next_note_marks, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              self.variant_endings.$push([]);
              self.variant_no = 0;
            };};
          if ($truthy(self['$_bar_is_repetition_end?'](type))) {
            result['$<<'](self.$_transform_bar_repeat_end(voice_element, index, voice_index))};
          if ($truthy(type['$include?'](":"))) {
            if ($truthy(false)) {
            } else if ($rb_minus(voice_element['$[]']("time"), self.measure_start_time)['$=='](self.wmeasure)) {
              } else {
              
              $writer = ["measure", false];
              $send(self.next_note_marks, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            }};
          self.is_first_measure = false;
          return result;
        }, TMP_Abc2svgToHarpnotes__transform_bar_22.$$arity = 3);
        
        Opal.defn(self, '$_transform_part', TMP_Abc2svgToHarpnotes__transform_part_23 = function $$_transform_part(voice_element, index, voice_index) {
          var self = this, start_pos = nil, end_pos = nil, $writer = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          if ($truthy(self.part_table['$[]'](voice_element['$[]']("time")))) {
            
            start_pos = self.$charpos_to_line_column(voice_element['$[]']("istart"));
            end_pos = self.$charpos_to_line_column(voice_element['$[]']("iend"));
            $gvars.log.$error($rb_plus("" + "abc:" + (start_pos.$first()) + ":" + (start_pos.$last()) + " Error: ", Opal.const_get_relative($nesting, 'I18n').$t("Multiple parts for same note")), start_pos, end_pos);};
          
          $writer = [voice_element['$[]']("time"), voice_element['$[]']("text")];
          $send(self.part_table, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return nil;
        }, TMP_Abc2svgToHarpnotes__transform_part_23.$$arity = 3);
        
        Opal.defn(self, '$_transform_remark', TMP_Abc2svgToHarpnotes__transform_remark_24 = function $$_transform_remark(voice_element, index, voice_index) {
          var self = this, start_pos = nil, end_pos = nil, $writer = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          if ($truthy(self.remark_table['$[]'](voice_element['$[]']("time")))) {
            
            start_pos = self.$charpos_to_line_column(voice_element['$[]']("istart"));
            end_pos = self.$charpos_to_line_column(voice_element['$[]']("iend"));
            $gvars.log.$error($rb_plus("" + "abc:" + (start_pos.$first()) + ":" + (start_pos.$last()) + " Error: ", Opal.const_get_relative($nesting, 'I18n').$t("Multiple remarks for same note")), start_pos, end_pos);};
          
          $writer = [voice_element['$[]']("time"), voice_element['$[]']("text")];
          $send(self.remark_table, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return nil;
        }, TMP_Abc2svgToHarpnotes__transform_remark_24.$$arity = 3);
        
        Opal.defn(self, '$_transform_note', TMP_Abc2svgToHarpnotes__transform_note_29 = function $$_transform_note(voice_element, index, voice_index) {
          var $a, $b, TMP_25, TMP_26, TMP_27, TMP_28, self = this, origin = nil, start_pos = nil, end_pos = nil, tuplet = nil, tuplet_end = nil, tuplet_start = nil, decorations = nil, duration = nil, notes = nil, result = nil, synchpoint = nil, first_note = nil, $writer = nil, amount_of_slur_ends = nil;

          
          origin = self.$_parse_origin(voice_element);
          $a = [origin['$[]']("startChar"), origin['$[]']("endChar")], (start_pos = $a[0]), (end_pos = $a[1]), $a;
          $b = self.$_parse_tuplet_info(voice_element), $a = Opal.to_ary($b), (tuplet = ($a[0] == null ? nil : $a[0])), (tuplet_end = ($a[1] == null ? nil : $a[1])), (tuplet_start = ($a[2] == null ? nil : $a[2])), $b;
          decorations = self.$_parse_decorations(voice_element);
          self.$_transform_measure_start(voice_element);
          duration = self.$_convert_duration(voice_element['$[]']("notes").$first()['$[]']("dur"));
          notes = $send(voice_element['$[]']("notes"), 'map', [], (TMP_25 = function(the_note){var self = TMP_25.$$s || this, result = nil, $writer = nil;
            if (self.measure_count == null) self.measure_count = nil;
            if (self.variant_no == null) self.variant_no = nil;
if (the_note == null) the_note = nil;
          
            result = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Note').$new(the_note['$[]']("midi"), duration);
            
            $writer = [decorations];
            $send(result, 'decorations=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [self.measure_count];
            $send(result, 'measure_count=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [self.$_transform_count_note(voice_element)];
            $send(result, 'count_note=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [voice_element['$[]']("time")];
            $send(result, 'time=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [self.$_mkznid(voice_element)];
            $send(result, 'znid=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [origin];
            $send(result, 'origin=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [self.$charpos_to_line_column(start_pos)];
            $send(result, 'start_pos=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [self.$charpos_to_line_column(end_pos)];
            $send(result, 'end_pos=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [tuplet];
            $send(result, 'tuplet=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [tuplet_start];
            $send(result, 'tuplet_start=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [tuplet_end];
            $send(result, 'tuplet_end=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [self.variant_no];
            $send(result, 'variant=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return result;}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25));
          result = [];
          if (notes.$count()['$=='](1)) {
            result['$<<'](notes.$first())
            } else {
            
            synchpoint = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'SynchPoint').$new(notes);
            first_note = notes.$first();
            
            $writer = [self.$_mkznid(voice_element)];
            $send(synchpoint, 'znid=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [decorations];
            $send(synchpoint, 'decorations=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [self.measure_count];
            $send(synchpoint, 'measure_count=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [self.$_transform_count_note(voice_element)];
            $send(synchpoint, 'count_note=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [first_note.$time()];
            $send(synchpoint, 'time=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [first_note.$duration()];
            $send(synchpoint, 'duration=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [first_note.$origin()];
            $send(synchpoint, 'origin=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [first_note.$start_pos()];
            $send(synchpoint, 'start_pos=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [first_note.$end_pos()];
            $send(synchpoint, 'end_pos=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [first_note.$tuplet()];
            $send(synchpoint, 'tuplet=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [first_note.$tuplet_start()];
            $send(synchpoint, 'tuplet_start=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [first_note.$tuplet_end()];
            $send(synchpoint, 'tuplet_end=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            result['$<<'](synchpoint);
          };
          if ($truthy(self.repetition_stack['$empty?']())) {
            self.repetition_stack['$<<'](result.$last())};
          
          $writer = [self.tie_started];
          $send(result.$first(), 'tie_end=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          self.tie_started = voice_element['$[]']("ti1")['$nil?']()['$!']();
          
          $writer = [self.tie_started];
          $send(result.$first(), 'tie_start=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [$send(self.$_parse_slur(voice_element['$[]']("slur_start")), 'map', [], (TMP_26 = function(i){var self = TMP_26.$$s || this;
if (i == null) i = nil;
          return self.$_push_slur()}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26))];
          $send(result.$first(), 'slur_starts=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          amount_of_slur_ends = ($truthy($a = voice_element['$[]']("slur_end")) ? $a : 0);
          
          $writer = [$send(Opal.Range.$new(1, amount_of_slur_ends, false), 'map', [], (TMP_27 = function(){var self = TMP_27.$$s || this;

          return self.$_pop_slur()}, TMP_27.$$s = self, TMP_27.$$arity = 0, TMP_27))];
          $send(result.$first(), 'slur_ends=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(self.next_note_marks['$[]']("measure"))) {
            
            $send(notes, 'each', [], (TMP_28 = function(note){var self = TMP_28.$$s || this;
if (note == null) note = nil;
            
              $writer = [true];
              $send(note, 'measure_start=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28));
            
            $writer = ["measure", false];
            $send(self.next_note_marks, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          self.$_make_repeats_jumps_annotations(result, voice_element, voice_index);
          return result;
        }, TMP_Abc2svgToHarpnotes__transform_note_29.$$arity = 3);
        
        Opal.defn(self, '$_transform_measure_start', TMP_Abc2svgToHarpnotes__transform_measure_start_30 = function $$_transform_measure_start(voice_element) {
          var self = this;

          if ($truthy(self.next_note_marks['$[]']("measure"))) {
            
            self.measure_count = $rb_plus(self.measure_count, 1);
            return (self.measure_start_time = voice_element['$[]']("time"));
            } else {
            return nil
          }
        }, TMP_Abc2svgToHarpnotes__transform_measure_start_30.$$arity = 1);
        
        Opal.defn(self, '$_transform_count_note', TMP_Abc2svgToHarpnotes__transform_count_note_34 = function $$_transform_count_note(voice_element) {
          var $a, TMP_31, TMP_32, TMP_33, self = this, count_base = nil, count_start = nil, count_end = nil, count_range = nil, notes = nil, fracts = nil;

          if ($truthy(self.countby)) {
            
            count_base = $rb_divide(Opal.const_get_relative($nesting, 'ABC2SVG_DURATION_FACTOR'), self.countby);
            count_start = $rb_divide($rb_times(4, $rb_minus(voice_element['$[]']("time"), self.measure_start_time)), count_base);
            count_end = $rb_plus(count_start, $rb_divide($rb_times(4, voice_element['$[]']("dur")), count_base));
            if ($truthy(($truthy($a = count_start['$%'](1)['$=='](0)) ? count_end['$%'](1)['$=='](0) : $a))) {
              count_range = $send(Opal.Range.$new(count_start,count_end, true).$to_a(), 'map', [], (TMP_31 = function(i){var self = TMP_31.$$s || this;
                if (self.countnames == null) self.countnames = nil;
if (i == null) i = nil;
              return self.countnames['$[]'](i)}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31)).$join()
            } else if (count_start['$%'](1)['$=='](0)) {
              count_range = $send(Opal.Range.$new(count_start,count_end.$ceil(), true).$to_a(), 'map', [], (TMP_32 = function(i){var self = TMP_32.$$s || this;
                if (self.countnames == null) self.countnames = nil;
if (i == null) i = nil;
              return self.countnames['$[]'](i)}, TMP_32.$$s = self, TMP_32.$$arity = 1, TMP_32)).$join("")
              } else {
              count_range = ""
            };
            notes = count_range.$split(/[eui\?]+/);
            fracts = count_range.$split(/[0-9]+/);
            if ($truthy(fracts['$empty?']())) {
              fracts = [""]};
            $send(fracts, 'each_with_index', [], (TMP_33 = function(v, i){var self = TMP_33.$$s || this, $writer = nil;
if (v == null) v = nil;if (i == null) i = nil;
            if ($truthy($rb_ge(i, 1))) {
                
                $writer = [i, nil];
                $send(fracts, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];
                } else {
                return nil
              }}, TMP_33.$$s = self, TMP_33.$$arity = 2, TMP_33));
            count_range = fracts.$zip(notes).$flatten().$compact().$join(" ").$strip().$split().$join("-");
            count_range = count_range.$gsub("ue", "u");
            return count_range;
            } else {
            return nil
          }
        }, TMP_Abc2svgToHarpnotes__transform_count_note_34.$$arity = 1);
        
        Opal.defn(self, '$_convert_duration', TMP_Abc2svgToHarpnotes__convert_duration_35 = function $$_convert_duration(raw_duration) {
          var self = this, duration = nil;

          
          duration = [128, $rb_times($rb_divide(raw_duration, Opal.const_get_relative($nesting, 'ABC2SVG_DURATION_FACTOR')), self._shortest_note).$round()].$min();
          return duration;
        }, TMP_Abc2svgToHarpnotes__convert_duration_35.$$arity = 1);
        
        Opal.defn(self, '$_transform_staves', TMP_Abc2svgToHarpnotes__transform_staves_36 = function $$_transform_staves(voice_element, index, voice_index) {
          var self = this, start_pos = nil, end_pos = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          if ($truthy(self.score_statements)) {
            } else {
            self.score_statements = []
          };
          self.score_statements.$push(voice_element);
          if ($truthy($rb_gt(self.score_statements.$length(), 1))) {
            
            start_pos = self.$charpos_to_line_column(voice_element['$[]']("istart"));
            end_pos = self.$charpos_to_line_column(voice_element['$[]']("iend"));
            return $gvars.log.$error("" + (Opal.const_get_relative($nesting, 'I18n').$t("you have multiple %%score statements")) + ": " + (self.score_statements.$length()), start_pos, end_pos);
            } else {
            return nil
          };
        }, TMP_Abc2svgToHarpnotes__transform_staves_36.$$arity = 3);
        
        Opal.defn(self, '$_transform_rest', TMP_Abc2svgToHarpnotes__transform_rest_38 = function $$_transform_rest(voice_element, index, voice_index) {
          var $a, TMP_37, $b, self = this, origin = nil, start_pos = nil, end_pos = nil, pitch_notes = nil, decorations = nil, pitch = nil, average_pitch = nil, duration = nil, tuplet = nil, tuplet_end = nil, tuplet_start = nil, result = nil, $writer = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          origin = self.$_parse_origin(voice_element);
          $a = [origin['$[]']("startChar"), origin['$[]']("endChar")], (start_pos = $a[0]), (end_pos = $a[1]), $a;
          pitch_notes = [self.pitch_providers['$[]'](Opal.Range.$new(0, index, false)).$compact().$last(), self.pitch_providers['$[]'](Opal.Range.$new(index, -1, false)).$compact().$first()];
          if ($gvars.conf['$[]']("restposition.default")['$==']("previous")) {
            pitch_notes = [($truthy($a = pitch_notes.$first()) ? $a : pitch_notes.$last())]};
          if ($gvars.conf['$[]']("restposition.default")['$==']("next")) {
            pitch_notes = [($truthy($a = pitch_notes.$last()) ? $a : pitch_notes.$first())]};
          decorations = self.$_parse_decorations(voice_element);
          pitch_notes = pitch_notes.$compact();
          if ($truthy(pitch_notes['$empty?']())) {
            pitch = 60
            } else {
            
            pitch_notes = $send(pitch_notes, 'map', [], (TMP_37 = function(pitch_note){var self = TMP_37.$$s || this;
if (pitch_note == null) pitch_note = nil;
            return pitch_note['$[]']("notes").$last()['$[]']("midi")}, TMP_37.$$s = self, TMP_37.$$arity = 1, TMP_37));
            pitch = (average_pitch = $rb_divide(pitch_notes.$inject("+"), pitch_notes.$length())).$floor().$to_i();
          };
          if ($truthy(pitch['$nil?']())) {
            
            self.$raise("undefined pitch");
            pitch = 60;};
          self.$_transform_measure_start(voice_element);
          duration = voice_element['$[]']("notes");
          duration = (function() {if ($truthy(duration)) {
            return duration.$first()['$[]']("dur")
            } else {
            return voice_element['$[]']("dur")
          }; return nil; })();
          duration = self.$_convert_duration(duration);
          $b = self.$_parse_tuplet_info(voice_element), $a = Opal.to_ary($b), (tuplet = ($a[0] == null ? nil : $a[0])), (tuplet_end = ($a[1] == null ? nil : $a[1])), (tuplet_start = ($a[2] == null ? nil : $a[2])), $b;
          result = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Pause').$new(pitch, duration);
          
          $writer = [self.measure_count];
          $send(result, 'measure_count=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [decorations];
          $send(result, 'decorations=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [self.$_transform_count_note(voice_element)];
          $send(result, 'count_note=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [self.$_mkznid(voice_element)];
          $send(result, 'znid=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [voice_element['$[]']("time")];
          $send(result, 'time=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [self.$_parse_origin(voice_element)];
          $send(result, 'origin=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [self.$charpos_to_line_column(start_pos)];
          $send(result, 'start_pos=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [self.$charpos_to_line_column(end_pos)];
          $send(result, 'end_pos=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [self.variant_no];
          $send(result, 'variant=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [tuplet];
          $send(result, 'tuplet=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [tuplet_start];
          $send(result, 'tuplet_start=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [tuplet_end];
          $send(result, 'tuplet_end=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(voice_element['$[]']("invis"))) {
            
            $writer = [false];
            $send(result, 'visible=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy(self.repetition_stack['$empty?']())) {
            self.repetition_stack['$<<'](result)};
          result = [result];
          if ($truthy(self.next_note_marks['$[]']("measure"))) {
            
            
            $writer = [true];
            $send(result.$first(), 'measure_start=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["measure", false];
            $send(self.next_note_marks, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          self.$_make_repeats_jumps_annotations(result, voice_element, voice_index);
          return result;
        }, TMP_Abc2svgToHarpnotes__transform_rest_38.$$arity = 3);
        
        Opal.defn(self, '$_transform_tempo', TMP_Abc2svgToHarpnotes__transform_tempo_39 = function $$_transform_tempo(voice_element, index, voice_id) {
          var self = this, start_pos = nil, end_pos = nil;
          if ($gvars.log == null) $gvars.log = nil;

          if (voice_element['$[]']("istart")['$=='](self.meta_data['$[]']("tempo")['$[]']("sym")['$[]']("istart"))) {
            return nil
            } else {
            
            start_pos = self.$charpos_to_line_column(voice_element['$[]']("istart"));
            end_pos = self.$charpos_to_line_column(voice_element['$[]']("iend"));
            return $gvars.log.$error($rb_plus("" + "abc:" + (start_pos.$first()) + ":" + (start_pos.$last()) + " Error: ", Opal.const_get_relative($nesting, 'I18n').$t("tempo change not suported by zupfnoter")), start_pos, end_pos);
          }
        }, TMP_Abc2svgToHarpnotes__transform_tempo_39.$$arity = 3);
        
        Opal.defn(self, '$_transform_yspace', TMP_Abc2svgToHarpnotes__transform_yspace_40 = function $$_transform_yspace(voice_element, index) {
          var self = this;

          return nil
        }, TMP_Abc2svgToHarpnotes__transform_yspace_40.$$arity = 2);
        
        Opal.defn(self, '$_transform_bar_repeat_end', TMP_Abc2svgToHarpnotes__transform_bar_repeat_end_41 = function $$_transform_bar_repeat_end(voice_element, index, voice_id) {
          var self = this, level = nil, start = nil, goto_info = nil, distance = nil, $writer = nil, entity = nil, conf_key = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          level = self.repetition_stack.$length();
          if (level['$=='](1)) {
            start = self.repetition_stack.$last()
            } else {
            start = self.repetition_stack.$pop()
          };
          goto_info = self.$_extract_goto_info_from_bar(voice_element);
          distance = (function() { try {
            return goto_info.$last()['$[]']("distance")
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return [2]
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }})();
          if ($truthy($rb_gt(distance.$count(), 1))) {
            self.$raise("" + "too many distance values for repeat end. Need only one " + (distance))};
          if ($truthy(self.previous_note['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Pause')))) {
            if ($gvars.conf['$[]']("restposition.repeatend")['$==']("previous")) {
              
              $writer = [self.previous_note.$prev_pitch()];
              $send(self.previous_note, 'pitch=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];}};
          distance = distance.$first();
          
          $writer = ["first_in_part", true];
          $send(self.next_note_marks, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          entity = self.previous_note;
          conf_key = "" + "notebound.c_jumplines." + (voice_id) + "." + (entity.$znid()) + ".p_repeat";
          return [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Goto').$new(self.previous_note, start, $hash2(["distance", "is_repeat", "level", "conf_key"], {"distance": distance, "is_repeat": true, "level": level, "conf_key": conf_key}))];
        }, TMP_Abc2svgToHarpnotes__transform_bar_repeat_end_41.$$arity = 3);
        
        Opal.defn(self, '$_transform_grace', TMP_Abc2svgToHarpnotes__transform_grace_42 = function $$_transform_grace() {
          var self = this;

          return nil
        }, TMP_Abc2svgToHarpnotes__transform_grace_42.$$arity = 0);
        
        Opal.defn(self, '$_transform_format', TMP_Abc2svgToHarpnotes__transform_format_43 = function $$_transform_format(voice_element) {
          var self = this;

          return nil
        }, TMP_Abc2svgToHarpnotes__transform_format_43.$$arity = 1);
        
        Opal.defn(self, '$_transform_key', TMP_Abc2svgToHarpnotes__transform_key_44 = function $$_transform_key(voice_element) {
          var self = this;

          return nil
        }, TMP_Abc2svgToHarpnotes__transform_key_44.$$arity = 1);
        
        Opal.defn(self, '$_transform_meter', TMP_Abc2svgToHarpnotes__transform_meter_45 = function $$_transform_meter(voice_element) {
          var self = this, start_pos = nil, end_pos = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          if ($truthy(self.next_note_marks['$[]']("measure"))) {
            } else {
            
            start_pos = self.$charpos_to_line_column(voice_element['$[]']("istart"));
            end_pos = self.$charpos_to_line_column(voice_element['$[]']("iend"));
            debugger;
            $gvars.log.$warning($rb_plus("" + "abc:" + (start_pos.$first()) + ":" + (start_pos.$last()) + " Error: ", Opal.const_get_relative($nesting, 'I18n').$t("Meter change not at beginning of measure")), start_pos, end_pos);
          };
          self.is_first_measure = true;
          self.wmeasure = voice_element['$[]']("wmeasure");
          self.countby = (function() { try {
            return voice_element['$[]']("a_meter").$first()['$[]']("bot").$to_i()
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }})();
          return nil;
        }, TMP_Abc2svgToHarpnotes__transform_meter_45.$$arity = 1);
        
        Opal.defn(self, '$_transform_block', TMP_Abc2svgToHarpnotes__transform_block_46 = function $$_transform_block(voice_element) {
          var self = this;

          return nil
        }, TMP_Abc2svgToHarpnotes__transform_block_46.$$arity = 1);
        
        Opal.defn(self, '$_transform_clef', TMP_Abc2svgToHarpnotes__transform_clef_47 = function $$_transform_clef(voice_element) {
          var self = this;

          return nil
        }, TMP_Abc2svgToHarpnotes__transform_clef_47.$$arity = 1);
        
        Opal.defn(self, '$_make_variant_ending_jumps', TMP_Abc2svgToHarpnotes__make_variant_ending_jumps_51 = function $$_make_variant_ending_jumps(voice_id) {
          var TMP_48, self = this, result = nil, lastvariantgroup = nil;

          
          result = [];
          lastvariantgroup = (function() {if ($truthy(self.variant_endings.$last()['$empty?']())) {
            return -2
            } else {
            return -1
          }; return nil; })();
          $send(self.variant_endings['$[]'](Opal.Range.$new(0, lastvariantgroup, false)), 'each', [], (TMP_48 = function(variant_ending_group){var self = TMP_48.$$s || this, TMP_49, TMP_50, distance = nil, entity = nil, conf_base = nil, lastvariant = nil, conf_key = nil;
if (variant_ending_group == null) variant_ending_group = nil;
          
            distance = variant_ending_group['$[]'](0)['$[]']("distance");
            entity = variant_ending_group.$first()['$[]']("rbstop");
            conf_base = "" + "notebound.c_jumplines." + (voice_id) + "." + (entity.$znid());
            if ($truthy(variant_ending_group['$[]'](-1)['$[]']("is_followup"))) {
              lastvariant = -2
              } else {
              lastvariant = -1
            };
            $send(variant_ending_group['$[]'](Opal.Range.$new(1, lastvariant, false)), 'each_with_index', [], (TMP_49 = function(variant_ending, index){var self = TMP_49.$$s || this, conf_key = nil;
if (variant_ending == null) variant_ending = nil;if (index == null) index = nil;
            
              conf_key = "" + (conf_base) + "." + (index) + ".p_begin";
              return result['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Goto').$new(variant_ending_group['$[]'](0)['$[]']("rbstop"), variant_ending['$[]']("rbstart"), $hash2(["conf_key", "distance", "from_anchor", "to_anchor"], {"conf_key": conf_key, "distance": distance['$[]'](0), "from_anchor": "after", "to_anchor": "before"})));}, TMP_49.$$s = self, TMP_49.$$arity = 2, TMP_49));
            $send(variant_ending_group['$[]']($range(1, -3, false)), 'each_with_index', [], (TMP_50 = function(variant_ending, index){var self = TMP_50.$$s || this, conf_key = nil;
if (variant_ending == null) variant_ending = nil;if (index == null) index = nil;
            if ($truthy(variant_ending['$[]']("repeat_end"))) {
                return nil
                } else {
                
                conf_key = "" + (conf_base) + ".p_end";
                return result['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Goto').$new(variant_ending['$[]']("rbstop"), variant_ending_group['$[]'](-1)['$[]']("rbstart"), $hash2(["conf_key", "distance", "from_anchor", "to_anchor", "vertical_anchor"], {"conf_key": conf_key, "distance": distance['$[]'](1), "from_anchor": "after", "to_anchor": "before", "vertical_anchor": "to"})));
              }}, TMP_50.$$s = self, TMP_50.$$arity = 2, TMP_50));
            if ($truthy(variant_ending_group['$[]'](-1)['$[]']("is_followup"))) {
              
              conf_key = "" + (conf_base) + ".p_follow";
              return result['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Goto').$new(variant_ending_group['$[]'](-2)['$[]']("rbstop"), variant_ending_group['$[]'](-1)['$[]']("rbstart"), $hash2(["conf_key", "distance", "from_anchor", "to_anchor", "vertical_anchor"], {"conf_key": conf_key, "distance": distance['$[]'](2), "from_anchor": "after", "to_anchor": "before", "vertical_anchor": "to"})));
              } else {
              return nil
            };}, TMP_48.$$s = self, TMP_48.$$arity = 1, TMP_48));
          return result;
        }, TMP_Abc2svgToHarpnotes__make_variant_ending_jumps_51.$$arity = 1);
        
        Opal.defn(self, '$_make_jumplines', TMP_Abc2svgToHarpnotes__make_jumplines_53 = function $$_make_jumplines(element, voice_id) {
          var TMP_52, self = this, goto_infos = nil;

          if ($truthy(element['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable')))) {
            
            goto_infos = self.$_extract_goto_info_from_bar(element.$origin()['$[]']("raw_voice_element"));
            return $send(goto_infos, 'inject', [[]], (TMP_52 = function(result, goto_info){var self = TMP_52.$$s || this, $a, targetname = nil, target = nil, conf_key = nil, argument = nil;
              if (self.jumptargets == null) self.jumptargets = nil;
              if ($gvars.log == null) $gvars.log = nil;
if (result == null) result = nil;if (goto_info == null) goto_info = nil;
            
              targetname = goto_info['$[]']("target");
              target = self.jumptargets['$[]'](targetname);
              conf_key = "" + "notebound.c_jumplines." + (voice_id) + "." + (element.$znid()) + ".p_goto";
              argument = ($truthy($a = goto_info['$[]']("distance").$first()) ? $a : 2);
              if ($truthy(target['$nil?']())) {
                $gvars.log.$error("" + "target '" + (targetname) + "' not found in voice at " + (element.$start_pos_to_s()), element.$start_pos(), element.$end_pos())
                } else {
                result['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Goto').$new(element, target, $hash2(["conf_key", "distance"], {"conf_key": conf_key, "distance": argument})))
              };
              return result;}, TMP_52.$$s = self, TMP_52.$$arity = 2, TMP_52));
            } else {
            return nil
          }
        }, TMP_Abc2svgToHarpnotes__make_jumplines_53.$$arity = 2);
        
        Opal.defn(self, '$_make_notebound_annotations', TMP_Abc2svgToHarpnotes__make_notebound_annotations_58 = function $$_make_notebound_annotations(entity, voice_id) {
          var TMP_54, self = this, result = nil, chords = nil;

          
          result = [];
          if ($truthy(entity['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable')))) {
            
            chords = self.$_extract_chord_lines(entity.$origin()['$[]']("raw_voice_element"));
            $send(chords, 'each_with_index', [], (TMP_54 = function(name, index){var self = TMP_54.$$s || this, TMP_55, TMP_56, TMP_57, $a, $b, match = nil, semantic = nil, text = nil, pos_x = nil, pos_y = nil, $case = nil, annotation = nil, $writer = nil, notepos = nil, position = nil, conf_key = nil;
              if (self.annotations == null) self.annotations = nil;
              if ($gvars.log == null) $gvars.log = nil;
              if ($gvars.conf == null) $gvars.conf = nil;
if (name == null) name = nil;if (index == null) index = nil;
            
              match = name.$match(/^([!#\<\>])([^\@]+)?(\@(\-?[0-9\.]+),(\-?[0-9\.]+))?$/);
              if ($truthy(match)) {
                
                semantic = match['$[]'](1);
                text = match['$[]'](2);
                if ($truthy(match['$[]'](4))) {
                  pos_x = match['$[]'](4)};
                if ($truthy(match['$[]'](5))) {
                  pos_y = match['$[]'](5)};
                $case = semantic;
                if ("#"['$===']($case)) {
                annotation = self.annotations['$[]'](text);
                if ($truthy(annotation)) {
                  } else {
                  $gvars.log.$error("" + "could not find annotation " + (text), entity.$start_pos(), entity.$end_pos())
                };}
                else if ("!"['$===']($case)) {annotation = $hash2(["text", "style"], {"text": text, "style": "regular"})}
                else if ("<"['$===']($case)) {
                
                $writer = [$hash2(["dir", "size", "style"], {"dir": -1, "size": text, "style": "regular"})];
                $send(entity, 'shift=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                if ($truthy(entity['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'SynchPoint')))) {
                  $send(entity.$notes(), 'each', [], (TMP_55 = function(note){var self = TMP_55.$$s || this;
if (note == null) note = nil;
                  
                    $writer = [$hash2(["dir", "size", "style"], {"dir": -1, "size": text, "style": "regular"})];
                    $send(note, 'shift=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];}, TMP_55.$$s = self, TMP_55.$$arity = 1, TMP_55))};}
                else if (">"['$===']($case)) {
                
                $writer = [$hash2(["dir", "size", "style"], {"dir": 1, "size": text, "style": "regular"})];
                $send(entity, 'shift=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                if ($truthy(entity['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'SynchPoint')))) {
                  $send(entity.$notes(), 'each', [], (TMP_56 = function(note){var self = TMP_56.$$s || this;
if (note == null) note = nil;
                  
                    $writer = [$hash2(["dir", "size", "style"], {"dir": 1, "size": text, "style": "regular"})];
                    $send(note, 'shift=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];}, TMP_56.$$s = self, TMP_56.$$arity = 1, TMP_56))};}
                else {annotation = nil};
                if ($truthy(annotation)) {
                  
                  if ($truthy(pos_x)) {
                    notepos = $send([pos_x, pos_y], 'map', [], (TMP_57 = function(p){var self = TMP_57.$$s || this;
if (p == null) p = nil;
                    return p.$to_f()}, TMP_57.$$s = self, TMP_57.$$arity = 1, TMP_57))};
                  position = ($truthy($a = ($truthy($b = notepos) ? $b : annotation['$[]']("pos"))) ? $a : $gvars.conf['$[]']("defaults.notebound.annotation.pos"));
                  if ($truthy(entity.$znid())) {
                    conf_key = "" + "notebound.annotation." + (voice_id) + "." + (entity.$znid())};
                  if ($truthy($rb_gt(index, 0))) {
                    conf_key = "" + "notebound.annotation." + (voice_id) + "." + (entity.$znid()) + "." + (index)};
                  return result['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'NoteBoundAnnotation').$new(entity, $hash2(["style", "pos", "text"], {"style": annotation['$[]']("style"), "pos": position, "text": annotation['$[]']("text")}), conf_key));
                  } else {
                  return nil
                };
                } else {
                return nil
              };}, TMP_54.$$s = self, TMP_54.$$arity = 2, TMP_54));};
          return result;
        }, TMP_Abc2svgToHarpnotes__make_notebound_annotations_58.$$arity = 2);
        
        Opal.defn(self, '$_make_repeats_jumps_annotations', TMP_Abc2svgToHarpnotes__make_repeats_jumps_annotations_62 = function $$_make_repeats_jumps_annotations(harpnote_elements, voice_element, voice_id) {
          var TMP_59, TMP_60, self = this, the_note = nil, part_label = nil, $writer = nil, znid = nil, conf_key = nil, position = nil, text = nil, chords = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          the_note = harpnote_elements.$first();
          part_label = self.part_table['$[]'](voice_element['$[]']("time"));
          if ($truthy(self.previous_note)) {
            
            
            $writer = [the_note.$pitch()];
            $send(self.previous_note, 'next_pitch=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [the_note];
            $send(self.previous_note, 'next_playable=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if ($truthy(part_label)) {
              
              $writer = [true];
              $send(self.previous_note, 'next_first_in_part=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            
            $writer = [self.previous_note.$pitch()];
            $send(the_note, 'prev_pitch=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [self.previous_note];
            $send(the_note, 'prev_playable=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          self.previous_note = the_note;
          znid = the_note.$znid();
          if ($truthy(part_label)) {
            
            if ($truthy(znid)) {
              conf_key = "" + "notebound.partname." + (voice_id) + "." + (znid)};
            position = $gvars.conf['$[]']("defaults.notebound.partname.pos");
            
            $writer = [true];
            $send(harpnote_elements.$first(), 'first_in_part=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            harpnote_elements['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'NoteBoundAnnotation').$new(harpnote_elements.$first(), $hash2(["style", "pos", "text"], {"style": "regular", "pos": position, "text": part_label}), conf_key));};
          if ($truthy(self.next_note_marks['$[]']("repeat_start"))) {
            
            
            $writer = [true];
            $send(self.previous_note, 'first_in_part=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            self.repetition_stack['$<<'](harpnote_elements.$first());
            
            $writer = ["repeat_start", false];
            $send(self.next_note_marks, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          if ($truthy(self.next_note_marks['$[]']("first_in_part"))) {
            
            
            $writer = [true];
            $send(self.previous_note, 'first_in_part=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["first_in_part", false];
            $send(self.next_note_marks, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          if ($truthy(self.next_note_marks['$[]']("variant_ending"))) {
            
            text = self.next_note_marks['$[]']("variant_ending")['$[]']("text");
            if ($truthy(znid)) {
              conf_key = "" + "notebound.variantend." + (voice_id) + "." + (znid)};
            position = $gvars.conf['$[]']("defaults.notebound.variantend.pos");
            
            $writer = [true];
            $send(harpnote_elements.$first(), 'first_in_part=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            harpnote_elements['$<<'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'NoteBoundAnnotation').$new(harpnote_elements.$first(), $hash2(["style", "pos", "text", "policy"], {"style": "regular", "pos": position, "text": text, "policy": "Goto"}), conf_key));
            
            $writer = ["variant_ending", nil];
            $send(self.next_note_marks, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            self.variant_endings.$last().$push($hash2([], {}));
            
            $writer = ["rbstart", self.previous_note];
            $send(self.variant_endings.$last().$last(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          if ($truthy(self.next_note_marks['$[]']("variant_followup"))) {
            
            
            $writer = [true];
            $send(self.previous_note, 'first_in_part=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            self.variant_endings['$[]'](-2).$push($hash2(["rbstart", "is_followup"], {"rbstart": self.previous_note, "is_followup": true}));
            
            $writer = ["variant_followup", false];
            $send(self.next_note_marks, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          chords = self.$_extract_chord_lines(voice_element);
          return $send($send(chords, 'select', [], (TMP_59 = function(chord){var self = TMP_59.$$s || this;
if (chord == null) chord = nil;
          return chord['$[]'](0)['$=='](":")}, TMP_59.$$s = self, TMP_59.$$arity = 1, TMP_59)), 'each', [], (TMP_60 = function(name){var self = TMP_60.$$s || this, TMP_61;
            if (self.jumptargets == null) self.jumptargets = nil;
if (name == null) name = nil;
          
            $writer = [name['$[]']($range(1, -1, false)), $send(harpnote_elements, 'select', [], (TMP_61 = function(n){var self = TMP_61.$$s || this;
if (n == null) n = nil;
            return n['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable'))}, TMP_61.$$s = self, TMP_61.$$arity = 1, TMP_61)).$last()];
            $send(self.jumptargets, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_60.$$s = self, TMP_60.$$arity = 1, TMP_60));
        }, TMP_Abc2svgToHarpnotes__make_repeats_jumps_annotations_62.$$arity = 3);
        
        Opal.defn(self, '$_get_extra', TMP_Abc2svgToHarpnotes__get_extra_64 = function $$_get_extra(voice_element, id) {
          var $a, TMP_63, self = this, r = nil;

          
          r = (function() { try {
            
            return ($truthy($a = voice_element['$[]']("extra")) ? $send(voice_element['$[]']("extra"), 'select', [], (TMP_63 = function(e){var self = TMP_63.$$s || this;
if (e == null) e = nil;
            return e['$[]']("type").$to_s()['$=='](id.$to_s())}, TMP_63.$$s = self, TMP_63.$$arity = 1, TMP_63)).$first() : $a);
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }})();
          return r;
        }, TMP_Abc2svgToHarpnotes__get_extra_64.$$arity = 2);
        
        Opal.defn(self, '$_push_slur', TMP_Abc2svgToHarpnotes__push_slur_65 = function $$_push_slur() {
          var self = this;

          return (self.slurstack = $rb_plus(self.slurstack, 1))
        }, TMP_Abc2svgToHarpnotes__push_slur_65.$$arity = 0);
        
        Opal.defn(self, '$_pop_slur', TMP_Abc2svgToHarpnotes__pop_slur_66 = function $$_pop_slur() {
          var self = this, result = nil;

          
          result = self.slurstack;
          self.slurstack = $rb_minus(self.slurstack, 1);
          if ($truthy($rb_lt(self.slurstack, 0))) {
            self.slurstack = 0};
          return result;
        }, TMP_Abc2svgToHarpnotes__pop_slur_66.$$arity = 0);
        
        Opal.defn(self, '$_extract_chord_lines', TMP_Abc2svgToHarpnotes__extract_chord_lines_69 = function $$_extract_chord_lines(voice_element) {
          var TMP_67, TMP_68, self = this, chords = nil, result = nil;

          
          chords = voice_element['$[]']("a_gch");
          if ($truthy(chords)) {
            result = $send($send(chords, 'select', [], (TMP_67 = function(e){var self = TMP_67.$$s || this, $writer = nil;
if (e == null) e = nil;
            
              $writer = ["type", "^"];
              $send(e, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, TMP_67.$$s = self, TMP_67.$$arity = 1, TMP_67)), 'map', [], (TMP_68 = function(e){var self = TMP_68.$$s || this;
if (e == null) e = nil;
            return e['$[]']("text")}, TMP_68.$$s = self, TMP_68.$$arity = 1, TMP_68))
            } else {
            result = []
          };
          return result;
        }, TMP_Abc2svgToHarpnotes__extract_chord_lines_69.$$arity = 1);
        
        Opal.defn(self, '$_extract_goto_info_from_bar', TMP_Abc2svgToHarpnotes__extract_goto_info_from_bar_72 = function $$_extract_goto_info_from_bar(bar) {
          var TMP_70, self = this, chordlines = nil, result = nil;

          
          chordlines = self.$_extract_chord_lines(bar);
          result = $send(chordlines, 'inject', [[]], (TMP_70 = function(result, line){var self = TMP_70.$$s || this, TMP_71, level = nil, target = nil, distance = nil, start_pos = nil, end_pos = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (result == null) result = nil;if (line == null) line = nil;
          
            if ($truthy(line['$start_with?']("@"))) {
              
              level = line.$match(/^^@([^\@]*)@(\-?\d*)(,(\-?\d*),(\-?\d*))?$/);
              if ($truthy(level)) {
                
                target = level['$[]'](1);
                distance = $send([2, 4, 5], 'map', [], (TMP_71 = function(i){var self = TMP_71.$$s || this;
if (i == null) i = nil;
                if ($truthy(level['$[]'](i))) {
                    return level['$[]'](i).$to_i()
                    } else {
                    return nil
                  }}, TMP_71.$$s = self, TMP_71.$$arity = 1, TMP_71)).$compact();
                result.$push($hash2(["target", "distance"], {"target": target, "distance": distance}));
                } else {
                
                start_pos = self.$charpos_to_line_column(bar['$[]']("istart"));
                end_pos = self.$charpos_to_line_column(bar['$[]']("iend"));
                $gvars.log.$error("Syntax-Error in Jump anotation", start_pos, end_pos);
              };};
            return result;}, TMP_70.$$s = self, TMP_70.$$arity = 2, TMP_70));
          return result;
        }, TMP_Abc2svgToHarpnotes__extract_goto_info_from_bar_72.$$arity = 1);
        
        Opal.defn(self, '$_parse_decorations', TMP_Abc2svgToHarpnotes__parse_decorations_75 = function $$_parse_decorations(voice_element) {
          var $a, TMP_73, TMP_74, self = this, a_dd = nil, result = nil;

          
          a_dd = ($truthy($a = voice_element['$[]']("a_dd")) ? $a : []);
          result = $send(a_dd, 'map', [], (TMP_73 = function(dd){var self = TMP_73.$$s || this;
if (dd == null) dd = nil;
          return (result = dd['$[]']("name").$to_sym())}, TMP_73.$$s = self, TMP_73.$$arity = 1, TMP_73));
          return $send(result.$flatten(), 'select', [], (TMP_74 = function(i){var self = TMP_74.$$s || this;
if (i == null) i = nil;
          return ["fermata", "emphasis"]['$include?'](i)}, TMP_74.$$s = self, TMP_74.$$arity = 1, TMP_74));
        }, TMP_Abc2svgToHarpnotes__parse_decorations_75.$$arity = 1);
        
        Opal.defn(self, '$_parse_origin', TMP_Abc2svgToHarpnotes__parse_origin_76 = function $$_parse_origin(voice_element) {
          var self = this;

          return $hash2(["startChar", "endChar", "start_pos", "end_pos", "raw_voice_element"], {"startChar": voice_element['$[]']("istart"), "endChar": voice_element['$[]']("iend"), "start_pos": voice_element['$[]']("start_pos"), "end_pos": voice_element['$[]']("end_pos"), "raw_voice_element": voice_element})
        }, TMP_Abc2svgToHarpnotes__parse_origin_76.$$arity = 1);
        
        Opal.defn(self, '$_parse_slur', TMP_Abc2svgToHarpnotes__parse_slur_77 = function $$_parse_slur(slurstart) {
          var $a, self = this, startvalue = nil, result = nil;

          
          startvalue = ($truthy($a = slurstart) ? $a : 0);
          result = [];
          while ($truthy($rb_gt(startvalue, 0))) {
            
            result.$push(startvalue['$&'](15));
            startvalue = startvalue['$>>'](4);
          };
          return result;
        }, TMP_Abc2svgToHarpnotes__parse_slur_77.$$arity = 1);
        return (Opal.defn(self, '$_parse_tuplet_info', TMP_Abc2svgToHarpnotes__parse_tuplet_info_78 = function $$_parse_tuplet_info(voice_element) {
          var self = this, start_pos = nil, end_pos = nil, tuplet_start = nil, tuplet = nil, tuplet_end = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          if ($truthy(voice_element['$[]']("in_tuplet"))) {
            
            if ($truthy(voice_element['$[]']("tp1"))) {
              
              start_pos = self.$charpos_to_line_column(voice_element['$[]']("istart"));
              end_pos = self.$charpos_to_line_column(voice_element['$[]']("iend"));
              $gvars.log.$error($rb_plus("" + "abc:" + (start_pos.$first()) + ":" + (start_pos.$last()) + " Error: ", Opal.const_get_relative($nesting, 'I18n').$t("Nested Tuplet")), start_pos, end_pos);};
            if ($truthy(voice_element['$[]']("tp0"))) {
              
              self.tuplet_p = voice_element['$[]']("tp0");
              tuplet_start = true;
              } else {
              tuplet_start = nil
            };
            tuplet = self.tuplet_p;
            if ($truthy(voice_element['$[]']("te0"))) {
              tuplet_end = true
              } else {
              tuplet_end = nil
            };
            } else {
            
            tuplet = 1;
            tuplet_start = nil;
            tuplet_end = nil;
          };
          return [tuplet, tuplet_end, tuplet_start];
        }, TMP_Abc2svgToHarpnotes__parse_tuplet_info_78.$$arity = 1), nil) && '_parse_tuplet_info';
      })($nesting[0], Opal.const_get_relative($nesting, 'AbstractAbcToHarpnotes'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["opal-svg"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $hash2 = Opal.hash2, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$lambda', '$info', '$conf_key', '$Native', '$clear', '$+', '$push', '$join', '$first', '$last', '$to_n', '$call', '$map', '$round', '$[]', '$Vector2d', '$-', '$x', '$y', '$path_to_raphael', '$to_a', '$[]=', '$*', '$rotate', '$-@', '$angle', '$make_path_from_jumpline', '$_attr_to_xml', '$new_id!', '$/', '$delete', '$is_a?', '$inject', '$path', '$split']);
  return (function($base, $parent_nesting) {
    var $ZnSvg, self = $ZnSvg = $module($base, 'ZnSvg');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Paper(){};
      var self = $Paper = $klass($base, $super, 'Paper', $Paper);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Paper_initialize_6, TMP_Paper_new_id$B_7, TMP_Paper_get_svg_8, TMP_Paper_line_width$eq_9, TMP_Paper_clear_10, TMP_Paper_on_mouseover_11, TMP_Paper_on_mouseout_12, TMP_Paper_on_drag_start_13, TMP_Paper_on_drag_end_14, TMP_Paper_on_draggable_rightclick_15, TMP_Paper_set_canvas_16, TMP_Paper_set_conf_editable_17, TMP_Paper_set_draggable_pos_20, TMP_Paper_set_draggable_tuplet_23, TMP_Paper_set_draggable_imagesize_24, TMP_Paper_set_draggable_jumpline_25, TMP_Paper_add_abcref_26, TMP_Paper_ellipse_27, TMP_Paper_image_28, TMP_Paper_path_29, TMP_Paper_path_to_raphael_31, TMP_Paper_rect_32, TMP_Paper_set_view_box_33, TMP_Paper_line_34, TMP_Paper_text_36, TMP_Paper__attr_to_xml_38, TMP_Paper_size_outdated_39, TMP_Paper_scroll_to_element_40;

      def.id = def.svgbuffer = def.canvas = def.viewbox = def.on_mouseover_handler = def.on_mouseout_handler = def.draggable_rightclick_handler = def.draggable_dragstart_handler = def.draggable_dragend_handler = def.line_width = def.container_id = nil;
      
      
      Opal.defn(self, '$initialize', TMP_Paper_initialize_6 = function $$initialize(container_id, width, height) {
        var TMP_1, TMP_2, TMP_3, TMP_4, TMP_5, self = this;

        
        self.container_id = container_id;
        self.draggable_dragstart_handler = $send(self, 'lambda', [], (TMP_1 = function(dropinfo){var self = TMP_1.$$s || this;
if (dropinfo == null) dropinfo = nil;
        return nil}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));
        self.draggable_dragend_handler = $send(self, 'lambda', [], (TMP_2 = function(dropinfo){var self = TMP_2.$$s || this;
if (dropinfo == null) dropinfo = nil;
        return nil}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));
        self.on_mouseover_handler = $send(self, 'lambda', [], (TMP_3 = function(dropinfo){var self = TMP_3.$$s || this;
          if ($gvars.log == null) $gvars.log = nil;
if (dropinfo == null) dropinfo = nil;
        return $gvars.log.$info(self.$Native(dropinfo).$conf_key())}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3));
        self.on_mouseout_handler = $send(self, 'lambda', [], (TMP_4 = function(dropinfo){var self = TMP_4.$$s || this;
          if ($gvars.log == null) $gvars.log = nil;
if (dropinfo == null) dropinfo = nil;
        return $gvars.log.$info(self.$Native(dropinfo).$conf_key())}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));
        self.draggable_rightclick_handler = $send(self, 'lambda', [], (TMP_5 = function(dropinfo){var self = TMP_5.$$s || this;
if (dropinfo == null) dropinfo = nil;
        return nil}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
        self.canvas = [width, height];
        self.scale = 1;
        self.viewbox = [0, 0, 420, 297];
        self.svgbuffer = [];
        self.id = 0;
        self.line_width = 0.2;
        return self.$clear();
      }, TMP_Paper_initialize_6.$$arity = 3);
      
      Opal.defn(self, '$new_id!', TMP_Paper_new_id$B_7 = function() {
        var self = this;

        return "" + "ZN_" + ((self.id = $rb_plus(self.id, 1)))
      }, TMP_Paper_new_id$B_7.$$arity = 0);
      
      Opal.defn(self, '$get_svg', TMP_Paper_get_svg_8 = function $$get_svg() {
        var self = this;

        
        self.svgbuffer.$push("</svg>");
        return self.svgbuffer.$join();
      }, TMP_Paper_get_svg_8.$$arity = 0);
      
      Opal.defn(self, '$line_width=', TMP_Paper_line_width$eq_9 = function(width) {
        var self = this;

        return (self.line_width = width)
      }, TMP_Paper_line_width$eq_9.$$arity = 1);
      
      Opal.defn(self, '$clear', TMP_Paper_clear_10 = function $$clear() {
        var self = this;

        
        self.id = 0;
        self.svgbuffer = [];
        return self.svgbuffer.$push("" + "<svg width=\"" + (self.canvas.$first()) + "\" height=\"" + (self.canvas.$last()) + "\" viewBox=\"" + (self.viewbox.$join(", ")) + "\" > ");
      }, TMP_Paper_clear_10.$$arity = 0);
      
      Opal.defn(self, '$on_mouseover', TMP_Paper_on_mouseover_11 = function $$on_mouseover() {
        var self = this, $iter = TMP_Paper_on_mouseover_11.$$p, block = $iter || nil;

        if ($iter) TMP_Paper_on_mouseover_11.$$p = null;
        return (self.on_mouseover_handler = block)
      }, TMP_Paper_on_mouseover_11.$$arity = 0);
      
      Opal.defn(self, '$on_mouseout', TMP_Paper_on_mouseout_12 = function $$on_mouseout() {
        var self = this, $iter = TMP_Paper_on_mouseout_12.$$p, block = $iter || nil;

        if ($iter) TMP_Paper_on_mouseout_12.$$p = null;
        return (self.on_mouseout_handler = block)
      }, TMP_Paper_on_mouseout_12.$$arity = 0);
      
      Opal.defn(self, '$on_drag_start', TMP_Paper_on_drag_start_13 = function $$on_drag_start() {
        var self = this, $iter = TMP_Paper_on_drag_start_13.$$p, block = $iter || nil;

        if ($iter) TMP_Paper_on_drag_start_13.$$p = null;
        return (self.draggable_dragstart_handler = block)
      }, TMP_Paper_on_drag_start_13.$$arity = 0);
      
      Opal.defn(self, '$on_drag_end', TMP_Paper_on_drag_end_14 = function $$on_drag_end() {
        var self = this, $iter = TMP_Paper_on_drag_end_14.$$p, block = $iter || nil;

        if ($iter) TMP_Paper_on_drag_end_14.$$p = null;
        return (self.draggable_dragend_handler = block)
      }, TMP_Paper_on_drag_end_14.$$arity = 0);
      
      Opal.defn(self, '$on_draggable_rightclick', TMP_Paper_on_draggable_rightclick_15 = function $$on_draggable_rightclick() {
        var self = this, $iter = TMP_Paper_on_draggable_rightclick_15.$$p, block = $iter || nil;

        if ($iter) TMP_Paper_on_draggable_rightclick_15.$$p = null;
        return (self.draggable_rightclick_handler = block)
      }, TMP_Paper_on_draggable_rightclick_15.$$arity = 0);
      
      Opal.defn(self, '$set_canvas', TMP_Paper_set_canvas_16 = function $$set_canvas(size) {
        var self = this;

        
        self.canvas = size;
        return nil;
      }, TMP_Paper_set_canvas_16.$$arity = 1);
      
      Opal.defn(self, '$set_conf_editable', TMP_Paper_set_conf_editable_17 = function $$set_conf_editable(svg_element, conf_key, more_conf_keys) {
        var self = this;

        
        
          var me = svg_element;
          mouseoverFnc = function(){
            self.on_mouseover_handler({element: me, conf_key: conf_key})
          }

          mouseoutFnc = function(){
            self.on_mouseout_handler({element: me, conf_key: conf_key})
          }
          me.mouseover(mouseoverFnc);
          me.mouseout(mouseoutFnc);

          // as we bind the handler on a mouseover, the event does not fire on very first mouseover
          // so we call it here to display the conf_key even on the first move
          // todo: do not know why it worked on draggable elements
          mouseoverFnc({element:me, conf_key: conf_key});

          me[0].oncontextmenu = function(){ return self.draggable_rightclick_handler({element: svg_element, conf_key: conf_key, more_conf_keys: more_conf_keys});};
      ;
        return nil;
      }, TMP_Paper_set_conf_editable_17.$$arity = 3);
      
      Opal.defn(self, '$set_draggable_pos', TMP_Paper_set_draggable_pos_20 = function $$set_draggable_pos(svg_element_id, conf_key, conf_value) {
        var TMP_18, TMP_19, self = this, conf_value_new = nil;

        
        conf_value_new = conf_value.$to_n();
        

          var xx = SVG.get(svg_element_id);
          var sy = 0, sy=0;
          xx.addClass("zn_draggable");

          xx.draggable(function(x, y) {
            return {
              x: Math.round(x),// Math.floor(x),
              y: Math.round(y)// Math.floor(y)
            }
          });

          xx.on('dragstart', function(e) {
             self.draggable_dragstart_handler.$call($hash2(["element", "conf_key", "conf_value_new"], {"element": this, "conf_key": conf_key, "conf_value_new": $send(self.$Native(conf_value_new), 'map', [], (TMP_18 = function(i){var self = TMP_18.$$s || this;
if (i == null) i = nil;
        return i.$round(2)}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18))}));
            ismoved = false;
            sx = e.detail.p.x;
            sy = e.detail.p.y;
            this.fill("blue");
          });

          // todo: don't know why 'this' is the only way to change the filling ...
          xx.on('dragend', function(e) {

            this.fill("red");
            deltax =  Math.round(e.detail.p.x - sx);
            deltay =  Math.round(e.detail.p.y - sy);

            conf_value_new[0] += deltax;
            conf_value_new[1] += deltay;

             self.draggable_dragend_handler.$call($hash2(["element", "conf_key", "conf_value_new"], {"element": this, "conf_key": conf_key, "conf_value_new": $send(self.$Native(conf_value_new), 'map', [], (TMP_19 = function(i){var self = TMP_19.$$s || this;
if (i == null) i = nil;
        return i.$round(2)}, TMP_19.$$s = self, TMP_19.$$arity = 1, TMP_19))}));
          })
      ;
        return nil;
      }, TMP_Paper_set_draggable_pos_20.$$arity = 3);
      
      Opal.defn(self, '$set_draggable_tuplet', TMP_Paper_set_draggable_tuplet_23 = function $$set_draggable_tuplet(svg_element_id, conf_key, conf_value, draginfo) {
        var TMP_21, TMP_22, self = this, p1 = nil, p2 = nil, cp1 = nil, cp2 = nil, deltap = nil, $writer = nil, rotate_by = nil, np1 = nil, np2 = nil;

        
      var xx = SVG.get(svg_element_id);
      var cp_id = "to be set after dragging"
      xx.addClass("zn_draggable");
      xx.draggable();

      var sx = 0,                 // initialize the outer variables for the closures
          sy = 0,
          target_id = null,
          target_curve=null;


      // *******************************************************************************************
      xx.on('dragstart', function(e) {

        self.draggable_dragstart_handler.$call($hash2(["element", "conf_key"], {"element": this, "conf_key": conf_key}));

        sx = e.detail.p.x;
        sy = e.detail.p.y;
        this.stroke("blue");
        target_id = draginfo['$[]']("target_id");
        target_curve = document.getElementById(target_id)
      });



      // *******************************************************************************************
      xx.on('dragmove', function(e){

        e.preventDefault();

        dx = e.detail.p.x - sx; // dx = dx - dx % 5;
        dy = e.detail.p.y - sy; // dy = dy - dy % 5;
        ((p1 = self.$Vector2d(draginfo['$[]']("p1"))), (p2 = self.$Vector2d(draginfo['$[]']("p2"))), (cp1 = self.$Vector2d(draginfo['$[]']("cp1"))), (cp2 = self.$Vector2d(draginfo['$[]']("cp2"))), (deltap = $rb_minus(p2, p1)))

      // need to find out which of the handle was drag
      cp_id = e.target.childNodes[0].attributes['data-cp'].value // use childNodes for Edge Browser
      if (cp_id == "cp1") {(cp1 = $rb_plus(cp1, [dx, dy]))}
                 else {(cp2 = $rb_plus(cp2, [dx, dy]))}

      // the bezier curve
      newpath = [['M', p1.$x(), p1.$y()], ['C', cp1.$x(), cp1.$y(), cp2.$x(), cp2.$y(), p2.$x(), p2.$y()]]
      np = self.$path_to_raphael(newpath);
      target_curve.childNodes[0].setAttribute('d', np);

      // draw the lines to illustrate the controlpoints
      newpath = [['M', p1.$x(), p1.$y()], ['L', cp1.$x(), cp1.$y()], ['L', cp2.$x(), cp2.$y()], ['L', p2.$x(), p2.$y()]]
      np = self.$path_to_raphael(newpath);
      e.target.firstChild.setAttribute('d', np);

      })

      // *************************************************************************************************************
        xx.on('dragend', function(e) {
      ((($writer = ["cp1", cp1.$to_a()]), $send(draginfo, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]), (($writer = ["cp2", cp2.$to_a()]), $send(draginfo, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
          this.stroke("red");
            conf_key_to_change = draginfo['$[]']("conf_key") + "." + cp_id;

            ((rotate_by = $rb_times(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Math'), 'PI'), 0.5)), (np1 = $rb_minus(p1, cp1).$rotate(deltap.$angle()['$-@']()).$rotate(rotate_by['$-@']())), (np2 = $rb_minus(p2, cp2).$rotate(deltap.$angle()['$-@']()).$rotate(rotate_by['$-@']())))

             if (cp_id == "cp1") {
                 conf_value_new = $send(np1.$to_a(), 'map', [], (TMP_21 = function(i){var self = TMP_21.$$s || this;
if (i == null) i = nil;
        return i.$round(2)}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21))
                  newpath = [['M', p1.$x(), p1.$y()], ['L', cp1.$x(), cp1.$y()]]
                  np = self.$path_to_raphael(newpath);
                  e.target.firstChild.setAttribute('d', np);
                }
                 else
                {
                 conf_value_new = $send(np2.$to_a(), 'map', [], (TMP_22 = function(i){var self = TMP_22.$$s || this;
if (i == null) i = nil;
        return i.$round(2)}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22))
                  newpath = [['M', p2.$x(), p2.$y()],  ['L', cp2.$x(), cp2.$y()]]
                  np = self.$path_to_raphael(newpath);
                  e.target.firstChild.setAttribute('d', np);
                }

            self.draggable_dragend_handler( { conf_key: conf_key_to_change, conf_value_new: conf_value_new } )
        })
      
      }, TMP_Paper_set_draggable_tuplet_23.$$arity = 4);
      
      Opal.defn(self, '$set_draggable_imagesize', TMP_Paper_set_draggable_imagesize_24 = function $$set_draggable_imagesize(svg_element_id, conf_key, conf_value, draginfo) {
        var self = this;

        
      var xx = SVG.get(svg_element_id);
      xx.addClass("nn_draggable")
      xx.draggable();
      
      }, TMP_Paper_set_draggable_imagesize_24.$$arity = 4);
      
      Opal.defn(self, '$set_draggable_jumpline', TMP_Paper_set_draggable_jumpline_25 = function $$set_draggable_jumpline(svg_element_id, conf_key, conf_value, draginfo) {
        var self = this, vertical = nil, $writer = nil, newpath = nil;
        if ($gvars.conf == null) $gvars.conf = nil;

        

      var xx = SVG.get(svg_element_id);
      xx.addClass("zn_draggable");

      xx.draggable();

      xx.on('dragstart', function(e) {
        self.draggable_dragstart_handler.$call($hash2(["element", "conf_key"], {"element": this, "conf_key": conf_key}));
        (vertical = draginfo['$[]']("jumpline")['$[]']("vertical"))
        sx = e.detail.p.x;
        sy = e.detail.p.y;
        this.stroke("blue");
      });

      xx.on('dragmove', function(e){
        e.preventDefault();

        dx = e.detail.p.x - sx;
        dx = dx - dx % draginfo['$[]']("xspacing"); // we still drag in string rasters.

        ((($writer = ["vertical", $rb_plus(vertical, dx)]), $send(draginfo['$[]']("jumpline"), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]), (newpath = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Layout'), 'Default').$make_path_from_jumpline(draginfo['$[]']("jumpline"))['$[]'](0)))

        np = self.$path_to_raphael(newpath)
        e.target.childNodes[0].setAttribute('d', np);
      })

        // todo: don't know why 'this' is the only way to change the filling ...
        xx.on('dragend', function(e) {
          this.stroke("red");
          var result = {
            delta: [ e.detail.p.x - sx, e.detail.p.y - sy],
            element: svg_element_id
          };
            conf_value_new = Math.round(((vertical + dx ) / $gvars.conf['$[]']("layout.X_SPACING")))  // todo: #154 this does not work for diatonic instruments
            if (conf_value_new <= 0) conf_value_new -= 1
            self.draggable_dragend_handler( { delta: [e.detail.p.x - sx, e.detail.p.y - sy], element: this, conf_key: conf_key, conf_value: conf_value, conf_value_new: conf_value_new } )
        })
      
      }, TMP_Paper_set_draggable_jumpline_25.$$arity = 4);
      
      Opal.defn(self, '$add_abcref', TMP_Paper_add_abcref_26 = function $$add_abcref(x, y, rx, ry, start_char, attributes) {
        var self = this, attr = nil, id = nil, padding = nil, svg = nil;

        if (start_char == null) {
          start_char = nil;
        }
        if (attributes == null) {
          attributes = $hash2([], {});
        }
        
        attr = self.$_attr_to_xml(attributes);
        id = self['$new_id!']();
        padding = 2;
        svg = "" + "<rect " + (attr) + " class=\"abcref znref _" + (start_char) + "_\" id=\"" + (id) + "\" x=\"" + ($rb_minus($rb_minus(x, rx), $rb_divide(padding, 2))) + "\" y=\"" + ($rb_minus($rb_minus(y, ry), $rb_divide(padding, 2))) + "\" width=\"" + ($rb_plus($rb_times(2, rx), padding)) + "\" height=\"" + ($rb_plus($rb_times(2, ry), padding)) + "\"/>";
        self.svgbuffer.$push(svg);
        return id;
      }, TMP_Paper_add_abcref_26.$$arity = -5);
      
      Opal.defn(self, '$ellipse', TMP_Paper_ellipse_27 = function $$ellipse(x, y, rx, ry, attributes) {
        var self = this, attr = nil, svg = nil;

        if (attributes == null) {
          attributes = $hash2([], {});
        }
        
        attr = self.$_attr_to_xml(attributes);
        svg = "" + "<ellipse  cx=\"" + (x) + "\" cy=\"" + (y) + "\" rx=\"" + (rx) + "\" ry=\"" + (ry) + "\" stroke-width=\"" + (self.line_width) + "\" " + (attr) + "/>";
        self.svgbuffer.$push(svg);
        return nil;
      }, TMP_Paper_ellipse_27.$$arity = -5);
      
      Opal.defn(self, '$image', TMP_Paper_image_28 = function $$image(url, x, y, height) {
        var self = this, id = nil;

        
        id = self['$new_id!']();
        self.svgbuffer.$push("" + "  <image id = " + (id) + " x=\"" + (x) + "\" y=\"" + (y) + "\" height=\"" + (height) + "\"\n" + "    preserveAspectRatio=\"none\"\n" + "    xlink:href=\"" + (url) + "\">\n" + "  </image>");
        return id;
      }, TMP_Paper_image_28.$$arity = 4);
      
      Opal.defn(self, '$path', TMP_Paper_path_29 = function $$path(spec, attributes, bgrectspec) {
        var self = this, thespec = nil, id = nil, group_attrs = nil, $writer = nil, attrs = nil, bgrect = nil;

        if (attributes == null) {
          attributes = $hash2([], {});
        }
        if (bgrectspec == null) {
          bgrectspec = nil;
        }
        
        thespec = self.$path_to_raphael(spec);
        id = self['$new_id!']();
        group_attrs = self.$_attr_to_xml($hash2(["fill", "stroke"], {"fill": attributes['$[]']("fill"), "stroke": attributes['$[]']("stroke")}));
        attributes.$delete("fill");
        attributes.$delete("stroke");
        if ($truthy(attributes['$[]']("stroke-width"))) {
          } else {
          
          $writer = ["stroke-width", self.line_width];
          $send(attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        attrs = self.$_attr_to_xml(attributes);
        if ($truthy(bgrectspec)) {
          bgrect = "" + "<rect class=\"abcref\" x=\"" + (bgrectspec['$[]'](0)) + "\" y=\"" + (bgrectspec['$[]'](1)) + "\" width=\"" + (bgrectspec['$[]'](2)) + "\" height=\"" + (bgrectspec['$[]'](3)) + "\" />"};
        self.svgbuffer.$push("" + "<g id=\"" + (id) + "\" " + (group_attrs) + " >" + (bgrect) + "<path id=\"" + (id) + "\" " + (attrs) + " d=\"" + (thespec) + "\"/></g>");
        return id;
      }, TMP_Paper_path_29.$$arity = -2);
      
      Opal.defn(self, '$path_to_raphael', TMP_Paper_path_to_raphael_31 = function $$path_to_raphael(path) {
        var TMP_30, self = this, result = nil;

        
        if ($truthy(path['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
          result = $send(path, 'inject', [""], (TMP_30 = function(result, element){var self = TMP_30.$$s || this;
if (result == null) result = nil;if (element == null) element = nil;
          
            result = $rb_plus(result, element.$first());
            return (result = $rb_plus(result, element['$[]']($range(1, -1, false)).$join(" ")));}, TMP_30.$$s = self, TMP_30.$$arity = 2, TMP_30))
          } else {
          result = path
        };
        return result;
      }, TMP_Paper_path_to_raphael_31.$$arity = 1);
      
      Opal.defn(self, '$rect', TMP_Paper_rect_32 = function $$rect(x, y, rx, ry, radius, attributes) {
        var self = this, id = nil, attr = nil;

        if (radius == null) {
          radius = 0;
        }
        if (attributes == null) {
          attributes = $hash2(["fill", "stroke", "stroke-width"], {"fill": "none", "stroke": "black", "stroke-width": self.line_width});
        }
        
        id = self['$new_id!']();
        attr = self.$_attr_to_xml(attributes);
        self.svgbuffer.$push("" + "<rect id=\"" + (id) + "\" x=\"" + (x) + "\" y=\"" + (y) + "\" width=\"" + (rx) + "\" height=\"" + (ry) + "\" rx=\"" + (radius) + "\" ry=\"" + (radius) + "\"  stroke-width=\"" + (self.line_width) + "\" " + (attr) + " />");
        return id;
      }, TMP_Paper_rect_32.$$arity = -5);
      
      Opal.defn(self, '$set_view_box', TMP_Paper_set_view_box_33 = function $$set_view_box(x, y, width, height, fit) {
        var self = this;

        
        self.viewbox = [x, y, width, height];
        return (self.scale = $rb_divide(self.canvas.$last(), height));
      }, TMP_Paper_set_view_box_33.$$arity = 5);
      
      Opal.defn(self, '$line', TMP_Paper_line_34 = function $$line(x1, y1, x2, y2, attributes, draginfo) {
        var self = this;

        if (attributes == null) {
          attributes = $hash2([], {});
        }
        if (draginfo == null) {
          draginfo = nil;
        }
        return self.$path("" + "M" + (x1) + "," + (y1) + "L" + (x2) + "," + (y2), attributes)
      }, TMP_Paper_line_34.$$arity = -5);
      
      Opal.defn(self, '$text', TMP_Paper_text_36 = function $$text(x, y, text, attributes) {
        var TMP_35, self = this, id = nil, attrs = nil, tspans = nil;

        if (attributes == null) {
          attributes = $hash2([], {});
        }
        
        id = self['$new_id!']();
        attrs = self.$_attr_to_xml(attributes);
        tspans = $send(text.$split("\n"), 'map', [], (TMP_35 = function(l){var self = TMP_35.$$s || this;
if (l == null) l = nil;
        return "" + "<tspan dy=\"1.2em\" x=\"" + (x) + "\">" + (l) + "</tspan>"}, TMP_35.$$s = self, TMP_35.$$arity = 1, TMP_35)).$join();
        self.svgbuffer.$push("" + "<g id=\"" + (id) + "\" x=\"" + (x) + "\" y=\"" + (y) + "\"><text x=\"" + (x) + "\" y=\"" + (y) + "\" id=\"" + (id) + "\" " + (attrs) + ">" + (tspans) + "</text></g>");
        return id;
      }, TMP_Paper_text_36.$$arity = -4);
      
      Opal.defn(self, '$_attr_to_xml', TMP_Paper__attr_to_xml_38 = function $$_attr_to_xml(attributes) {
        var TMP_37, self = this;

        return $send(attributes, 'map', [], (TMP_37 = function(k, v){var self = TMP_37.$$s || this;
if (k == null) k = nil;if (v == null) v = nil;
        return "" + (k) + "=\"" + (v) + "\""}, TMP_37.$$s = self, TMP_37.$$arity = 2, TMP_37)).$join(" ")
      }, TMP_Paper__attr_to_xml_38.$$arity = 1);
      
      Opal.defn(self, '$size_outdated', TMP_Paper_size_outdated_39 = function $$size_outdated() {
        var self = this;

        return [self.r.canvas.offsetWidth, self.r.canvas.offsetHeight]
      }, TMP_Paper_size_outdated_39.$$arity = 0);
      return (Opal.defn(self, '$scroll_to_element', TMP_Paper_scroll_to_element_40 = function $$scroll_to_element(element) {
        var self = this;

        
        height = $("#" + self.container_id + " svg").height();
        thetopraw = element[0].y.baseVal.value;
        thetop = thetopraw * (height / self.viewbox['$[]'](3)) - 100;  // keep 110 px from top border
        $("#"+self.container_id).get(0).scrollTop = thetop;
      
      }, TMP_Paper_scroll_to_element_40.$$arity = 1), nil) && 'scroll_to_element';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["svg_engine"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$attr_reader', '$nil?', '$find', '$new', '$include?', '$bind_the_element', '$push', '$stopPropagation', '$Native', '$dig', '$call', '$set_view_box', '$set_canvas', '$get_svg', '$save_scroll_position', '$html', '$t', '$[]', '$first', '$last', '$warn', '$clear', '$rect', '$+', '$-', '$each', '$children', '$line_width', '$line_width=', '$is_a?', '$visible?', '$draw_ellipse', '$draw_flowline', '$draw_glyph', '$draw_annotation', '$draw_path', '$draw_image', '$error', '$class', '$flush', '$on_mouseover', '$on_mouseout', '$on_drag_start', '$on_drag_end', '$on_draggable_rightclick', '$unhighlight_element', '$unhighlight_all', '$range_highlight_more', '$get_elements_by_range', '$highlight_element', '$==', '$empty?', '$scroll_to_element', '$private', '$sort', '$map', '$>', '$*', '$add_class', '$remove_class', '$set_conf_editable', '$===', '$set_draggable_pos', '$set_draggable_jumpline', '$set_draggable_tuplet', '$origin', '$!', '$tap', '$delete', '$conf_key', '$conf_value', '$more_conf_keys', '$draginfo', '$[]=', '$color', '$fill', '$size', '$rect?', '$center', '$ellipse', '$/', '$dotted?', '$draw_the_dot', '$hasbarover?', '$draw_the_barover', '$add_abcref', '$merge', '$push_element', '$glyph', '$path', '$style', '$line', '$from', '$to', '$distance', '$level', '$get', '$gsub', '$text', '$-@', '$to_s', '$align', '$Vector2d', '$llpos', '$height', '$image', '$url', '$x', '$y', '$filled?']);
  
  self.$require("opal-svg");
  self.$require("harpnotes");
  return (function($base, $parent_nesting) {
    var $Harpnotes, self = $Harpnotes = $module($base, 'Harpnotes');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $SvgEngine(){};
      var self = $SvgEngine = $klass($base, $super, 'SvgEngine', $SvgEngine);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SvgEngine_initialize_1, TMP_SvgEngine__bind_on_mouseover_2, TMP_SvgEngine__clickabcnote_3, TMP_SvgEngine_set_view_box_4, TMP_SvgEngine_set_canvas_5, TMP_SvgEngine_clear_6, TMP_SvgEngine_flush_7, TMP_SvgEngine_display_no_preview_available_8, TMP_SvgEngine_save_scroll_position_9, TMP_SvgEngine_set_svg_10, TMP_SvgEngine_draw_12, TMP_SvgEngine_on_select_13, TMP_SvgEngine_on_mouseover_14, TMP_SvgEngine_on_mouseout_16, TMP_SvgEngine_on_drag_start_18, TMP_SvgEngine_on_drag_end_20, TMP_SvgEngine_on_draggable_rightcklick_22, TMP_SvgEngine_unhighlight_all_25, TMP_SvgEngine_range_highlight_26, TMP_SvgEngine_range_highlight_more_28, TMP_SvgEngine_range_unhighlight_30, TMP_SvgEngine_get_elements_by_range_33, TMP_SvgEngine_highlight_element_34, TMP_SvgEngine_scroll_to_element_35, TMP_SvgEngine_unhighlight_element_36, TMP_SvgEngine_bind_elements_38, TMP_SvgEngine_bind_the_element_39, TMP_SvgEngine_push_element_41, TMP_SvgEngine_draw_ellipse_43, TMP_SvgEngine_draw_glyph_44, TMP_SvgEngine_draw_the_barover_45, TMP_SvgEngine_draw_the_dot_46, TMP_SvgEngine_draw_flowline_47, TMP_SvgEngine_draw_jumpline_outdated_48, TMP_SvgEngine_draw_annotation_50, TMP_SvgEngine_draw_image_51, TMP_SvgEngine_draw_path_52;

      def.container_id = def.bound_elements = def.interactive_elements = def.on_select = def.paper = def.preview_container = def.preview_scroll = def.viewbox = def.highlighted = def.onclick_for_svg = def.attr_for_on_contextmenu = def.attr_for_draggable = nil;
      
      self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'));
      self.$attr_reader("paper");
      Opal.const_set($nesting[0], 'PADDING', 5);
      Opal.const_set($nesting[0], 'ARROW_SIZE', 1.0);
      Opal.const_set($nesting[0], 'JUMPLINE_INDENT', 10);
      Opal.const_set($nesting[0], 'DOTTED_SIZE', 0.5);
      Opal.const_set($nesting[0], 'COLORS', $hash2(["black", "white", "grey", "lightgrey", "darkgrey", "dimgrey"], {"black": "black", "white": "white", "grey": "grey", "lightgrey": "lightgrey", "darkgrey": "darkgrey", "dimgrey": "dimgrey"}));
      
      Opal.defn(self, '$initialize', TMP_SvgEngine_initialize_1 = function $$initialize(element_id, width, height) {
        var self = this, harpnote_preview_printer = nil;

        
        self.viewbox = [0, 0, 100, 100];
        if ($truthy(element_id['$nil?']())) {
          } else {
          
          self.container_id = element_id;
          self.preview_container = Opal.const_get_relative($nesting, 'Element').$find("" + "#" + (self.container_id));
        };
        self.paper = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'ZnSvg'), 'Paper').$new(element_id, width, height);
        self.on_select = nil;
        self.highlighted = [];
        harpnote_preview_printer = "Opal.top.uicontroller.harpnote_preview_printer";
        self.onclick_for_svg = "" + (harpnote_preview_printer) + ".$_clickabcnote(evt, id)";
        self.attr_for_on_contextmenu = $hash2(["onmouseover"], {"onmouseover": "" + (harpnote_preview_printer) + ".$_bind_on_mouseover(evt, id)"});
        return (self.attr_for_draggable = $hash2(["onmouseover"], {"onmouseover": "" + (harpnote_preview_printer) + ".$_bind_on_mouseover(evt, id)"}));
      }, TMP_SvgEngine_initialize_1.$$arity = 3);
      
      Opal.defn(self, '$_bind_on_mouseover', TMP_SvgEngine__bind_on_mouseover_2 = function $$_bind_on_mouseover(evt, id) {
        var $a, self = this;

        
        self.bound_elements = ($truthy($a = self.bound_elements) ? $a : []);
        if ($truthy(self.bound_elements['$include?'](id))) {
          return nil
          } else {
          
          self.$bind_the_element(id);
          return self.bound_elements.$push(id);
        };
      }, TMP_SvgEngine__bind_on_mouseover_2.$$arity = 2);
      
      Opal.defn(self, '$_clickabcnote', TMP_SvgEngine__clickabcnote_3 = function $$_clickabcnote(evt, id) {
        var $a, self = this, music_model_element = nil;

        
        self.$Native(evt).$stopPropagation();
        music_model_element = self.interactive_elements.$dig(id, "music_model_elemment_origin");
        if ($truthy(($truthy($a = music_model_element['$nil?']()) ? $a : self.on_select['$nil?']()))) {
          return nil
          } else {
          return self.on_select.$call(music_model_element)
        };
      }, TMP_SvgEngine__clickabcnote_3.$$arity = 2);
      
      Opal.defn(self, '$set_view_box', TMP_SvgEngine_set_view_box_4 = function $$set_view_box(x, y, width, height) {
        var self = this;

        
        self.viewbox = [x, y, width, height];
        return self.paper.$set_view_box(x, y, width, height, true);
      }, TMP_SvgEngine_set_view_box_4.$$arity = 4);
      
      Opal.defn(self, '$set_canvas', TMP_SvgEngine_set_canvas_5 = function $$set_canvas(size) {
        var self = this;

        return self.paper.$set_canvas(size)
      }, TMP_SvgEngine_set_canvas_5.$$arity = 1);
      
      Opal.defn(self, '$clear', TMP_SvgEngine_clear_6 = function $$clear() {
        var self = this;

        return (self.interactive_elements = $hash2([], {}))
      }, TMP_SvgEngine_clear_6.$$arity = 0);
      
      Opal.defn(self, '$flush', TMP_SvgEngine_flush_7 = function $$flush() {
        var self = this, svg = nil;

        
        svg = self.paper.$get_svg();
        return $hash2(["svg", "interactive_elements"], {"svg": self.paper.$get_svg(), "interactive_elements": self.interactive_elements});
      }, TMP_SvgEngine_flush_7.$$arity = 0);
      
      Opal.defn(self, '$display_no_preview_available', TMP_SvgEngine_display_no_preview_available_8 = function $$display_no_preview_available() {
        var self = this;

        
        self.$save_scroll_position();
        return self.preview_container.$html("" + "<h1>" + (Opal.const_get_relative($nesting, 'I18n').$t("no preview available yet")) + "</h1>");
      }, TMP_SvgEngine_display_no_preview_available_8.$$arity = 0);
      
      Opal.defn(self, '$save_scroll_position', TMP_SvgEngine_save_scroll_position_9 = function $$save_scroll_position() {
        var self = this;

        return (self.preview_scroll = [self.preview_container.scrollLeft(), self.preview_container.scrollTop()])
      }, TMP_SvgEngine_save_scroll_position_9.$$arity = 0);
      
      Opal.defn(self, '$set_svg', TMP_SvgEngine_set_svg_10 = function $$set_svg(svg_and_positions) {
        var self = this;
        if ($gvars.log == null) $gvars.log = nil;

        
        self.bound_elements = [];
        self.preview_container.$html(svg_and_positions['$[]']("svg"));
        self.interactive_elements = svg_and_positions['$[]']("interactive_elements");
        if ($truthy(self.preview_scroll)) {
          
        self.preview_container.scrollLeft(self.preview_scroll.$first());
        self.preview_container.scrollTop(self.preview_scroll.$last());
        
          } else {
          $gvars.log.$warn("BUG: preview Scroll empty")
        };
        return nil;
      }, TMP_SvgEngine_set_svg_10.$$arity = 1);
      
      Opal.defn(self, '$draw', TMP_SvgEngine_draw_12 = function $$draw(sheet) {
        var TMP_11, self = this;

        
        self.paper.$clear();
        self.highlighted = [];
        self.paper.$rect($rb_plus(self.viewbox['$[]'](0), 1), $rb_plus(self.viewbox['$[]'](1), 1), $rb_minus(self.viewbox['$[]'](2), 2), $rb_minus(self.viewbox['$[]'](3), 2));
        self.paper.$rect(self.viewbox['$[]'](0), self.viewbox['$[]'](1), self.viewbox['$[]'](2), self.viewbox['$[]'](3));
        $send(sheet.$children(), 'each', [], (TMP_11 = function(child){var self = TMP_11.$$s || this, $writer = nil;
          if (self.paper == null) self.paper = nil;
          if ($gvars.log == null) $gvars.log = nil;
if (child == null) child = nil;
        
          
          $writer = [child.$line_width()];
          $send(self.paper, 'line_width=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(child['$is_a?'](Opal.const_get_relative($nesting, 'Ellipse')))) {
            if ($truthy(child['$visible?']())) {
              return self.$draw_ellipse(child)
              } else {
              return nil
            }
          } else if ($truthy(child['$is_a?'](Opal.const_get_relative($nesting, 'FlowLine')))) {
            if ($truthy(child['$visible?']())) {
              return self.$draw_flowline(child)
              } else {
              return nil
            }
          } else if ($truthy(child['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Glyph')))) {
            if ($truthy(child['$visible?']())) {
              return self.$draw_glyph(child)
              } else {
              return nil
            }
          } else if ($truthy(child['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Annotation')))) {
            if ($truthy(child['$visible?']())) {
              return self.$draw_annotation(child)
              } else {
              return nil
            }
          } else if ($truthy(child['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path')))) {
            if ($truthy(child['$visible?']())) {
              return self.$draw_path(child)
              } else {
              return nil
            }
          } else if ($truthy(child['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Image')))) {
            return self.$draw_image(child)
            } else {
            
            $gvars.log.$error("" + "BUG:don't know how to draw " + (child.$class()) + " (" + ("svg_engine") + " " + (127) + ")");
            return nil;
          };}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11));
        return self.$flush();
      }, TMP_SvgEngine_draw_12.$$arity = 1);
      
      Opal.defn(self, '$on_select', TMP_SvgEngine_on_select_13 = function $$on_select() {
        var self = this, $iter = TMP_SvgEngine_on_select_13.$$p, block = $iter || nil;

        if ($iter) TMP_SvgEngine_on_select_13.$$p = null;
        return (self.on_select = block)
      }, TMP_SvgEngine_on_select_13.$$arity = 0);
      
      Opal.defn(self, '$on_mouseover', TMP_SvgEngine_on_mouseover_14 = function $$on_mouseover() {
        var TMP_15, self = this, $iter = TMP_SvgEngine_on_mouseover_14.$$p, block = $iter || nil;

        if ($iter) TMP_SvgEngine_on_mouseover_14.$$p = null;
        
        self.on_mouseover = block;
        return $send(self.paper, 'on_mouseover', [], (TMP_15 = function(info){var self = TMP_15.$$s || this;
if (info == null) info = nil;
        return block.$call(self.$Native(info))}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15));
      }, TMP_SvgEngine_on_mouseover_14.$$arity = 0);
      
      Opal.defn(self, '$on_mouseout', TMP_SvgEngine_on_mouseout_16 = function $$on_mouseout() {
        var TMP_17, self = this, $iter = TMP_SvgEngine_on_mouseout_16.$$p, block = $iter || nil;

        if ($iter) TMP_SvgEngine_on_mouseout_16.$$p = null;
        
        self.on_mouseout = block;
        return $send(self.paper, 'on_mouseout', [], (TMP_17 = function(info){var self = TMP_17.$$s || this;
if (info == null) info = nil;
        return block.$call(self.$Native(info))}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17));
      }, TMP_SvgEngine_on_mouseout_16.$$arity = 0);
      
      Opal.defn(self, '$on_drag_start', TMP_SvgEngine_on_drag_start_18 = function $$on_drag_start() {
        var TMP_19, self = this, $iter = TMP_SvgEngine_on_drag_start_18.$$p, block = $iter || nil;

        if ($iter) TMP_SvgEngine_on_drag_start_18.$$p = null;
        return $send(self.paper, 'on_drag_start', [], (TMP_19 = function(info){var self = TMP_19.$$s || this;
if (info == null) info = nil;
        return block.$call(self.$Native(info))}, TMP_19.$$s = self, TMP_19.$$arity = 1, TMP_19))
      }, TMP_SvgEngine_on_drag_start_18.$$arity = 0);
      
      Opal.defn(self, '$on_drag_end', TMP_SvgEngine_on_drag_end_20 = function $$on_drag_end() {
        var TMP_21, self = this, $iter = TMP_SvgEngine_on_drag_end_20.$$p, block = $iter || nil;

        if ($iter) TMP_SvgEngine_on_drag_end_20.$$p = null;
        return $send(self.paper, 'on_drag_end', [], (TMP_21 = function(info){var self = TMP_21.$$s || this;
if (info == null) info = nil;
        return block.$call(self.$Native(info))}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21))
      }, TMP_SvgEngine_on_drag_end_20.$$arity = 0);
      
      Opal.defn(self, '$on_draggable_rightcklick', TMP_SvgEngine_on_draggable_rightcklick_22 = function $$on_draggable_rightcklick() {
        var TMP_23, self = this, $iter = TMP_SvgEngine_on_draggable_rightcklick_22.$$p, block = $iter || nil;

        if ($iter) TMP_SvgEngine_on_draggable_rightcklick_22.$$p = null;
        
        self.on_draggable_rightclick = block;
        return $send(self.paper, 'on_draggable_rightclick', [], (TMP_23 = function(info){var self = TMP_23.$$s || this;
if (info == null) info = nil;
        return block.$call(self.$Native(info))}, TMP_23.$$s = self, TMP_23.$$arity = 1, TMP_23));
      }, TMP_SvgEngine_on_draggable_rightcklick_22.$$arity = 0);
      
      Opal.defn(self, '$unhighlight_all', TMP_SvgEngine_unhighlight_all_25 = function $$unhighlight_all() {
        var TMP_24, self = this;

        return $send(self.highlighted, 'each', [], (TMP_24 = function(e){var self = TMP_24.$$s || this;
if (e == null) e = nil;
        return self.$unhighlight_element(e)}, TMP_24.$$s = self, TMP_24.$$arity = 1, TMP_24))
      }, TMP_SvgEngine_unhighlight_all_25.$$arity = 0);
      
      Opal.defn(self, '$range_highlight', TMP_SvgEngine_range_highlight_26 = function $$range_highlight(from, to) {
        var self = this;

        
        self.$unhighlight_all();
        return self.$range_highlight_more(from, to);
      }, TMP_SvgEngine_range_highlight_26.$$arity = 2);
      
      Opal.defn(self, '$range_highlight_more', TMP_SvgEngine_range_highlight_more_28 = function $$range_highlight_more(from, to) {
        var TMP_27, self = this, elements = nil;
        if ($gvars.settings == null) $gvars.settings = nil;

        
        elements = self.$get_elements_by_range(from, to);
        $send(elements, 'each', [], (TMP_27 = function(element){var self = TMP_27.$$s || this;
if (element == null) element = nil;
        return self.$highlight_element(element)}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27));
        if ($gvars.settings['$[]']("autoscroll")['$==']("false")) {
          return nil
        } else if ($truthy(elements['$empty?']())) {
          return nil
          } else {
          return self.$scroll_to_element(elements.$first())
        };
      }, TMP_SvgEngine_range_highlight_more_28.$$arity = 2);
      
      Opal.defn(self, '$range_unhighlight', TMP_SvgEngine_range_unhighlight_30 = function $$range_unhighlight(from, to) {
        var TMP_29, self = this, elements = nil;

        
        elements = self.$get_elements_by_range(from, to);
        $send(elements, 'each', [], (TMP_29 = function(element){var self = TMP_29.$$s || this;
if (element == null) element = nil;
        return self.$unhighlight_element(element)}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29));
        return nil;
      }, TMP_SvgEngine_range_unhighlight_30.$$arity = 2);
      self.$private();
      
      Opal.defn(self, '$get_elements_by_range', TMP_SvgEngine_get_elements_by_range_33 = function $$get_elements_by_range(from, to) {
        var TMP_31, self = this, result = nil, range = nil;

        
        result = [];
        range = [from, to].$sort();
        $send(self.interactive_elements, 'each', [], (TMP_31 = function(k, value){var self = TMP_31.$$s || this, TMP_32, origin = nil, noterange = nil;
if (k == null) k = nil;if (value == null) value = nil;
        
          origin = value.$dig("music_model_elemment_origin", "origin");
          if ($truthy(origin['$nil?']())) {
            return nil
            } else {
            
            noterange = $send(["startChar", "endChar"], 'map', [], (TMP_32 = function(c){var self = TMP_32.$$s || this;
if (c == null) c = nil;
            return origin['$[]'](c)}, TMP_32.$$s = self, TMP_32.$$arity = 1, TMP_32)).$sort();
            if ($truthy($rb_gt($rb_times($rb_minus(range.$first(), noterange.$last()), $rb_minus(noterange.$first(), range.$last())), 0))) {
              return result.$push(Opal.const_get_relative($nesting, 'Element').$find("" + "#" + (k)))
              } else {
              return nil
            };
          };}, TMP_31.$$s = self, TMP_31.$$arity = 2, TMP_31));
        return result;
      }, TMP_SvgEngine_get_elements_by_range_33.$$arity = 2);
      
      Opal.defn(self, '$highlight_element', TMP_SvgEngine_highlight_element_34 = function $$highlight_element(element) {
        var self = this;

        
        self.highlighted.$push(element);
        element.$add_class("highlight");
        return nil;
      }, TMP_SvgEngine_highlight_element_34.$$arity = 1);
      
      Opal.defn(self, '$scroll_to_element', TMP_SvgEngine_scroll_to_element_35 = function $$scroll_to_element(element) {
        var self = this;

        return self.paper.$scroll_to_element(element)
      }, TMP_SvgEngine_scroll_to_element_35.$$arity = 1);
      
      Opal.defn(self, '$unhighlight_element', TMP_SvgEngine_unhighlight_element_36 = function $$unhighlight_element(element) {
        var self = this;

        
        element.$remove_class("highlight");
        self.highlighted = $rb_minus(self.highlighted, [element]);
        return nil;
      }, TMP_SvgEngine_unhighlight_element_36.$$arity = 1);
      
      Opal.defn(self, '$bind_elements', TMP_SvgEngine_bind_elements_38 = function $$bind_elements() {
        var TMP_37, self = this;

        return $send(self.interactive_elements, 'each', [], (TMP_37 = function(svg_id, drawing_element){var self = TMP_37.$$s || this;
if (svg_id == null) svg_id = nil;if (drawing_element == null) drawing_element = nil;
        return self.$bind_the_element(svg_id)}, TMP_37.$$s = self, TMP_37.$$arity = 2, TMP_37))
      }, TMP_SvgEngine_bind_elements_38.$$arity = 0);
      
      Opal.defn(self, '$bind_the_element', TMP_SvgEngine_bind_the_element_39 = function $$bind_the_element(svg_id) {
        var self = this, drawing_element = nil, svg_node = nil, conf_key = nil, draginfo = nil, conf_value = nil, $case = nil;

        
        drawing_element = self.interactive_elements['$[]'](svg_id);
        svg_node = Opal.const_get_relative($nesting, 'Element').$find("" + "#" + (svg_id));
        conf_key = drawing_element['$[]']("conf_key");
        self.paper.$set_conf_editable(svg_node, conf_key, drawing_element['$[]']("more_conf_keys"));
        draginfo = drawing_element['$[]']("draginfo");
        if ($truthy(draginfo)) {
          
          conf_value = drawing_element['$[]']("conf_value");
          return (function() {$case = draginfo['$[]']("handler");
          if ("annotation"['$===']($case)) {return self.paper.$set_draggable_pos(svg_id, conf_key, conf_value)}
          else if ("jumpline"['$===']($case)) {return self.paper.$set_draggable_jumpline(svg_id, conf_key, conf_value, draginfo)}
          else if ("tuplet"['$===']($case)) {return self.paper.$set_draggable_tuplet(svg_id, conf_key, conf_value, draginfo)}
          else { return nil }})();
          } else {
          return nil
        };
      }, TMP_SvgEngine_bind_the_element_39.$$arity = 1);
      
      Opal.defn(self, '$push_element', TMP_SvgEngine_push_element_41 = function $$push_element(layout_model_element, svg_id) {
        var $a, TMP_40, self = this, music_model_element = nil, music_model_element_hash = nil, drawing_element = nil, $writer = nil;

        
        music_model_element = layout_model_element.$origin();
        if ($truthy(($truthy($a = music_model_element['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable'))) ? layout_model_element['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Drawing'), 'Path'))['$!']() : $a))) {
          music_model_element_hash = $hash2(["origin"], {"origin": $send(music_model_element.$origin(), 'tap', [], (TMP_40 = function(x){var self = TMP_40.$$s || this;
if (x == null) x = nil;
          return x.$delete("raw_voice_element")}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40))})
          } else {
          music_model_element_hash = nil
        };
        drawing_element = $hash2(["music_model_elemment_origin", "conf_key", "conf_value", "more_conf_keys", "draginfo"], {"music_model_elemment_origin": music_model_element_hash, "conf_key": layout_model_element.$conf_key(), "conf_value": layout_model_element.$conf_value(), "more_conf_keys": layout_model_element.$more_conf_keys(), "draginfo": layout_model_element.$draginfo()});
        
        $writer = [svg_id, drawing_element];
        $send(self.interactive_elements, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, TMP_SvgEngine_push_element_41.$$arity = 2);
      
      Opal.defn(self, '$draw_ellipse', TMP_SvgEngine_draw_ellipse_43 = function $$draw_ellipse(root) {
        var $a, TMP_42, self = this, color = nil, attr = nil, $writer = nil, size = nil, e = nil, startChar = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        color = ($truthy($a = Opal.const_get_relative($nesting, 'COLORS')['$[]'](root.$color())) ? $a : $gvars.log.$error("BUG - wrong color in Ellipse"));
        attr = $hash2([], {});
        
        $writer = ["fill", (function() {if (root.$fill()['$==']("filled")) {
          return color
          } else {
          return Opal.const_get_relative($nesting, 'COLORS')['$[]']("white")
        }; return nil; })()];
        $send(attr, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["stroke", color];
        $send(attr, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        size = root.$size();
        
        $writer = [0];
        $send(self.paper, 'line_width=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        if ($truthy(root['$rect?']())) {
          e = self.paper.$rect($rb_minus(root.$center().$first(), size.$first()), $rb_minus(root.$center().$last(), size.$last()), $rb_times(2, size.$first()), $rb_times(2, size.$last()), 0, attr)
          } else {
          e = self.paper.$ellipse(root.$center().$first(), root.$center().$last(), size.$first(), size.$last(), attr)
        };
        if (root.$fill()['$==']("filled")) {
          } else {
          
          
          $writer = [root.$line_width()];
          $send(self.paper, 'line_width=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          size = $send(root.$size(), 'map', [], (TMP_42 = function(s){var self = TMP_42.$$s || this;
if (s == null) s = nil;
          return $rb_minus(s, $rb_divide(root.$line_width(), 2))}, TMP_42.$$s = self, TMP_42.$$arity = 1, TMP_42));
          if ($truthy(root['$rect?']())) {
            e = self.paper.$rect($rb_minus(root.$center().$first(), size.$first()), $rb_minus(root.$center().$last(), size.$last()), $rb_times(2, size.$first()), $rb_times(2, size.$last()), 0, attr)
            } else {
            e = self.paper.$ellipse(root.$center().$first(), root.$center().$last(), size.$first(), size.$last(), attr)
          };
        };
        if ($truthy(root['$dotted?']())) {
          self.$draw_the_dot(root)};
        if ($truthy(root['$hasbarover?']())) {
          self.$draw_the_barover(root)};
        if ($truthy(root.$origin())) {
          
          startChar = root.$origin().$origin()['$[]']("startChar");
          e = self.paper.$add_abcref(root.$center().$first(), root.$center().$last(), $rb_times(0.75, root.$size().$first()), $rb_times(0.75, root.$size().$last()), startChar, $hash2(["onclick"], {"onclick": self.onclick_for_svg}).$merge(self.attr_for_on_contextmenu));
          return self.$push_element(root, e);
          } else {
          return nil
        };
      }, TMP_SvgEngine_draw_ellipse_43.$$arity = 1);
      
      Opal.defn(self, '$draw_glyph', TMP_SvgEngine_draw_glyph_44 = function $$draw_glyph(root) {
        var self = this, center = nil, size = nil, color = nil, is_playable = nil, $writer = nil, bgrect = nil, e = nil, scalefactor = nil, attr = nil, startChar = nil;

        
        center = [root.$center().$first(), root.$center().$last()];
        size = [$rb_times(root.$size().$first(), 2), $rb_times(root.$size().$last(), 2)];
        color = Opal.const_get_relative($nesting, 'COLORS')['$[]'](root.$color());
        is_playable = root.$origin()['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'Playable'));
        
        $writer = [0.1];
        $send(self.paper, 'line_width=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        bgrect = [$rb_minus(root.$center().$first(), $rb_divide(size.$first(), 2)), $rb_minus(root.$center().$last(), $rb_divide(size.$last(), 2)), size.$first(), size.$last(), 0];
        if ($truthy(is_playable)) {
          e = self.paper.$rect($rb_minus(root.$center().$first(), $rb_divide(size.$first(), 2)), $rb_minus(root.$center().$last(), $rb_divide(size.$last(), 2)), size.$first(), size.$last(), 0, $hash2(["fill", "stroke"], {"fill": "white", "stroke": "white"}))};
        
        $writer = [root.$line_width()];
        $send(self.paper, 'line_width=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        scalefactor = $rb_divide(size.$last(), root.$glyph()['$[]']("h"));
        attr = $hash2([], {});
        
        $writer = ["fill", color];
        $send(attr, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["transform", "" + "translate(" + (center.$first()) + "," + (center.$last()) + ") scale(" + (scalefactor) + ")"];
        $send(attr, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        attr = attr.$merge(self.attr_for_draggable);
        e = self.paper.$path(root.$glyph()['$[]']("d"), attr, bgrect);
        if ($truthy(root['$dotted?']())) {
          self.$draw_the_dot(root)};
        if ($truthy(root['$hasbarover?']())) {
          self.$draw_the_barover(root)};
        if ($truthy(is_playable)) {
          
          attr = $hash2(["onclick"], {"onclick": self.onclick_for_svg}).$merge(self.attr_for_on_contextmenu);
          startChar = root.$origin().$origin()['$[]']("startChar");
          e = self.paper.$add_abcref(root.$center().$first(), root.$center().$last(), $rb_times(0.6, root.$size().$first()), $rb_times(0.6, root.$size().$last()), startChar, attr);
          return self.$push_element(root, e);
          } else {
          return self.$push_element(root, e)
        };
      }, TMP_SvgEngine_draw_glyph_44.$$arity = 1);
      
      Opal.defn(self, '$draw_the_barover', TMP_SvgEngine_draw_the_barover_45 = function $$draw_the_barover(root) {
        var self = this, e_bar = nil;

        return (e_bar = self.paper.$rect($rb_minus(root.$center().$first(), root.$size().$first()), $rb_minus($rb_minus(root.$center().$last(), root.$size().$last()), $rb_times(1.5, root.$line_width())), $rb_times(2, root.$size().$first()), 0.5, 0, $hash2(["fill"], {"fill": Opal.const_get_relative($nesting, 'COLORS')['$[]'](root.$color())})))
      }, TMP_SvgEngine_draw_the_barover_45.$$arity = 1);
      
      Opal.defn(self, '$draw_the_dot', TMP_SvgEngine_draw_the_dot_46 = function $$draw_the_dot(root) {
        var self = this, $writer = nil, ds1 = nil, ds2 = nil, x = nil, y = nil, white = nil, e_dot = nil;

        
        
        $writer = [0];
        $send(self.paper, 'line_width=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        ds1 = $rb_plus(Opal.const_get_relative($nesting, 'DOTTED_SIZE'), root.$line_width());
        ds2 = $rb_plus(Opal.const_get_relative($nesting, 'DOTTED_SIZE'), root.$line_width());
        x = $rb_plus(root.$center().$first(), $rb_plus(root.$size().$first(), ds1));
        y = root.$center().$last();
        white = Opal.const_get_relative($nesting, 'COLORS')['$[]']("white");
        e_dot = self.paper.$ellipse(x, y, ds2, ds2, $hash2(["stroke", "fill"], {"stroke": white, "fill": white}));
        return (e_dot = self.paper.$ellipse(x, y, Opal.const_get_relative($nesting, 'DOTTED_SIZE'), Opal.const_get_relative($nesting, 'DOTTED_SIZE'), $hash2(["fill"], {"fill": Opal.const_get_relative($nesting, 'COLORS')['$[]'](root.$color())})));
      }, TMP_SvgEngine_draw_the_dot_46.$$arity = 1);
      
      Opal.defn(self, '$draw_flowline', TMP_SvgEngine_draw_flowline_47 = function $$draw_flowline(root) {
        var self = this, color = nil, attr = nil, $writer = nil, e = nil;

        
        color = Opal.const_get_relative($nesting, 'COLORS')['$[]'](root.$color());
        attr = $hash2(["stroke"], {"stroke": color});
        if (root.$style()['$==']("dashed")) {
          
          $writer = ["stroke-dasharray", "" + ($rb_divide(3, 2.84)) + " " + ($rb_divide(3, 2.84))];
          $send(attr, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if (root.$style()['$==']("dotted")) {
          
          $writer = ["stroke-dasharray", "" + ($rb_divide(1.5, 2.84)) + " " + ($rb_divide(1.5, 2.84))];
          $send(attr, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        e = self.paper.$line(root.$from().$center()['$[]'](0), root.$from().$center()['$[]'](1), root.$to().$center()['$[]'](0), root.$to().$center()['$[]'](1), attr);
        return e;
      }, TMP_SvgEngine_draw_flowline_47.$$arity = 1);
      
      Opal.defn(self, '$draw_jumpline_outdated', TMP_SvgEngine_draw_jumpline_outdated_48 = function $$draw_jumpline_outdated(root) {
        var self = this, startpoint = nil, $writer = nil, endpoint = nil, distance = nil, depth = nil, path = nil, attr = nil, arrow = nil;

        
        startpoint = root.$from().$center();
        
        $writer = [0, $rb_plus(startpoint['$[]'](0), Opal.const_get_relative($nesting, 'PADDING'))];
        $send(startpoint, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        endpoint = root.$to().$center();
        
        $writer = [0, $rb_plus(endpoint['$[]'](0), Opal.const_get_relative($nesting, 'PADDING'))];
        $send(endpoint, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        distance = root.$distance();
        if ($truthy(distance['$nil?']())) {
          depth = $rb_minus(420, $rb_times(root.$level(), Opal.const_get_relative($nesting, 'JUMPLINE_INDENT')))
          } else {
          depth = $rb_plus(endpoint['$[]'](0), distance)
        };
        path = "" + "M" + (endpoint['$[]'](0)) + "," + (endpoint['$[]'](1)) + "L" + (depth) + "," + (endpoint['$[]'](1)) + "L" + (depth) + "," + (startpoint['$[]'](1)) + "L" + (startpoint['$[]'](0)) + "," + (startpoint['$[]'](1));
        self.paper.$path(path);
        attr = $hash2(["fill", "transform"], {"fill": "red", "transform": "" + "t" + (startpoint['$[]'](0)) + "," + (startpoint['$[]'](1))});
        return (arrow = self.paper.$path("" + "M0,0L" + (Opal.const_get_relative($nesting, 'ARROW_SIZE')) + "," + ($rb_times(-0.5, Opal.const_get_relative($nesting, 'ARROW_SIZE'))) + "L" + (Opal.const_get_relative($nesting, 'ARROW_SIZE')) + "," + ($rb_times(0.5, Opal.const_get_relative($nesting, 'ARROW_SIZE'))) + "L0,0", attr));
      }, TMP_SvgEngine_draw_jumpline_outdated_48.$$arity = 1);
      
      Opal.defn(self, '$draw_annotation', TMP_SvgEngine_draw_annotation_50 = function $$draw_annotation(root) {
        var $a, TMP_49, self = this, style = nil, text = nil, attr = nil, $writer = nil, element = nil;
        if ($gvars.conf == null) $gvars.conf = nil;

        
        style = ($truthy($a = $gvars.conf.$get("layout.FONT_STYLE_DEF")['$[]'](root.$style())) ? $a : $gvars.conf.$get("layout.FONT_STYLE_DEF")['$[]']("regular"));
        text = $send(root.$text().$gsub(/\ +\n/, "\n").$gsub("\n\n", "\n \n"), 'gsub', [/(\\?)(~)/], (TMP_49 = function(m){var self = TMP_49.$$s || this;
if (m == null) m = nil;
        if (m['$[]'](0)['$==']("\\")) {
            return m['$[]'](1)
            } else {
            return "&nbsp;"
          }}, TMP_49.$$s = self, TMP_49.$$arity = 1, TMP_49));
        attr = $hash2([], {});
        
        $writer = ["font-size", $rb_divide(style['$[]']("font_size"), 3)];
        $send(attr, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["font-family", "Arial"];
        $send(attr, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["transform", "" + "scale(1.05, 1) translate(0," + ($rb_divide(style['$[]']("font_size")['$-@'](), 8)) + ")"];
        $send(attr, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        if ($truthy(style['$[]']("font_style").$to_s()['$include?']("bold"))) {
          
          $writer = ["font-weight", "bold"];
          $send(attr, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(style['$[]']("font_style").$to_s()['$include?']("italic"))) {
          
          $writer = ["font-style", "italic"];
          $send(attr, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        
        $writer = ["text-anchor", (function() {if ($truthy(root.$align()['$==']("right"))) {
          return "end"
          } else {
          return "start "
        }; return nil; })()];
        $send(attr, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        attr = attr.$merge(self.attr_for_on_contextmenu).$merge(self.attr_for_draggable);
        element = self.paper.$text($rb_divide(root.$center().$first(), 1.05), root.$center().$last(), text, attr);
        self.$push_element(root, element);
        return element;
      }, TMP_SvgEngine_draw_annotation_50.$$arity = 1);
      
      Opal.defn(self, '$draw_image', TMP_SvgEngine_draw_image_51 = function $$draw_image(root) {
        var self = this, position = nil, e = nil, draginfo = nil, $writer = nil;

        
        position = $rb_plus($rb_plus(self.$Vector2d([0, 0]), root.$llpos()), [0, root.$height()]);
        e = self.paper.$image(root.$url(), position.$x(), position.$y(), root.$height());
        draginfo = root.$draginfo();
        if ($truthy(draginfo)) {
          
          
          $writer = ["target_id", e];
          $send(draginfo, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          self.$push_element(root, e);};
        return e;
      }, TMP_SvgEngine_draw_image_51.$$arity = 1);
      return (Opal.defn(self, '$draw_path', TMP_SvgEngine_draw_path_52 = function $$draw_path(root) {
        var self = this, color = nil, attr = nil, $writer = nil, e = nil, draginfo = nil, $case = nil;

        
        color = Opal.const_get_relative($nesting, 'COLORS')['$[]'](root.$color());
        attr = $hash2(["stroke", "fill"], {"stroke": color, "fill": "none"});
        if ($truthy(root['$filled?']())) {
          
          $writer = ["fill", color];
          $send(attr, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        
        $writer = ["stroke-linecap", "round"];
        $send(attr, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        attr = attr.$merge(self.attr_for_on_contextmenu);
        e = self.paper.$path(root.$path(), attr);
        draginfo = root.$draginfo();
        if ($truthy(draginfo)) {
          
          
          $writer = ["target_id", e];
          $send(draginfo, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return (function() {$case = draginfo['$[]']("handler");
          if ("jumpline"['$===']($case)) {return self.$push_element(root, e)}
          else if ("tuplet"['$===']($case)) {
          attr = $hash2(["stroke", "class", "stroke-width"], {"stroke": "grey", "class": "zncontrol", "stroke-width": "1"}).$merge(self.attr_for_on_contextmenu);
          e = self.paper.$line(draginfo['$[]']("p1")['$[]'](0), draginfo['$[]']("p1")['$[]'](1), draginfo['$[]']("cp1")['$[]'](0), draginfo['$[]']("cp1")['$[]'](1), attr.$merge($hash2(["data-cp"], {"data-cp": "cp1"})));
          self.$push_element(root, e);
          e = self.paper.$line(draginfo['$[]']("p2")['$[]'](0), draginfo['$[]']("p2")['$[]'](1), draginfo['$[]']("cp2")['$[]'](0), draginfo['$[]']("cp2")['$[]'](1), attr.$merge($hash2(["data-cp"], {"data-cp": "cp2"})));
          self.$push_element(root, e);
          return nil;}
          else { return nil }})();
          } else {
          return nil
        };
      }, TMP_SvgEngine_draw_path_52.$$arity = 1), nil) && 'draw_path';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["init_conf"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $gvars = Opal.gvars, $range = Opal.range;

  Opal.add_stubs(['$join', '$map', '$each_with_index', '$split', '$between?', '$lambda', '$[]', '$get', '$cut_string_names', '$year', '$now', '$t', '$to_a', '$first', '$+', '$last']);
  
  (function($base, $parent_nesting) {
    var $InitConf, self = $InitConf = $module($base, 'InitConf');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_InitConf_cut_string_names_2, TMP_InitConf_init_conf_35;

    
    Opal.defs(self, '$cut_string_names', TMP_InitConf_cut_string_names_2 = function $$cut_string_names(stringnames, from, to) {
      var TMP_1, self = this;

      return $send(stringnames.$split(" ").$each_with_index(), 'map', [], (TMP_1 = function(v, index){var self = TMP_1.$$s || this;
if (v == null) v = nil;if (index == null) index = nil;
      if ($truthy(index['$between?'](from, to))) {
          return v
          } else {
          return "~"
        }}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1)).$join(" ")
    }, TMP_InitConf_cut_string_names_2.$$arity = 3);
    Opal.defs(self, '$init_conf', TMP_InitConf_init_conf_35 = function $$init_conf() {
      var TMP_3, TMP_4, TMP_5, TMP_6, TMP_7, TMP_8, TMP_9, TMP_10, TMP_11, TMP_12, TMP_13, TMP_14, TMP_15, TMP_16, TMP_17, TMP_18, TMP_19, TMP_20, TMP_21, TMP_22, TMP_23, TMP_24, TMP_25, TMP_26, TMP_27, TMP_28, TMP_29, TMP_30, TMP_31, TMP_32, TMP_33, TMP_34, self = this, explicit_sort = nil, result = nil;

      
      explicit_sort = ["produce", "annotations", "restposition", "default", "repeatstart", "repeatend", "extract", "title", "filenamepart", "startpos", "voices", "flowlines", "subflowlines", "synchlines", "jumplines", "repeatsigns", "layoutlines", "barnumbers", "countnotes", "legend", "nonflowrest", "lyrics", "notes", "images", "tuplets", "layout", "printer", "annotation", "decoration", "partname", "variantend", "countnote", "c_jumplines", "tuplet", "minc", "flowline", "imagename", "stringnames", "limit_a3", "LINE_THIN", "LINE_MEDIUM", "LINE_THICK", "ELLIPSE_SIZE", "REST_SIZE", "DRAWING_AREA_SIZE", "instrument", "bottomup", "beams", "packer", "pack_method", "pack_max_spreadfactor", "pack_min_increment", "sortmark", "show", "fill", "size", "PITCH_OFFSET", "X_OFFSET", "X_SPACING", "jumpline_anchor", "a3_offset", "a4_offset", "a4_pages", "T01_number", "T01_number_extract", "T02_copyright_music", "T03_copyright_harpnotes", "T04_to_order", "T05_printed_extracts", "T99_do_not_copy", "0", "1", "2", "3", "4", "5", "6", "verses", "cp1", "cp2", "shape", "pos", "hpos", "height", "vpos", "spos", "autopos", "apbase", "text", "style", "marks", "resources", "d64", "d48", "d32", "d24", "d16", "d12", "d8", "d6", "d4", "d3", "d2", "d1"];
      result = $hash2(["produce", "abc_parser", "restposition", "template", "wrap", "defaults", "templates", "presets", "annotations", "extract", "layout", "neatjson"], {"produce": [0], "abc_parser": "ABC2SVG", "restposition": $hash2(["default", "repeatstart", "repeatend"], {"default": "center", "repeatstart": "next", "repeatend": "default"}), "template": $hash2(["filebase", "title"], {"filebase": "-no-template-", "title": "- no template -"}), "wrap": 60, "defaults": $hash2(["notebound"], {"notebound": $hash2(["annotation", "partname", "variantend", "tuplet", "flowline"], {"annotation": $hash2(["pos"], {"pos": [5, -7]}), "partname": $hash2(["pos"], {"pos": [-4, -7]}), "variantend": $hash2(["pos"], {"pos": [-4, -7]}), "tuplet": $hash2(["cp1", "cp2", "shape", "show"], {"cp1": [5, 2], "cp2": [5, -2], "shape": ["c"], "show": true}), "flowline": $hash2(["cp1", "cp2", "shape", "show"], {"cp1": [0, 10], "cp2": [0, -10], "shape": ["c"], "show": true})})}), "templates": $hash2(["notes", "lyrics", "images", "tuplet", "annotations"], {"notes": $hash2(["pos", "text", "style"], {"pos": [320, 6], "text": "ENTER_NOTE", "style": "large"}), "lyrics": $hash2(["verses", "pos", "style"], {"verses": [1], "pos": [350, 70], "style": "regular"}), "images": $hash2(["imagename", "show", "pos", "height"], {"imagename": "", "show": true, "pos": [10, 10], "height": 100}), "tuplet": $hash2(["cp1", "cp2", "shape", "show"], {"cp1": [5, 2], "cp2": [5, -2], "shape": ["c"], "show": true}), "annotations": $hash2(["text", "pos"], {"text": "_vorlage_", "pos": [-5, -6]})}), "presets": $hash2(["barnumbers_countnotes", "stdextract", "layout", "instrument", "notes", "printer"], {"barnumbers_countnotes": $hash2(["anchor_at_box", "anchor_at_center"], {"anchor_at_box": $hash2(["barnumbers", "countnotes"], {"barnumbers": $hash2(["apanchor", "apbase"], {"apanchor": "box", "apbase": [1, 1]}), "countnotes": $hash2(["apanchor", "apbase"], {"apanchor": "box", "apbase": [1, -0.5]})}), "anchor_at_center": $hash2(["barnumbers", "countnotes"], {"barnumbers": $hash2(["apanchor", "apbase"], {"apanchor": "center", "apbase": [1, 0.3]}), "countnotes": $hash2(["apanchor", "apbase"], {"apanchor": "center", "apbase": [1, 0]})})}), "stdextract": $hash2([], {}), "layout": $hash2(["notes_small", "notes_regular", "notes_large", "notes_with_beams", "-", "packer_compact", "packer_regular", "--", "color_on", "color_off", "---", "jumpline_anchor_close", "jumpline_anchor_medium", "jumpline_anchor_wide"], {"notes_small": $hash2(["LINE_MEDIUM", "LINE_THICK", "ELLIPSE_SIZE", "REST_SIZE", "beams"], {"LINE_MEDIUM": 0.2, "LINE_THICK": 0.3, "ELLIPSE_SIZE": [3.5, 1.3], "REST_SIZE": [4, 1.5], "beams": false}), "notes_regular": $hash2(["LINE_MEDIUM", "LINE_THICK", "ELLIPSE_SIZE", "REST_SIZE", "beams"], {"LINE_MEDIUM": $send(self, 'lambda', [], (TMP_3 = function(){var self = TMP_3.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.LINE_MEDIUM")}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3)), "LINE_THICK": $send(self, 'lambda', [], (TMP_4 = function(){var self = TMP_4.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.LINE_THICK")}, TMP_4.$$s = self, TMP_4.$$arity = 0, TMP_4)), "ELLIPSE_SIZE": $send(self, 'lambda', [], (TMP_5 = function(){var self = TMP_5.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.ELLIPSE_SIZE")}, TMP_5.$$s = self, TMP_5.$$arity = 0, TMP_5)), "REST_SIZE": $send(self, 'lambda', [], (TMP_6 = function(){var self = TMP_6.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.REST_SIZE")}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6)), "beams": false}), "notes_large": $hash2(["LINE_MEDIUM", "LINE_THICK", "ELLIPSE_SIZE", "REST_SIZE", "beams"], {"LINE_MEDIUM": 0.3, "LINE_THICK": 0.7, "ELLIPSE_SIZE": [4, 2], "REST_SIZE": [4, 2], "beams": false}), "notes_with_beams": $hash2(["LINE_THIN", "LINE_MEDIUM", "LINE_THICK", "ELLIPSE_SIZE", "REST_SIZE", "beams"], {"LINE_THIN": 0.1, "LINE_MEDIUM": 0.2, "LINE_THICK": 0.5, "ELLIPSE_SIZE": [1.3, 1], "REST_SIZE": [2, 1.3], "beams": true}), "-": $hash2([], {}), "packer_compact": $hash2(["packer"], {"packer": $hash2(["pack_method", "pack_max_spreadfactor", "pack_min_increment"], {"pack_method": 1, "pack_max_spreadfactor": 2, "pack_min_increment": 0.2})}), "packer_regular": $hash2(["packer"], {"packer": $send(self, 'lambda', [], (TMP_7 = function(){var self = TMP_7.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf.$get("extract.0.layout.packer")}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7))}), "--": $hash2([], {}), "color_on": $hash2(["color"], {"color": $hash2(["color_default", "color_variant1", "color_variant2"], {"color_default": "black", "color_variant1": "grey", "color_variant2": "darkgrey"})}), "color_off": $hash2(["color"], {"color": $hash2(["color_default", "color_variant1", "color_variant2"], {"color_default": "black", "color_variant1": "black", "color_variant2": "black"})}), "---": $hash2([], {}), "jumpline_anchor_close": $hash2(["jumpline_anchor"], {"jumpline_anchor": [3, 1]}), "jumpline_anchor_medium": $hash2(["jumpline_anchor"], {"jumpline_anchor": [5, 1]}), "jumpline_anchor_wide": $hash2(["jumpline_anchor"], {"jumpline_anchor": [10, 1]})}), "instrument": $hash2(["37-strings-g-g", "25-strings-g-g", "25-strings-G-g Bass", "21-strings-a-f", "18-strings-b-e", "saitenspiel", "Zipino", "Okon-Harfe"], {"37-strings-g-g": $hash2(["layout", "stringnames", "printer"], {"layout": $hash2(["instrument", "limit_a3", "beams", "bottomup", "PITCH_OFFSET", "X_SPACING", "X_OFFSET"], {"instrument": "37-strings-g-g", "limit_a3": true, "beams": false, "bottomup": false, "PITCH_OFFSET": $send(self, 'lambda', [], (TMP_8 = function(){var self = TMP_8.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.PITCH_OFFSET")}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8)), "X_SPACING": $send(self, 'lambda', [], (TMP_9 = function(){var self = TMP_9.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.X_SPACING")}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9)), "X_OFFSET": $send(self, 'lambda', [], (TMP_10 = function(){var self = TMP_10.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.X_OFFSET")}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10))}), "stringnames": $hash2(["text", "marks"], {"text": $send(self, 'lambda', [], (TMP_11 = function(){var self = TMP_11.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.stringnames.text")}, TMP_11.$$s = self, TMP_11.$$arity = 0, TMP_11)), "marks": $hash2(["hpos"], {"hpos": [43, 79]})}), "printer": $hash2(["a4_pages", "a4_offset", "a3_offset"], {"a4_pages": [0, 1, 2], "a4_offset": $send(self, 'lambda', [], (TMP_12 = function(){var self = TMP_12.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.printer.a4_offset")}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12)), "a3_offset": $send(self, 'lambda', [], (TMP_13 = function(){var self = TMP_13.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.printer.a3_offset")}, TMP_13.$$s = self, TMP_13.$$arity = 0, TMP_13))})}), "25-strings-g-g": $hash2(["layout", "stringnames", "printer"], {"layout": $hash2(["instrument", "limit_a3", "beams", "bottomup", "PITCH_OFFSET", "X_SPACING", "X_OFFSET"], {"instrument": "25-strings-g-g", "limit_a3": false, "beams": false, "bottomup": false, "PITCH_OFFSET": $send(self, 'lambda', [], (TMP_14 = function(){var self = TMP_14.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.PITCH_OFFSET")}, TMP_14.$$s = self, TMP_14.$$arity = 0, TMP_14)), "X_SPACING": $send(self, 'lambda', [], (TMP_15 = function(){var self = TMP_15.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.X_SPACING")}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15)), "X_OFFSET": $send(self, 'lambda', [], (TMP_16 = function(){var self = TMP_16.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.X_OFFSET")}, TMP_16.$$s = self, TMP_16.$$arity = 0, TMP_16))}), "stringnames": $hash2(["text", "marks"], {"text": $send(self, 'lambda', [], (TMP_17 = function(){var self = TMP_17.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return self.$cut_string_names($gvars.conf['$[]']("extract.0.stringnames.text"), 12, 36)}, TMP_17.$$s = self, TMP_17.$$arity = 0, TMP_17)), "marks": $hash2(["hpos"], {"hpos": [55, 79]})}), "printer": $hash2(["a4_pages", "a3_offset", "a4_offset"], {"a4_pages": [1, 2], "a3_offset": [-5, 0], "a4_offset": $send(self, 'lambda', [], (TMP_18 = function(){var self = TMP_18.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.printer.a4_offset")}, TMP_18.$$s = self, TMP_18.$$arity = 0, TMP_18))})}), "25-strings-G-g Bass": $hash2(["layout", "stringnames", "printer"], {"layout": $hash2(["instrument", "limit_a3", "beams", "bottomup", "PITCH_OFFSET", "X_SPACING", "X_OFFSET"], {"instrument": "25-strings-g-g", "limit_a3": false, "beams": false, "bottomup": false, "PITCH_OFFSET": $send(self, 'lambda', [], (TMP_19 = function(){var self = TMP_19.$$s || this;

      return -31}, TMP_19.$$s = self, TMP_19.$$arity = 0, TMP_19)), "X_SPACING": $send(self, 'lambda', [], (TMP_20 = function(){var self = TMP_20.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.X_SPACING")}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20)), "X_OFFSET": $send(self, 'lambda', [], (TMP_21 = function(){var self = TMP_21.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.X_OFFSET")}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21))}), "stringnames": $hash2(["text", "marks"], {"text": $send(self, 'lambda', [], (TMP_22 = function(){var self = TMP_22.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return self.$cut_string_names($gvars.conf['$[]']("extract.0.stringnames.text"), 12, 36)}, TMP_22.$$s = self, TMP_22.$$arity = 0, TMP_22)), "marks": $hash2(["hpos"], {"hpos": [43, 67]})}), "printer": $hash2(["a4_pages", "a3_offset", "a4_offset"], {"a4_pages": [1, 2], "a3_offset": [-5, 0], "a4_offset": $send(self, 'lambda', [], (TMP_23 = function(){var self = TMP_23.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.printer.a4_offset")}, TMP_23.$$s = self, TMP_23.$$arity = 0, TMP_23))})}), "21-strings-a-f": $hash2(["layout", "stringnames", "printer"], {"layout": $hash2(["instrument", "limit_a3", "beams", "bottomup", "PITCH_OFFSET", "X_SPACING", "X_OFFSET"], {"instrument": "21-strings-a-f", "limit_a3": false, "beams": false, "bottomup": false, "PITCH_OFFSET": $send(self, 'lambda', [], (TMP_24 = function(){var self = TMP_24.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.PITCH_OFFSET")}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24)), "X_SPACING": $send(self, 'lambda', [], (TMP_25 = function(){var self = TMP_25.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.X_SPACING")}, TMP_25.$$s = self, TMP_25.$$arity = 0, TMP_25)), "X_OFFSET": 23}), "stringnames": $hash2(["text", "marks"], {"text": $send(self, 'lambda', [], (TMP_26 = function(){var self = TMP_26.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return self.$cut_string_names($gvars.conf['$[]']("extract.0.stringnames.text"), 14, 34)}, TMP_26.$$s = self, TMP_26.$$arity = 0, TMP_26)), "marks": $hash2(["hpos"], {"hpos": [57, 77]})}), "printer": $hash2(["a4_pages", "a3_offset", "a4_offset"], {"a4_pages": [1, 2], "a3_offset": [-5, 0], "a4_offset": $send(self, 'lambda', [], (TMP_27 = function(){var self = TMP_27.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.printer.a4_offset")}, TMP_27.$$s = self, TMP_27.$$arity = 0, TMP_27))})}), "18-strings-b-e": $hash2(["layout", "stringnames", "printer"], {"layout": $hash2(["instrument", "limit_a3", "beams", "bottomup", "PITCH_OFFSET", "X_SPACING", "X_OFFSET"], {"instrument": "18-strings-b-e", "limit_a3": false, "beams": false, "bottomup": false, "PITCH_OFFSET": $send(self, 'lambda', [], (TMP_28 = function(){var self = TMP_28.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.PITCH_OFFSET")}, TMP_28.$$s = self, TMP_28.$$arity = 0, TMP_28)), "X_SPACING": $send(self, 'lambda', [], (TMP_29 = function(){var self = TMP_29.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("extract.0.layout.X_SPACING")}, TMP_29.$$s = self, TMP_29.$$arity = 0, TMP_29)), "X_OFFSET": 28.5}), "stringnames": $hash2(["text", "marks"], {"text": $send(self, 'lambda', [], (TMP_30 = function(){var self = TMP_30.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return self.$cut_string_names($gvars.conf['$[]']("extract.0.stringnames.text"), 16, 33)}, TMP_30.$$s = self, TMP_30.$$arity = 0, TMP_30)), "marks": $hash2(["hpos"], {"hpos": [59, 76]})}), "printer": $hash2(["a4_pages", "a3_offset", "a4_offset"], {"a4_pages": [2], "a3_offset": [0, 0], "a4_offset": [40, 0]})}), "saitenspiel": $hash2(["layout", "stringnames", "printer"], {"layout": $hash2(["instrument", "limit_a3", "beams", "bottomup", "PITCH_OFFSET", "X_SPACING", "X_OFFSET"], {"instrument": "saitenspiel", "limit_a3": false, "beams": false, "bottomup": false, "PITCH_OFFSET": -24, "X_SPACING": 14.5, "X_OFFSET": 240}), "stringnames": $hash2(["text", "marks"], {"text": "G C D E F G A B C D  ~ ~ ~ ~ ~ ~ ~", "marks": $hash2(["hpos"], {"hpos": [55, 74]})}), "printer": $hash2(["a4_pages", "a3_offset", "a4_offset"], {"a4_pages": [2], "a3_offset": [0, 0], "a4_offset": [35, 0]})}), "Zipino": $hash2(["layout", "stringnames", "printer"], {"layout": $hash2(["instrument", "limit_a3", "beams", "bottomup", "PITCH_OFFSET", "X_SPACING", "X_OFFSET", "ELLIPSE_SIZE", "REST_SIZE"], {"instrument": "Zipino", "limit_a3": true, "beams": true, "bottomup": false, "PITCH_OFFSET": 0, "X_SPACING": 12.5, "X_OFFSET": 230, "ELLIPSE_SIZE": [2, 2], "REST_SIZE": [2, 2]}), "stringnames": $hash2(["text", "marks"], {"text": "F# G A B C D E F# G A B C D E F# ~ ~ ~ ~ ~ ~  ~", "marks": $hash2(["hpos"], {"hpos": [54]})}), "printer": $hash2(["a4_pages", "a3_offset", "a4_offset"], {"a4_pages": [2], "a3_offset": [0, 0], "a4_offset": [35, 0]})}), "Okon-Harfe": $hash2(["layout", "stringnames", "printer"], {"layout": $hash2(["instrument", "beams", "bottomup", "limit_a3", "PITCH_OFFSET", "X_SPACING", "X_OFFSET"], {"instrument": "okon-f", "beams": true, "bottomup": true, "limit_a3": false, "PITCH_OFFSET": 0, "X_SPACING": 15, "X_OFFSET": 50}), "stringnames": $hash2(["text", "marks"], {"text": "G A B C D E F G A B C D E F G A B C ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~", "marks": $hash2(["hpos"], {"hpos": [55, 74]})}), "printer": $hash2(["a4_pages", "a3_offset", "a4_offset"], {"a4_pages": [1, 2], "a3_offset": [-35, 0], "a4_offset": [70, 0]})})}), "notes": $hash2(["T01_number", "T01_number_extract", "T01_number_extract_value", "T02_copyright_music", "T03_copyright_harpnotes", "T04_to_order", "T05_printed_extracts", "T06_legend", "T99_do_not_copy", "T01_T99"], {"T01_number": $hash2(["value"], {"value": $hash2(["pos", "text", "style", "align"], {"pos": [410, 17], "text": "XXX-{{number}}", "style": "bold", "align": "l"})}), "T01_number_extract": $hash2(["value"], {"value": $hash2(["pos", "text", "style"], {"pos": [411, 17], "text": "{{extract_filename}}", "style": "bold"})}), "T01_number_extract_value": $hash2(["key", "value"], {"key": "T01_number_extract", "value": $hash2(["text"], {"text": "{{extract_filename}}"})}), "T02_copyright_music": $hash2(["value"], {"value": $hash2(["pos", "text", "style"], {"pos": [340, 251], "text": $send(self, 'lambda', [], (TMP_31 = function(){var self = TMP_31.$$s || this;

      
        return "" + "© " + (Opal.const_get_relative($nesting, 'Time').$now().$year()) + "\n" + (Opal.const_get_relative($nesting, 'I18n').$t("Private copy"));}, TMP_31.$$s = self, TMP_31.$$arity = 0, TMP_31)), "style": "small"})}), "T03_copyright_harpnotes": $hash2(["value"], {"value": $hash2(["pos", "text", "style"], {"pos": [340, 260], "text": "" + "© " + (Opal.const_get_relative($nesting, 'Time').$now().$year()) + " Notenbild: zupfnoter.de", "style": "small"})}), "T04_to_order": $hash2(["value"], {"value": $hash2(["pos", "text", "style"], {"pos": [340, 242], "text": $send(self, 'lambda', [], (TMP_32 = function(){var self = TMP_32.$$s || this;

      return Opal.const_get_relative($nesting, 'I18n').$t("provided by\n")}, TMP_32.$$s = self, TMP_32.$$arity = 0, TMP_32)), "style": "small"})}), "T05_printed_extracts": $hash2(["value"], {"value": $hash2(["pos", "text", "style", "align"], {"pos": [410, 22], "text": "{{printed_extracts}}", "style": "smaller", "align": "l"})}), "T06_legend": $hash2(["value"], {"value": $hash2(["pos", "text", "style"], {"pos": [360, 30], "text": "{{extract_title}}\n{{composer}}\nTakt: {{meter}} ({{tempo}})\nTonart: {{key}}", "style": "small"})}), "T99_do_not_copy": $hash2(["value"], {"value": $hash2(["pos", "text", "style"], {"pos": [380, 284], "text": $send(self, 'lambda', [], (TMP_33 = function(){var self = TMP_33.$$s || this;

      return Opal.const_get_relative($nesting, 'I18n').$t("Please do not copy")}, TMP_33.$$s = self, TMP_33.$$arity = 0, TMP_33)), "style": "small_bold"})}), "T01_T99": $hash2(["value"], {"value": $hash2([], {})})}), "printer": $hash2(["printer_left", "printer_centric", "printer_right"], {"printer_left": $hash2(["printer", "layout"], {"printer": $hash2(["a3_offset", "a4_offset", "show_border"], {"a3_offset": [-10, 0], "a4_offset": [-5, 0], "show_border": false}), "layout": $hash2(["limit_a3"], {"limit_a3": false})}), "printer_centric": $hash2(["printer", "layout"], {"printer": $hash2(["a3_offset", "a4_offset", "show_border"], {"a3_offset": [0, 0], "a4_offset": [5, 0], "show_border": false}), "layout": $hash2(["limit_a3"], {"limit_a3": true})}), "printer_right": $hash2(["printer", "layout"], {"printer": $hash2(["a3_offset", "a4_offset", "show_border"], {"a3_offset": [10, 0], "a4_offset": [5, 0], "show_border": false}), "layout": $hash2(["limit_a3"], {"limit_a3": false})})})}), "annotations": $hash2(["vl", "vt", "vr"], {"vl": $hash2(["text", "pos"], {"text": "v", "pos": [-5, -5]}), "vt": $hash2(["text", "pos"], {"text": "v", "pos": [-1, -5]}), "vr": $hash2(["text", "pos"], {"text": "v", "pos": [2, -5]})}), "extract": $hash2(["0", "1", "2", "3", "4", "5"], {"0": $hash2(["title", "startpos", "voices", "synchlines", "flowlines", "subflowlines", "jumplines", "repeatsigns", "layoutlines", "legend", "lyrics", "images", "layout", "sortmark", "nonflowrest", "notes", "tuplets", "barnumbers", "countnotes", "stringnames", "printer"], {"title": "alle Stimmen", "startpos": 15, "voices": [1, 2, 3, 4], "synchlines": [[1, 2], [3, 4]], "flowlines": [1, 3], "subflowlines": [2, 4], "jumplines": [1, 3], "repeatsigns": $hash2(["voices", "left", "right"], {"voices": [], "left": $hash2(["pos", "text", "style"], {"pos": [-7, -2], "text": "|:", "style": "bold"}), "right": $hash2(["pos", "text", "style"], {"pos": [5, -2], "text": ":|", "style": "bold"})}), "layoutlines": [1, 2, 3, 4], "legend": $hash2(["spos", "pos"], {"spos": [320, 27], "pos": [320, 7]}), "lyrics": $hash2([], {}), "images": $hash2([], {}), "layout": $hash2(["limit_a3", "bottomup", "beams", "jumpline_anchor", "color", "LINE_THIN", "LINE_MEDIUM", "LINE_THICK", "PITCH_OFFSET", "X_SPACING", "X_OFFSET", "ELLIPSE_SIZE", "REST_SIZE", "DRAWING_AREA_SIZE", "instrument", "packer"], {"limit_a3": true, "bottomup": false, "beams": false, "jumpline_anchor": [3, 1], "color": $hash2(["color_default", "color_variant1", "color_variant2"], {"color_default": "black", "color_variant1": "grey", "color_variant2": "dimgrey"}), "LINE_THIN": 0.1, "LINE_MEDIUM": 0.3, "LINE_THICK": 0.5, "PITCH_OFFSET": -43, "X_SPACING": 11.5, "X_OFFSET": 2.8, "ELLIPSE_SIZE": [3.5, 1.7], "REST_SIZE": [4, 2], "DRAWING_AREA_SIZE": [400, 282], "instrument": "37-strings-g-g", "packer": $hash2(["pack_method", "pack_max_spreadfactor", "pack_min_increment"], {"pack_method": 0, "pack_max_spreadfactor": 2, "pack_min_increment": 0.2})}), "sortmark": $hash2(["size", "fill", "show"], {"size": [2, 4], "fill": true, "show": false}), "nonflowrest": false, "notes": $hash2([], {}), "tuplets": $hash2(["text"], {"text": "{{tuplet}}"}), "barnumbers": $hash2(["voices", "pos", "autopos", "apanchor", "apbase", "style", "prefix"], {"voices": [], "pos": [6, -4], "autopos": true, "apanchor": "box", "apbase": [1, 1], "style": "small_bold", "prefix": ""}), "countnotes": $hash2(["voices", "pos", "autopos", "apbase", "apanchor", "style"], {"voices": [], "pos": [3, -2], "autopos": true, "apbase": [1, -0.5], "apanchor": "box", "style": "smaller"}), "stringnames": $hash2(["text", "vpos", "style", "marks"], {"text": "G G# A A# B C C# D D# E F F# G G# A A# B C C# D D# E F F# G G# A A# B C C# D D# E F F# G", "vpos": [], "style": "small", "marks": $hash2(["vpos", "hpos"], {"vpos": [11], "hpos": [43, 55, 79]})}), "printer": $hash2(["a3_offset", "a4_offset", "a4_pages", "show_border"], {"a3_offset": [0, 0], "a4_offset": [-5, 0], "a4_pages": [0, 1, 2], "show_border": false})}), "1": $hash2(["title", "voices"], {"title": "Sopran, Alt", "voices": [1, 2]}), "2": $hash2(["title", "voices"], {"title": "Tenor, Bass", "voices": [3, 4]}), "3": $hash2(["title", "voices"], {"title": "Melodie", "voices": [1]}), "4": $hash2(["title", "voices"], {"title": "Extract 4", "voices": [1]}), "5": $hash2(["title", "voices"], {"title": "Extract 5", "voices": [1]})}), "layout": $hash2(["grid", "limit_a3", "SHOW_SLUR", "LINE_THIN", "LINE_MEDIUM", "LINE_THICK", "ELLIPSE_SIZE", "REST_SIZE", "X_SPACING", "X_OFFSET", "Y_SCALE", "DRAWING_AREA_SIZE", "BEAT_RESOLUTION", "SHORTEST_NOTE", "BEAT_PER_DURATION", "PITCH_OFFSET", "FONT_STYLE_DEF", "MM_PER_POINT", "DURATION_TO_STYLE", "DURATION_TO_BEAMS", "REST_TO_GLYPH"], {"grid": false, "limit_a3": true, "SHOW_SLUR": false, "LINE_THIN": 0.1, "LINE_MEDIUM": 0.3, "LINE_THICK": 0.5, "ELLIPSE_SIZE": [3.5, 1.7], "REST_SIZE": [4, 2], "X_SPACING": 11.5, "X_OFFSET": 2.8, "Y_SCALE": 4, "DRAWING_AREA_SIZE": [400, 282], "BEAT_RESOLUTION": 192, "SHORTEST_NOTE": 64, "BEAT_PER_DURATION": 3, "PITCH_OFFSET": -43, "FONT_STYLE_DEF": $hash2(["bold", "italic", "large", "regular", "small_bold", "small_italic", "small", "smaller"], {"bold": $hash2(["text_color", "font_size", "font_style"], {"text_color": [0, 0, 0], "font_size": 12, "font_style": "bold"}), "italic": $hash2(["text_color", "font_size", "font_style"], {"text_color": [0, 0, 0], "font_size": 12, "font_style": "italic"}), "large": $hash2(["text_color", "font_size", "font_style"], {"text_color": [0, 0, 0], "font_size": 20, "font_style": "bold"}), "regular": $hash2(["text_color", "font_size", "font_style"], {"text_color": [0, 0, 0], "font_size": 12, "font_style": "normal"}), "small_bold": $hash2(["text_color", "font_size", "font_style"], {"text_color": [0, 0, 0], "font_size": 9, "font_style": "bold"}), "small_italic": $hash2(["text_color", "font_size", "font_style"], {"text_color": [0, 0, 0], "font_size": 9, "font_style": "italic"}), "small": $hash2(["text_color", "font_size", "font_style"], {"text_color": [0, 0, 0], "font_size": 9, "font_style": "normal"}), "smaller": $hash2(["text_color", "font_size", "font_style"], {"text_color": [0, 0, 0], "font_size": 6, "font_style": "normal"})}), "MM_PER_POINT": 0.3, "DURATION_TO_STYLE": $hash2(["err", "d64", "d48", "d32", "d24", "d16", "d12", "d8", "d6", "d4", "d3", "d2", "d1"], {"err": [2, "filled", false], "d64": [1, "empty", false], "d48": [0.75, "empty", true], "d32": [0.75, "empty", false], "d24": [0.75, "filled", true], "d16": [0.75, "filled", false], "d12": [0.5, "filled", true], "d8": [0.5, "filled", false], "d6": [0.3, "filled", true], "d4": [0.3, "filled", false], "d3": [0.1, "filled", true], "d2": [0.1, "filled", false], "d1": [0.05, "filled", false]}), "DURATION_TO_BEAMS": $hash2(["d64", "d48", "d32", "d24", "d16", "d12", "d8", "d6", "d4", "d3", "d2", "d1"], {"d64": [1, "empty", false], "d48": [1, "empty", true, 0], "d32": [1, "empty", false, 0], "d24": [1, "filled", true, 0], "d16": [1, "filled", false, 0], "d12": [1, "filled", true, 1], "d8": [1, "filled", false, 1], "d6": [1, "filled", true, 2], "d4": [1, "filled", false, 2], "d3": [1, "filled", true, 3], "d2": [1, "filled", false, 3], "d1": [1, "filled", false, 4]}), "REST_TO_GLYPH": $hash2(["err", "d64", "d48", "d32", "d24", "d16", "d12", "d8", "d6", "d4", "d3", "d2", "d1"], {"err": [[2, 2], "rest_1", false], "d64": [[1, 0.8], "rest_1", false], "d48": [[0.5, 0.4], "rest_1", true], "d32": [[0.5, 0.4], "rest_1", false], "d24": [[0.4, 0.75], "rest_4", true], "d16": [[0.4, 0.75], "rest_4", false], "d12": [[0.4, 0.5], "rest_8", true], "d8": [[0.4, 0.5], "rest_8", false], "d6": [[0.4, 0.3], "rest_16", true], "d4": [[0.3, 0.3], "rest_16", false], "d3": [[0.3, 0.5], "rest_32", true], "d2": [[0.3, 0.5], "rest_32", false], "d1": [[0.3, 0.5], "rest_64", false]})}), "neatjson": $hash2(["wrap", "aligned", "after_comma", "after_colon_1", "after_colon_n", "before_colon_n", "short", "afterComma", "afterColon1", "afterColonN", "beforeColonN", "decimals", "explicit_sort"], {"wrap": 60, "aligned": true, "after_comma": 1, "after_colon_1": 1, "after_colon_n": 1, "before_colon_n": 1, "short": false, "afterComma": 1, "afterColon1": 1, "afterColonN": 1, "beforeColonN": 1, "decimals": 2, "explicit_sort": Opal.const_get_relative($nesting, 'Hash')['$[]']($send(explicit_sort.$each_with_index().$to_a(), 'map', [], (TMP_34 = function(i){var self = TMP_34.$$s || this;
if (i == null) i = nil;
      return [i.$first(), $rb_plus("_", (("" + "000") + (i.$last()))['$[]']($range(-4, -1, false)))]}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34)))})});
      return result;
    }, TMP_InitConf_init_conf_35.$$arity = 0);
  })($nesting[0], $nesting);
  Opal.const_set($nesting[0], 'DBX_APIKEY_FULL', "zwydv2vbgp30e05");
  Opal.const_set($nesting[0], 'DBX_APIKEY_APP', "xr3zna7wrp75zax");
  return Opal.const_set($nesting[0], 'CONFIG_SEPARATOR', "%%%%zupfnoter.config");
};

/* Generated by Opal 0.11.4 */
Opal.modules["text_pane"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars, $range = Opal.range;

  Opal.add_stubs(['$attr_accessor', '$reset', '$push', '$[]', '$pop', '$empty?', '$reverse', '$flatten', '$lambda', '$new', '$_clean_models', '$create_lyrics_editor', '$from_lyrics', '$on', '$Native', '$getSession', '$save_to_localstorage', '$clear_markers', '$call', '$get_selection_positions', '$min', '$first', '$max', '$last', '$strip', '$_get_abc_from_editor', '$+', '$_get_config_json', '$_has_resources?', '$_get_resources_json', '$_split_parts', '$editor', '$map', '$-', '$set_markers', '$to_n', '$each', '$add_marker', '$join', '$split', '$<<', '$clear', '$_get_config_model', '$scan', '$to_s', '$[]=', '$==', '$do', '$_set_config_model', '$get', '$set_config_model', '$gsub', '$_set_config_json', '$token', '$get_selection_info', '$type', '$raise', '$replace_range', '$startpos', '$endpos', '$start_with?', '$delete', '$deep_dup', '$get_lyrics_raw', '$>', '$count', '$get_abc_part', '$error', '$clear_errors', '$get_lyrics', '$replace_text', '$call_consumers', '$nil?', '$_set_abc_to_editor', '$_set_resources_json', '$set_text', '$parse', '$select', '$clean_localstorage', '$each_with_index', '$t', '$benchmark', '$neat_generate', '$undo', '$info', '$dig', '$redo', '$undo_history', '$redo_history', '$!']);
  return (function($base, $parent_nesting) {
    var $Harpnotes, self = $Harpnotes = $module($base, 'Harpnotes');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $TextPane(){};
      var self = $TextPane = $klass($base, $super, 'TextPane', $TextPane);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_TextPane_initialize_9, TMP_TextPane_create_lyrics_editor_10, TMP_TextPane_on_change_11, TMP_TextPane_on_selection_change_13, TMP_TextPane_on_cursor_change_15, TMP_TextPane_clear_selection_17, TMP_TextPane_get_selection_positions_18, TMP_TextPane_get_selection_ranges_19, TMP_TextPane_get_selection_info_20, TMP_TextPane_select_range_by_position_21, TMP_TextPane_set_focus_22, TMP_TextPane_select_add_range_by_position_23, TMP_TextPane_get_text_24, TMP_TextPane_set_text_25, TMP_TextPane_replace_range_26, TMP_TextPane_replace_text_27, TMP_TextPane_set_annotations_29, TMP_TextPane_set_markers_31, TMP_TextPane_prepend_comment_33, TMP_TextPane_append_text_34, TMP_TextPane_add_marker_35, TMP_TextPane_clear_markers_37, TMP_TextPane_get_abc_part_38, TMP_TextPane_get_config_part_39, TMP_TextPane_get_config_model_40, TMP_TextPane_get_checksum_41, TMP_TextPane_resize_42, TMP_TextPane_set_config_model_43, TMP_TextPane_patch_config_part_44, TMP_TextPane_copy_config_part_to_extract_45, TMP_TextPane_neat_config_part_46, TMP_TextPane_patch_resources_47, TMP_TextPane_patch_token_48, TMP_TextPane_extend_config_part_49, TMP_TextPane_delete_config_part_50, TMP_TextPane_get_config_part_value_51, TMP_TextPane_get_lyrics_53, TMP_TextPane_get_lyrics_raw_54, TMP_TextPane_to_lyrics_55, TMP_TextPane_from_lyrics_57, TMP_TextPane_restore_from_localstorage_58, TMP_TextPane_save_to_localstorage_59, TMP_TextPane_clean_localstorage_60, TMP_TextPane_get_config_from_text_62, TMP_TextPane__split_parts_64, TMP_TextPane__set_abc_to_editor_65, TMP_TextPane__get_abc_from_editor_66, TMP_TextPane__set_config_json_67, TMP_TextPane__get_config_json_69, TMP_TextPane__get_config_model_70, TMP_TextPane__set_config_model_71, TMP_TextPane_undo_config_72, TMP_TextPane_redo_config_73, TMP_TextPane_history_config_74, TMP_TextPane__set_resources_json_75, TMP_TextPane__get_resources_json_76, TMP_TextPane__has_resources$q_77, TMP_TextPane__clean_models_78;

      def.editor = def.range = def.config_separator = def.markers = def.config_models = def.dirty = def.config_undo = def.on_change = def.lyrics_editor = def.controller = def.handle_from_lyrics = nil;
      
      self.$attr_accessor("editor", "controller", "autofold");
      (function($base, $super, $parent_nesting) {
        function $UndoManager(){};
        var self = $UndoManager = $klass($base, $super, 'UndoManager', $UndoManager);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UndoManager_initialize_1, TMP_UndoManager_reset_2, TMP_UndoManager_do_3, TMP_UndoManager_undo_4, TMP_UndoManager_redo_5, TMP_UndoManager_undo_history_6, TMP_UndoManager_redo_history_7;

        def.undostack = def.currentstate = def.redostack = nil;
        
        
        Opal.defn(self, '$initialize', TMP_UndoManager_initialize_1 = function $$initialize() {
          var self = this;

          return self.$reset()
        }, TMP_UndoManager_initialize_1.$$arity = 0);
        
        Opal.defn(self, '$reset', TMP_UndoManager_reset_2 = function $$reset() {
          var self = this;

          
          self.undostack = [];
          self.redostack = [];
          return (self.currentstate = $hash2(["title", "state"], {"title": "init state", "state": $hash2([], {})}));
        }, TMP_UndoManager_reset_2.$$arity = 0);
        
        Opal.defn(self, '$do', TMP_UndoManager_do_3 = function(newstate, title) {
          var self = this;

          
          self.undostack.$push(self.currentstate);
          self.redostack = [];
          self.currentstate = $hash2(["title", "state"], {"title": title, "state": newstate});
          return self.currentstate;
        }, TMP_UndoManager_do_3.$$arity = 2);
        
        Opal.defn(self, '$undo', TMP_UndoManager_undo_4 = function $$undo() {
          var self = this, momento = nil;

          if ($truthy(self.undostack['$[]'](1))) {
            
            momento = self.undostack.$pop();
            self.redostack.$push(self.currentstate);
            return (self.currentstate = momento);
            } else {
            return nil
          }
        }, TMP_UndoManager_undo_4.$$arity = 0);
        
        Opal.defn(self, '$redo', TMP_UndoManager_redo_5 = function $$redo() {
          var self = this, momento = nil;

          if ($truthy(self.redostack['$empty?']())) {
            return nil
            } else {
            
            momento = self.redostack.$pop();
            self.undostack.$push(self.currentstate);
            return (self.currentstate = momento);
          }
        }, TMP_UndoManager_redo_5.$$arity = 0);
        
        Opal.defn(self, '$undo_history', TMP_UndoManager_undo_history_6 = function $$undo_history() {
          var self = this;

          return [self.undostack, self.currentstate].$flatten().$reverse()
        }, TMP_UndoManager_undo_history_6.$$arity = 0);
        return (Opal.defn(self, '$redo_history', TMP_UndoManager_redo_history_7 = function $$redo_history() {
          var self = this;

          return [self.redostack].$flatten().$reverse()
        }, TMP_UndoManager_redo_history_7.$$arity = 0), nil) && 'redo_history';
      })($nesting[0], null, $nesting);
      
      Opal.defn(self, '$initialize', TMP_TextPane_initialize_9 = function $$initialize(div) {
        var TMP_8, self = this;

        
        
        // see http://stackoverflow.com/questions/13545433/autocompletion-in-ace-editor
        //     http://stackoverflow.com/questions/26991288/ace-editor-autocompletion-remove-local-variables
        var langTools = ace.require("ace/ext/language_tools");
        langTools.setCompleters([langTools.snippetCompleter])

        var editor = ace.edit(div);

        // clear shortcuts occupied by Zupfnoter
        editor.commands.bindKey("Cmd-L", null);
        editor.commands.bindKey("Ctrl-L", null);
        editor.commands.bindKey("Ctrl-P", null);
        editor.commands.bindKey("Ctrl-K", null);
        editor.$blockScrolling = Infinity;

        editor.getSession().setMode("ace/mode/abc");

        editor.setTheme("ace/theme/abc");

        editor.setOptions({
          highlightActiveLine: true,
          enableBasicAutocompletion: true,
          enableSnippets: true,
          enableLiveAutocompletion: false        });

        // todo: refine autocompletion according to http://plnkr.co/edit/6MVntVmXYUbjR0DI82Cr?p=preview
        //                                          https://github.com/ajaxorg/ace/wiki/How-to-enable-Autocomplete-in-the-Ace-editor

      ;
        self.editor = editor;
        self.range = ace.require('ace/range').Range;
        self.inhibit_callbacks = false;
        self.markers = [];
        self.autofold = true;
        self.on_change = $send(self, 'lambda', [], (TMP_8 = function(){var self = TMP_8.$$s || this;

        return nil}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8));
        self.config_separator = "%%%%zupfnoter";
        self.dirty = $hash2([], {});
        self.config_undo = Opal.const_get_relative($nesting, 'UndoManager').$new();
        self.$_clean_models();
        return self.$create_lyrics_editor("abcLyrics");
      }, TMP_TextPane_initialize_9.$$arity = 1);
      
      Opal.defn(self, '$create_lyrics_editor', TMP_TextPane_create_lyrics_editor_10 = function $$create_lyrics_editor(div) {
        var self = this;

        
        
        // see http://stackoverflow.com/questions/13545433/autocompletion-in-ace-editor
        //     http://stackoverflow.com/questions/26991288/ace-editor-autocompletion-remove-local-variables
        var langTools = ace.require("ace/ext/language_tools");
        langTools.setCompleters([langTools.snippetCompleter])

        var editor = ace.edit(div);
        editor.$blockScrolling = Infinity;

        editor.getSession().setMode("ace/mode/markdown");

        editor.setTheme("ace/theme/abc");

        editor.setOptions({
          highlightActiveLine: true,
          enableBasicAutocompletion: true,
          enableSnippets: true,
          enableLiveAutocompletion: false        });

        // todo: refine autocompletion according to http://plnkr.co/edit/6MVntVmXYUbjR0DI82Cr?p=preview
        //                                          https://github.com/ajaxorg/ace/wiki/How-to-enable-Autocomplete-in-the-Ace-editor
        editor.on('change', function(){self.$from_lyrics()})
      ;
        self.lyrics_editor = editor;
        self.lyrics_range = ace.require('ace/range').Range;
        self.lyrics_inhibit_callbacks = false;
        return (self.lyrics_markers = []);
      }, TMP_TextPane_create_lyrics_editor_10.$$arity = 1);
      
      Opal.defn(self, '$on_change', TMP_TextPane_on_change_11 = function $$on_change() {
        var TMP_12, self = this, $iter = TMP_TextPane_on_change_11.$$p, block = $iter || nil;

        if ($iter) TMP_TextPane_on_change_11.$$p = null;
        
        self.on_change = block;
        return $send(self.$Native(self.$Native(self.editor).$getSession()), 'on', ["change"], (TMP_12 = function(e){var self = TMP_12.$$s || this;
          if (self.on_change == null) self.on_change = nil;
if (e == null) e = nil;
        
          self.$save_to_localstorage("zn_abc");
          self.$clear_markers();
          return self.on_change.$call(e);}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));
      }, TMP_TextPane_on_change_11.$$arity = 0);
      
      Opal.defn(self, '$on_selection_change', TMP_TextPane_on_selection_change_13 = function $$on_selection_change() {
        var TMP_14, self = this, $iter = TMP_TextPane_on_selection_change_13.$$p, block = $iter || nil;

        if ($iter) TMP_TextPane_on_selection_change_13.$$p = null;
        return $send(self.$Native(self.$Native(self.editor)['$[]']("selection")), 'on', ["changeSelection"], (TMP_14 = function(e){var self = TMP_14.$$s || this;
          if (self.inhibit_callbacks == null) self.inhibit_callbacks = nil;
if (e == null) e = nil;
        if ($truthy(self.inhibit_callbacks)) {
            return nil
            } else {
            return block.$call(e)
          }}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14))
      }, TMP_TextPane_on_selection_change_13.$$arity = 0);
      
      Opal.defn(self, '$on_cursor_change', TMP_TextPane_on_cursor_change_15 = function $$on_cursor_change() {
        var TMP_16, self = this, $iter = TMP_TextPane_on_cursor_change_15.$$p, block = $iter || nil;

        if ($iter) TMP_TextPane_on_cursor_change_15.$$p = null;
        
        block.$call(nil);
        return $send(self.$Native(self.$Native(self.editor)['$[]']("selection")), 'on', ["changeCursor"], (TMP_16 = function(e){var self = TMP_16.$$s || this;
          if (self.inhibit_callbacks == null) self.inhibit_callbacks = nil;
if (e == null) e = nil;
        if ($truthy(self.inhibit_callbacks)) {
            return nil
            } else {
            return block.$call(e)
          }}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));
      }, TMP_TextPane_on_cursor_change_15.$$arity = 0);
      
      Opal.defn(self, '$clear_selection', TMP_TextPane_clear_selection_17 = function $$clear_selection() {
        var self = this;

        return 
      self.editor.selection.clearSelection()
      
      }, TMP_TextPane_clear_selection_17.$$arity = 0);
      
      Opal.defn(self, '$get_selection_positions', TMP_TextPane_get_selection_positions_18 = function $$get_selection_positions() {
        var self = this;

        
        
        doc = self.editor.selection.doc;
        range = self.editor.selection.getRange();
        range_start = doc.positionToIndex(range.start, 0);
        range_end = doc.positionToIndex(range.end, 0);
      ;
        return [range_start, range_end];
      }, TMP_TextPane_get_selection_positions_18.$$arity = 0);
      
      Opal.defn(self, '$get_selection_ranges', TMP_TextPane_get_selection_ranges_19 = function $$get_selection_ranges() {
        var self = this;

        
        
        var doc = self.editor.selection.doc;
        var ranges = self.editor.selection.getAllRanges();
        var result = ranges.map(function(therange){
           var range_start = doc.positionToIndex(therange.start, 0);
           var range_end = doc.positionToIndex(therange.end, 0);
           return([range_start, range_end])
        })
      ;
        return result;
      }, TMP_TextPane_get_selection_ranges_19.$$arity = 0);
      
      Opal.defn(self, '$get_selection_info', TMP_TextPane_get_selection_info_20 = function $$get_selection_info() {
        var self = this;

        
        
         doc = self.editor.selection.doc;
         range = self.editor.selection.getRange();
         token = self.editor.session.getTokenAt(range.start.row, range.start.column);
         if (token){
           token.startpos = [range.start.row, token.start];
           token.endpos = [range.start.row, token.start + token.value.length];
         }
         else
         {
          //todo handle missing token
         }
        ;
        return self.$Native({selection: [[range.start.row+1, range.start.column+1], [range.end.row+1, range.end.column+1]], token: token});
      }, TMP_TextPane_get_selection_info_20.$$arity = 0);
      
      Opal.defn(self, '$select_range_by_position', TMP_TextPane_select_range_by_position_21 = function $$select_range_by_position(requested_selection_start, requested_selection_end, expand_selection) {
        var self = this, current_selection = nil, selection_newstart = nil, selection_end = nil;

        if (expand_selection == null) {
          expand_selection = false;
        }
        
        if ($truthy(expand_selection)) {
          current_selection = self.$get_selection_positions()
          } else {
          current_selection = [requested_selection_start, requested_selection_end]
        };
        selection_newstart = [current_selection.$first(), requested_selection_start].$min();
        selection_end = [current_selection.$last(), requested_selection_end].$max();
        
        doc = self.editor.selection.doc
        startrange = doc.indexToPosition(selection_newstart);
        endrange = doc.indexToPosition(selection_end);
        range = new self.range(startrange.row, startrange.column, endrange.row, endrange.column);
        myrange = {start:startrange, end:endrange}
        self.editor.focus();
          self.editor.selection.setSelectionRange(myrange, false);
      ;
      }, TMP_TextPane_select_range_by_position_21.$$arity = -3);
      
      Opal.defn(self, '$set_focus', TMP_TextPane_set_focus_22 = function $$set_focus() {
        var self = this;

        return self.editor.focus();
      }, TMP_TextPane_set_focus_22.$$arity = 0);
      
      Opal.defn(self, '$select_add_range_by_position', TMP_TextPane_select_add_range_by_position_23 = function $$select_add_range_by_position(requested_selection_start, requested_selection_end, expand_selection) {
        var self = this, current_selection = nil, selection_newstart = nil, selection_end = nil;

        if (expand_selection == null) {
          expand_selection = false;
        }
        
        if ($truthy(expand_selection)) {
          current_selection = self.$get_selection_positions()
          } else {
          current_selection = [requested_selection_start, requested_selection_end]
        };
        selection_newstart = [current_selection.$first(), requested_selection_start].$min();
        selection_end = [current_selection.$last(), requested_selection_end].$max();
        
        doc = self.editor.selection.doc
        startrange = doc.indexToPosition(selection_newstart);
        endrange = doc.indexToPosition(selection_end);
        range = new self.range(startrange.row, startrange.column, endrange.row, endrange.column);
        myrange = {start:startrange, end:endrange}
        self.editor.focus();
        self.editor.selection.addRange(range, false);
      ;
      }, TMP_TextPane_select_add_range_by_position_23.$$arity = -3);
      
      Opal.defn(self, '$get_text', TMP_TextPane_get_text_24 = function $$get_text() {
        var self = this, result = nil;

        
        result = self.$_get_abc_from_editor().$strip();
        result = $rb_plus(result, $rb_plus("" + "\n\n" + (self.config_separator) + ".config\n\n", self.$_get_config_json()));
        if ($truthy(self['$_has_resources?']())) {
          result = $rb_plus(result, $rb_plus("" + "\n\n" + (self.config_separator) + ".resources\n\n", self.$_get_resources_json()))};
        return result;
      }, TMP_TextPane_get_text_24.$$arity = 0);
      
      Opal.defn(self, '$set_text', TMP_TextPane_set_text_25 = function $$set_text(text) {
        var self = this;

        return self.$_split_parts(text)
      }, TMP_TextPane_set_text_25.$$arity = 1);
      
      Opal.defn(self, '$replace_range', TMP_TextPane_replace_range_26 = function $$replace_range(startpos, endpos, text) {
        var self = this;

        
      therange = new self.range(startpos[0], startpos[1], endpos[0], endpos[1]);
      self.$editor().getSession().replace(therange, text);
      
      }, TMP_TextPane_replace_range_26.$$arity = 3);
      
      Opal.defn(self, '$replace_text', TMP_TextPane_replace_text_27 = function $$replace_text(oldtext, newtext) {
        var self = this;

        
        self.editor.replace(newtext, {needle: oldtext}) ;
        return nil;
      }, TMP_TextPane_replace_text_27.$$arity = 2);
      
      Opal.defn(self, '$set_annotations', TMP_TextPane_set_annotations_29 = function $$set_annotations(annotations) {
        var TMP_28, self = this, editor_annotations = nil;

        
        editor_annotations = $send(annotations, 'map', [], (TMP_28 = function(annotation){var self = TMP_28.$$s || this;
if (annotation == null) annotation = nil;
        return $hash2(["row", "text", "type"], {"row": $rb_minus(annotation['$[]']("start_pos").$first(), 1), "text": annotation['$[]']("text"), "type": annotation['$[]']("type")})}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28));
        self.$set_markers(annotations);
        self.editor.getSession().setAnnotations(editor_annotations.$to_n());
        return nil;
      }, TMP_TextPane_set_annotations_29.$$arity = 1);
      
      Opal.defn(self, '$set_markers', TMP_TextPane_set_markers_31 = function $$set_markers(annotations) {
        var TMP_30, self = this;

        
        self.$clear_markers();
        return $send(annotations, 'each', [], (TMP_30 = function(annotation){var self = TMP_30.$$s || this;
if (annotation == null) annotation = nil;
        return self.$add_marker(annotation)}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30));
      }, TMP_TextPane_set_markers_31.$$arity = 1);
      
      Opal.defn(self, '$prepend_comment', TMP_TextPane_prepend_comment_33 = function $$prepend_comment(message) {
        var TMP_32, self = this, text = nil;

        
        text = $rb_plus($send(message.$split(/\r?\n/), 'map', [], (TMP_32 = function(l){var self = TMP_32.$$s || this;
if (l == null) l = nil;
        return "" + "% " + (l)}, TMP_32.$$s = self, TMP_32.$$arity = 1, TMP_32)).$join("\n"), "\n%\n");
        
      self.editor.selection.moveCursorFileStart();
      self.editor.insert(text);
      ;
      }, TMP_TextPane_prepend_comment_33.$$arity = 1);
      
      Opal.defn(self, '$append_text', TMP_TextPane_append_text_34 = function $$append_text(text) {
        var self = this;

        
      self.editor.selection.moveCursorFileEnd();
      self.editor.insert(text);
      
      }, TMP_TextPane_append_text_34.$$arity = 1);
      
      Opal.defn(self, '$add_marker', TMP_TextPane_add_marker_35 = function $$add_marker(annotation) {
        var self = this, marker_start = nil, marker_end = nil, id = nil;

        
        marker_start = $hash2(["row", "col"], {"row": annotation['$[]']("start_pos").$first(), "col": annotation['$[]']("start_pos").$last()});
        marker_end = $hash2(["row", "col"], {"row": annotation['$[]']("end_pos").$first(), "col": annotation['$[]']("end_pos").$last()});
        id = self.editor.getSession().addMarker(new self.range($rb_minus(marker_start['$[]']("row"), 1), $rb_minus(marker_start['$[]']("col"), 1),
                                                              $rb_minus(marker_end['$[]']("row"), 1), $rb_minus(marker_end['$[]']("col"), 1)),
                                               "marked", "line", true);
        self.markers['$<<']($hash2(["from", "to", "id"], {"from": [marker_start['$[]']("row"), marker_start['$[]']("col")], "to": [marker_end['$[]']("row"), marker_end['$[]']("col")], "id": id}));
        return nil;
      }, TMP_TextPane_add_marker_35.$$arity = 1);
      
      Opal.defn(self, '$clear_markers', TMP_TextPane_clear_markers_37 = function $$clear_markers() {
        var TMP_36, self = this;

        
        $send(self.markers, 'each', [], (TMP_36 = function(marker){var self = TMP_36.$$s || this;
          if (self.editor == null) self.editor = nil;
if (marker == null) marker = nil;
        return self.editor.session.removeMarker(marker['$[]']("id"))}, TMP_36.$$s = self, TMP_36.$$arity = 1, TMP_36));
        return self.markers.$clear();
      }, TMP_TextPane_clear_markers_37.$$arity = 0);
      
      Opal.defn(self, '$get_abc_part', TMP_TextPane_get_abc_part_38 = function $$get_abc_part() {
        var self = this;

        return self.editor.getSession().getValue()
      }, TMP_TextPane_get_abc_part_38.$$arity = 0);
      
      Opal.defn(self, '$get_config_part', TMP_TextPane_get_config_part_39 = function $$get_config_part() {
        var self = this;

        return self.config_models['$[]']("config")
      }, TMP_TextPane_get_config_part_39.$$arity = 0);
      
      Opal.defn(self, '$get_config_model', TMP_TextPane_get_config_model_40 = function $$get_config_model() {
        var self = this, config_model = nil;

        
        config_model = self.$_get_config_model();
        if ($truthy(config_model)) {
          return [self.$_get_config_model(), true]
          } else {
          return [$hash2([], {}), false]
        };
      }, TMP_TextPane_get_config_model_40.$$arity = 0);
      
      Opal.defn(self, '$get_checksum', TMP_TextPane_get_checksum_41 = function $$get_checksum() {
        var self = this, s = nil;

        
        s = self.$_get_abc_from_editor().$strip();
        
            var i;
            var chk = 0x12345678;

            for (i = 0; i < s.length; i++) {
              chk += (s.charCodeAt(i) * (i + 1));
           }
         ;
        return (chk).$to_s().$scan(/...?/).$join(" ");
      }, TMP_TextPane_get_checksum_41.$$arity = 0);
      
      Opal.defn(self, '$resize', TMP_TextPane_resize_42 = function $$resize() {
        var self = this;

        return self.editor.resize()
      }, TMP_TextPane_resize_42.$$arity = 0);
      
      Opal.defn(self, '$set_config_model', TMP_TextPane_set_config_model_43 = function $$set_config_model(object, desc, handleundo) {
        var self = this, $writer = nil;

        if (desc == null) {
          desc = "no desc";
        }
        if (handleundo == null) {
          handleundo = true;
        }
        
        
        $writer = ["zn_config", true];
        $send(self.dirty, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        if (handleundo['$=='](true)) {
          self.config_undo.$do(object, desc)};
        return self.$_set_config_model(object);
      }, TMP_TextPane_set_config_model_43.$$arity = -2);
      
      Opal.defn(self, '$patch_config_part', TMP_TextPane_patch_config_part_44 = function $$patch_config_part(key, object, desc) {
        var self = this, pconfig = nil, pconfig_patch = nil, $writer = nil;

        if (desc == null) {
          desc = key;
        }
        
        pconfig = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Confstack'), 'Confstack').$new(false);
        pconfig_patch = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Confstack'), 'Confstack').$new(false);
        pconfig.$push(self.$_get_config_model());
        
        $writer = [key, object];
        $send(pconfig_patch, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        pconfig.$push(pconfig_patch.$get());
        return self.$set_config_model(pconfig.$get(), desc, true);
      }, TMP_TextPane_patch_config_part_44.$$arity = -3);
      
      Opal.defn(self, '$copy_config_part_to_extract', TMP_TextPane_copy_config_part_to_extract_45 = function $$copy_config_part_to_extract(key, targetid, desc) {
        var self = this, pconfig = nil, pconfig_patch = nil, key0 = nil, $writer = nil;

        if (desc == null) {
          desc = key;
        }
        
        pconfig = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Confstack'), 'Confstack').$new(false);
        pconfig_patch = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Confstack'), 'Confstack').$new(false);
        pconfig.$push(self.$_get_config_model());
        key0 = key.$gsub(/^extract\.\d+/, "" + "extract." + (targetid));
        
        $writer = [key0, pconfig.$get(key)];
        $send(pconfig_patch, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        pconfig.$push(pconfig_patch.$get());
        return self.$set_config_model(pconfig.$get(), desc, true);
      }, TMP_TextPane_copy_config_part_to_extract_45.$$arity = -3);
      
      Opal.defn(self, '$neat_config_part', TMP_TextPane_neat_config_part_46 = function $$neat_config_part() {
        var self = this;

        return self.$_set_config_json(self.$_get_config_json(), "neat config_part", false)
      }, TMP_TextPane_neat_config_part_46.$$arity = 0);
      
      Opal.defn(self, '$patch_resources', TMP_TextPane_patch_resources_47 = function $$patch_resources(key, value) {
        var self = this, $writer = nil;
        if ($gvars.resources == null) $gvars.resources = nil;

        
        
        $writer = ["zn_resources", true];
        $send(self.dirty, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [key, value];
        $send($gvars.resources, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        self.$save_to_localstorage("zn_resources");
        return self.on_change.$call(nil);
      }, TMP_TextPane_patch_resources_47.$$arity = 2);
      
      Opal.defn(self, '$patch_token', TMP_TextPane_patch_token_48 = function $$patch_token(token, endpos, newvalue) {
        var self = this, oldtoken = nil;

        
        oldtoken = self.$get_selection_info().$token();
        if (oldtoken.$type().$to_s()['$=='](token.$to_s())) {
          } else {
          self.$raise("" + "cannot patch token if there is a name mismatch '" + (oldtoken.$type()) + "' - '" + (token) + "'")
        };
        return self.$replace_range(oldtoken.$startpos(), oldtoken.$endpos(), newvalue);
      }, TMP_TextPane_patch_token_48.$$arity = 3);
      
      Opal.defn(self, '$extend_config_part', TMP_TextPane_extend_config_part_49 = function $$extend_config_part(key, object) {
        var self = this, pconfig = nil, pconfig_patch = nil, $writer = nil;

        
        pconfig = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Confstack'), 'Confstack').$new(false);
        pconfig_patch = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Confstack'), 'Confstack').$new(false);
        pconfig.$push(self.$_get_config_model());
        
        $writer = [key, object];
        $send(pconfig_patch, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        pconfig.$push(pconfig_patch.$get());
        pconfig.$push(self.$_get_config_model());
        return self.$set_config_model(pconfig.$get(), "" + "extend " + (key), true);
      }, TMP_TextPane_extend_config_part_49.$$arity = 2);
      
      Opal.defn(self, '$delete_config_part', TMP_TextPane_delete_config_part_50 = function $$delete_config_part(key) {
        var self = this, pconfig = nil, $writer = nil;
        if ($gvars.resources == null) $gvars.resources = nil;

        if ($truthy(key['$start_with?']("$resources"))) {
          return $gvars.resources.$delete(key.$split(".").$last())
          } else {
          
          pconfig = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Confstack'), 'Confstack').$new(false);
          pconfig.$push(self.$_get_config_model().$deep_dup());
          
          $writer = [key, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Confstack'), 'DeleteMe')];
          $send(pconfig, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return self.$set_config_model(pconfig.$get(), "" + "delete " + (key), true);
        }
      }, TMP_TextPane_delete_config_part_50.$$arity = 1);
      
      Opal.defn(self, '$get_config_part_value', TMP_TextPane_get_config_part_value_51 = function $$get_config_part_value(key) {
        var self = this, pconfig = nil, result = nil;

        
        pconfig = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Confstack'), 'Confstack').$new(false);
        pconfig.$push(self.$_get_config_model());
        result = pconfig['$[]'](key);
        return result;
      }, TMP_TextPane_get_config_part_value_51.$$arity = 1);
      
      Opal.defn(self, '$get_lyrics', TMP_TextPane_get_lyrics_53 = function $$get_lyrics() {
        var TMP_52, self = this, retval = nil, lyrics = nil;

        
        retval = self.$get_lyrics_raw();
        if ($truthy($rb_gt(retval.$count(), 0))) {
          lyrics = $send(retval, 'map', [], (TMP_52 = function(r){var self = TMP_52.$$s || this;
if (r == null) r = nil;
          return r.$first().$gsub(/\nW\:[ \t]*/, "\n")}, TMP_52.$$s = self, TMP_52.$$arity = 1, TMP_52)).$join().$strip()
          } else {
          lyrics = nil
        };
        return lyrics;
      }, TMP_TextPane_get_lyrics_53.$$arity = 0);
      
      Opal.defn(self, '$get_lyrics_raw', TMP_TextPane_get_lyrics_raw_54 = function $$get_lyrics_raw() {
        var self = this, regex = nil, abc_code = nil, retval = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        regex = /((\n((W\:)([^\n]*)\n)+)+)/;
        abc_code = self.$get_abc_part();
        retval = abc_code.$scan(regex);
        if ($truthy($rb_gt(retval.$count(), 1))) {
          $gvars.log.$error("you have more than one lyrics section in your abc code")};
        return retval;
      }, TMP_TextPane_get_lyrics_raw_54.$$arity = 0);
      
      Opal.defn(self, '$to_lyrics', TMP_TextPane_to_lyrics_55 = function $$to_lyrics() {
        var self = this, lyrics = nil, abc = nil, abc_with_lyris = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        $gvars.log.$clear_errors();
        lyrics = self.$get_lyrics();
        if ($truthy(lyrics)) {
          } else {
          
          abc = self.$get_abc_part();
          abc_with_lyris = $rb_plus(abc.$strip(), "\n%\nW:\n%\n%\n");
          self.$replace_text(abc, abc_with_lyris);
        };
        self.handle_from_lyrics = false;
        self.lyrics_editor.getSession().setValue(self.$get_lyrics());;
        self.handle_from_lyrics = true;
        self.controller.$call_consumers("error_alert");
        return nil;
      }, TMP_TextPane_to_lyrics_55.$$arity = 0);
      
      Opal.defn(self, '$from_lyrics', TMP_TextPane_from_lyrics_57 = function $$from_lyrics() {
        var TMP_56, self = this, lyrics_raw = nil, oldtext = nil, newtext = nil;

        
        if ($truthy(self.handle_from_lyrics)) {
          
          lyrics_raw = self.$get_lyrics_raw();
          oldtext = lyrics_raw.$first().$first();
          newtext = self.lyrics_editor.getSession().getValue();;
          if ($truthy(newtext['$empty?']())) {
            newtext = " "};
          newtext = $send(newtext.$split("\n"), 'map', [], (TMP_56 = function(l){var self = TMP_56.$$s || this;
if (l == null) l = nil;
          return "" + "W:" + (l)}, TMP_56.$$s = self, TMP_56.$$arity = 1, TMP_56)).$join("\n");
          newtext = "" + "\n" + (newtext) + "\n";
          self.$replace_text(oldtext, newtext);};
        return nil;
      }, TMP_TextPane_from_lyrics_57.$$arity = 0);
      
      Opal.defn(self, '$restore_from_localstorage', TMP_TextPane_restore_from_localstorage_58 = function $$restore_from_localstorage() {
        var $a, self = this, abc = nil, abctext = nil, configjson = nil, resources = nil;

        
        abc = self.$Native(localStorage.getItem('abc_data'));
        if ($truthy(abc['$nil?']())) {
          
          abctext = self.$Native(localStorage.getItem('zn_abc'));
          if ($truthy(abctext)) {
            self.$_set_abc_to_editor(abctext)};
          configjson = ($truthy($a = self.$Native(localStorage.getItem('zn_config'))) ? $a : $hash2([], {}));
          self.config_undo.$reset();
          if ($truthy(configjson)) {
            self.$_set_config_json(configjson, "from localstore zn_config", true)};
          resources = self.$Native(localStorage.getItem('zn_resources'));
          if ($truthy(resources)) {
            self.$_set_resources_json(resources)};
          } else {
          
          localStorage.removeItem('abc_data');
          if ($truthy(abc['$nil?']())) {
            } else {
            self.$set_text(abc)
          };
        };
        return (self.dirty = $hash2([], {}));
      }, TMP_TextPane_restore_from_localstorage_58.$$arity = 0);
      
      Opal.defn(self, '$save_to_localstorage', TMP_TextPane_save_to_localstorage_59 = function $$save_to_localstorage(dirty_name) {
        var self = this, $writer = nil;

        if (dirty_name == null) {
          dirty_name = nil;
        }
        
        if ($truthy(dirty_name)) {
          
          $writer = [dirty_name, true];
          $send(self.dirty, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if (self.dirty['$[]']("zn_abc")['$=='](true)) {
          localStorage.setItem('zn_abc', self.$_get_abc_from_editor())};
        if (self.dirty['$[]']("zn_config")['$=='](true)) {
          localStorage.setItem('zn_config', self.$_get_config_json())};
        if (self.dirty['$[]']("zn_resources")['$=='](true)) {
          localStorage.setItem('zn_resources', self.$_get_resources_json())};
        return (self.dirty = $hash2([], {}));
      }, TMP_TextPane_save_to_localstorage_59.$$arity = -1);
      
      Opal.defn(self, '$clean_localstorage', TMP_TextPane_clean_localstorage_60 = function $$clean_localstorage() {
        var self = this;

        
        localStorage.removeItem('zn_abc');
        localStorage.removeItem('zn_config');
        localStorage.removeItem('zn_resources');
        return nil;
      }, TMP_TextPane_clean_localstorage_60.$$arity = 0);
      
      Opal.defn(self, '$get_config_from_text', TMP_TextPane_get_config_from_text_62 = function $$get_config_from_text(fulltext) {
        var TMP_61, self = this;

        return Opal.const_get_relative($nesting, 'JSON').$parse($send(fulltext.$split(self.config_separator), 'select', [], (TMP_61 = function(i){var self = TMP_61.$$s || this;
if (i == null) i = nil;
        return i['$start_with?'](".config")}, TMP_61.$$s = self, TMP_61.$$arity = 1, TMP_61)).$first().$gsub(".config", ""))
      }, TMP_TextPane_get_config_from_text_62.$$arity = 1);
      
      Opal.defn(self, '$_split_parts', TMP_TextPane__split_parts_64 = function $$_split_parts(fulltext) {
        var TMP_63, self = this;

        
        self.$_clean_models();
        self.$clean_localstorage();
        return $send(fulltext.$split(self.config_separator), 'each_with_index', [], (TMP_63 = function(part, i){var self = TMP_63.$$s || this;
          if (self.config_undo == null) self.config_undo = nil;
          if ($gvars.log == null) $gvars.log = nil;
if (part == null) part = nil;if (i == null) i = nil;
        if (i['$=='](0)) {
            return self.$_set_abc_to_editor(part)
          } else if ($truthy(part['$start_with?'](".config"))) {
            
            self.config_undo.$reset();
            return self.$_set_config_json(part.$split(".config").$last(), "from loaded abc", true);
          } else if ($truthy(part['$start_with?'](".resources"))) {
            return self.$_set_resources_json(part.$split(".resources").$last())
            } else {
            return $gvars.log.$error($rb_plus(Opal.const_get_relative($nesting, 'I18n').$t("unsupported section found in abc file: "), part['$[]']($range(0, 10, false))))
          }}, TMP_63.$$s = self, TMP_63.$$arity = 2, TMP_63));
      }, TMP_TextPane__split_parts_64.$$arity = 1);
      
      Opal.defn(self, '$_set_abc_to_editor', TMP_TextPane__set_abc_to_editor_65 = function $$_set_abc_to_editor(abctext) {
        var self = this;

        
        self.inhibit_callbacks = true;
        self.editor.getSession().setValue(abctext);;
        self.inhibit_callbacks = false;
        return self.$save_to_localstorage("zn_abc");
      }, TMP_TextPane__set_abc_to_editor_65.$$arity = 1);
      
      Opal.defn(self, '$_get_abc_from_editor', TMP_TextPane__get_abc_from_editor_66 = function $$_get_abc_from_editor() {
        var self = this;

        
        return self.editor.getSession().getValue();
        return nil;
      }, TMP_TextPane__get_abc_from_editor_66.$$arity = 0);
      
      Opal.defn(self, '$_set_config_json', TMP_TextPane__set_config_json_67 = function $$_set_config_json(json, desc, handleundo) {
        var self = this;

        if (desc == null) {
          desc = "no desc";
        }
        if (handleundo == null) {
          handleundo = true;
        }
        return self.$set_config_model(Opal.const_get_relative($nesting, 'JSON').$parse(json), desc, handleundo)
      }, TMP_TextPane__set_config_json_67.$$arity = -2);
      
      Opal.defn(self, '$_get_config_json', TMP_TextPane__get_config_json_69 = function $$_get_config_json() {
        var TMP_68, self = this, options = nil, result = nil;
        if ($gvars.conf == null) $gvars.conf = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        options = $gvars.conf['$[]']("neatjson");
        result = $send($gvars.log, 'benchmark', ["neat_json", 715, "text_pane"], (TMP_68 = function(){var self = TMP_68.$$s || this;

        return Opal.const_get_relative($nesting, 'JSON').$neat_generate(self.$_get_config_model(), options)}, TMP_68.$$s = self, TMP_68.$$arity = 0, TMP_68));
        return result;
      }, TMP_TextPane__get_config_json_69.$$arity = 0);
      
      Opal.defn(self, '$_get_config_model', TMP_TextPane__get_config_model_70 = function $$_get_config_model() {
        var $a, self = this;

        return ($truthy($a = self.config_models['$[]']("config")) ? $a : $hash2([], {}))
      }, TMP_TextPane__get_config_model_70.$$arity = 0);
      
      Opal.defn(self, '$_set_config_model', TMP_TextPane__set_config_model_71 = function $$_set_config_model(object) {
        var self = this, $writer = nil;

        
        
        $writer = ["config", object];
        $send(self.config_models, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        self.$save_to_localstorage("zn_config");
        return self.on_change.$call(nil);
      }, TMP_TextPane__set_config_model_71.$$arity = 1);
      
      Opal.defn(self, '$undo_config', TMP_TextPane_undo_config_72 = function $$undo_config() {
        var self = this, momento = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        momento = self.config_undo.$undo();
        if ($truthy(momento)) {
          
          $gvars.log.$info("" + "undo: " + (momento['$[]']("title")) + ": " + (momento['$[]']("state").$dig("extract", "0", "legend", "pos")));
          if ($truthy(momento)) {
            return self.$set_config_model(momento['$[]']("state"), momento['$[]']("title"), false)
            } else {
            return nil
          };
          } else {
          return nil
        };
      }, TMP_TextPane_undo_config_72.$$arity = 0);
      
      Opal.defn(self, '$redo_config', TMP_TextPane_redo_config_73 = function $$redo_config() {
        var self = this, momento = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        momento = self.config_undo.$redo();
        if ($truthy(momento)) {
          
          $gvars.log.$info("" + "redo: " + (momento['$[]']("title")) + ": " + (momento['$[]']("state").$dig("extract", "0", "legend", "pos")));
          if ($truthy(momento)) {
            return self.$set_config_model(momento['$[]']("state"), momento['$[]']("title"), false)
            } else {
            return nil
          };
          } else {
          return nil
        };
      }, TMP_TextPane_redo_config_73.$$arity = 0);
      
      Opal.defn(self, '$history_config', TMP_TextPane_history_config_74 = function $$history_config() {
        var self = this;

        return $hash2(["undo", "redo"], {"undo": self.config_undo.$undo_history(), "redo": self.config_undo.$redo_history()})
      }, TMP_TextPane_history_config_74.$$arity = 0);
      
      Opal.defn(self, '$_set_resources_json', TMP_TextPane__set_resources_json_75 = function $$_set_resources_json(json) {
        var self = this;

        
        $gvars.resources = Opal.const_get_relative($nesting, 'JSON').$parse(json);
        self.$save_to_localstorage("zn_resources");
        return self.on_change.$call(nil);
      }, TMP_TextPane__set_resources_json_75.$$arity = 1);
      
      Opal.defn(self, '$_get_resources_json', TMP_TextPane__get_resources_json_76 = function $$_get_resources_json() {
        var self = this, result = nil;
        if ($gvars.resources == null) $gvars.resources = nil;
        if ($gvars.conf == null) $gvars.conf = nil;

        
        result = Opal.const_get_relative($nesting, 'JSON').$neat_generate($gvars.resources, $gvars.conf['$[]']("neatjson"));
        return result;
      }, TMP_TextPane__get_resources_json_76.$$arity = 0);
      
      Opal.defn(self, '$_has_resources?', TMP_TextPane__has_resources$q_77 = function() {
        var self = this;
        if ($gvars.resources == null) $gvars.resources = nil;

        return $gvars.resources['$empty?']()['$!']()
      }, TMP_TextPane__has_resources$q_77.$$arity = 0);
      return (Opal.defn(self, '$_clean_models', TMP_TextPane__clean_models_78 = function $$_clean_models() {
        var self = this;

        
        $gvars.resources = $hash2([], {});
        self.config_models = $hash2([], {});
        return (self.dirty = $hash2([], {}));
      }, TMP_TextPane__clean_models_78.$$arity = 0), nil) && '_clean_models';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["harpnote_player"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$attr_accessor', '$call_on_songoff', '$call_on_note', '$error', '$call_consumers', '$==', '$call', '$lambda', '$>=', '$count', '$>', '$uniq', '$map', '$[]', '$play_selection', '$play_from_selection', '$debug', '$to_s', '$first', '$select', '$include?', '$play_notes', '$play_from_abc', '$stop', '$empty?', '$warning', '$sort_by', '$last', '$*', '$+', '$-', '$get', '$mk_to_play_for_abc2svgplay', '$clamp', '$is_playing?', '$each', '$sort', '$<=>', '$Native', '$nil?', '$class', '$<', '$===', '$push', '$%', '$compact', '$flatten', '$pitch_to_note', '$reduce', '$meta_data', '$/', '$_load_voice_elements_from_voices', '$group_by', '$each_with_index', '$voices', '$is_a?', '$mk_to_play', '$notes', '$pitch', '$tie_end?', '$[]=', '$tie_start?', '$beat', '$duration', '$origin']);
  return (function($base, $parent_nesting) {
    var $Harpnotes, self = $Harpnotes = $module($base, 'Harpnotes');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Music, self = $Music = $module($base, 'Music');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $HarpnotePlayer(){};
        var self = $HarpnotePlayer = $klass($base, $super, 'HarpnotePlayer', $HarpnotePlayer);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_HarpnotePlayer_initialize_1, TMP_HarpnotePlayer_is_playing$q_2, TMP_HarpnotePlayer_is_stopped$q_3, TMP_HarpnotePlayer_call_on_note_4, TMP_HarpnotePlayer_call_on_songoff_5, TMP_HarpnotePlayer_on_noteon_6, TMP_HarpnotePlayer_on_noteoff_7, TMP_HarpnotePlayer_on_songoff_8, TMP_HarpnotePlayer_play_auto_11, TMP_HarpnotePlayer_play_from_selection_14, TMP_HarpnotePlayer_play_selection_15, TMP_HarpnotePlayer_play_song_16, TMP_HarpnotePlayer_play_from_abc_17, TMP_HarpnotePlayer_play_notes_20, TMP_HarpnotePlayer_set_speed_21, TMP_HarpnotePlayer_stop_22, TMP_HarpnotePlayer_unhighlight_all_23, TMP_HarpnotePlayer_range_highlight_26, TMP_HarpnotePlayer_pitch_to_note_27, TMP_HarpnotePlayer_get_notes_32, TMP_HarpnotePlayer_load_song_34, TMP_HarpnotePlayer_get_worker_model_35, TMP_HarpnotePlayer_set_worker_model_37, TMP_HarpnotePlayer__load_voice_elements_from_voices_43, TMP_HarpnotePlayer_mk_to_play_for_abc2svgplay_44, TMP_HarpnotePlayer_mk_to_play_45;

        def.abcplay = def.controller = def.status = def.noteon_callback = def.noteoff_callback = def.songoff_callback = def.selection = def.voice_elements = def.player_model_abc = def.song_off_timer = def.duration_timefactor = def.speed = def.active_voices = def.beat_timefactor = nil;
        
        self.$attr_accessor("player_model_abc", "controller");
        
        Opal.defn(self, '$initialize', TMP_HarpnotePlayer_initialize_1 = function $$initialize() {
          var self = this;
          if ($gvars.log == null) $gvars.log = nil;

          
          self.abcplay = new AbcPlay({
             onend: function(){self.$call_on_songoff()}, // todo: activate after fix https://github.com/moinejf/abc2svg/issues/43
             onnote: function(index, on,  custom){self.$call_on_note(index, on, custom)},
             errmsg: function(message){$gvars.log.$error(message);self.controller.$call_consumers("error_alert");}
          })
           self.abcplay.set_sfu("public/soundfont/zupfnoter")  // Scct1t2
           self.abcplay.set_sft('js')
           self.abcplay.set_vol(1.0)
        ;
          self.status = "stopped";
          self.selection = [];
          self.voices_to_play = [1, 2, 3, 4, 5, 6, 7, 8];
          self.voice_elements = [];
          self.player_model_abc = [];
          self.controller = nil;
          return (self.speed = 1);
        }, TMP_HarpnotePlayer_initialize_1.$$arity = 0);
        
        Opal.defn(self, '$is_playing?', TMP_HarpnotePlayer_is_playing$q_2 = function() {
          var self = this;

          return self.status['$==']("playing")
        }, TMP_HarpnotePlayer_is_playing$q_2.$$arity = 0);
        
        Opal.defn(self, '$is_stopped?', TMP_HarpnotePlayer_is_stopped$q_3 = function() {
          var self = this;

          return self.status['$==']("stopped")
        }, TMP_HarpnotePlayer_is_stopped$q_3.$$arity = 0);
        
        Opal.defn(self, '$call_on_note', TMP_HarpnotePlayer_call_on_note_4 = function $$call_on_note(index, on, custom) {
          var self = this;

          if (custom == null) {
            custom = nil;
          }
          if ($truthy(on)) {
            return self.noteon_callback.$call($hash2(["startChar", "endChar"], {"startChar": index, "endChar": index}))
            } else {
            return self.noteoff_callback.$call($hash2(["startChar", "endChar"], {"startChar": index, "endChar": index}))
          }
        }, TMP_HarpnotePlayer_call_on_note_4.$$arity = -3);
        
        Opal.defn(self, '$call_on_songoff', TMP_HarpnotePlayer_call_on_songoff_5 = function $$call_on_songoff() {
          var self = this;

          
          
           setTimeout(function(){self.songoff_callback.$call()}, 10)
          ;
          return nil;
        }, TMP_HarpnotePlayer_call_on_songoff_5.$$arity = 0);
        
        Opal.defn(self, '$on_noteon', TMP_HarpnotePlayer_on_noteon_6 = function $$on_noteon() {
          var self = this, $iter = TMP_HarpnotePlayer_on_noteon_6.$$p, block = $iter || nil;

          if ($iter) TMP_HarpnotePlayer_on_noteon_6.$$p = null;
          return (self.noteon_callback = block)
        }, TMP_HarpnotePlayer_on_noteon_6.$$arity = 0);
        
        Opal.defn(self, '$on_noteoff', TMP_HarpnotePlayer_on_noteoff_7 = function $$on_noteoff() {
          var self = this, $iter = TMP_HarpnotePlayer_on_noteoff_7.$$p, block = $iter || nil;

          if ($iter) TMP_HarpnotePlayer_on_noteoff_7.$$p = null;
          return (self.noteoff_callback = block)
        }, TMP_HarpnotePlayer_on_noteoff_7.$$arity = 0);
        
        Opal.defn(self, '$on_songoff', TMP_HarpnotePlayer_on_songoff_8 = function $$on_songoff() {
          var TMP_9, self = this, $iter = TMP_HarpnotePlayer_on_songoff_8.$$p, block = $iter || nil;

          if ($iter) TMP_HarpnotePlayer_on_songoff_8.$$p = null;
          return (self.songoff_callback = $send(self, 'lambda', [], (TMP_9 = function(){var self = TMP_9.$$s || this;

          
            block.$call();
            return (self.status = "stopped");}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9)))
        }, TMP_HarpnotePlayer_on_songoff_8.$$arity = 0);
        
        Opal.defn(self, '$play_auto', TMP_HarpnotePlayer_play_auto_11 = function $$play_auto() {
          var $a, TMP_10, self = this, counts = nil;

          if ($truthy(($truthy($a = $rb_ge(self.selection.$count(), 0)) ? $rb_gt((counts = $send(self.selection, 'map', [], (TMP_10 = function(i){var self = TMP_10.$$s || this;
if (i == null) i = nil;
          return i['$[]']("delay")}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10)).$uniq().$count()), 1) : $a))) {
            return self.$play_selection()
            } else {
            return self.$play_from_selection()
          }
        }, TMP_HarpnotePlayer_play_auto_11.$$arity = 0);
        
        Opal.defn(self, '$play_from_selection', TMP_HarpnotePlayer_play_from_selection_14 = function $$play_from_selection() {
          var TMP_12, TMP_13, self = this, notes_to_play = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          $gvars.log.$debug("" + (self.selection.$to_s()) + " (" + ("harpnote_player") + " " + (81) + ")");
          if ($truthy(self.selection.$first())) {
            
            notes_to_play = $send(self.voice_elements, 'select', [], (TMP_12 = function(n){var self = TMP_12.$$s || this;
              if (self.selection == null) self.selection = nil;
if (n == null) n = nil;
            return $rb_ge(n['$[]']("delay"), self.selection.$first()['$[]']("delay"))}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));
            notes_to_play = $send(notes_to_play, 'select', [], (TMP_13 = function(v){var self = TMP_13.$$s || this;
              if (self.active_voices == null) self.active_voices = nil;
if (v == null) v = nil;
            return self.active_voices['$include?'](v['$[]']("index"))}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13));
            return self.$play_notes(notes_to_play);
            } else {
            return self.$play_from_abc()
          };
        }, TMP_HarpnotePlayer_play_from_selection_14.$$arity = 0);
        
        Opal.defn(self, '$play_selection', TMP_HarpnotePlayer_play_selection_15 = function $$play_selection() {
          var self = this;

          return self.$play_notes(self.selection)
        }, TMP_HarpnotePlayer_play_selection_15.$$arity = 0);
        
        Opal.defn(self, '$play_song', TMP_HarpnotePlayer_play_song_16 = function $$play_song() {
          var self = this;

          return self.$play_from_abc()
        }, TMP_HarpnotePlayer_play_song_16.$$arity = 0);
        
        Opal.defn(self, '$play_from_abc', TMP_HarpnotePlayer_play_from_abc_17 = function $$play_from_abc() {
          var self = this;

          
          
        self.abcplay.play(0, 1000000, self.player_model_abc)
          ;
          return (self.status = "playing");
        }, TMP_HarpnotePlayer_play_from_abc_17.$$arity = 0);
        
        Opal.defn(self, '$play_notes', TMP_HarpnotePlayer_play_notes_20 = function $$play_notes(the_notes) {
          var TMP_18, TMP_19, self = this, firstnote = nil, lastnote = nil, stop_time = nil, start_offset = nil, pe = nil;
          if ($gvars.log == null) $gvars.log = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

          
          self.$stop();
          if ($truthy(the_notes['$empty?']())) {
            return $gvars.log.$warning("nothing selected to play")
            } else {
            
            if ($truthy(self.song_off_timer)) {
              clearTimeout(self.song_off_timer)};
            the_notes = $send(the_notes, 'sort_by', [], (TMP_18 = function(the_note){var self = TMP_18.$$s || this;
if (the_note == null) the_note = nil;
            return the_note['$[]']("delay")}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18));
            firstnote = the_notes.$first();
            lastnote = the_notes.$last();
            stop_time = $rb_times($rb_plus($rb_plus($rb_minus(lastnote['$[]']("delay"), firstnote['$[]']("delay")), lastnote['$[]']("duration")), $rb_times($gvars.conf.$get("layout.SHORTEST_NOTE"), self.duration_timefactor)), 1000);
            self.song_off_timer = setTimeout(function(){self.songoff_callback.$call()}, stop_time );
            start_offset = firstnote['$[]']("delay");
            pe = $send(the_notes, 'map', [], (TMP_19 = function(i){var self = TMP_19.$$s || this;
if (i == null) i = nil;
            return self.$mk_to_play_for_abc2svgplay(i, start_offset)}, TMP_19.$$s = self, TMP_19.$$arity = 1, TMP_19));
            
          self.abcplay.play(0, 1000000, pe)
          ;
            return (self.status = "playing");
          };
        }, TMP_HarpnotePlayer_play_notes_20.$$arity = 1);
        
        Opal.defn(self, '$set_speed', TMP_HarpnotePlayer_set_speed_21 = function $$set_speed(speed) {
          var self = this;

          
          self.speed = speed.$clamp(0.25, 4);
          self.abcplay.set_speed(self.speed);
          return nil;
        }, TMP_HarpnotePlayer_set_speed_21.$$arity = 1);
        
        Opal.defn(self, '$stop', TMP_HarpnotePlayer_stop_22 = function $$stop() {
          var self = this;

          
          if ($truthy(self['$is_playing?']())) {
            self.abcplay.stop()};
          self.status['$==']("stopping");
          return nil;
        }, TMP_HarpnotePlayer_stop_22.$$arity = 0);
        
        Opal.defn(self, '$unhighlight_all', TMP_HarpnotePlayer_unhighlight_all_23 = function $$unhighlight_all() {
          var self = this;

          return (self.selection = [])
        }, TMP_HarpnotePlayer_unhighlight_all_23.$$arity = 0);
        
        Opal.defn(self, '$range_highlight', TMP_HarpnotePlayer_range_highlight_26 = function $$range_highlight(from, to) {
          var TMP_24, TMP_25, self = this;

          
          self.selection = [];
          $send($send(self.voice_elements, 'sort', [], (TMP_24 = function(a, b){var self = TMP_24.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
          return a['$[]']("delay")['$<=>'](b['$[]']("delay"))}, TMP_24.$$s = self, TMP_24.$$arity = 2, TMP_24)), 'each', [], (TMP_25 = function(element){var self = TMP_25.$$s || this, $a, $b, origin = nil, el_start = nil, el_end = nil;
            if (self.selection == null) self.selection = nil;
            if ($gvars.log == null) $gvars.log = nil;
if (element == null) element = nil;
          
            origin = self.$Native(element['$[]']("origin"));
            if ($truthy(origin['$nil?']())) {
              return $gvars.log.$error("" + "BUG: note without origin " + (element.$class()))
              } else {
              
              el_start = origin['$[]']("startChar");
              el_end = origin['$[]']("endChar");
              if ($truthy(($truthy($a = ($truthy($b = $rb_gt(to, el_start)) ? $rb_lt(from, el_end) : $b)) ? $a : ($truthy($b = to['$==='](from)) ? to['$==='](el_end) : $b)))) {
                return self.selection.$push(element)
                } else {
                return nil
              };
            };}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25));
          return nil;
        }, TMP_HarpnotePlayer_range_highlight_26.$$arity = 2);
        
        Opal.defn(self, '$pitch_to_note', TMP_HarpnotePlayer_pitch_to_note_27 = function $$pitch_to_note(pitch) {
          var self = this;

          return ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]['$[]'](pitch['$%'](12))
        }, TMP_HarpnotePlayer_pitch_to_note_27.$$arity = 1);
        
        Opal.defn(self, '$get_notes', TMP_HarpnotePlayer_get_notes_32 = function $$get_notes() {
          var TMP_28, TMP_30, TMP_31, self = this, pitches = nil;

          
          pitches = $send(self.selection, 'map', [], (TMP_28 = function(i){var self = TMP_28.$$s || this, TMP_29;
            if (self.voice_elements_by_time == null) self.voice_elements_by_time = nil;
if (i == null) i = nil;
          return $send(self.voice_elements_by_time['$[]'](i['$[]']("delay")), 'map', [], (TMP_29 = function(i){var self = TMP_29.$$s || this;
if (i == null) i = nil;
            return i['$[]']("pitch")}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29))}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28)).$flatten().$uniq().$compact();
          return $send($send(pitches, 'map', [], (TMP_30 = function(i){var self = TMP_30.$$s || this;
if (i == null) i = nil;
          return i['$%'](12)}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30)).$uniq().$sort(), 'map', [], (TMP_31 = function(i){var self = TMP_31.$$s || this;
if (i == null) i = nil;
          return self.$pitch_to_note(i)}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));
        }, TMP_HarpnotePlayer_get_notes_32.$$arity = 0);
        
        Opal.defn(self, '$load_song', TMP_HarpnotePlayer_load_song_34 = function $$load_song(music, active_voices) {
          var TMP_33, self = this, specduration = nil, specbpm = nil, spectf = nil, tf = nil;
          if ($gvars.conf == null) $gvars.conf = nil;
          if ($gvars.log == null) $gvars.log = nil;

          
          self.active_voices = active_voices;
          specduration = music.$meta_data()['$[]']("tempo")['$[]']("duration").$reduce("+");
          specbpm = music.$meta_data()['$[]']("tempo")['$[]']("bpm");
          spectf = $rb_times(specduration, specbpm);
          tf = $rb_times(spectf, $rb_divide(128, 120));
          self.duration_timefactor = $rb_divide(1, tf);
          self.beat_timefactor = $rb_divide(1, $rb_times(tf, $gvars.conf.$get("layout.BEAT_PER_DURATION")));
          $gvars.log.$debug("" + "playing with tempo: " + (tf) + " ticks per quarter " + ("harpnote_player") + " " + (205));
          self.$_load_voice_elements_from_voices(music);
          self.voice_elements_by_time = $send(self.voice_elements, 'group_by', [], (TMP_33 = function(element){var self = TMP_33.$$s || this;
if (element == null) element = nil;
          return element['$[]']("delay")}, TMP_33.$$s = self, TMP_33.$$arity = 1, TMP_33));
          return self;
        }, TMP_HarpnotePlayer_load_song_34.$$arity = 2);
        
        Opal.defn(self, '$get_worker_model', TMP_HarpnotePlayer_get_worker_model_35 = function $$get_worker_model() {
          var self = this;

          return $hash2(["voice_elements", "active_voices", "duration_timefactor", "beat_timefactor"], {"voice_elements": self.voice_elements, "active_voices": self.active_voices, "duration_timefactor": self.duration_timefactor, "beat_timefactor": self.beat_timefactor})
        }, TMP_HarpnotePlayer_get_worker_model_35.$$arity = 0);
        
        Opal.defn(self, '$set_worker_model', TMP_HarpnotePlayer_set_worker_model_37 = function $$set_worker_model(worker_model) {
          var TMP_36, self = this;

          
          self.duration_timefactor = worker_model['$[]']("duration_timefactor");
          self.beat_timefactor = worker_model['$[]']("beat_timefactor");
          self.voice_elements = worker_model['$[]']("voice_elements");
          self.active_voices = worker_model['$[]']("active_voices");
          self.voice_elements_by_time = $send(self.voice_elements, 'group_by', [], (TMP_36 = function(element){var self = TMP_36.$$s || this;
if (element == null) element = nil;
          return element['$[]']("delay")}, TMP_36.$$s = self, TMP_36.$$arity = 1, TMP_36));
          return nil;
        }, TMP_HarpnotePlayer_set_worker_model_37.$$arity = 1);
        
        Opal.defn(self, '$_load_voice_elements_from_voices', TMP_HarpnotePlayer__load_voice_elements_from_voices_43 = function $$_load_voice_elements_from_voices(music) {
          var TMP_38, self = this;

          return (self.voice_elements = $send(music.$voices().$each_with_index(), 'map', [], (TMP_38 = function(voice, index){var self = TMP_38.$$s || this, TMP_39, TMP_40, tie_start = nil;
if (voice == null) voice = nil;if (index == null) index = nil;
          
            if (index['$=='](0)) {
              return nil;};
            tie_start = $hash2([], {});
            return $send($send(voice, 'select', [], (TMP_39 = function(c){var self = TMP_39.$$s || this;
if (c == null) c = nil;
            return c['$is_a?'](Opal.const_get_relative($nesting, 'Playable'))}, TMP_39.$$s = self, TMP_39.$$arity = 1, TMP_39)), 'map', [], (TMP_40 = function(root){var self = TMP_40.$$s || this, TMP_41, TMP_42, velocity = nil, to_play = nil, more_to_play = nil, $writer = nil, reault = nil, result = nil;
if (root == null) root = nil;
            
              velocity = 0.5;
              if ($truthy(root['$is_a?'](Opal.const_get_relative($nesting, 'Pause')))) {
                velocity = 1.1e-05};
              to_play = self.$mk_to_play(root, velocity, index);
              more_to_play = [];
              if ($truthy(root['$is_a?'](Opal.const_get_relative($nesting, 'SynchPoint')))) {
                more_to_play = $send(root.$notes().$each(), 'map', [], (TMP_41 = function(note){var self = TMP_41.$$s || this;
if (note == null) note = nil;
                if ($truthy(note.$pitch()['$==='](root.$pitch()))) {
                    return nil
                    } else {
                    return self.$mk_to_play(note, velocity, index)
                  }}, TMP_41.$$s = self, TMP_41.$$arity = 1, TMP_41)).$compact()};
              if ($truthy(root['$tie_end?']())) {
                if (tie_start['$[]']("pitch")['$=='](to_play['$[]']("pitch"))) {
                  
                  
                  $writer = ["duration", $rb_plus(to_play['$[]']("duration"), tie_start['$[]']("duration"))];
                  $send(to_play, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = ["startChar", tie_start['$[]']("origin")['$[]']("startChar")];
                  $send(to_play['$[]']("origin"), '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = ["delay", tie_start['$[]']("delay")];
                  $send(to_play, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  $send(more_to_play, 'each', [], (TMP_42 = function(p){var self = TMP_42.$$s || this;
if (p == null) p = nil;
                  
                    
                    $writer = ["duration", $rb_plus(p['$[]']("duration"), tie_start['$[]']("duration"))];
                    $send(p, '[]=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];;
                    
                    $writer = ["delay", tie_start['$[]']("delay")];
                    $send(p, '[]=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];;}, TMP_42.$$s = self, TMP_42.$$arity = 1, TMP_42));}};
              if ($truthy(root['$tie_start?']())) {
                
                tie_start = to_play;
                reault = nil;
                } else {
                result = $rb_plus([to_play], [more_to_play])
              };
              return result;}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40));}, TMP_38.$$s = self, TMP_38.$$arity = 2, TMP_38)).$flatten().$compact())
        }, TMP_HarpnotePlayer__load_voice_elements_from_voices_43.$$arity = 1);
        
        Opal.defn(self, '$mk_to_play_for_abc2svgplay', TMP_HarpnotePlayer_mk_to_play_for_abc2svgplay_44 = function $$mk_to_play_for_abc2svgplay(note, start_delay) {
          var self = this;

          if (start_delay == null) {
            start_delay = 0;
          }
          return [note['$[]']("origin")['$[]']("startChar"), $rb_divide($rb_minus(note['$[]']("delay"), start_delay), self.speed), 25, note['$[]']("pitch"), $rb_divide(note['$[]']("duration"), self.speed), (function() {if ($truthy($rb_gt(note['$[]']("velocity"), 0.2))) {
            return 1
            } else {
            return 0
          }; return nil; })()]
        }, TMP_HarpnotePlayer_mk_to_play_for_abc2svgplay_44.$$arity = -2);
        return (Opal.defn(self, '$mk_to_play', TMP_HarpnotePlayer_mk_to_play_45 = function $$mk_to_play(note, velocity, index) {
          var self = this;

          return $hash2(["delay", "pitch", "duration", "velocity", "origin", "index"], {"delay": $rb_times(note.$beat(), self.beat_timefactor), "pitch": note.$pitch(), "duration": $rb_times($rb_times(1, note.$duration()), self.duration_timefactor), "velocity": velocity, "origin": note.$origin(), "index": index})
        }, TMP_HarpnotePlayer_mk_to_play_45.$$arity = 3), nil) && 'mk_to_play';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["json"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$raise', '$new', '$push', '$[]=', '$-', '$[]', '$create_id', '$json_create', '$const_get', '$attr_accessor', '$create_id=', '$===', '$parse', '$generate', '$from_object', '$merge', '$to_json', '$responds_to?', '$to_io', '$write', '$to_s', '$to_a', '$strftime']);
  
  (function($base, $parent_nesting) {
    var $JSON, self = $JSON = $module($base, 'JSON');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JSON_$$_1, TMP_JSON_parse_2, TMP_JSON_parse$B_3, TMP_JSON_load_4, TMP_JSON_from_object_5, TMP_JSON_generate_6, TMP_JSON_dump_7, $writer = nil;

    
    (function($base, $super, $parent_nesting) {
      function $JSONError(){};
      var self = $JSONError = $klass($base, $super, 'JSONError', $JSONError);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
    (function($base, $super, $parent_nesting) {
      function $ParserError(){};
      var self = $ParserError = $klass($base, $super, 'ParserError', $ParserError);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], Opal.const_get_relative($nesting, 'JSONError'), $nesting);
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'null':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                (($writer = [k, to_opal(value[k], options)]), $send((hash), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]'](Opal.const_get_relative($nesting, 'JSON').$create_id())) != nil) {
              return Opal.const_get_qualified('::', 'Object').$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    
    $writer = ["json_class"];
    $send(self, 'create_id=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    Opal.defs(self, '$[]', TMP_JSON_$$_1 = function(value, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      if ($truthy(Opal.const_get_relative($nesting, 'String')['$==='](value))) {
        return self.$parse(value, options)
        } else {
        return self.$generate(value, options)
      }
    }, TMP_JSON_$$_1.$$arity = -2);
    Opal.defs(self, '$parse', TMP_JSON_parse_2 = function $$parse(source, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})))
    }, TMP_JSON_parse_2.$$arity = -2);
    Opal.defs(self, '$parse!', TMP_JSON_parse$B_3 = function(source, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      return self.$parse(source, options)
    }, TMP_JSON_parse$B_3.$$arity = -2);
    Opal.defs(self, '$load', TMP_JSON_load_4 = function $$load(source, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      return self.$from_object($parse(source), options)
    }, TMP_JSON_load_4.$$arity = -2);
    Opal.defs(self, '$from_object', TMP_JSON_from_object_5 = function $$from_object(js_object, options) {
      var $a, self = this, $writer = nil;

      if (options == null) {
        options = $hash2([], {});
      }
      
      ($truthy($a = options['$[]']("object_class")) ? $a : (($writer = ["object_class", Opal.const_get_relative($nesting, 'Hash')]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      ($truthy($a = options['$[]']("array_class")) ? $a : (($writer = ["array_class", Opal.const_get_relative($nesting, 'Array')]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      return to_opal(js_object, options.$$smap);
    }, TMP_JSON_from_object_5.$$arity = -2);
    Opal.defs(self, '$generate', TMP_JSON_generate_6 = function $$generate(obj, options) {
      var self = this;

      if (options == null) {
        options = $hash2([], {});
      }
      return obj.$to_json(options)
    }, TMP_JSON_generate_6.$$arity = -2);
    Opal.defs(self, '$dump', TMP_JSON_dump_7 = function $$dump(obj, io, limit) {
      var self = this, string = nil;

      if (io == null) {
        io = nil;
      }
      if (limit == null) {
        limit = nil;
      }
      
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()};
        io.$write(string);
        return io;
        } else {
        return string
      };
    }, TMP_JSON_dump_7.$$arity = -2);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $Object(){};
    var self = $Object = $klass($base, $super, 'Object', $Object);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Object_to_json_8;

    return (Opal.defn(self, '$to_json', TMP_Object_to_json_8 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, TMP_Object_to_json_8.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var $Enumerable, self = $Enumerable = $module($base, 'Enumerable');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerable_to_json_9;

    
    Opal.defn(self, '$to_json', TMP_Enumerable_to_json_9 = function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, TMP_Enumerable_to_json_9.$$arity = 0)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $Array(){};
    var self = $Array = $klass($base, $super, 'Array', $Array);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_to_json_10;

    return (Opal.defn(self, '$to_json', TMP_Array_to_json_10 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(', ') + ']';
    
    }, TMP_Array_to_json_10.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Boolean(){};
    var self = $Boolean = $klass($base, $super, 'Boolean', $Boolean);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Boolean_to_json_11;

    return (Opal.defn(self, '$to_json', TMP_Boolean_to_json_11 = function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false'
    }, TMP_Boolean_to_json_11.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Hash(){};
    var self = $Hash = $klass($base, $super, 'Hash', $Hash);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_to_json_12;

    return (Opal.defn(self, '$to_json', TMP_Hash_to_json_12 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(', ') + '}';
    
    }, TMP_Hash_to_json_12.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $NilClass(){};
    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NilClass_to_json_13;

    return (Opal.defn(self, '$to_json', TMP_NilClass_to_json_13 = function $$to_json() {
      var self = this;

      return "null"
    }, TMP_NilClass_to_json_13.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Numeric(){};
    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numeric_to_json_14;

    return (Opal.defn(self, '$to_json', TMP_Numeric_to_json_14 = function $$to_json() {
      var self = this;

      return self.toString()
    }, TMP_Numeric_to_json_14.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return Opal.alias(self, "to_json", "inspect")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Time(){};
    var self = $Time = $klass($base, $super, 'Time', $Time);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Time_to_json_15;

    return (Opal.defn(self, '$to_json', TMP_Time_to_json_15 = function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, TMP_Time_to_json_15.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    function $Date(){};
    var self = $Date = $klass($base, $super, 'Date', $Date);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Date_to_json_16, TMP_Date_as_json_17;

    
    
    Opal.defn(self, '$to_json', TMP_Date_to_json_16 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, TMP_Date_to_json_16.$$arity = 0);
    return (Opal.defn(self, '$as_json', TMP_Date_as_json_17 = function $$as_json() {
      var self = this;

      return self.$to_s()
    }, TMP_Date_as_json_17.$$arity = 0), nil) && 'as_json';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["confstack2"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $hash = Opal.hash, $range = Opal.range;

  Opal.add_stubs(['$to_n', '$duplicable?', '$dup', '$map', '$to_proc', '$each_pair', '$===', '$deep_dup', '$[]=', '$-', '$delete', '$deep_merge!', '$[]', '$is_a?', '$deep_merge', '$key?', '$call', '$inject', '$respond_to?', '$keys', '$join', '$compact', '$push', '$digkeys', '$require', '$attr_accessor', '$+', '$push_from_env', '$first', '$caller', '$last', '$count', '$new', '$get_from_env', '$to_json', '$push_to_env', '$include?', '$nil?', '$parse', '$pop', '$get', '$open', '$puts', '$to_yaml', '$has_key?', '$dig', '$split', '$!', '$raise', '$==', '$_resolve_dependencies', '$each', '$each_with_index', '$_get_one', '$select', '$to_i', '$reverse', '$private', '$index', '$class', '$_resolve_value_dependency', '$_resolve_hash_dependency', '$_resolve_array_dependency']);
  
  (function($base, $super, $parent_nesting) {
    function $Object(){};
    var self = $Object = $klass($base, $super, 'Object', $Object);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Object_duplicable$q_1;

    return (Opal.defn(self, '$duplicable?', TMP_Object_duplicable$q_1 = function() {
      var self = this;

      return true
    }, TMP_Object_duplicable$q_1.$$arity = 0), nil) && 'duplicable?'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $NilClass(){};
    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NilClass_duplicable$q_2;

    return (Opal.defn(self, '$duplicable?', TMP_NilClass_duplicable$q_2 = function() {
      var self = this;

      return false
    }, TMP_NilClass_duplicable$q_2.$$arity = 0), nil) && 'duplicable?'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $FalseClass(){};
    var self = $FalseClass = $klass($base, $super, 'FalseClass', $FalseClass);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_FalseClass_duplicable$q_3;

    return (Opal.defn(self, '$duplicable?', TMP_FalseClass_duplicable$q_3 = function() {
      var self = this;

      return false
    }, TMP_FalseClass_duplicable$q_3.$$arity = 0), nil) && 'duplicable?'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $TrueClass(){};
    var self = $TrueClass = $klass($base, $super, 'TrueClass', $TrueClass);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_TrueClass_duplicable$q_4;

    return (Opal.defn(self, '$duplicable?', TMP_TrueClass_duplicable$q_4 = function() {
      var self = this;

      return false
    }, TMP_TrueClass_duplicable$q_4.$$arity = 0), nil) && 'duplicable?'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Symbol(){};
    var self = $Symbol = $klass($base, $super, 'Symbol', $Symbol);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Symbol_duplicable$q_5;

    return (Opal.defn(self, '$duplicable?', TMP_Symbol_duplicable$q_5 = function() {
      var self = this;

      return false
    }, TMP_Symbol_duplicable$q_5.$$arity = 0), nil) && 'duplicable?'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Numeric(){};
    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numeric_duplicable$q_6;

    return (Opal.defn(self, '$duplicable?', TMP_Numeric_duplicable$q_6 = function() {
      var self = this;

      return false
    }, TMP_Numeric_duplicable$q_6.$$arity = 0), nil) && 'duplicable?'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $BigDecimal(){};
    var self = $BigDecimal = $klass($base, $super, 'BigDecimal', $BigDecimal);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BigDecimal_duplicable$q_7;

    return (Opal.defn(self, '$duplicable?', TMP_BigDecimal_duplicable$q_7 = function() {
      var self = this;

      return true
    }, TMP_BigDecimal_duplicable$q_7.$$arity = 0), nil) && 'duplicable?'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Method(){};
    var self = $Method = $klass($base, $super, 'Method', $Method);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Method_duplicable$q_8;

    return (Opal.defn(self, '$duplicable?', TMP_Method_duplicable$q_8 = function() {
      var self = this;

      return false
    }, TMP_Method_duplicable$q_8.$$arity = 0), nil) && 'duplicable?'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $String(){};
    var self = $String = $klass($base, $super, 'String', $String);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_deep_dup_9;

    return (Opal.defn(self, '$deep_dup', TMP_String_deep_dup_9 = function $$deep_dup() {
      var self = this;

      return self.$to_n()
    }, TMP_String_deep_dup_9.$$arity = 0), nil) && 'deep_dup'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Numerical(){};
    var self = $Numerical = $klass($base, $super, 'Numerical', $Numerical);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numerical_deep_dup_10;

    return (Opal.defn(self, '$deep_dup', TMP_Numerical_deep_dup_10 = function $$deep_dup() {
      var self = this;

      return self.$to_n()
    }, TMP_Numerical_deep_dup_10.$$arity = 0), nil) && 'deep_dup'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Object(){};
    var self = $Object = $klass($base, $super, 'Object', $Object);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Object_deep_dup_11;

    return (Opal.defn(self, '$deep_dup', TMP_Object_deep_dup_11 = function $$deep_dup() {
      var self = this;

      if ($truthy(self['$duplicable?']())) {
        return self.$dup()
        } else {
        return self
      }
    }, TMP_Object_deep_dup_11.$$arity = 0), nil) && 'deep_dup'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Array(){};
    var self = $Array = $klass($base, $super, 'Array', $Array);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_deep_dup_12;

    return (Opal.defn(self, '$deep_dup', TMP_Array_deep_dup_12 = function $$deep_dup() {
      var self = this;

      return $send(self, 'map', [], "deep_dup".$to_proc())
    }, TMP_Array_deep_dup_12.$$arity = 0), nil) && 'deep_dup'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Hash(){};
    var self = $Hash = $klass($base, $super, 'Hash', $Hash);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_deep_dup_14, TMP_Hash_deep_merge_15, TMP_Hash_deep_merge$B_16;

    
    
    Opal.defn(self, '$deep_dup', TMP_Hash_deep_dup_14 = function $$deep_dup() {
      var TMP_13, self = this, hash = nil;

      
      hash = self.$dup();
      $send(self, 'each_pair', [], (TMP_13 = function(key, value){var self = TMP_13.$$s || this, $a, $writer = nil;
if (key == null) key = nil;if (value == null) value = nil;
      if ($truthy(($truthy($a = false) ? Opal.const_get_qualified('::', 'String')['$==='](key) : $a))) {
          
          $writer = [key, value.$deep_dup()];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
          } else {
          
          hash.$delete(key);
          
          $writer = [key.$deep_dup(), value.$deep_dup()];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }}, TMP_13.$$s = self, TMP_13.$$arity = 2, TMP_13));
      return hash;
    }, TMP_Hash_deep_dup_14.$$arity = 0);
    
    Opal.defn(self, '$deep_merge', TMP_Hash_deep_merge_15 = function $$deep_merge(other_hash) {
      var self = this, $iter = TMP_Hash_deep_merge_15.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_deep_merge_15.$$p = null;
      return $send(self.$dup(), 'deep_merge!', [other_hash], block.$to_proc())
    }, TMP_Hash_deep_merge_15.$$arity = 1);
    return (Opal.defn(self, '$deep_merge!', TMP_Hash_deep_merge$B_16 = function(other_hash) {
      var TMP_17, self = this, $iter = TMP_Hash_deep_merge$B_16.$$p, block = $iter || nil;

      if ($iter) TMP_Hash_deep_merge$B_16.$$p = null;
      
      $send(other_hash, 'each_pair', [], (TMP_17 = function(current_key, other_value){var self = TMP_17.$$s || this, $a, this_value = nil, $writer = nil;
if (current_key == null) current_key = nil;if (other_value == null) other_value = nil;
      
        this_value = self['$[]'](current_key);
        
        $writer = [current_key, (function() {if ($truthy(($truthy($a = this_value['$is_a?'](Opal.const_get_relative($nesting, 'Hash'))) ? other_value['$is_a?'](Opal.const_get_relative($nesting, 'Hash')) : $a))) {
          return $send(this_value, 'deep_merge', [other_value], block.$to_proc())
        } else if ($truthy((($a = (block !== nil)) ? self['$key?'](current_key) : (block !== nil)))) {
          return block.$call(current_key, this_value, other_value)
          } else {
          return other_value
        }; return nil; })()];
        $send(self, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;}, TMP_17.$$s = self, TMP_17.$$arity = 2, TMP_17));
      return self;
    }, TMP_Hash_deep_merge$B_16.$$arity = 1), nil) && 'deep_merge!';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    function $Hash(){};
    var self = $Hash = $klass($base, $super, 'Hash', $Hash);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_dig_19, TMP_Hash_digkeys_21;

    
    
    Opal.defn(self, '$dig', TMP_Hash_dig_19 = function $$dig($a_rest) {
      var TMP_18, self = this, path;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      path = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        path[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send(path, 'inject', [self], (TMP_18 = function(location, key){var self = TMP_18.$$s || this;
if (location == null) location = nil;if (key == null) key = nil;
      if ($truthy(location['$respond_to?']("keys"))) {
          return location['$[]'](key)
          } else {
          return nil
        }}, TMP_18.$$s = self, TMP_18.$$arity = 2, TMP_18))
    }, TMP_Hash_dig_19.$$arity = -1);
    return (Opal.defn(self, '$digkeys', TMP_Hash_digkeys_21 = function $$digkeys(r, parent_key) {
      var TMP_20, self = this;

      if (r == null) {
        r = [];
      }
      if (parent_key == null) {
        parent_key = nil;
      }
      return $send(self.$keys(), 'inject', [r], (TMP_20 = function(r, key){var self = TMP_20.$$s || this, newkey = nil;
if (r == null) r = nil;if (key == null) key = nil;
      
        newkey = [parent_key, key].$compact().$join(".");
        r.$push(newkey);
        if ($truthy(self['$[]'](key)['$respond_to?']("keys"))) {
          self['$[]'](key).$digkeys(r, newkey)};
        return r;}, TMP_20.$$s = self, TMP_20.$$arity = 2, TMP_20))
    }, TMP_Hash_digkeys_21.$$arity = -1), nil) && 'digkeys';
  })($nesting[0], null, $nesting);
  self.$require("json");
  return (function($base, $super, $parent_nesting) {
    function $Confstack(){};
    var self = $Confstack = $klass($base, $super, 'Confstack', $Confstack);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Confstack_initialize_22, TMP_Confstack_push_23, TMP_Confstack_push_to_env_24, TMP_Confstack_push_from_env_25, TMP_Confstack_get_from_env_26, TMP_Confstack_pop_27, TMP_Confstack_reset_to_28, TMP_Confstack_save_31, TMP_Confstack_get_32, TMP_Confstack_each_33, TMP_Confstack_keys_35, TMP_Confstack_get_source_39, TMP_Confstack_$$$eq_41, TMP_Confstack_delete_42, TMP_Confstack__resolve_value_dependency_44, TMP_Confstack__resolve_array_dependency_46, TMP_Confstack__resolve_hash_dependency_48, TMP_Confstack__resolve_dependencies_49;

    def.confstack_name = def.sourcestack = def.confstack = def.lookup_cache = def.strict = def.confresult_cache = def.callstack = nil;
    
    (function($base, $super, $parent_nesting) {
      function $DeleteMe(){};
      var self = $DeleteMe = $klass($base, $super, 'DeleteMe', $DeleteMe);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], null, $nesting);
    self.$attr_accessor("strict");
    
    Opal.defn(self, '$initialize', TMP_Confstack_initialize_22 = function $$initialize(name) {
      var self = this;

      if (name == null) {
        name = "default";
      }
      
      self.callstack = [];
      self.confstack = [$hash2([], {})];
      self.lookup_cache = $hash2([], {});
      self.confresult_cache = $hash2([], {});
      self.sourcestack = [];
      self.strict = true;
      if ($truthy(name)) {
        
        self.confstack_name = $rb_plus("confstack__", name);
        self.$push($hash2(["confstack"], {"confstack": $hash2(["env"], {"env": self.confstack_name})}));
        self.$push_from_env();};
      return self;
    }, TMP_Confstack_initialize_22.$$arity = -1);
    
    Opal.defn(self, '$push', TMP_Confstack_push_23 = function $$push(hash) {
      var self = this, newconf = nil;

      if (hash == null) {
        hash = $hash2([], {});
      }
      
      self.confresult_cache = $hash2([], {});
      self.lookup_cache = $hash2([], {});
      if ($truthy(hash['$is_a?'](Opal.const_get_relative($nesting, 'Hash')))) {
        
        self.sourcestack.$push(self.$caller().$first());
        newconf = self.confstack.$last().$deep_dup().$deep_merge(hash);
        self.confstack.$push(newconf);
        } else {
        self
      };
      return self.confstack.$count();
    }, TMP_Confstack_push_23.$$arity = -1);
    
    Opal.defn(self, '$push_to_env', TMP_Confstack_push_to_env_24 = function $$push_to_env(hash) {
      var self = this, localstack = nil, newpush = nil, hash_json = nil, $writer = nil;

      if (hash == null) {
        hash = $hash2([], {});
      }
      
      localstack = Opal.const_get_relative($nesting, 'Confstack').$new(false);
      localstack.$push(self.$get_from_env());
      localstack.$push(hash);
      newpush = localstack['$[]']();
      hash_json = newpush.$to_json();
      
      $writer = [self['$[]']("confstack.env"), hash_json];
      $send(Opal.const_get_relative($nesting, 'ENV'), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return self.$push(hash);
    }, TMP_Confstack_push_to_env_24.$$arity = -1);
    
    Opal.defn(self, '$push_from_env', TMP_Confstack_push_from_env_25 = function $$push_from_env() {
      var self = this;

      return self.$push_to_env(self.$get_from_env())
    }, TMP_Confstack_push_from_env_25.$$arity = 0);
    
    Opal.defn(self, '$get_from_env', TMP_Confstack_get_from_env_26 = function $$get_from_env() {
      var self = this, result = nil, fromenv = nil;

      
      result = $hash2([], {});
      if ($truthy(self.$keys()['$include?']("confstack.env"))) {
        
        fromenv = Opal.const_get_relative($nesting, 'ENV')['$[]'](self['$[]']("confstack.env"));
        if ($truthy(fromenv['$nil?']())) {
          } else {
          result = Opal.const_get_relative($nesting, 'JSON').$parse(fromenv)
        };};
      return result;
    }, TMP_Confstack_get_from_env_26.$$arity = 0);
    
    Opal.defn(self, '$pop', TMP_Confstack_pop_27 = function $$pop() {
      var self = this;

      
      self.lookup_cache = $hash2([], {});
      self.sourcestack.$pop();
      self.confstack.$pop();
      return self.confstack.$count();
    }, TMP_Confstack_pop_27.$$arity = 0);
    
    Opal.defn(self, '$reset_to', TMP_Confstack_reset_to_28 = function $$reset_to(level) {
      var self = this;

      
      self.lookup_cache = $hash2([], {});
      self.sourcestack = self.sourcestack['$[]'](Opal.Range.$new(0, level, false));
      self.confstack = self.confstack['$[]'](Opal.Range.$new(0, level, false));
      return self.confstack.$count();
    }, TMP_Confstack_reset_to_28.$$arity = 1);
    
    Opal.defn(self, '$save', TMP_Confstack_save_31 = function $$save(name) {
      var TMP_29, TMP_30, self = this, result = nil;

      
      result = self.$get();
      $send(Opal.const_get_relative($nesting, 'File'), 'open', ["" + (name) + ".yaml", "w"], (TMP_29 = function(f){var self = TMP_29.$$s || this;
if (f == null) f = nil;
      return f.$puts(result.$to_yaml())}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29));
      return $send(Opal.const_get_relative($nesting, 'File'), 'open', ["" + (name) + ".json", "w"], (TMP_30 = function(f){var self = TMP_30.$$s || this;
if (f == null) f = nil;
      return f.$puts(result.$to_json())}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30));
    }, TMP_Confstack_save_31.$$arity = 1);
    
    Opal.defn(self, '$get', TMP_Confstack_get_32 = function $$get(key, options) {
      var $a, $b, self = this, result = nil, $writer = nil;

      if (key == null) {
        key = nil;
      }
      if (options == null) {
        options = $hash2(["resolve"], {"resolve": true});
      }
      
      if ($truthy(key['$nil?']())) {
        result = self.confstack.$last()
      } else if ($truthy(self.lookup_cache['$has_key?'](key))) {
        result = self.lookup_cache['$[]'](key)
        } else {
        
        result = $send(self.confstack.$last(), 'dig', Opal.to_a(key.$split(".")));
        
        $writer = [key, result];
        $send(self.lookup_cache, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        if ($truthy(result)) {
        } else if ($truthy(($truthy($a = ($truthy($b = result['$nil?']()) ? self.$keys()['$include?'](key)['$!']() : $b)) ? self.strict : $a))) {
          self.$raise("" + "confstack: key not available: " + (key))};
      };
      if (options['$[]']("resolve")['$=='](true)) {
        result = self.$_resolve_dependencies(key, result)};
      return result;
    }, TMP_Confstack_get_32.$$arity = -1);
    Opal.alias(self, "[]", "get");
    
    Opal.defn(self, '$each', TMP_Confstack_each_33 = function $$each() {
      var TMP_34, self = this, $iter = TMP_Confstack_each_33.$$p, block = $iter || nil;

      if ($iter) TMP_Confstack_each_33.$$p = null;
      return $send(self.$keys(), 'each', [], (TMP_34 = function(k){var self = TMP_34.$$s || this;
if (k == null) k = nil;
      return block.$call(k, self['$[]'](k))}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34))
    }, TMP_Confstack_each_33.$$arity = 0);
    
    Opal.defn(self, '$keys', TMP_Confstack_keys_35 = function $$keys() {
      var self = this;

      return self.confstack.$last().$digkeys()
    }, TMP_Confstack_keys_35.$$arity = 0);
    
    Opal.defn(self, '$get_source', TMP_Confstack_get_source_39 = function $$get_source(key) {
      var TMP_36, TMP_37, TMP_38, self = this, stack = nil, result = nil;

      
      stack = $send(self.confstack.$each_with_index(), 'map', [], (TMP_36 = function(s, index){var self = TMP_36.$$s || this;
if (s == null) s = nil;if (index == null) index = nil;
      return [self.$_get_one(s, key), index]}, TMP_36.$$s = self, TMP_36.$$arity = 2, TMP_36));
      result = $send(stack, 'select', [], (TMP_37 = function(value){var self = TMP_37.$$s || this;
if (value == null) value = nil;
      return value.$first()['$nil?']()['$!']()}, TMP_37.$$s = self, TMP_37.$$arity = 1, TMP_37)).$last();
      $send(self.confstack, 'map', [], (TMP_38 = function(s, index){var self = TMP_38.$$s || this;
if (s == null) s = nil;if (index == null) index = nil;
      return self.$_get_one(s, key)}, TMP_38.$$s = self, TMP_38.$$arity = 2, TMP_38)).$compact().$last();
      return self.sourcestack['$[]'](result.$last().$to_i());
    }, TMP_Confstack_get_source_39.$$arity = 1);
    
    Opal.defn(self, '$[]=', TMP_Confstack_$$$eq_41 = function(key, value) {
      var TMP_40, self = this, array = nil, h = nil;

      if ($truthy(value['$=='](Opal.const_get_relative($nesting, 'DeleteMe')))) {
        return self.$delete(key)
        } else {
        
        array = key.$split(".").$reverse();
        h = $send(array, 'inject', [value], (TMP_40 = function(a, n){var self = TMP_40.$$s || this;
if (a == null) a = nil;if (n == null) n = nil;
        return $hash(n, a)}, TMP_40.$$s = self, TMP_40.$$arity = 2, TMP_40));
        return self.$push(h);
      }
    }, TMP_Confstack_$$$eq_41.$$arity = 2);
    
    Opal.defn(self, '$delete', TMP_Confstack_delete_42 = function(key) {
      var self = this, keys = nil;

      
      keys = key.$split(".");
      return $send(self.confstack.$last(), 'dig', Opal.to_a(keys['$[]']($range(0, -2, false)))).$delete(keys.$last());
    }, TMP_Confstack_delete_42.$$arity = 1);
    self.$private();
    
    Opal.defn(self, '$_resolve_value_dependency', TMP_Confstack__resolve_value_dependency_44 = function $$_resolve_value_dependency(key, value) {
      var TMP_43, self = this, result = nil, loop = nil, $writer = nil;

      
      if ($truthy(self.confresult_cache['$has_key?'](value))) {
        result = self.confresult_cache['$[]'](value)
        } else {
        
        if ($truthy(self.callstack['$include?'](key))) {
          
          loop = self.callstack['$[]'](Opal.Range.$new($send(self.callstack, 'index', [], (TMP_43 = function(x){var self = TMP_43.$$s || this;
if (x == null) x = nil;
          return x['$=='](key)}, TMP_43.$$s = self, TMP_43.$$arity = 1, TMP_43)), -1, false));
          self.callstack = [];
          self.$raise("" + "circular conf dependency: " + ($rb_plus(loop, ["" + (key) + " ..."])));};
        self.callstack.$push(key);
        result = value.$call();
        self.callstack.$pop();
        
        $writer = [key, result];
        $send(self.confresult_cache, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
      };
      return result;
    }, TMP_Confstack__resolve_value_dependency_44.$$arity = 2);
    
    Opal.defn(self, '$_resolve_array_dependency', TMP_Confstack__resolve_array_dependency_46 = function $$_resolve_array_dependency(key, array) {
      var TMP_45, self = this;

      return $send(array, 'map', [], (TMP_45 = function(f){var self = TMP_45.$$s || this;
if (f == null) f = nil;
      return self.$_resolve_dependencies(nil, f)}, TMP_45.$$s = self, TMP_45.$$arity = 1, TMP_45))
    }, TMP_Confstack__resolve_array_dependency_46.$$arity = 2);
    
    Opal.defn(self, '$_resolve_hash_dependency', TMP_Confstack__resolve_hash_dependency_48 = function $$_resolve_hash_dependency(key, hash) {
      var TMP_47, self = this, result = nil;

      
      result = $send(hash, 'inject', [$hash2([], {})], (TMP_47 = function(r, v){var self = TMP_47.$$s || this, $writer = nil;
if (r == null) r = nil;if (v == null) v = nil;
      
        
        $writer = [v.$first(), self.$_resolve_dependencies([key, v.$first()], v.$last())];
        $send(r, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return r;}, TMP_47.$$s = self, TMP_47.$$arity = 2, TMP_47));
      return result;
    }, TMP_Confstack__resolve_hash_dependency_48.$$arity = 2);
    return (Opal.defn(self, '$_resolve_dependencies', TMP_Confstack__resolve_dependencies_49 = function $$_resolve_dependencies(key, result) {
      var self = this;

      
      if (result.$class()['$=='](Opal.const_get_relative($nesting, 'Proc'))) {
        result = self.$_resolve_value_dependency(key, result)};
      if (result.$class()['$=='](Opal.const_get_relative($nesting, 'Hash'))) {
        result = self.$_resolve_hash_dependency(key, result)};
      if (result.$class()['$=='](Opal.const_get_relative($nesting, 'Array'))) {
        result = self.$_resolve_array_dependency(key, result)};
      return result;
    }, TMP_Confstack__resolve_dependencies_49.$$arity = 2), nil) && '_resolve_dependencies';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.4 */
Opal.modules["opal-abc2svg"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$attr_accessor', '$lambda', '$phrases', '$set_callback', '$error', '$+', '$[]', '$===', '$_anno_start', '$_anno_stop', '$push', '$_callback_get_abcmodel', '$to_n', '$unhighlight_all', '$range_highlight_more', '$each', '$get_elements_by_range', '$find', '$==', '$scroll_into_view', '$add_class', '$remove_class', '$id', '$gsub', '$t', '$strip_js', '$get_svg', '$compute_tune_preview', '$set_svg', '$html', '$join', '$[]=', '$-', '$sort', '$map', '$>', '$*', '$first', '$last', '$private', '$parse', '$loglevel', '$debug', '$to_json', '$split', '$inject', '$length', '$_mk_id', '$stopPropagation', '$Native', '$call']);
  return (function($base, $parent_nesting) {
    var $ABC2SVG, self = $ABC2SVG = $module($base, 'ABC2SVG');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Abc2Svg(){};
      var self = $Abc2Svg = $klass($base, $super, 'Abc2Svg', $Abc2Svg);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Abc2Svg_initialize_8, TMP_Abc2Svg_range_highlight_9, TMP_Abc2Svg_scroll_into_view_10, TMP_Abc2Svg_range_highlight_more_12, TMP_Abc2Svg_range_unhighlight_more_14, TMP_Abc2Svg_unhighlight_all_15, TMP_Abc2Svg_on_select_16, TMP_Abc2Svg_strip_js_17, TMP_Abc2Svg_compute_tune_preview_18, TMP_Abc2Svg_draw_19, TMP_Abc2Svg_set_svg_20, TMP_Abc2Svg_get_abcmodel_21, TMP_Abc2Svg_get_svg_22, TMP_Abc2Svg_get_html_23, TMP_Abc2Svg_set_callback_24, TMP_Abc2Svg_get_elements_by_range_27, TMP_Abc2Svg__callback_get_abcmodel_28, TMP_Abc2Svg__get_charpos_30, TMP_Abc2Svg__anno_start_31, TMP_Abc2Svg__clickabcnote_32, TMP_Abc2Svg__anno_stop_33, TMP_Abc2Svg__mk_id_34;

      def.user = def.root = def.printer = def.abc_source = def.interactive_elements = def.abc_model = def.player_model = def.svgbuf = def.on_select = nil;
      
      self.$attr_accessor("abcplay");
      
      Opal.defn(self, '$initialize', TMP_Abc2Svg_initialize_8 = function $$initialize(div, options) {
        var TMP_1, TMP_2, TMP_3, TMP_4, TMP_5, TMP_6, TMP_7, self = this, $case = nil, defaults = nil;
        if ($gvars.log == null) $gvars.log = nil;

        if (options == null) {
          options = $hash2(["mode"], {"mode": "svg"});
        }
        
        self.on_select = $send(self, 'lambda', [], (TMP_1 = function(element){var self = TMP_1.$$s || this;
if (element == null) element = nil;
        return nil}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));
        self.printer = div;
        self.svgbuf = [];
        self.abc_source = "";
        self.interactive_elements = $hash2([], {});
        self.abc_model = nil;
        self.player_model = [];
        self.object_map = $hash2([], {});
        self.abcplay = nil;
        self.user = $hash2(["img_out", "errmsg", "read_file", "annotate", "page_format", "keep_remark", "textrans"], {"img_out": nil, "errmsg": nil, "read_file": nil, "annotate": true, "page_format": true, "keep_remark": true, "textrans": Opal.const_get_relative($nesting, 'I18n').$phrases()});
        $send(self, 'set_callback', ["errmsg"], (TMP_2 = function(message, line_number, column_number){var self = TMP_2.$$s || this;
          if ($gvars.log == null) $gvars.log = nil;
if (message == null) message = nil;if (line_number == null) line_number = nil;if (column_number == null) column_number = nil;
        if ($truthy(line_number)) {
            return $gvars.log.$error(message, [$rb_plus(line_number, 1), $rb_plus(column_number, 1)])
            } else {
            return $gvars.log.$error(message)
          }}, TMP_2.$$s = self, TMP_2.$$arity = 3, TMP_2));
        $case = options['$[]']("mode");
        if ("svg"['$===']($case)) {
        $send(self, 'set_callback', ["anno_start"], (TMP_3 = function(type, start, stop, x, y, w, h){var self = TMP_3.$$s || this;
if (type == null) type = nil;if (start == null) start = nil;if (stop == null) stop = nil;if (x == null) x = nil;if (y == null) y = nil;if (w == null) w = nil;if (h == null) h = nil;
        return self.$_anno_start(type, start, stop, x, y, w, h)}, TMP_3.$$s = self, TMP_3.$$arity = 7, TMP_3));
        $send(self, 'set_callback', ["anno_stop"], (TMP_4 = function(type, start, stop, x, y, w, h){var self = TMP_4.$$s || this;
if (type == null) type = nil;if (start == null) start = nil;if (stop == null) stop = nil;if (x == null) x = nil;if (y == null) y = nil;if (w == null) w = nil;if (h == null) h = nil;
        return self.$_anno_stop(type, start, stop, x, y, w, h)}, TMP_4.$$s = self, TMP_4.$$arity = 7, TMP_4));
        $send(self, 'set_callback', ["img_out"], (TMP_5 = function(svg){var self = TMP_5.$$s || this;
          if (self.svgbuf == null) self.svgbuf = nil;
if (svg == null) svg = nil;
        return self.svgbuf.$push(svg)}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
        $send(self, 'set_callback', ["get_abcmodel"], (TMP_6 = function(tsfirst, voice_tb, anno_type, info){var self = TMP_6.$$s || this;
if (tsfirst == null) tsfirst = nil;if (voice_tb == null) voice_tb = nil;if (anno_type == null) anno_type = nil;if (info == null) info = nil;
        return nil}, TMP_6.$$s = self, TMP_6.$$arity = 4, TMP_6));}
        else if ("model"['$===']($case)) {$send(self, 'set_callback', ["get_abcmodel"], (TMP_7 = function(tsfirst, voice_tb, anno_type, info){var self = TMP_7.$$s || this;
if (tsfirst == null) tsfirst = nil;if (voice_tb == null) voice_tb = nil;if (anno_type == null) anno_type = nil;if (info == null) info = nil;
        return self.$_callback_get_abcmodel(tsfirst, voice_tb, anno_type, info)}, TMP_7.$$s = self, TMP_7.$$arity = 4, TMP_7))}
        else {$gvars.log.$error("BUG: unsupported mode for abc2svg")};
        self.root = new abc2svg.Abc(self.user.$to_n());
        defaults = "" + "\n" + "I:titletrim 0\n" + "I:measurenb 1\n" + "I:contbarnb 1\n" + "I:linewarn 0\n" + "I:staffnonote 2\n" + "I:stretchlast 1\n" + "      ";
        self.root.tosvg("my_parameters",defaults);;
        return self.root;
      }, TMP_Abc2Svg_initialize_8.$$arity = -2);
      
      Opal.defn(self, '$range_highlight', TMP_Abc2Svg_range_highlight_9 = function $$range_highlight(from, to) {
        var self = this;

        
        self.$unhighlight_all();
        self.$range_highlight_more(from, to);
        return nil;
      }, TMP_Abc2Svg_range_highlight_9.$$arity = 2);
      
      Opal.defn(self, '$scroll_into_view', TMP_Abc2Svg_scroll_into_view_10 = function $$scroll_into_view(element) {
        var self = this;

        return element.parents('.svg_block').get(0).scrollIntoView(true)
      }, TMP_Abc2Svg_scroll_into_view_10.$$arity = 1);
      
      Opal.defn(self, '$range_highlight_more', TMP_Abc2Svg_range_highlight_more_12 = function $$range_highlight_more(from, to) {
        var TMP_11, self = this;

        
        $send(self.$get_elements_by_range(from, to), 'each', [], (TMP_11 = function(id){var self = TMP_11.$$s || this, element = nil;
          if ($gvars.settings == null) $gvars.settings = nil;
if (id == null) id = nil;
        
          element = Opal.const_get_relative($nesting, 'Element').$find("" + "#" + (id));
          if ($gvars.settings['$[]']("autoscroll")['$==']("false")) {
            } else {
            self.$scroll_into_view(element)
          };
          return element.$add_class("highlight");}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11));
        return nil;
      }, TMP_Abc2Svg_range_highlight_more_12.$$arity = 2);
      
      Opal.defn(self, '$range_unhighlight_more', TMP_Abc2Svg_range_unhighlight_more_14 = function $$range_unhighlight_more(from, to) {
        var TMP_13, self = this;

        return $send(self.$get_elements_by_range(from, to), 'each', [], (TMP_13 = function(id){var self = TMP_13.$$s || this, foo = nil;
if (id == null) id = nil;
        
          foo = Opal.const_get_relative($nesting, 'Element').$find("" + "#" + (id));
          return foo.$remove_class("highlight");}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13))
      }, TMP_Abc2Svg_range_unhighlight_more_14.$$arity = 2);
      
      Opal.defn(self, '$unhighlight_all', TMP_Abc2Svg_unhighlight_all_15 = function $$unhighlight_all() {
        var self = this;

        return Opal.const_get_relative($nesting, 'Element').$find("" + "#" + (self.printer.$id()) + " .highlight").$remove_class("highlight")
      }, TMP_Abc2Svg_unhighlight_all_15.$$arity = 0);
      
      Opal.defn(self, '$on_select', TMP_Abc2Svg_on_select_16 = function $$on_select() {
        var self = this, $iter = TMP_Abc2Svg_on_select_16.$$p, block = $iter || nil;

        if ($iter) TMP_Abc2Svg_on_select_16.$$p = null;
        return (self.on_select = block)
      }, TMP_Abc2Svg_on_select_16.$$arity = 0);
      
      Opal.defn(self, '$strip_js', TMP_Abc2Svg_strip_js_17 = function $$strip_js(abc_code) {
        var self = this, r = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        r = abc_code.$gsub(/(I:|%%)(beginjs|endjs)/, "% removed ");
        if (abc_code['$=='](r)) {
          } else {
          $gvars.log.$error(Opal.const_get_relative($nesting, 'I18n').$t("CAUTION: your abc-code is vulnerable !!! removed beginjs / endjs"), [1, 1])
        };
        return r;
      }, TMP_Abc2Svg_strip_js_17.$$arity = 1);
      
      Opal.defn(self, '$compute_tune_preview', TMP_Abc2Svg_compute_tune_preview_18 = function $$compute_tune_preview(abc_code, checksum) {
        var self = this, abc_text_insert = nil;

        if (checksum == null) {
          checksum = "";
        }
        
        abc_text_insert = "" + "\n" + "%%textoption right\n" + "%%textfont * * 8\n" + "%%text " + (checksum) + "\n" + "      ";
        self.abc_source = self.$strip_js(abc_code);
        self.interactive_elements = $hash2([], {});
        self.svgbuf = [];
        
      self.root.tosvg("abc", $rb_plus(self.abc_source, abc_text_insert));
      ;
        return $hash2(["svg", "interactive_elements"], {"svg": self.$get_svg(), "interactive_elements": self.interactive_elements});
      }, TMP_Abc2Svg_compute_tune_preview_18.$$arity = -2);
      
      Opal.defn(self, '$draw', TMP_Abc2Svg_draw_19 = function $$draw(abc_code, checksum) {
        var self = this, svg_and_positions = nil;

        if (checksum == null) {
          checksum = "";
        }
        
        svg_and_positions = self.$compute_tune_preview(abc_code, (checksum = ""));
        return self.$set_svg(svg_and_positions);
      }, TMP_Abc2Svg_draw_19.$$arity = -2);
      
      Opal.defn(self, '$set_svg', TMP_Abc2Svg_set_svg_20 = function $$set_svg(svg_and_positions) {
        var self = this;

        
        self.interactive_elements = svg_and_positions['$[]']("interactive_elements");
        self.printer.$html(svg_and_positions['$[]']("svg"));
        return nil;
      }, TMP_Abc2Svg_set_svg_20.$$arity = 1);
      
      Opal.defn(self, '$get_abcmodel', TMP_Abc2Svg_get_abcmodel_21 = function $$get_abcmodel(abc_code) {
        var self = this, stripped_abc_code = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        stripped_abc_code = self.$strip_js(abc_code);
        abc2svg.modules.load(stripped_abc_code,
                              function(){console.log("modules loaded")},
                              function(msg){$gvars.log.$error(msg) } )     ;
        self.root.tosvg("abc", stripped_abc_code);
        return [self.abc_model, self.player_model];
      }, TMP_Abc2Svg_get_abcmodel_21.$$arity = 1);
      
      Opal.defn(self, '$get_svg', TMP_Abc2Svg_get_svg_22 = function $$get_svg() {
        var self = this, result = nil;

        
        result = self.svgbuf.$join("\n");
        result = result.$gsub("<svg ", "<div class=\"svg_block\"><svg ");
        result = result.$gsub("</svg>", "</svg></div>");
        return result;
      }, TMP_Abc2Svg_get_svg_22.$$arity = 0);
      
      Opal.defn(self, '$get_html', TMP_Abc2Svg_get_html_23 = function $$get_html() {
        var self = this;

        return "" + "\n" + "      <html>\n" + "      <head>\n" + "        <meta charset=\"utf-8\"/>\n" + "        <style type=\"text/css\">\n" + "           rect.abcref {fill-opacity:0.0}\n" + "          .nobrk s\t{ white-space:nowrap; }\n" + "          svg {display:block}\n" + "        </style>\n" + "      </head>\n" + "      <body>\n" + "         " + (self.printer.$html()) + "\n" + "      </body>\n" + "      "
      }, TMP_Abc2Svg_get_html_23.$$arity = 0);
      
      Opal.defn(self, '$set_callback', TMP_Abc2Svg_set_callback_24 = function $$set_callback(event) {
        var self = this, $iter = TMP_Abc2Svg_set_callback_24.$$p, block = $iter || nil, $writer = nil;

        if ($iter) TMP_Abc2Svg_set_callback_24.$$p = null;
        
        $writer = [event, block];
        $send(self.user, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, TMP_Abc2Svg_set_callback_24.$$arity = 1);
      
      Opal.defn(self, '$get_elements_by_range', TMP_Abc2Svg_get_elements_by_range_27 = function $$get_elements_by_range(from, to) {
        var TMP_25, self = this, range = nil, result = nil;

        
        range = [from, to].$sort();
        result = [];
        $send(self.interactive_elements, 'each', [], (TMP_25 = function(k, value){var self = TMP_25.$$s || this, TMP_26, noterange = nil;
if (k == null) k = nil;if (value == null) value = nil;
        
          noterange = $send(["startChar", "endChar"], 'map', [], (TMP_26 = function(c){var self = TMP_26.$$s || this;
if (c == null) c = nil;
          return value['$[]'](c)}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26)).$sort();
          if ($truthy($rb_gt($rb_times($rb_minus(range.$first(), noterange.$last()), $rb_minus(noterange.$first(), range.$last())), 0))) {
            return result.$push(k)
            } else {
            return nil
          };}, TMP_25.$$s = self, TMP_25.$$arity = 2, TMP_25));
        return result;
      }, TMP_Abc2Svg_get_elements_by_range_27.$$arity = 2);
      self.$private();
      
      Opal.defn(self, '$_callback_get_abcmodel', TMP_Abc2Svg__callback_get_abcmodel_28 = function $$_callback_get_abcmodel(tsfirst, voice_tb, music_types, info) {
        var self = this, json_model = nil;
        if ($gvars.log == null) $gvars.log = nil;

        
        json_model = "";
        
          var abcmidi = new AbcMIDI();
          abcmidi.add(tsfirst, voice_tb);
          var to_json = new AbcJSON();
          json_model =  to_json.gen_json(tsfirst, voice_tb, music_types, info);

          var to_audio = new ToAudio()
          to_audio.add(tsfirst, voice_tb)
          self.player_model = to_audio.clear()
      ;
        self.abc_model = Opal.const_get_relative($nesting, 'JSON').$parse(json_model);
        if ($gvars.log.$loglevel()['$==']("debug")) {
          $gvars.log.$debug(self.abc_model.$to_json())};
        return self.abc_model;
      }, TMP_Abc2Svg__callback_get_abcmodel_28.$$arity = 4);
      
      Opal.defn(self, '$_get_charpos', TMP_Abc2Svg__get_charpos_30 = function $$_get_charpos(abc_source, line, column) {
        var TMP_29, self = this, lines = nil, result = nil;

        
        lines = self.abc_source.$split("\n");
        result = $send(lines['$[]'](Opal.Range.$new(0, line, false)), 'inject', [0], (TMP_29 = function(r, v){var self = TMP_29.$$s || this;
if (r == null) r = nil;if (v == null) v = nil;
        return (r = $rb_plus(r, v.$length()))}, TMP_29.$$s = self, TMP_29.$$arity = 2, TMP_29));
        return $rb_plus(result, column);
      }, TMP_Abc2Svg__get_charpos_30.$$arity = 3);
      
      Opal.defn(self, '$_anno_start', TMP_Abc2Svg__anno_start_31 = function $$_anno_start(music_type, start_offset, stop_offset, x, y, w, h) {
        var self = this, id = nil;

        
        id = self.$_mk_id(music_type, start_offset, stop_offset);
        self.root.out_svg('<g class="' + id +'">\n');
        return nil;
      }, TMP_Abc2Svg__anno_start_31.$$arity = 7);
      
      Opal.defn(self, '$_clickabcnote', TMP_Abc2Svg__clickabcnote_32 = function $$_clickabcnote(evt, id) {
        var self = this;

        
        self.$Native(evt).$stopPropagation();
        return self.on_select.$call(self.interactive_elements['$[]'](id));
      }, TMP_Abc2Svg__clickabcnote_32.$$arity = 2);
      
      Opal.defn(self, '$_anno_stop', TMP_Abc2Svg__anno_stop_33 = function $$_anno_stop(music_type, start_offset, stop_offset, x, y, w, h) {
        var self = this, id = nil, onclick = nil, $writer = nil;

        
        id = self.$_mk_id(music_type, start_offset, stop_offset);
        onclick = "" + "onclick=\"Opal.top.uicontroller.tune_preview_printer.$_clickabcnote(evt, '" + (id) + "')\"";
        
          // close the container
          self.root.out_svg('</g>\n');
          // create a rectangle
          self.root.out_svg('<rect ' + onclick + ' class="abcref _' + start_offset + '_" id="' + id +'" x="');
          self.root.out_sxsy(x, '" y="', y);
          self.root.out_svg('" width="' + w.toFixed(2) + '" height="' + h.toFixed(2) + '"/>\n');
        ;
        
        $writer = [id, $hash2(["startChar", "endChar"], {"startChar": start_offset, "endChar": stop_offset})];
        $send(self.interactive_elements, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, TMP_Abc2Svg__anno_stop_33.$$arity = 7);
      return (Opal.defn(self, '$_mk_id', TMP_Abc2Svg__mk_id_34 = function $$_mk_id(music_type, start_offset, end_offset) {
        var self = this;

        return "" + "_" + (music_type) + "_" + (start_offset) + "_" + (end_offset) + "_"
      }, TMP_Abc2Svg__mk_id_34.$$arity = 3), nil) && '_mk_id';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.4 */
Opal.modules["version-prod"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$year', '$now']);
  
  Opal.const_set($nesting[0], 'VERSION', "v_1.11.2");
  Opal.const_set($nesting[0], 'SCHEMA_VERSION', "https://zupfnoter.weichel21.de/schema/zupfnoter-config_1.0.json");
  return Opal.const_set($nesting[0], 'COPYRIGHT', "" + "© " + (Opal.const_get_relative($nesting, 'Time').$now().$year()) + " https://www.zupfnoter.de");
};

// compiled for Zupfnoter 2018-08-25 09:35:30 +0200
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// abc2svg - abc2svg.js
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

// start of the abc2svg object
abc2svg = {

// constants
    C: {
	BLEN: 1536,

	// symbol types
	BAR: 0,
	CLEF: 1,
	CUSTOS: 2,
	GRACE: 4,
	KEY: 5,
	METER: 6,
	MREST: 7,
	NOTE: 8,
	PART: 9,
	REST: 10,
	SPACE: 11,
	STAVES: 12,
	STBRK: 13,
	TEMPO: 14,
	BLOCK: 16,
	REMARK: 17,

	// note heads
	FULL: 0,
	EMPTY: 1,
	OVAL: 2,
	OVALBARS: 3,
	SQUARE: 4,

	// slur/tie types (3 + 1 bits)
	SL_ABOVE: 0x01,
	SL_BELOW: 0x02,
	SL_AUTO: 0x03,
	SL_HIDDEN: 0x04,
	SL_DOTTED: 0x08		// (modifier bit)
    },

// start of the Abc object
  Abc: function(user) {
	"use strict";

    // constants
    var	C = abc2svg.C;

	// mask some unsafe functions
    var	require = empty_function,
	system = empty_function,
	write = empty_function,
	XMLHttpRequest = empty_function;

	this.user = user

// -- constants --

// staff system
var	OPEN_BRACE = 0x01,
	CLOSE_BRACE = 0x02,
	OPEN_BRACKET = 0x04,
	CLOSE_BRACKET = 0x08,
	OPEN_PARENTH = 0x10,
	CLOSE_PARENTH = 0x20,
	STOP_BAR = 0x40,
	FL_VOICE = 0x80,
	OPEN_BRACE2 = 0x0100,
	CLOSE_BRACE2 = 0x0200,
	OPEN_BRACKET2 = 0x0400,
	CLOSE_BRACKET2 = 0x0800,
	MASTER_VOICE = 0x1000,

	IN = 96,		// resolution 96 PPI
	CM = 37.8,		// 1 inch = 2.54 centimeter
	YSTEP = 256		/* number of steps for y offsets */

// error texts
var errs = {
	bad_char: "Bad character '$1'",
	bad_val: "Bad value in $1",
	bar_grace: "Cannot have a bar in grace notes",
	ignored: "$1: inside tune - ignored",
	misplaced: "Misplaced '$1' in %%staves",
	must_note: "!$1! must be on a note",
	must_note_rest: "!$1! must be on a note or a rest",
	nonote_vo: "No note in voice overlay",
	not_enough_n: 'Not enough notes/rests for %%repeat',
	not_enough_m: 'Not enough measures for %%repeat',
	not_ascii: "Not an ASCII character"
}

var	glovar = {
		meter: {
			type: C.METER,		// meter in tune header
			wmeasure: 1,		// no M:
			a_meter: []		// default: none
		}
	},
	info = {},			// information fields
	mac = {},			// macros (m:)
	maci = new Int8Array(128),	// first letter of macros
	parse = {
		ctx: {},
		prefix: '%',
		state: 0,
		line: new scanBuf()
	},
	psvg			// PostScript

// utilities
function clone(obj, lvl) {
	if (!obj)
		return obj
	var tmp = new obj.constructor()
	for (var k in obj)
	    if (obj.hasOwnProperty(k)) {
		if (lvl && typeof obj[k] == 'object')
			tmp[k] = clone(obj[k], lvl - 1)
		else
			tmp[k] = obj[k]
	    }
	return tmp
}

function errbld(sev, txt, fn, idx) {
	var i, j, l, c, h

	if (user.errbld) {
		switch (sev) {
		case 0: sev = "warn"; break
		case 1: sev = "error"; break
		default: sev= "fatal"; break
		}
		user.errbld(sev, txt, fn, idx)
		return
	}
	if (idx != undefined && idx >= 0) {
		i = l = 0
		while (1) {
			j = parse.file.indexOf('\n', i)
			if (j < 0 || j > idx)
				break
			l++;
			i = j + 1
		}
		c = idx - i
	}
	h = ""
	if (fn) {
		h = fn
		if (l)
			h += ":" + (l + 1) + ":" + (c + 1);
		h += " "
	}
	switch (sev) {
	case 0: h += "Warning: "; break
	case 1: h += "Error: "; break
	default: h += "Internal bug: "; break
	}
	user.errmsg(h + txt, l, c)
}

function error(sev, s, msg, a1, a2, a3, a4) {
	var i, j, regex, tmp

	if (user.textrans) {
		tmp = user.textrans[msg]
		if (tmp)
			msg = tmp
	}
	if (arguments.length > 3)
		msg = msg.replace(/\$./g, function(a) {
			switch (a) {
			case '$1': return a1
			case '$2': return a2
			case '$3': return a3
			default  : return a4
			}
		})
	if (s && s.fname)
		errbld(sev, msg, s.fname, s.istart)
	else
		errbld(sev, msg)
}

// scanning functions
function scanBuf() {
//	this.buffer = buffer
	this.index = 0;

	scanBuf.prototype.char = function() {
		return this.buffer[this.index]
	}
	scanBuf.prototype.next_char = function() {
		return this.buffer[++this.index]
	}
	scanBuf.prototype.get_int = function() {
		var	val = 0,
			c = this.buffer[this.index]
		while (c >= '0' && c <= '9') {
			val = val * 10 + Number(c);
			c = this.next_char()
		}
		return val
	}
}

function syntax(sev, msg, a1, a2, a3, a4) {
    var	s = {
		fname: parse.fname,
		istart: parse.istart + parse.line.index
	}

	error(sev, s, msg, a1, a2, a3, a4)
}

// inject javascript code
function js_inject(js) {
	if (!/eval *\(|Function|setTimeout|setInterval/.test(js))
		eval('"use strict"\n' + js)
	else
		syntax(1, "Unsecure code")
}
// abc2svg - deco.js - decorations
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

var	dd_tb = {},		// definition of the decorations
	a_de,			// array of the decoration elements
	od		// ottava: index = type + staff, value = counter + voice number

// decorations - populate with standard decorations
var decos = {
	dot: "0 stc 5 1 1",
	tenuto: "0 emb 5 3 3",
	slide: "1 sld 3 7 0",
	arpeggio: "2 arp 12 10 0",
	roll: "3 roll 7 6 6",
	fermata: "3 hld 12 7 7",
	emphasis: "3 accent 7 4 4",
	lowermordent: "3 lmrd 10 5 5",
	coda: "3 coda 24 10 10",
	uppermordent: "3 umrd 10 5 5",
	segno: "3 sgno 22 8 8",
	trill: "3 trl 14 5 5",
	upbow: "3 upb 10 5 5",
	downbow: "3 dnb 9 5 5",
	gmark: "3 grm 6 5 5",
	wedge: "3 wedge 8 3 3",		// (staccatissimo or spiccato)
	turnx: "3 turnx 10 0 5",
	breath: "3 brth 0 1 20",
	longphrase: "3 lphr 0 1 1",
	mediumphrase: "3 mphr 0 1 1",
	shortphrase: "3 sphr 0 1 1",
	invertedfermata: "3 hld 12 7 7",
	invertedturn: "3 turn 10 0 5",
	invertedturnx: "3 turnx 10 0 5",
	"0": "3 fng 8 3 3 0",
	"1": "3 fng 8 3 3 1",
	"2": "3 fng 8 3 3 2",
	"3": "3 fng 8 3 3 3",
	"4": "3 fng 8 3 3 4",
	"5": "3 fng 8 3 3 5",
	plus: "3 dplus 7 3 3",
	"+": "3 dplus 7 3 3",
	accent: "3 accent 6 4 4",
	">": "3 accent 6 4 4",
	marcato: "3 marcato 9 3 3",
	"^": "3 marcato 9 3 3",
	mordent: "3 lmrd 10 5 5",
	open: "3 opend 10 3 3",
	snap: "3 snap 14 3 3",
	thumb: "3 thumb 14 3 3",
	dacapo: "3 dacs 16 20 20 Da Capo",
	dacoda: "3 dacs 16 20 20 Da Coda",
	"D.C.": "3 dacs 16 10 10 D.C.",
	"D.S.": "3 dacs 16 10 10 D.S.",
	"D.C.alcoda": "3 dacs 16 38 38 D.C. al Coda",
	"D.S.alcoda": "3 dacs 16 38 38 D.S. al Coda",
	"D.C.alfine": "3 dacs 16 38 38 D.C. al Fine",
	"D.S.alfine": "3 dacs 16 38 38 D.S. al Fine",
	fine: "3 dacs 16 10 10 Fine",
	turn: "3 turn 10 0 5",
	"trill(": "3 ltr 8 0 0",
	"trill)": "3 ltr 8 0 0",
	f: "6 pf 18 1 7",
	ff: "6 pf 18 2 10",
	fff: "6 pf 18 4 13",
	ffff: "6 pf 18 6 16",
	mf: "6 pf 18 6 13",
	mp: "6 pf 18 6 16",
	p: "6 pf 18 2 8",
	pp: "6 pf 18 5 14",
	ppp: "6 pf 18 8 20",
	pppp: "6 pf 18 10 25",
	pralltriller: "3 umrd 10 5 5",
	sfz: '6 sfz 18 4 10 ""',
	ped: "4 ped 20 0 0",
	"ped-up": "4 pedoff 20 0 0",
	"crescendo(": "7 cresc 18 0 0",
	"crescendo)": "7 cresc 18 0 0",
	"<(": "7 cresc 18 0 0",
	"<)": "7 cresc 18 0 0",
	"diminuendo(": "7 dim 18 0 0",
	"diminuendo)": "7 dim 18 0 0",
	">(": "7 dim 18 0 0",
	">)": "7 dim 18 0 0",
	"-(": "8 gliss 0 0 0",
	"-)": "8 gliss 0 0 0",
	"~(": "8 glisq 0 0 0",
	"~)": "8 glisq 0 0 0",
	"8va(": "3 8va 10 0 0",
	"8va)": "3 8va 10 0 0",
	"8vb(": "4 8vb 10 0 0",
	"8vb)": "4 8vb 10 0 0",
	"15ma(": "3 15ma 10 0 0",
	"15ma)": "3 15ma 10 0 0",
	"15mb(": "4 15mb 10 0 0",
	"15mb)": "4 15mb 10 0 0",
// internal
//	color: "10 0 0 0 0",
	invisible: "32 0 0 0 0",
	beamon: "33 0 0 0 0",
	trem1: "34 0 0 0 0",
	trem2: "34 0 0 0 0",
	trem3: "34 0 0 0 0",
	trem4: "34 0 0 0 0",
	xstem: "35 0 0 0 0",
	beambr1: "36 0 0 0 0",
	beambr2: "36 0 0 0 0",
	rbstop: "37 0 0 0 0",
	"/": "38 0 0 6 6",
	"//": "38 0 0 6 6",
	"///": "38 0 0 6 6",
	"beam-accel": "39 0 0 0 0",
	"beam-rall": "39 0 0 0 0",
	stemless: "40 0 0 0 0",
	rbend: "41 0 0 0 0"},

	// types of decoration per function
	f_near = [true, true, true],
	f_note = [false, false, false, true, true, true, false, false, true],
	f_staff = [false, false, false, false, false, false, true, true]

/* -- get the max/min vertical offset -- */
function y_get(st, up, x, w) {
	var	y,
		p_staff = staff_tb[st],
		i = (x / realwidth * YSTEP) | 0,
		j = ((x + w) / realwidth * YSTEP) | 0

	if (i < 0)
		i = 0
	if (j >= YSTEP) {
		j = YSTEP - 1
		if (i > j)
			i = j
	}
	if (up) {
		y = p_staff.top[i++]
		while (i <= j) {
			if (y < p_staff.top[i])
				y = p_staff.top[i];
			i++
		}
	} else {
		y = p_staff.bot[i++]
		while (i <= j) {
			if (y > p_staff.bot[i])
				y = p_staff.bot[i];
			i++
		}
	}
	return y
}

/* -- adjust the vertical offsets -- */
function y_set(st, up, x, w, y) {
	var	p_staff = staff_tb[st],
		i = (x / realwidth * YSTEP) | 0,
		j = ((x + w) / realwidth * YSTEP) | 0

	/* (may occur when annotation on 'y' at start of an empty staff) */
	if (i < 0)
		i = 0
	if (j >= YSTEP) {
		j = YSTEP - 1
		if (i > j)
			i = j
	}
	if (up) {
		while (i <= j) {
			if (p_staff.top[i] < y)
				p_staff.top[i] = y;
			i++
		}
	} else {
		while (i <= j) {
			if (p_staff.bot[i] > y)
				p_staff.bot[i] = y;
			i++
		}
	}
}

/* -- get the staff position of the dynamic and volume marks -- */
function up_p(s, pos) {
	switch (pos) {
	case C.SL_ABOVE:
		return true
	case C.SL_BELOW:
		return false
	}
	if (s.multi && s.multi != 0)
		return s.multi > 0
	if (!s.p_v.have_ly)
		return false

	/* above if the lyrics are below the staff */
	return s.pos.voc != C.SL_ABOVE
}

/* -- drawing functions -- */
/* 2: special case for arpeggio */
function d_arp(de) {
	var	m, h, dx,
		s = de.s,
		dd = de.dd,
		xc = 5

	if (s.type == C.NOTE) {
		for (m = 0; m <= s.nhd; m++) {
			if (s.notes[m].acc) {
				dx = 5 + s.notes[m].shac
			} else {
				dx = 6 - s.notes[m].shhd
				switch (s.head) {
				case C.SQUARE:
					dx += 3.5
					break
				case C.OVALBARS:
				case C.OVAL:
					dx += 2
					break
				}
			}
			if (dx > xc)
				xc = dx
		}
	}
	h = 3 * (s.notes[s.nhd].pit - s.notes[0].pit) + 4;
	m = dd.h			/* minimum height */
	if (h < m)
		h = m;

	de.has_val = true;
	de.val = h;
//	de.x = s.x - xc;
	de.x -= xc;
	de.y = 3 * (s.notes[0].pit - 18) - 3
}

/* 7: special case for crescendo/diminuendo */
function d_cresc(de) {
	if (de.ldst)			// skip start of deco
		return
	var	s, dd, dd2, up, x, dx, x2, i,
		s2 = de.s,
		de2 = de.start,		/* start of the deco */
		de2_prev, de_next;

	s = de2.s;
	x = s.x + 3;
	i = de2.ix
	if (i > 0)
		de2_prev = a_de[i - 1];

	de.st = s2.st;
	de.lden = false;		/* old behaviour */
	de.has_val = true;
	up = up_p(s2, s2.pos.dyn)
	if (up)
		de.up = true

	// shift the starting point if any dynamic mark on the left
	if (de2_prev && de2_prev.s == s
	 && ((de.up && !de2_prev.up)
	  || (!de.up && de2_prev.up))) {
		dd2 = de2_prev.dd
		if (f_staff[dd2.func]) {	// if dynamic mark
			x2 = de2_prev.x + de2_prev.val + 4
			if (x2 > x)
				x = x2
		}
	}

	if (de.defl.noen) {		/* if no decoration end */
		dx = de.x - x
		if (dx < 20) {
			x = de.x - 20 - 3;
			dx = 20
		}
	} else {

		// shift the ending point if any dynamic mark on the right
		x2 = s2.x;
		de_next = a_de[de.ix + 1]
		if (de_next
		 && de_next.s == s
		 && ((de.up && !de_next.up)
		  || (!de.up && de_next.up))) {
			dd2 = de_next.dd
			if (f_staff[dd2.func])	// if dynamic mark
				x2 -= 5
		}
		dx = x2 - x - 4
		if (dx < 20) {
			x -= (20 - dx) * .5;
			dx = 20
		}
	}

	de.val = dx;
	de.x = x;
	de.y = y_get(de.st, up, x, dx)
	if (!up) {
		dd = de.dd;
		de.y -= dd.h
	}
	/* (y_set is done later in draw_deco_staff) */
}

/* 0: near the note (dot, tenuto) */
function d_near(de) {
	var	y, up,
		s = de.s,
		dd = de.dd

	if (dd.str) {			// annotation like decoration
//		de.x = s.x;
//		de.y = s.y;
		return
	}
	if (s.multi)
		up = s.multi > 0
	else
		up = s.stem < 0
	if (up)
		y = s.ymx | 0
	else
		y = (s.ymn - dd.h) | 0
	if (y > -6 && y < 24) {
		if (up)
			y += 3;
		y = (((y + 6) / 6) | 0) * 6 - 6		/* between lines */
	}
	if (up)
		s.ymx = y + dd.h
	else
		s.ymn = y;
	de.y = y
//	de.x = s.x + s.notes[s.stem >= 0 ? 0 : s.nhd].shhd
	if (s.type == C.NOTE)
		de.x += s.notes[s.stem >= 0 ? 0 : s.nhd].shhd
	if (dd.name[0] == 'd'			/* if dot decoration */
	 && s.nflags >= -1) {			/* on stem */
		if (up) {
			if (s.stem > 0)
				de.x += 3.5	// stem_xoff
		} else {
			if (s.stem < 0)
				de.x -= 3.5
		}
	}
}

/* 6: dynamic marks */
function d_pf(de) {
	var	dd2, x2, str, x, up,
		s = de.s,
		dd = de.dd,
		de_prev;

	de.val = dd.wl + dd.wr;
	up = up_p(s, s.pos.vol)
	if (up)
		de.up = true;
	x = s.x - dd.wl
	if (de.ix > 0) {
		de_prev = a_de[de.ix - 1]
		if (de_prev.s == s
		 && ((de.up && !de_prev.up)
		  || (!de.up && de_prev.up))) {
			dd2 = de_prev.dd
			if (f_staff[dd2.func]) {	/* if dynamic mark */
				x2 = de_prev.x + de_prev.val + 4;
				if (x2 > x)
					x = x2
			}
		}
	}

	de.x = x;
	de.y = y_get(s.st, up, x, de.val)
	if (!up)
		de.y -= dd.h
	/* (y_set is done later in draw_deco_staff) */
}

/* 1: special case for slide */
function d_slide(de) {
	var	m, dx,
		s = de.s,
		yc = s.notes[0].pit,
		xc = 5

	for (m = 0; m <= s.nhd; m++) {
		if (s.notes[m].acc) {
			dx = 4 + s.notes[m].shac
		} else {
			dx = 5 - s.notes[m].shhd
			switch (s.head) {
			case C.SQUARE:
				dx += 3.5
				break
			case C.OVALBARS:
			case C.OVAL:
				dx += 2
				break
			}
		}
		if (s.notes[m].pit <= yc + 3 && dx > xc)
			xc = dx
	}
//	de.x = s.x - xc;
	de.x -= xc;
	de.y = 3 * (yc - 18)
}

/* 5: special case for long trill */
function d_trill(de) {
	if (de.ldst)
		return
	var	dd, up, y, w, tmp,
		s2 = de.s,
		st = s2.st,
		s = de.start.s,
		x = s.x

	if (de.prev) {			// hack 'tr~~~~~'
		x = de.prev.x + 10;
		y = de.prev.y
	}
	de.st = st

	if (de.dd.func != 4) {		// if not below
		switch (de.dd.glyph) {
		case "8va":
		case "15ma":
			up = 1
			break
		default:
			up = s2.multi >= 0
			break
		}
	}
	if (de.defl.noen) {		/* if no decoration end */
		w = de.x - x
		if (w < 20) {
			x = de.x - 20 - 3;
			w = 20
		}
	} else {
		w = s2.x - x - 6
		if (s2.type == C.NOTE)
			w -= 6
		if (w < 20) {
			x -= (20 - w) * .5;
			w = 20
		}
	}
	dd = de.dd;
	if (!y)
		y = y_get(st, up, x, w)
	if (up) {
		tmp = staff_tb[s.st].topbar + 2
		if (y < tmp)
			y = tmp
	} else {
		y -= dd.h;
		tmp = staff_tb[s.st].botbar - 2
		if (y > tmp)
			y = tmp
	}
	de.lden = false;
	de.has_val = true;
	de.val = w;
	de.x = x;
	de.y = y
	if (up)
		y += dd.h;
	y_set(st, up, x, w, y)
	if (up)
		s.ymx = s2.ymx = y
	else
		s.ymn = s2.ymn = y
}

/* 3, 4: above (or below) the staff */
function d_upstaff(de) {

	// don't treat here the long decorations
	if (de.ldst)			// if long deco start
		return
	if (de.start) {			// if long decoration
		d_trill(de)
		return
	}
	var	yc, up, inv,
		s = de.s,
		dd = de.dd,
		x = s.x,
		w = dd.wl + dd.wr,
		stafft = staff_tb[s.st].topbar + 2,
		staffb = staff_tb[s.st].botbar - 2

	if (s.nhd)
		x += s.notes[s.stem >= 0 ? 0 : s.nhd].shhd;
	up = -1
	if (dd.func == 4) {		// below
		up = 0
	} else if (s.pos) {
		switch (s.pos.orn) {
		case C.SL_ABOVE:
			up = 1
			break
		case C.SL_BELOW:
			up = 0
			break
		}
	}

	switch (dd.glyph) {
	case "accent":
	case "roll":
		if (!up
		 || (up < 0
		  && (s.multi < 0
		   || (!s.multi && s.stem > 0)))) {
			yc = y_get(s.st, false, s.x - dd.wl, w)
			if (yc > staffb)
				yc = staffb;
			yc -= dd.h;
			y_set(s.st, false, s.x, 0, yc);
			inv = true;
			s.ymn = yc
		} else {
			yc = y_get(s.st, true, s.x, 0)
			if (yc < stafft)
				yc = stafft;
			y_set(s.st, true, s.x - dd.wl, w, yc + dd.h);
			s.ymx = yc + dd.h
		}
		break
	case "brth":
	case "lphr":
	case "mphr":
	case "sphr":
		yc = stafft + 1
		if (dd.glyph == "brth" && yc < s.ymx)
			yc = s.ymx
		for (s = s.ts_next; s; s = s.ts_next)
			if (s.seqst)
				break
		x += ((s ? s.x : realwidth) - x) * .45
		break
	default:
		if (dd.name.indexOf("invert") == 0)
			inv = true
		if (dd.name != "invertedfermata"
		 && (up > 0
		  || (up < 0 && s.multi >= 0))) {
			yc = y_get(s.st, true, s.x - dd.wl, w) + 2
			if (yc < stafft)
				yc = stafft;
			y_set(s.st, true, s.x - dd.wl, w, yc + dd.h);
			s.ymx = yc + dd.h
		} else {
			yc = y_get(s.st, false, s.x - dd.wl, w) - 2
			if (yc > staffb)
				yc = staffb;
			yc -= dd.h;
			y_set(s.st, false, s.x - dd.wl, w, yc)
			if (dd.name == "fermata")
				inv = true;
			s.ymn = yc
		}
		break
	}
	if (inv) {
		yc += dd.h;
		de.inv = true
	}
	de.x = x;
	de.y = yc
}

/* deco function table */
var func_tb = [
	d_near,		/* 0 - near the note */
	d_slide,	/* 1 */
	d_arp,		/* 2 */
	d_upstaff,	/* 3 - tied to note */
	d_upstaff,	/* 4 (below the staff) */
	d_trill,	/* 5 */
	d_pf,		/* 6 - tied to staff (dynamic marks) */
	d_cresc		/* 7 */
]

// add a decoration
/* syntax:
 *	%%deco <name> <c_func> <glyph> <h> <wl> <wr> [<str>]
 */
function deco_add(param) {
	var dv = param.match(/(\S*)\s+(.*)/);
	decos[dv[1]] = dv[2]
}

// define a decoration
function deco_def(nm) {
    var a, dd, dd2, name2, c, i, elts, str,
	text = decos[nm]

	if (!text) {
		if (cfmt.decoerr)
			error(1, null, "Unknown decoration '$1'", nm)
		return //undefined
	}

	// extract the values
	a = text.match(/(\d+)\s+(.+?)\s+([0-9.]+)\s+([0-9.]+)\s+([0-9.]+)/)
	if (!a) {
		error(1, null, "Invalid decoration '$1'", nm)
		return //undefined
	}
	var	c_func = Number(a[1]),
//		glyph = a[2],
		h = parseFloat(a[3]),
		wl = parseFloat(a[4]),
		wr = parseFloat(a[5])

	if (isNaN(c_func)) {
		error(1, null, "%%deco: bad C function value '$1'", a[1])
		return //undefined
	}
	if ((c_func < 0 || c_func > 10)
	 && (c_func < 32 || c_func > 41)) {
		error(1, null, "%%deco: bad C function index '$1'", c_func)
		return //undefined
	}
	if (h < 0 || wl < 0 || wr < 0) {
		error(1, null, "%%deco: cannot have a negative value '$1'", text)
		return //undefined
	}
	if (h > 50 || wl > 80 || wr > 80) {
		error(1, null, "%%deco: abnormal h/wl/wr value '$1'", text)
		return //undefined
	}

	// create/redefine the decoration
	dd = dd_tb[nm]
	if (!dd) {
		dd = {
			name: nm
		}
		dd_tb[nm] = dd
	}

	/* set the values */
	dd.func = dd.name.indexOf("head-") == 0 ? 9 : c_func;
	dd.glyph = a[2];
	dd.h = h;
	dd.wl = wl;
	dd.wr = wr;
	str = text.replace(a[0], '').trim()
	if (str) {				// optional string
		if (str[0] == '"')
			str = str.slice(1, -1);
		dd.str = str
	}

	/* compatibility */
	if (dd.func == 6 && dd.str == undefined)
		dd.str = dd.name

	// link the start and end of long decorations
	c = dd.name.slice(-1)
	if (c == '(' ||
	    (c == ')' && dd.name.indexOf('(') < 0)) {
		name2 = dd.name.slice(0, -1) + (c == '(' ? ')' : '(');
		dd2 = dd_tb[name2]
		if (dd2) {
			if (c == '(') {
				dd.dd_en = dd2;
				dd2.dd_st = dd
			} else {
				dd.dd_st = dd2;
				dd2.dd_en = dd
			}
		} else {
			dd2 = deco_def(name2)
			if (!dd2)
				return //undefined
		}
	}
	return dd
}

/* -- convert the decorations -- */
function deco_cnv(a_dcn, s, prev) {
	var	i, j, dd, dcn, note,
		nd = a_dcn.length

	for (i = 0; i < nd; i++) {
		dcn = a_dcn[i];
		dd = dd_tb[dcn]
		if (!dd) {
			dd = deco_def(dcn)
			if (!dd)
				continue
		}

		/* special decorations */
		switch (dd.func) {
		case 0:			// near
			if (s.type == C.BAR && dd.name == "dot") {
				s.bar_dotted = true
				break
			}
			// fall thru
		case 1:			// slide
		case 2:			// arp
//			if (s.type != C.NOTE && s.type != C.REST) {
			if (!s.notes) {
				error(1, s,
					errs.must_note_rest, dd.name)
				continue
			}
			break
		case 8:			// gliss
			if (s.type != C.NOTE) {
				error(1, s,
					errs.must_note, dd.name)
				continue
			}
			note = s.notes[s.nhd] // move to the upper note of the chord
			if (!note.a_dcn)
				note.a_dcn = []
			note.a_dcn.push(dd.name)
			continue
		case 9:			// alternate head
			if (!s.notes) {
				error(1, s,
					errs.must_note_rest, dd.name)
				continue
			}

			// move the alternate head of the chord to the notes
			for (j = 0; j <= s.nhd; j++) {
				note = s.notes[j]
				if (!note.a_dcn)
					note.a_dcn = []
				note.a_dcn.push(dd.name)
			}
			continue
		default:
			break
		case 10:		/* color */
			if (s.notes) {
				for (j = 0; j <= s.nhd; j++)
					s.notes[j].color = dd.name
			} else {
				s.color = dd.name
			}
			continue
		case 32:		/* invisible */
			s.invis = true
			continue
		case 33:		/* beamon */
			if (s.type != C.BAR) {
				error(1, s, "!beamon! must be on a bar")
				continue
			}
			s.beam_on = true
			continue
		case 34:		/* trem1..trem4 */
			if (s.type != C.NOTE
			 || !prev
			 || prev.type != C.NOTE
			 || s.nflags != prev.nflags) {
				error(1, s,
					"!$1! must be on the last of a couple of notes",
					dd.name)
				continue
			}
			s.trem2 = true;
			s.beam_end = true;
//			s.beam_st = false;
			prev.trem2 = true;
			prev.beam_st = true;
//			prev.beam_end = false;
			s.ntrem = prev.ntrem = Number(dd.name[4]);
			prev.nflags = --s.nflags;
			prev.head = ++s.head
			if (s.nflags > 0) {
				s.nflags += s.ntrem;
			} else {
				if (s.nflags <= -2) {
					s.stemless = true;
					prev.stemless = true
				}
				s.nflags = s.ntrem;
			}
			prev.nflags = s.nflags
			for (j = 0; j <= s.nhd; j++)
				s.notes[j].dur *= 2;
			for (j = 0; j <= prev.nhd; j++)
				prev.notes[j].dur *= 2
			continue
		case 35:		/* xstem */
			if (s.type != C.NOTE) {
				error(1, s, "!xstem! must be on a note")
				continue
			}
			s.xstem = true;
			s.nflags = 0		// beam break
			continue
		case 36:		/* beambr1 / beambr2 */
			if (s.type != C.NOTE) {
				error(1, s, errs.must_note, dd.name)
				continue
			}
			if (dd.name[6] == '1')
				s.beam_br1 = true
			else
				s.beam_br2 = true
			continue
		case 37:		/* rbstop */
			s.rbstop = 1	// open
			continue
		case 38:		/* /, // and /// = tremolo */
			if (s.type != C.NOTE) {
				error(1, s, errs.must_note, dd.name)
				continue
			}
			s.trem1 = true;
			s.ntrem = dd.name.length	/* 1, 2 or 3 */
			if (s.nflags > 0)
				s.nflags += s.ntrem
			else
				s.nflags = s.ntrem
			continue
		case 39:		/* beam-accel/beam-rall */
			if (s.type != C.NOTE) {
				error(1, s, errs.must_note, dd.name)
				continue
			}
			s.feathered_beam = dd.name[5] == 'a' ? 1 : -1;
			continue
		case 40:		/* stemless */
			s.stemless = true
			continue
		case 41:		/* rbend */
			s.rbstop = 2	// with end
			continue
		}

		// add the decoration in the symbol
		if (!s.a_dd)
			s.a_dd = []
		s.a_dd.push(dd)
	}
}

/* -- update the x position of a decoration -- */
// used to center the rests
function deco_update(s, dx) {
	var	i, de,
		nd = a_de.length

	for (i = 0; i < nd; i++) {
		de = a_de[i]
		if (de.s == s)
			de.x += dx
	}
}

/* -- adjust the symbol width -- */
function deco_width(s) {
	var	dd, i,
		wl = 0,
		a_dd = s.a_dd,
		nd = a_dd.length

	for (i = 0; i < nd; i++) {
		dd =  a_dd[i]
		switch (dd.func) {
		case 1:			/* slide */
			if (wl < 7)
				wl = 7
			break
		case 2:			/* arpeggio */
			if (wl < 14)
				wl = 14
			break
		case 3:
			switch (dd.glyph) {
			case "brth":
			case "lphr":
			case "mphr":
			case "sphr":
				if (s.wr < 20)
					s.wr = 20
				break
			}
			break
		}
	}
	if (wl != 0 && s.prev && s.prev.type == C.BAR)
		wl -= 3
	return wl
}

/* -- draw the decorations -- */
/* (the staves are defined) */
function draw_all_deco() {
	if (a_de.length == 0)
		return
	var	de, de2, dd, s, note, f, st, x, y, y2, ym, uf, i, str, a,
		new_de = [],
		ymid = []

	if (!cfmt.dynalign) {
		st = nstaff;
		y = staff_tb[st].y
		while (--st >= 0) {
			y2 = staff_tb[st].y;
			ymid[st] = (y + 24 + y2) * .5;
			y = y2
		}
	}

	while (1) {
		de = a_de.shift()
		if (!de)
			break
		dd = de.dd
		if (!dd)
			continue		// deleted

		if (dd.dd_en)			// start of long decoration
			continue

		// handle the stem direction
		s = de.s
		f = dd.glyph;
		i = f.indexOf('/')
		if (i > 0) {
			if (s.stem >= 0)
				f = f.slice(0, i)
			else
				f = f.slice(i + 1)
		}

		// no voice scale if staff decoration
		if (f_staff[dd.func])
			set_sscale(s.st)
		else
			set_scale(s);

		st = de.st;
		if (!staff_tb[st].topbar)
			continue		// invisible staff
		x = de.x;
//		y = de.y + staff_tb[st].y / staff_tb[st].staffscale
		y = de.y + staff_tb[st].y

		// update the coordinates if head decoration
		if (de.m != undefined) {
			note = s.notes[de.m];
			x += note.shhd * stv_g.scale;

		/* center the dynamic marks between two staves */
/*fixme: KO when deco on other voice and same direction*/
		} else if (f_staff[dd.func] && !cfmt.dynalign
			&& ((de.up && st > 0)
			 || (!de.up && st < nstaff))) {
			if (de.up)
				ym = ymid[--st]
			else
				ym = ymid[st++];
			ym -= dd.h * .5
			if ((de.up && y < ym)
			 || (!de.up && y > ym)) {
//				if (s.st > st) {
//					while (s.st != st)
//						s = s.ts_prev
//				} else if (s.st < st) {
//					while (s.st != st)
//						s = s.ts_next
//				}
				y2 = y_get(st, !de.up, de.x, de.val)
					+ staff_tb[st].y
				if (de.up)
					y2 -= dd.h
//fixme: y_set is not used later!
				if ((de.up && y2 > ym)
				 || (!de.up && y2 < ym)) {
					y = ym;
//					y_set(st, de.up, de.x, de.val,
//						(de.up ? y + dd.h : y)
//							- staff_tb[st].y)
				}
			}
		}

		// check if user JS decoration
		uf = user[f]
		if (uf && typeof(uf) == "function") {
			uf(x, y, de)
			continue
		}

		// check if user PS definition
		if (psdeco(f, x, y, de))
			continue

		anno_start(s, 'deco')
//		if (de.flags.grace) {
//			g_open(x, y, 0, .7, de.inv ? -.7 : 0);
//			x = y = 0
//		} else
		if (de.inv) {
			g_open(x, y, 0, 1, -1);
			x = y = 0
		}
		if (de.has_val) {
			if (dd.func != 2	// if not !arpeggio!
			 || stv_g.st < 0)	// or not staff scale
// || voice_tb[s.v].scale != 1)
				out_deco_val(x, y, f, de.val / stv_g.scale, de.defl)
			else
				out_deco_val(x, y, f, de.val, de.defl)
			if (de.defl.noen)
				new_de.push(de.start)	// to be continued next line
		} else if (dd.str != undefined
			&& dd.str != 'sfz') {
			str = dd.str
			if (str[0] == '@') {
				a = str.match(/^@([0-9.-]+),([0-9.-]+);?/);
				x += Number(a[1]);
				y += Number(a[2]);
				str = str.replace(a[0], "")
			}
//			out_deco_str(x, y + de.dy,	// - dd.h * .2,
			out_deco_str(x, y,		// - dd.h * .2,
					f, str)
		} else if (de.lden) {
			out_deco_long(x, y, de)
		} else {
			xygl(x, y, f)
		}
		if (stv_g.g)
			g_close();
		anno_stop(s, 'deco')
	}

	// keep the long decorations which continue on the next line
	a_de = new_de
}

/* -- create the decorations and define the ones near the notes -- */
/* (the staves are not yet defined) */
/* (delayed output) */
/* this function must be called first as it builds the deco element table */
    var	ottava = {"8va(":1, "8va)":1, "15ma(":1, "15ma)":1,
		"8vb(":1, "8vb)":1, "15mb(":1, "15mb)":1}
function draw_deco_near() {
    var	s, g

	// update starting old decorations
	function ldeco_update(s) {
		var	i, de,
//			x = s.ts_prev.x + s.ts_prev.wr
			x = s.x - s.wl,
			nd = a_de.length

		for (i = 0; i < nd; i++) {
			de = a_de[i];
			de.ix = i;
			de.s.x = de.x = x;
			de.defl.nost = true
		}
	}

	/* -- create the deco elements, and treat the near ones -- */
	function create_deco(s) {
		var	dd, k, l, pos, de, x,
			nd = s.a_dd.length

/*fixme:pb with decorations above the staff*/
		for (k = 0; k < nd; k++) {
			dd = s.a_dd[k]

			/* check if hidden */
			switch (dd.func) {
			default:
				pos = 0
				break
			case 3:				/* d_upstaff */
			case 4:
//fixme:trill does not work yet
			case 5:				/* trill */
				if (ottava[dd.name]) {	// only one ottava per staff
					x = dd.name.slice(0, -1) + s.st.toString()
					if (od[x]) {
						if (dd.name[dd.name.length - 1] == '(') {
							od[x]++
							continue
						}
						od[x]--
						if (s.v + 1 != od[x] >> 8
						 || !od[x])
							continue
						od[x] &= 0xff
					} else if (dd.name[dd.name.length - 1] == '(') {
						od[x] = 1 + ((s.v + 1) << 8)
					}
				}
				pos = s.pos.orn
				break
			case 6:				/* d_pf */
				pos = s.pos.vol
				break
			case 7:				/* d_cresc */
				pos = s.pos.dyn
				break
			}
			if (pos == C.SL_HIDDEN)
				continue

			de = {
				s: s,
				dd: dd,
				st: s.st,
				ix: a_de.length,
				defl: {},
				x: s.x,
				y: s.y,
//				dy: 0
			}
			a_de.push(de)
			if (dd.dd_en) {
				de.ldst = true
			} else if (dd.dd_st) {
//fixme: pb with "()"
				de.lden = true;
				de.defl.nost = true
			}

			if (!f_near[dd.func])	/* if not near the note */
				continue
			func_tb[dd.func](de)
		}
	} // create_deco()

	// create the decorations of note heads
	function create_dh(s, m) {
		var	f, str, de, uf, k, dcn, dd,
			note = s.notes[m],
			nd = note.a_dcn.length

		for (k = 0; k < nd; k++) {
			dcn = note.a_dcn[k];
			dd = dd_tb[dcn]
			if (!dd) {
				dd = deco_def(dcn)
				if (!dd)
					continue
			}

			switch (dd.func) {
			case 0:
			case 1:
			case 3:
			case 4:
			case 8:			// gliss
				break
			default:
//			case 2:			// arpeggio
//			case 5:			// trill
//			case 7:			// d_cresc
				error(1, null, "Cannot have !$1! on a head", dd.name)
				continue
			case 9:			// head replacement
				note.invis = true
				break
			case 10:		// color
				note.color = dd.name
				continue
			case 32:		// invisible
				note.invis = true
				continue
			case 40:		// stemless chord (abcm2ps behaviour)
				s.stemless = true
				continue
			}

//fixme: check if hidden?
			de = {
				s: s,
				dd: dd,
				st: s.st,
				m: m,
				ix: 0,
				defl: {},
				x: s.x,
				y: 3 * (note.pit - 18),
//				dy: 0
			}
			a_de.push(de)
			if (dd.dd_en) {
				de.ldst = true
			} else if (dd.dd_st) {
				de.lden = true;
				de.defl.nost = true
			}
		}
	} // create_dh()

	// create all decoration of a note (chord and heads)
	function create_all(s) {
		var m

		if (s.a_dd)
			create_deco(s)
		if (s.notes) {
			for (m = 0; m < s.notes.length; m++) {
				if (s.notes[m].a_dcn)
					create_dh(s, m)
			}
		}
	} // create_all()

	// link the long decorations
	function ll_deco() {
		var	i, j, de, de2, dd, dd2, v, s, st,
			n_de = a_de.length

		// add ending decorations
		for (i = 0; i < n_de; i++) {
			de = a_de[i]
			if (!de.ldst)	// not the start of long decoration
				continue
			dd = de.dd;
			dd2 = dd.dd_en;
			s = de.s;
			v = s.v			// search later in the voice
			for (j = i + 1; j < n_de; j++) {
				de2 = a_de[j]
				if (!de2.start
				 && de2.dd == dd2 && de2.s.v == v)
					break
			}
			if (j == n_de) {	// no end, search in the staff
				st = s.st;
				for (j = i + 1; j < n_de; j++) {
					de2 = a_de[j]
					if (!de2.start
					 && de2.dd == dd2 && de2.s.st == st)
						break
				}
			}
			if (j == n_de) {	// no end, insert one
				de2 = {
					s: de.s,
					st: de.st,
					dd: dd2,
					ix: a_de.length - 1,
					x: realwidth - 6,
					y: de.s.y,
					lden: true,
					defl: {
						noen: true
					}
				}
				if (de2.x < s.x + 10)
					de2.x = s.x + 10
				if (de.m != undefined)
					de2.m = de.m;
				a_de.push(de2)
			}
			de2.start = de;
			de2.defl.nost = de.defl.nost

			// handle 'tr~~~~~'
			if (dd.name == "trill("
			 && i > 0 && a_de[i - 1].dd.name == "trill")
				de2.prev = a_de[i - 1]
		}

		// add starting decorations
		for (i = 0; i < n_de; i++) {
			de2 = a_de[i]
			if (!de2.lden	// not the end of long decoration
			 || de2.start)	// start already found
				continue
			s = de2.s;
			de = {
				s: prev_scut(s),
				st: de2.st,
				dd: de2.dd.dd_st,
				ix: a_de.length - 1,
//				x: s.x - s.wl - 4,
				y: s.y,
				ldst: true
			}
			de.x = de.s.x
			if (de2.m != undefined)
				de.m = de2.m;
			a_de.push(de);
			de2.start = de
		}
	} // ll_deco

	// update the long decorations started in the previous line
	for (s = tsfirst ; s; s = s.ts_next) {
		switch (s.type) {
		case C.CLEF:
		case C.KEY:
		case C.METER:
			continue
		}
		break
	}
	if (a_de.length != 0)
		ldeco_update(s)

	for ( ; s; s = s.ts_next) {
		switch (s.type) {
		case C.BAR:
		case C.MREST:
		case C.NOTE:
		case C.REST:
		case C.SPACE:
			break
		case C.GRACE:
			for (g = s.extra; g; g = g.next)
				create_all(g)
		default:
			continue
		}
		create_all(s)
	}
	ll_deco()			// link the long decorations
}

/* -- define the decorations tied to a note -- */
/* (the staves are not yet defined) */
/* (delayed output) */
function draw_deco_note() {
	var	i, de, dd, f,
		nd = a_de.length

	for (i = 0; i < nd; i++) {
		de = a_de[i];
		dd = de.dd;
		f = dd.func
		if (f_note[f]
		 && de.m == undefined)
			func_tb[f](de)
	}
}

// -- define the music elements tied to the staff --
//	- decoration tied to the staves
//	- chord symbols
//	- repeat brackets
/* (the staves are not yet defined) */
/* (unscaled delayed output) */
function draw_deco_staff() {
	var	s, first_gchord, p_voice, x, y, w, i, v, de, dd,
		gch, gch2, ix, top, bot,
		minmax = new Array(nstaff),
		nd = a_de.length

	/* draw the repeat brackets */
	function draw_repbra(p_voice) {
		var s, s1, y, y2, i, p, w, wh, first_repeat;

		/* search the max y offset */
		y = staff_tb[p_voice.st].topbar + 25	// 20 (vert bar) + 5 (room)
		for (s = p_voice.sym; s; s = s.next) {
			if (s.type != C.BAR)
				continue
			if (!s.rbstart || s.norepbra)
				continue
/*fixme: line cut on repeat!*/
			if (!s.next)
				break
			if (!first_repeat) {
				first_repeat = s;
				set_font("repeat")
			}
			s1 = s
			for (;;) {
				if (!s.next)
					break
				s = s.next
				if (s.rbstop)
					break
			}
			y2 = y_get(p_voice.st, true, s1.x, s.x - s1.x)
			if (y < y2)
				y = y2

			/* have room for the repeat numbers */
			if (s1.text) {
				wh = strwh(s1.text);
				y2 = y_get(p_voice.st, true, s1.x + 4, wh[0]);
				y2 += wh[1]
				if (y < y2)
					y = y2
			}
			if (s.rbstart)
				s = s.prev
		}

		/* draw the repeat indications */
		s = first_repeat
		if (!s)
			return
		set_dscale(p_voice.st, true);
		y2 =  y * staff_tb[p_voice.st].staffscale
		for ( ; s; s = s.next) {
			if (!s.rbstart || s.norepbra)
				continue
			s1 = s
			while (1) {
				if (!s.next)
					break
				s = s.next
				if (s.rbstop)
					break
			}
			if (s1 == s)
				break
			x = s1.x
//			if (s1.bar_type[0] == ":")
//				x -= 4;
			if (s.type != C.BAR) {
				w = s.rbstop ? 0 : s.x - realwidth + 4
			} else if ((s.bar_type.length > 1	// if complex bar
				 && s.bar_type != "[]")
				|| s.bar_type == "]") {
//				if (s.bar_type == "]")
//					s.invis = true
//fixme:%%staves: cur_sy moved?
				if (s1.st > 0
				 && !(cur_sy.staves[s1.st - 1].flags & STOP_BAR))
					w = s.wl
				else if (s.bar_type.slice(-1) == ':')
					w = 12
				else if (s.bar_type[0] != ':')
//				      || s.bar_type == "]")
					w = 0		/* explicit repeat end */
				else
					w = 8
			} else {
				w = s.rbstop ? 0 : 8
			}
			w = (s.x - x - w)	// / staff_tb[p_voice.st].staffscale;

			if (!s.next		// 2nd ending at end of line
			 && !s.rbstop
			 && !p_voice.bar_start) { // continue on next line
				p_voice.bar_start = clone(s);
				p_voice.bar_start.type = C.BAR;
				p_voice.bar_start.bar_type = "["
				delete p_voice.bar_start.text;
				p_voice.bar_start.rbstart = 1
				delete p_voice.bar_start.a_gch
			}
			if (s1.text)
				xy_str(x + 4, y2 - gene.curfont.size - 3,
					s1.text);
			xypath(x, y2);
			if (s1.rbstart == 2)
				output += 'm0 20v-20';
			output+= 'h' + w.toFixed(2)
			if (s.rbstop == 2)
				output += 'v20';
			output += '"/>\n';
			y_set(s1.st, true, x, w, y + 2)

			if (s.rbstart)
				s = s.prev
		}
	} // draw_repbra()

	/* create the decorations tied to the staves */
	for (i = 0; i <= nstaff; i++)
		minmax[i] = {
			ymin: 0,
			ymax: 0
		}
	for (i = 0; i < nd; i++) {
		de = a_de[i];
		dd = de.dd
		if (!dd)		// if error
			continue
		if (!f_staff[dd.func]	/* if not tied to the staff */
		 || de.m != undefined)	// or head decoration
			continue
		func_tb[dd.func](de)
		if (dd.dd_en)		// if start
			continue
		if (cfmt.dynalign) {
			if (de.up) {
				if (de.y > minmax[de.st].ymax)
					minmax[de.st].ymax = de.y
			} else {
				if (de.y < minmax[de.st].ymin)
					minmax[de.st].ymin = de.y
			}
		}
	}

	/* and, if wanted, set them at a same vertical offset */
	for (i = 0; i < nd; i++) {
		de = a_de[i];
		dd = de.dd
		if (!dd)		// if error
			continue
		if (dd.dd_en		// if start
		 || !f_staff[dd.func])
			continue
		if (cfmt.dynalign) {
			if (de.up)
				y = minmax[de.st].ymax
			else
				y = minmax[de.st].ymin;
			de.y = y
		} else {
			y = de.y
		}
		if (de.up)
			y += dd.h;
		y_set(de.st, de.up, de.x, de.val, y)
	}

	// search the vertical offset for the chord symbols
	for (i = 0; i <= nstaff; i++)
		minmax[i] = {
			ymin: 0,
			ymax: 24
		}
	for (s = tsfirst; s; s = s.ts_next) {
		if (!s.a_gch)
			continue
		if (!first_gchord)
			first_gchord = s;
		gch2 = null
		for (ix = 0; ix < s.a_gch.length; ix++) {
			gch = s.a_gch[ix]
			if (gch.type != 'g')
				continue
			gch2 = gch	// chord closest to the staff
			if (gch.y < 0)
				break
		}
		if (gch2) {
			w = gch2.w
			if (gch2.y >= 0) {
				y = y_get(s.st, true, s.x, w)
				if (y > minmax[s.st].ymax)
					minmax[s.st].ymax = y
			} else {
				y = y_get(s.st, false, s.x, w)
				if (y < minmax[s.st].ymin)
					minmax[s.st].ymin = y
			}
		}
	}

	// draw the chord symbols if any
	if (first_gchord) {
		for (i = 0; i <= nstaff; i++) {
			bot = staff_tb[i].botbar;
			if (minmax[i].ymin > bot - 4)
				minmax[i].ymin = bot - 4
			top = staff_tb[i].topbar;
			if (minmax[i].ymax < top + 4)
				minmax[i].ymax = top + 4
		}
		set_dscale(-1)		/* restore the scale parameters */
		for (s = first_gchord; s; s = s.ts_next) {
			if (!s.a_gch)
				continue
			draw_gchord(s, minmax[s.st].ymin, minmax[s.st].ymax)
		}
	}

	/* draw the repeat brackets */
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (p_voice.second || !p_voice.sym)
			continue
		draw_repbra(p_voice)
	}
}

/* -- draw the measure bar numbers -- */
/* (scaled delayed output) */
function draw_measnb() {
	var	s, st, bar_num, x, y, w, any_nb, font_size,
		sy = cur_sy

	/* search the top staff */
	for (st = 0; st <= nstaff; st++) {
		if (sy.st_print[st])
			break
	}
	if (st > nstaff)
		return				/* no visible staff */
	set_dscale(st)

	/* leave the measure numbers as unscaled */
	if (staff_tb[st].staffscale != 1) {
		font_size = get_font("measure").size;
		param_set_font("measurefont", "* " +
			(font_size / staff_tb[st].staffscale).toString())
	}
	set_font("measure");

	s = tsfirst;				/* clef */
	bar_num = gene.nbar
	if (bar_num > 1) {
		if (cfmt.measurenb == 0) {
			any_nb = true;
			y = y_get(st, true, 0, 20)
			if (y < staff_tb[st].topbar + 14)
				y = staff_tb[st].topbar + 14;
			if (cfmt.measurebox)
				xy_str_b(0, y, bar_num.toString())
			else
				xy_str(0, y, bar_num.toString());
			y_set(st, true, 0, 20, y + gene.curfont.size + 2)
		} else if (bar_num % cfmt.measurenb == 0) {
			for ( ; ; s = s.ts_next) {
				switch (s.type) {
				case C.METER:
				case C.CLEF:
				case C.KEY:
				case C.STBRK:
					continue
				}
				break
			}
			while (s.st != st)
				s = s.ts_next

			// don't display the number twice
		     if (s.type != C.BAR || !s.bar_num) {
			if (s.prev && s.prev.type != C.CLEF)
				s = s.prev;
			x = s.x - s.wl;
			any_nb = true;
			w = cwid('0') * gene.curfont.swfac
			if (bar_num >= 10)
				w *= bar_num >= 100 ? 3 : 2
			if (cfmt.measurebox)
				w += 4;
			y = y_get(st, true, x, w)
			if (y < staff_tb[st].topbar + 6)
				y = staff_tb[st].topbar + 6;
			y += 2;
			if (cfmt.measurebox) {
				xy_str_b(x, y, bar_num.toString());
				y += 2;
				w += 3
			} else {
				xy_str(x, y, bar_num.toString())
			}
			y += gene.curfont.size;
			y_set(st, true, x, w, y);
			s.ymx = y
		     }
		}
	}

	for ( ; s; s = s.ts_next) {
		switch (s.type) {
		case C.STAVES:
			sy = s.sy
			for (st = 0; st < nstaff; st++) {
				if (sy.st_print[st])
					break
			}
			set_sscale(st)
			continue
		default:
			continue
		case C.BAR:
			if (!s.bar_num)
				continue
			break
		}

		bar_num = s.bar_num
		if (cfmt.measurenb == 0
		 || (bar_num % cfmt.measurenb) != 0
		 || !s.next)
			continue
		if (!any_nb)
			any_nb = true;
		w = cwid('0') * gene.curfont.swfac
		if (bar_num >= 10)
			w *= bar_num >= 100 ? 3 : 2
		if (cfmt.measurebox)
			w += 4;
		x = s.x - w * .4;
		y = y_get(st, true, x, w)
		if (y < staff_tb[st].topbar + 6)
			y = staff_tb[st].topbar + 6
		if (s.next.type == C.NOTE) {
			if (s.next.stem > 0) {
				if (y < s.next.ys - gene.curfont.size)
					y = s.next.ys - gene.curfont.size
			} else {
				if (y < s.next.y)
					y = s.next.y
			}
		}
		y += 2;
		if (cfmt.measurebox) {
			xy_str_b(x, y, bar_num.toString());
			y += 2;
			w += 3
		} else {
			xy_str(x, y, bar_num.toString())
		}
		y += gene.curfont.size;
		y_set(st, true, x, w, y);
		s.ymx = y
	}
	gene.nbar = bar_num

	if (font_size)
		param_set_font("measurefont", "* " + font_size.toString());
}

/* -- draw the note of the tempo -- */
function draw_notempo(s, x, y, dur, sc) {
	var	dx, p, dotx,
		elts = identify_note(s, dur),
		head = elts[0],
		dots = elts[1],
		nflags = elts[2]

//useless
//	// protection against end of container
//	if (stv_g.started) {
//		output += "</g>\n";
//		stv_g.started = false
//	}

	out_XYAB('<g transform="translate(X,Y) scale(F)">\n',
		x + 4, y + 5, sc)
	switch (head) {
	case C.OVAL:
		p = "HD"
		break
	case C.EMPTY:
		p = "Hd"
		break
	default:
		p = "hd"
		break
	}
	xygl(-posx, posy, p);
	dx = 4
	if (dots) {
		dotx = 9
		if (nflags > 0)
			dotx += 4
		switch (head) {
		case C.SQUARE:
			dotx += 3
			break
		case C.OVALBARS:
		case C.OVAL:
			dotx += 2
			break
		case C.EMPTY:
			dotx += 1
			break
		}
		dx = dotx * dots;
		dotx -= posx
		while (--dots >= 0) {
			xygl(dotx, posy, "dot");
			dotx += 3.5
		}
	}
	if (dur < C.BLEN) {
		if (nflags <= 0) {
			out_stem(-posx, posy, 21)		// stem height
		} else {
			out_stem(-posx, posy, 21, false, nflags)
			if (dx < 6)
				dx = 6
		}
	}
	output += '</g>\n'
	return (dx + 15) * sc
}

/* -- estimate the tempo width -- */
function tempo_width(s) {
	var	w = 0;

	set_font("tempo")
	if (s.tempo_str1)
		w = strwh(s.tempo_str1)[0]
	if (s.tempo_ca)
		w += strwh(s.tempo_ca)[0]
	if (s.tempo_notes)
		w += 10 * s.tempo_notes.length +
			6 + cwid(' ') * gene.curfont.swfac * 6 + 10
	if (s.tempo_str2)
		w += strwh(s.tempo_str2)[0]
	return w
}

/* - output a tempo --*/
function write_tempo(s, x, y) {
	var	j, dx,
		sc = .6 * gene.curfont.size / 15.0; //fixme: 15.0 = initial tempofont

	set_font("tempo")
	if (s.tempo_str1) {
		xy_str(x, y, s.tempo_str1);
		x += strwh(s.tempo_str1)[0] + 3
	}
	if (s.tempo_notes) {
		for (j = 0; j < s.tempo_notes.length; j++)
			x += draw_notempo(s, x, y, s.tempo_notes[j], sc);
		xy_str(x, y, "=");
		x += strwh("= ")[0]
		if (s.tempo_ca) {
			xy_str(x, y, s.tempo_ca);
			x += strwh(s.tempo_ca)[0]
		}
		if (s.tempo) {
			xy_str(x, y, s.tempo.toString());
			dx = cwid('0') * gene.curfont.swfac;
			x += dx + 5
			if (s.tempo >= 10) {
				x += dx
				if (s.tempo >= 100)
					x += dx
			}
		} else {
			x += draw_notempo(s, x, y, s.new_beat, sc)
		}
	}
	if (s.tempo_str2)
		xy_str(x, y, s.tempo_str2)

	// don't display anymore
	s.del = true
}

/* -- draw the parts and the tempo information -- */
/* (the staves are being defined) */
function draw_partempo(st, top) {
	var	s, some_part, some_tempo, h, w, y,
		dy = 0,		/* put the tempo indication at top */
		ht = 0

	/* get the minimal y offset */
	var	ymin = staff_tb[st].topbar + 8,
		dosh = 0,
		shift = 1,
		x = 0
	for (s = tsfirst; s; s = s.ts_next) {
		if (s.type != C.TEMPO || s.del)
			continue
		if (!some_tempo)
			some_tempo = s;
		w = tempo_width(s);
		y = y_get(st, true, s.x - 16, w)
		if (y > ymin)
			ymin = y
		if (x >= s.x - 16 && !(dosh & (shift >> 1)))
			dosh |= shift;
		shift <<= 1;
		x = s.x - 16 + w
	}
	if (some_tempo) {
		set_sscale(-1);
		set_font("tempo");
		ht = gene.curfont.size + 2 + 2;
		y = 2 - ht;
		h = y - ht
		if (dosh != 0)
			ht *= 2
		if (top < ymin + ht)
			dy = ymin + ht - top

		/* draw the tempo indications */
		for (s = some_tempo; s; s = s.ts_next) {
			if (s.type != C.TEMPO
			 || s.del)		// (displayed by %%titleformat)
				continue
			if (user.anno_start || user.anno_stop) {
				s.wl = 16;
				s.wr = 30;
				s.ymn = (dosh & 1) ? h : y;
				s.ymx = s.ymn + 14;
				anno_start(s)
			}
			write_tempo(s, s.x - 16, (dosh & 1) ? h : y);
			anno_stop(s);
			dosh >>= 1
		}
	}

	/* then, put the parts */
/*fixme: should reduce vertical space if parts don't overlap tempo...*/
	ymin = staff_tb[st].topbar + 8
	for (s = tsfirst; s; s = s.ts_next) {
		if (s.type != C.PART)
			continue
		if (!some_part) {
			some_part = s;
			set_font("parts");
			h = gene.curfont.size + 2 + 2
						/* + cfmt.partsspace ?? */
		}
		w = strwh(s.text)[0];
		y = y_get(st, true, s.x - 10, w + 3)
		if (ymin < y)
			ymin = y
	}
	if (some_part) {
		set_sscale(-1)
		if (top < ymin + h + ht)
			dy = ymin + h + ht - top

		for (s = some_part; s; s = s.ts_next) {
			if (s.type != C.PART)
				continue
			s.x -= 10;
			if (user.anno_start || user.anno_stop) {
				w = strwh(s.text)[0];
				s.wl = 0;
				s.wr = w;
				s.ymn = -ht - h;
				s.ymx = s.ymn + h;
				anno_start(s)
			}
			if (cfmt.partsbox)
				xy_str_b(s.x, 2 - ht - h, s.text)
			else
				xy_str(s.x, 2 - ht - h, s.text)
			anno_stop(s)
		}
	}
	return dy
}
// abc2svg - draw.js - draw functions
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

// constants
var	STEM_MIN	= 16,	/* min stem height under beams */
	STEM_MIN2	= 14,	/* ... for notes with two beams */
	STEM_MIN3	= 12,	/* ... for notes with three beams */
	STEM_MIN4	= 10,	/* ... for notes with four beams */
	STEM_CH_MIN	= 14,	/* min stem height for chords under beams */
	STEM_CH_MIN2	= 10,	/* ... for notes with two beams */
	STEM_CH_MIN3	= 9,	/* ... for notes with three beams */
	STEM_CH_MIN4	= 9,	/* ... for notes with four beams */
	BEAM_DEPTH	= 3.2,	/* width of a beam stroke */
	BEAM_OFFSET	= .25,	/* pos of flat beam relative to staff line */
	BEAM_SHIFT	= 5,	/* shift of second and third beams */
	BEAM_SLOPE	= .4,	/* max slope of a beam */
	BEAM_STUB	= 8,	/* length of stub for flag under beam */ 
	SLUR_SLOPE	= .5,	/* max slope of a slur */
	GSTEM		= 15,	/* grace note stem length */
	GSTEM_XOFF	= 2.3	/* x offset for grace note stem */

    var cache

/* -- compute the best vertical offset for the beams -- */
function b_pos(grace, stem, nflags, b) {
	var	top, bot, d1, d2,
		shift = !grace ? BEAM_SHIFT : 3.5,
		depth = !grace ? BEAM_DEPTH : 1.8

	/* -- up/down shift needed to get k*6 -- */
	function rnd6(y) {
		var iy = Math.round((y + 12) / 6) * 6 - 12
		return iy - y
	} // rnd6()

	if (stem > 0) {
		bot = b - (nflags - 1) * shift - depth
		if (bot > 26)
			return 0
		top = b
	} else {
		top = b + (nflags - 1) * shift + depth
		if (top < -2)
			return 0
		bot = b
	}

	d1 = rnd6(top - BEAM_OFFSET);
	d2 = rnd6(bot + BEAM_OFFSET)
	return d1 * d1 > d2 * d2 ? d2 : d1
}

/* duplicate a note for beaming continuation */
function sym_dup(s_orig) {
	var	m, note,
		s = clone(s_orig);

	s.invis = true
	delete s.text
	delete s.a_gch
	delete s.a_ly
	delete s.a_dd;
	s.notes = clone(s_orig.notes)
	for (m = 0; m <= s.nhd; m++) {
		note = s.notes[m] = clone(s_orig.notes[m])
		delete note.a_dcn
	}
	return s
}

/* -- calculate a beam -- */
/* (the staves may be defined or not) */
var min_tb = [
	[STEM_MIN, STEM_MIN,
		STEM_MIN2, STEM_MIN3, STEM_MIN4, STEM_MIN4],
	[STEM_CH_MIN, STEM_CH_MIN,
		STEM_CH_MIN2, STEM_CH_MIN3, STEM_CH_MIN4, STEM_CH_MIN4]
]

function calculate_beam(bm, s1) {
	var	s, s2, notes, nflags, st, v, two_staves, two_dir,
		x, y, ys, a, b, stem_err, max_stem_err,
		p_min, p_max, s_closest,
		stem_xoff, scale,
		visible, dy

	if (!s1.beam_st) {	/* beam from previous music line */
		s = sym_dup(s1);
		lkvsym(s, s1);
		lktsym(s, s1);
		s.x -= 12
		if (s.x > s1.prev.x + 12)
			s.x = s1.prev.x + 12;
		s.beam_st = true
		delete s.beam_end;
		s.tmp = true
		delete s.slur_start
		delete s.slur_end;
		s1 = s
	}

	/* search last note in beam */
	notes = nflags = 0;	/* set x positions, count notes and flags */
	two_staves = two_dir = false;
	st = s1.st;
	v = s1.v;
	stem_xoff = s1.grace ? GSTEM_XOFF : 3.5
	for (s2 = s1;  ;s2 = s2.next) {
		if (s2.type == C.NOTE) {
			if (s2.nflags > nflags)
				nflags = s2.nflags;
			notes++
			if (s2.st != st)
				two_staves = true
			if (s2.stem != s1.stem)
				two_dir = true
			if (!visible && !s2.invis
			 && (!s2.stemless || s2.trem2))
				visible = true
			if (s2.beam_end)
				break
		}
		if (!s2.next) {		/* beam towards next music line */
			for (; ; s2 = s2.prev) {
				if (s2.type == C.NOTE)
					break
			}
			s = sym_dup(s2);
			s.next = s2.next
			if (s.next)
				s.next.prev = s;
			s2.next = s;
			s.prev = s2;
			s.ts_next = s2.ts_next
			if (s.ts_next)
				s.ts_next.ts_prev = s;
			s2.ts_next = s;
			s.ts_prev = s2
			delete s.beam_st;
			s.beam_end = true;
			s.tmp = true
			delete s.slur_start
			delete s.slur_end
			s.x += 12
			if (s.x < realwidth - 12)
				s.x = realwidth - 12;
			s2 = s;
			notes++
			break
		}
	}

	// at least, must have a visible note with a stem
	if (!visible)
		return false;

	bm.s2 = s2			/* (don't display the flags) */

	if (staff_tb[st].y == 0) {	/* staves not defined */
		if (two_staves)
			return false
	} else {			/* staves defined */
//		if (!two_staves && !s1.grace) {
		if (!two_staves) {
			bm.s1 = s1;	/* beam already calculated */
			bm.a = (s1.ys- s2.ys) / (s1.xs - s2.xs);
			bm.b = s1.ys - s1.xs * bm.a + staff_tb[st].y;
			bm.nflags = nflags
			return true
		}
	}

	s_closest = s1;
	p_min = 100;
	p_max = 0
	for (s = s1; ; s = s.next) {
		if (s.type != C.NOTE)
			continue
		if ((scale = s.p_v.scale) == 1)
			scale = staff_tb[s.st].staffscale
		if (s.stem >= 0) {
			x = stem_xoff + s.notes[0].shhd
			if (s.notes[s.nhd].pit > p_max) {
				p_max = s.notes[s.nhd].pit;
				s_closest = s
			}
		} else {
			x = -stem_xoff + s.notes[s.nhd].shhd
			if (s.notes[0].pit < p_min) {
				p_min = s.notes[0].pit;
				s_closest = s
			}
		}
		s.xs = s.x + x * scale;
		if (s == s2)
			break
	}

	// have flat beams when asked
	if (cfmt.flatbeams)
		a = 0

	// if a note inside the beam is the closest to the beam, the beam is flat
	else if (!two_dir
	      && notes >= 3
	      && s_closest != s1 && s_closest != s2)
		a = 0

	y = s1.ys + staff_tb[st].y
	if (a == undefined)
		a = (s2.ys + staff_tb[s2.st].y - y) / (s2.xs - s1.xs)

	if (a != 0) {
		if (a > 0)
			a = BEAM_SLOPE * a / (BEAM_SLOPE + a) // max steepness for beam
		else
			a = BEAM_SLOPE * a / (BEAM_SLOPE - a);
	}

	b = y - a * s1.xs;

/*fixme: have a look again*/
	/* have room for the symbols in the staff */
	max_stem_err = 0;		/* check stem lengths */
	s = s1
	if (two_dir) {				/* 2 directions */
/*fixme: more to do*/
		ys = ((s1.grace ? 3.5 : BEAM_SHIFT) * (nflags - 1) +
			BEAM_DEPTH) * .5
		if (s1.stem != s2.stem && s1.nflags < s2.nflags)
			ys *= s2.stem
		else
			ys *= s1.stem;
		b += ys
	} else if (!s1.grace) {		/* normal notes */
		var beam_h = BEAM_DEPTH + BEAM_SHIFT * (nflags - 1)
//--fixme: added for abc2svg
		while (s.ts_prev
		    && s.ts_prev.type == C.NOTE
		    && s.ts_prev.time == s.time
		    && s.ts_prev.x > s1.xs)
			s = s.ts_prev

		for (; s && s.time <= s2.time; s = s.ts_next) {
			if (s.type != C.NOTE
			 || s.invis
			 || (s.st != st
			  && s.v != v)) {
				continue
			}
			x = s.v == v ? s.xs : s.x;
			ys = a * x + b - staff_tb[s.st].y
			if (s.v == v) {
				stem_err = min_tb[s.nhd == 0 ? 0 : 1][s.nflags]
				if (s.stem > 0) {
					if (s.notes[s.nhd].pit > 26) {
						stem_err -= 2
						if (s.notes[s.nhd].pit > 28)
							stem_err -= 2
					}
					stem_err -= ys - 3 * (s.notes[s.nhd].pit - 18)
				} else {
					if (s.notes[0].pit < 18) {
						stem_err -= 2
						if (s.notes[0].pit < 16)
							stem_err -= 2
					}
					stem_err -= 3 * (s.notes[0].pit - 18) - ys
				}
				stem_err += BEAM_DEPTH + BEAM_SHIFT * (s.nflags - 1)
			} else {
/*fixme: KO when two_staves*/
				if (s1.stem > 0) {
					if (s.stem > 0) {
/*fixme: KO when the voice numbers are inverted*/
						if (s.ymn > ys + 4
						 || s.ymx < ys - beam_h - 2)
							continue
						if (s.v > v)
							stem_err = s.ymx - ys
						else
							stem_err = s.ymn + 8 - ys
					} else {
						stem_err = s.ymx - ys
					}
				} else {
					if (s.stem < 0) {
						if (s.ymx < ys - 4
						 || s.ymn > ys - beam_h - 2)
							continue
						if (s.v < v)
							stem_err = ys - s.ymn
						else
							stem_err = ys - s.ymx + 8
					} else {
						stem_err = ys - s.ymn
					}
				}
				stem_err += 2 + beam_h
			}
			if (stem_err > max_stem_err)
				max_stem_err = stem_err
		}
	} else {				/* grace notes */
		for ( ; ; s = s.next) {
			ys = a * s.xs + b - staff_tb[s.st].y;
			stem_err = GSTEM - 2
			if (s.stem > 0)
				stem_err -= ys - (3 * (s.notes[s.nhd].pit - 18))
			else
				stem_err += ys - (3 * (s.notes[0].pit - 18));
			stem_err += 3 * (s.nflags - 1)
			if (stem_err > max_stem_err)
				max_stem_err = stem_err
			if (s == s2)
				break
		}
	}

	if (max_stem_err > 0)		/* shift beam if stems too short */
		b += s1.stem * max_stem_err

	/* have room for the gracenotes, bars and clefs */
/*fixme: test*/
    if (!two_staves && !two_dir)
	for (s = s1.next; ; s = s.next) {
		var g
		switch (s.type) {
		case C.REST:		/* cannot move rests in multi-voices */
			g = s.ts_next
			if (!g || g.st != st
			 || (g.type != C.NOTE && g.type != C.REST))
				break
//fixme:too much vertical shift if some space above the note
//fixme:this does not fix rest under beam in second voice (ts_prev)
			/*fall thru*/
		case C.BAR:
			if (s.invis)
				break
			/*fall thru*/
		case C.CLEF:
			y = a * s.x + b
			if (s1.stem > 0) {
				y = s.ymx - y
					+ BEAM_DEPTH + BEAM_SHIFT * (nflags - 1)
					+ 2
				if (y > 0)
					b += y
			} else {
				y = s.ymn - y
					- BEAM_DEPTH - BEAM_SHIFT * (nflags - 1)
					- 2
				if (y < 0)
					b += y
			}
			break
		case C.GRACE:
			for (g = s.extra; g; g = g.next) {
				y = a * g.x + b
				if (s1.stem > 0) {
					y = g.ymx - y
						+ BEAM_DEPTH + BEAM_SHIFT * (nflags - 1)
						+ 2
					if (y > 0)
						b += y
				} else {
					y = g.ymn - y
						- BEAM_DEPTH - BEAM_SHIFT * (nflags - 1)
						- 2
					if (y < 0)
						b += y
				}
			}
			break
		}
		if (s == s2)
			break
	}

	if (a == 0)		/* shift flat beams onto staff lines */
		b += b_pos(s1.grace, s1.stem, nflags, b - staff_tb[st].y)

	/* adjust final stems and rests under beam */
	for (s = s1; ; s = s.next) {
		switch (s.type) {
		case C.NOTE:
			s.ys = a * s.xs + b - staff_tb[s.st].y
			if (s.stem > 0) {
				s.ymx = s.ys + 2.5
//fixme: hack
				if (s.ts_prev
				 && s.ts_prev.stem > 0
				 && s.ts_prev.st == s.st
				 && s.ts_prev.ymn < s.ymx
				 && s.ts_prev.x == s.x
				 && s.notes[0].shhd == 0) {
					s.ts_prev.x -= 3;	/* fix stem clash */
					s.ts_prev.xs -= 3
				}
			} else {
				s.ymn = s.ys - 2.5
			}
			break
		case C.REST:
			y = a * s.x + b - staff_tb[s.st].y
			dy = BEAM_DEPTH + BEAM_SHIFT * (nflags - 1)
				+ (s.head != C.FULL ? 4 : 9)
			if (s1.stem > 0) {
				y -= dy
				if (s1.multi == 0 && y > 12)
					y = 12
				if (s.y <= y)
					break
			} else {
				y += dy
				if (s1.multi == 0 && y < 12)
					y = 12
				if (s.y >= y)
					break
			}
			if (s.head != C.FULL)
				y = (((y + 3 + 12) / 6) | 0) * 6 - 12;
			s.y = y
			break
		}
		if (s == s2)
			break
	}

	/* save beam parameters */
	if (staff_tb[st].y == 0)	/* if staves not defined */
		return false
	bm.s1 = s1;
	bm.a = a;
	bm.b = b;
	bm.nflags = nflags
	return true
}

/* -- draw the beams for one word -- */
/* (the staves are defined) */
function draw_beams(bm) {
	var	s, i, beam_dir, shift, bshift, bstub, bh, da,
		k, k1, k2, x1,
		s1 = bm.s1,
		s2 = bm.s2

	/* -- draw a single beam -- */
	function draw_beam(x1, x2, dy, h, bm,
				 n) {		/* beam number (1..n) */
		var	y1, dy2,
			s = bm.s1,
			nflags = s.nflags

		if (s.ntrem)
			nflags -= s.ntrem
		if (s.trem2 && n > nflags) {
			if (s.dur >= C.BLEN / 2) {
				x1 = s.x + 6;
				x2 = bm.s2.x - 6
			} else if (s.dur < C.BLEN / 4) {
				x1 += 5;
				x2 -= 6
			}
		}

		y1 = bm.a * x1 + bm.b - dy;
		x2 -= x1;
	//--fixme: scale (bm.a already scaled!)
		x2 /= stv_g.scale;
		dy2 = bm.a * x2 * stv_g.scale;
		xypath(x1, y1, true);
		output += 'l' + x2.toFixed(2) + ' ' + (-dy2).toFixed(2) +
			'v' + h.toFixed(2) +
			'l' + (-x2).toFixed(2) + ' ' + dy2.toFixed(2) +
			'z"/>\n'
	} // draw_beam()

	anno_start(s1, 'beam')
/*fixme: KO if many staves with different scales*/
//	set_scale(s1)
	if (!s1.grace) {
		bshift = BEAM_SHIFT;
		bstub = BEAM_STUB;
		shift = .34;		/* (half width of the stem) */
		bh = BEAM_DEPTH
	} else {
		bshift = 3.5;
		bstub = 3.2;
		shift = .29;
		bh = 1.8
	}

/*fixme: quick hack for stubs at end of beam and different stem directions*/
	beam_dir = s1.stem
	if (s1.stem != s2.stem
	 && s1.nflags < s2.nflags)
		beam_dir = s2.stem
	if (beam_dir < 0)
		bh = -bh;

	/* make first beam over whole word and adjust the stem lengths */
	draw_beam(s1.xs - shift, s2.xs + shift, 0, bh, bm, 1);
	da = 0
	for (s = s1; ; s = s.next) {
		if (s.type == C.NOTE
		 && s.stem != beam_dir)
			s.ys = bm.a * s.xs + bm.b
				- staff_tb[s.st].y
				+ bshift * (s.nflags - 1) * s.stem
				- bh
		if (s == s2)
			break
	}

	if (s1.feathered_beam) {
		da = bshift / (s2.xs - s1.xs)
		if (s1.feathered_beam > 0) {
			da = -da;
			bshift = da * s1.xs
		} else {
			bshift = da * s2.xs
		}
		da = da * beam_dir
	}

	/* other beams with two or more flags */
	shift = 0
	for (i = 2; i <= bm.nflags; i++) {
		shift += bshift
		if (da != 0)
			bm.a += da
		for (s = s1; ; s = s.next) {
			if (s.type != C.NOTE
			 || s.nflags < i) {
				if (s == s2)
					break
				continue
			}
			if (s.trem1
			 && i > s.nflags - s.ntrem) {
				x1 = (s.dur >= C.BLEN / 2) ? s.x : s.xs;
				draw_beam(x1 - 5, x1 + 5,
					  (shift + 2.5) * beam_dir,
					  bh, bm, i)
				if (s == s2)
					break
				continue
			}
			k1 = s
			while (1) {
				if (s == s2)
					break
				k = s.next
				if (k.type == C.NOTE || k.type == C.REST) {
					if (k.trem1){
						if (k.nflags - k.ntrem < i)
							break
					} else if (k.nflags < i) {
						break
					}
				}
				if (k.beam_br1
				 || (k.beam_br2 && i > 2))
					break
				s = k
			}
			k2 = s
			while (k2.type != C.NOTE)
				k2 = k2.prev;
			x1 = k1.xs
			if (k1 == k2) {
				if (k1 == s1) {
					x1 += bstub
				} else if (k1 == s2) {
					x1 -= bstub
				} else if (k1.beam_br1
				        || (k1.beam_br2
					 && i > 2)) {
					x1 += bstub
				} else {
					k = k1.next
					while (k.type != C.NOTE)
						k = k.next
					if (k.beam_br1
					 || (k.beam_br2 && i > 2)) {
						x1 -= bstub
					} else {
						k1 = k1.prev
						while (k1.type != C.NOTE)
							k1 = k1.prev
						if (k1.nflags < k.nflags
						 || (k1.nflags == k.nflags
						  && k1.dots < k.dots))
							x1 += bstub
						else
							x1 -= bstub
					}
				}
			}
			draw_beam(x1, k2.xs,
				  shift * beam_dir,
				  bh, bm, i)
			if (s == s2)
				break
		}
	}
	if (s1.tmp)
		unlksym(s1)
	else if (s2.tmp)
		unlksym(s2)
	anno_stop(s1, 'beam')
}

/* -- draw the left side of the staves -- */
function draw_lstaff(x) {
//	if (cfmt.alignbars)
//		return
	var	i, j, yb, h,
		nst = cur_sy.nstaff,
		l = 0

	/* -- draw a system brace or bracket -- */
	function draw_sysbra(x, st, flag) {
		var i, st_end, yt, yb

		while (!cur_sy.st_print[st]) {
			if (cur_sy.staves[st].flags & flag)
				return
			st++
		}
		i = st_end = st
		while (1) {
			if (cur_sy.st_print[i])
				st_end = i
			if (cur_sy.staves[i].flags & flag)
				break
			i++
		}
		yt = staff_tb[st].y + staff_tb[st].topbar
					* staff_tb[st].staffscale;
		yb = staff_tb[st_end].y + staff_tb[st_end].botbar
					* staff_tb[st_end].staffscale
		if (flag & (CLOSE_BRACE | CLOSE_BRACE2))
			out_brace(x, yb, yt - yb)
		else
			out_bracket(x, yt, yt - yb)
	}

	for (i = 0; ; i++) {
		if (cur_sy.staves[i].flags & (OPEN_BRACE | OPEN_BRACKET))
			l++
		if (cur_sy.st_print[i])
			break
		if (cur_sy.staves[i].flags & (CLOSE_BRACE | CLOSE_BRACKET))
			l--
		if (i == nst)
			break
	}
	for (j = nst; j > i; j--) {
		if (cur_sy.st_print[j])
			break
	}
	if (i == j && l == 0)
		return
	yb = staff_tb[j].y + staff_tb[j].botbar * staff_tb[j].staffscale;
	h = staff_tb[i].y + staff_tb[i].topbar * staff_tb[i].staffscale - yb;
	xypath(x, yb);
	output += "v" + (-h).toFixed(2) + '"/>\n'
	for (i = 0; i <= nst; i++) {
		if (cur_sy.staves[i].flags & OPEN_BRACE)
			draw_sysbra(x, i, CLOSE_BRACE)
		if (cur_sy.staves[i].flags & OPEN_BRACKET)
			draw_sysbra(x, i, CLOSE_BRACKET)
		if (cur_sy.staves[i].flags & OPEN_BRACE2)
			draw_sysbra(x - 6, i, CLOSE_BRACE2)
		if (cur_sy.staves[i].flags & OPEN_BRACKET2)
			draw_sysbra(x - 6, i, CLOSE_BRACKET2)
	}
}

/* -- draw the time signature -- */
function draw_meter(x, s) {
	if (!s.a_meter)
		return
	var	dx, i, j, tmp1, tmp2,
		st = s.st,
		p_staff = staff_tb[st],
		y = p_staff.y;

	// adjust the vertical offset according to the staff definition
	if (p_staff.stafflines != '|||||')
		y += (p_staff.topbar + p_staff.botbar) / 2 - 12	// bottom

	for (i = 0; i < s.a_meter.length; i++) {
		var	f,
			meter = s.a_meter[i]

		x = s.x + s.x_meter[i]

		if (meter.bot) {
			tmp1 = tmp2 = ''
			for (j = 0; j < meter.top.length; j++)
				tmp1 += tgls["meter" + meter.top[j]].c
			for (j = 0; j < meter.bot.length; j++)
				tmp2 += tgls["meter" + meter.bot[j]].c;
			out_XYAB('<g transform="translate(X,Y)" text-anchor="middle">\n\
	<text y="-12">A</text>\n\
	<text>B</text>\n\
</g>\n', x, y + 6, tmp1, tmp2)
		} else {
			switch (meter.top[0]) {
			case 'C':
				f = meter.top[1] != '|' ? "csig" : "ctsig";
				x -= 5;
				y += 12
				break
			case 'c':
				f = meter.top[1] != '.' ? "imsig" : "iMsig"
				break
			case 'o':
				f = meter.top[1] != '.' ? "pmsig" : "pMsig"
				break
			default:
				tmp1 = ''
				for (j = 0; j < meter.top.length; j++)
					tmp1 += tgls["meter" + meter.top[j]].c;
				out_XYAB('\
<text x="X" y="Y" text-anchor="middle">A</text>\n',
					x, y + 12, tmp1)
				break
			}
		}
		if (f)
			xygl(x, y, f)
	}
}

/* -- draw an accidental -- */
function draw_acc(x, y, acc,
			micro_n,
			micro_d) {
	if (micro_n) {
		if (micro_n == micro_d) {
			acc = acc == -1 ?	// flat
				-2 : 2		// double flat : sharp
		} else if (micro_n * 2 != micro_d) {
			xygl(x, y, "acc" + acc + '_' + micro_n + '_' + micro_d)
			return
		}
	}
	xygl(x, y, "acc" + acc)
}

// draw helper lines between yl and yu
//fixme: double lines when needed for different voices
function draw_hl(x, yl, yu, st, hltype) {
    var	i, j,
	p_staff = staff_tb[st],
	staffb = p_staff.y,
	stafflines = p_staff.stafflines,
	top = (stafflines.length - 1) * 6,
	bot = p_staff.botline

	// no helper if no line
	if (!/[\[|]/.test(stafflines))
		return

	if (yl % 6)
		yl += 3
	if (yu % 6)
		yu -= 3
	if (stafflines.indexOf('-') >= 0	// if forced helper lines ('-')
	 && ((yl > bot && yl < top) || (yu > bot && yu < top)
	  || (yl <= bot && yu >= top))) {
		i = yl;
		j = yu
		while (i > bot && stafflines[i / 6] == '-')
			i -= 6
		while (j < top && stafflines[j / 6] == '-')
			j += 6
		for ( ; i < j; i += 6) {
			if (stafflines[i / 6] == '-')
				xygl(x, staffb + i, hltype)	// hole
		}
	}
	for (; yl < bot; yl += 6)
		xygl(x, staffb + yl, hltype)
	for (; yu > top; yu -= 6)
		xygl(x, staffb + yu, hltype)
}

/* -- draw a key signature -- */
var	sharp_cl = new Int8Array([24, 9, 15, 21, 6, 12, 18]),
	flat_cl = new Int8Array([12, 18, 24, 9, 15, 21, 6]),
	sharp1 = new Int8Array([-9, 12, -9, -9, 12, -9]),
	sharp2 = new Int8Array([12, -9, 12, -9, 12, -9]),
	flat1 = new Int8Array([9, -12, 9, -12, 9, -12]),
	flat2 = new Int8Array([-12, 9, -12, 9, -12, 9])

function draw_keysig(p_voice, x, s) {
	if (s.k_none)
		return
	var	old_sf = s.k_old_sf,
		st = p_voice.st,
		staffb = staff_tb[st].y,
		i, shift, p_seq,
		clef_ix = s.k_y_clef

	if (clef_ix & 1)
		clef_ix += 7;
	clef_ix /= 2
	while (clef_ix < 0)
		clef_ix += 7;
	clef_ix %= 7

	/* normal accidentals */
	if (!s.k_a_acc) {

		/* put neutrals if 'accidental cancel' */
		if (cfmt.cancelkey || s.k_sf == 0) {

			/* when flats to sharps, or sharps to flats, */
			if (s.k_sf == 0
			 || old_sf * s.k_sf < 0) {

				/* old sharps */
				shift = sharp_cl[clef_ix];
				p_seq = shift > 9 ? sharp1 : sharp2
				for (i = 0; i < old_sf; i++) {
					xygl(x, staffb + shift, "acc3");
					shift += p_seq[i];
					x += 5.5
				}

				/* old flats */
				shift = flat_cl[clef_ix];
				p_seq = shift < 18 ? flat1 : flat2
				for (i = 0; i > old_sf; i--) {
					xygl(x, staffb + shift, "acc3");
					shift += p_seq[-i];
					x += 5.5
				}
				if (s.k_sf != 0)
					x += 3		/* extra space */
			}
		}

		/* new sharps */
		if (s.k_sf > 0) {
			shift = sharp_cl[clef_ix];
			p_seq = shift > 9 ? sharp1 : sharp2
			for (i = 0; i < s.k_sf; i++) {
				xygl(x, staffb + shift, "acc1");
				shift += p_seq[i];
				x += 5.5
			}
			if (cfmt.cancelkey && i < old_sf) {
				x += 2
				for (; i < old_sf; i++) {
					xygl(x, staffb + shift, "acc3");
					shift += p_seq[i];
					x += 5.5
				}
			}
		}

		/* new flats */
		if (s.k_sf < 0) {
			shift = flat_cl[clef_ix];
			p_seq = shift < 18 ? flat1 : flat2
			for (i = 0; i > s.k_sf; i--) {
				xygl(x, staffb + shift, "acc-1");
				shift += p_seq[-i];
				x += 5.5
			}
			if (cfmt.cancelkey && i > old_sf) {
				x += 2
				for (; i > old_sf; i--) {
					xygl(x, staffb + shift, "acc3");
					shift += p_seq[-i];
					x += 5.5
				}
			}
		}
	} else if (s.k_a_acc.length) {

		/* explicit accidentals */
		var	acc,
			last_acc = s.k_a_acc[0].acc,
			last_shift = 100

		for (i = 0; i < s.k_a_acc.length; i++) {
			acc = s.k_a_acc[i];
			shift = (s.k_y_clef	// clef shift
				+ acc.pit - 18) * 3
			if (i != 0
			 && (shift > last_shift + 18
			  || shift < last_shift - 18))
				x -= 5.5		// no clash
			else if (acc.acc != last_acc)
				x += 3;
			last_acc = acc.acc;
			draw_hl(x, shift, shift, st, "hl");
			last_shift = shift;
			draw_acc(x, staffb + shift,
				 acc.acc, acc.micro_n, acc.micro_d);
			x += 5.5
		}
	}
}

/* -- convert the standard measure bars -- */
function bar_cnv(bar_type) {
	switch (bar_type) {
	case "[":
	case "[]":
		return ""			/* invisible */
	case "|:":
	case "|::":
	case "|:::":
		return "[" + bar_type		/* |::: -> [|::: */
	case ":|":
	case "::|":
	case ":::|":
		return bar_type + "]"		/* :..| -> :..|] */
	case "::":
		return cfmt.dblrepbar		/* :: -> double repeat bar */
	case '||:':
		return '[|:'
	}
	return bar_type
}

/* -- draw a measure bar -- */
function draw_bar(s, bot, h) {
	var	i, s2, yb, bar_type,
		st = s.st,
		p_staff = staff_tb[st],
		x = s.x

	bar_type = bar_cnv(s.bar_type)
	if (!bar_type)
		return				/* invisible */

	/* don't put a line between the staves if there is no bar above */
	if (st != 0
	 && s.ts_prev
//fixme: 's.ts_prev.st != st - 1' when floating voice in lower staff
//	 && (s.ts_prev.type != C.BAR || s.ts_prev.st != st - 1))
	 && s.ts_prev.type != C.BAR)
		h = p_staff.topbar * p_staff.staffscale;

	s.ymx = s.ymn + h;
	set_sscale(-1);
	anno_start(s)

	// compute the middle vertical offset of the staff
	yb = p_staff.y + 12;
	if (p_staff.stafflines != '|||||')
		yb += (p_staff.topbar + p_staff.botbar) / 2 - 12	// bottom

	/* if measure repeat, draw the '%' like glyphs */
	if (s.bar_mrep) {
		set_sscale(st)
		if (s.bar_mrep == 1) {
			for (s2 = s.prev; s2.type != C.REST; s2 = s2.prev)
				;
			xygl(s2.x, yb, "mrep")
		} else {
			xygl(x, yb, "mrep2")
			if (s.v == cur_sy.top_voice) {
				set_font("annotation");
				xy_str(x, yb + p_staff.topbar - 9,
						s.bar_mrep.toString(), "c")
			}
		}
	}

	for (i = bar_type.length; --i >= 0; ) {
		switch (bar_type[i]) {
		case "|":
			set_sscale(-1);
			out_bar(x, bot, h, s.bar_dotted)
			break
		default:
//		case "[":
//		case "]":
			x -= 3;
			set_sscale(-1);
			out_thbar(x, bot, h)
			break
		case ":":
			x -= 2;
			set_sscale(st);
			xygl(x + 1, yb - 12, "rdots")
			break
		}
		x -= 3
	}
	set_sscale(-1);
	anno_stop(s)
}

/* -- draw a rest -- */
/* (the staves are defined) */
var rest_tb = [
	"r128", "r64", "r32", "r16", "r8",
	"r4",
	"r2", "r1", "r0", "r00"]

function draw_rest(s) {
	var	s2, i, j, x, y, dotx, yb, yt, head,
		p_staff = staff_tb[s.st]

	/* don't display the rests of invisible staves */
	/* (must do this here for voices out of their normal staff) */
	if (!p_staff.topbar)
		return

	/* if rest alone in the measure or measure repeat, center */
	if (s.dur == s.p_v.meter.wmeasure
	 || (s.rep_nb && s.rep_nb >= 0)) {

		/* don't use next/prev: there is no bar in voice overlay */
		s2 = s.ts_next
		while (s2 && s2.time != s.time + s.dur)
			s2 = s2.ts_next;
		x = s2 ? s2.x : realwidth;
		s2 = s
		while (!s2.seqst)
			s2 = s2.ts_prev;
		s2 = s2.ts_prev;
		x = (x + s2.x) / 2

		/* center the associated decorations */
		if (s.a_dd)
			deco_update(s, x - s.x);
		s.x = x
	} else {
		x = s.x
		if (s.notes[0].shhd)
			x += s.notes[0].shhd * stv_g.scale
	}
	if (s.invis)
		return

	yb = p_staff.y			// bottom of staff

	if (s.rep_nb) {
		set_sscale(s.st);
		anno_start(s);
		if (p_staff.stafflines == '|||||')
			yb += 12
		else
			yb += (p_staff.topbar + p_staff.botbar) / 2
		if (s.rep_nb < 0) {
			xygl(x, yb, "srep")
		} else {
			xygl(x, yb, "mrep")
			if (s.rep_nb > 2 && s.v == cur_sy.top_voice) {
				set_font("annotation");
				xy_str(x, yb + p_staff.topbar - 9,
					s.rep_nb.toString(), "c")
			}
		}
		anno_stop(s)
		return
	}

	set_scale(s);
	anno_start(s);

	y = s.y;

	i = 5 - s.nflags		/* rest_tb index (5 = C_XFLAGS) */
	if (i == 7 && y == 12
	 && p_staff.stafflines.length <= 2)
		y -= 6				/* semibreve a bit lower */

	// draw the rest
	xygl(x, y + yb, s.notes[0].head ? s.notes[0].head : rest_tb[i])

	/* output ledger line(s) when greater than minim */
	if (i >= 6) {
		j = y / 6
		switch (i) {
		default:
			switch (p_staff.stafflines[j + 1]) {
			case '|':
			case '[':
				break
			default:
				xygl(x, y + 6 + yb, "hl1")
				break
			}
			if (i == 9) {			/* longa */
				y -= 6;
				j--
			}
			break
		case 7:					/* semibreve */
			y += 6;
			j++
		case 6:					/* minim */
			break
		}
		switch (p_staff.stafflines[j]) {
		case '|':
		case '[':
			break
		default:
			xygl(x, y + yb, "hl1")
			break
		}
	}
	x += 8;
	y += yb + 3
	for (i = 0; i < s.dots; i++) {
		xygl(x, y, "dot");
		x += 3.5
	}
	anno_stop(s)
}

/* -- draw grace notes -- */
/* (the staves are defined) */
function draw_gracenotes(s) {
	var	yy, x0, y0, x1, y1, x2, y2, x3, y3, bet1, bet2,
		dy1, dy2, g, last, note,
		bm = {}

	/* draw the notes */
//	bm.s2 = undefined			/* (draw flags) */
	for (g = s.extra; g; g = g.next) {
		if (g.beam_st && !g.beam_end) {
			if (calculate_beam(bm, g))
				draw_beams(bm)
		}
		anno_start(g);
		draw_note(g, !bm.s2)
		if (g == bm.s2)
			bm.s2 = null			/* (draw flags again) */
		anno_stop(g)
		if (!g.next)
			break			/* (keep the last note) */
	}

	// if an acciaccatura, draw a bar 
	if (s.sappo) {
		g = s.extra
		if (!g.next) {			/* if one note */
			x1 = 9;
			y1 = g.stem > 0 ? 5 : -5
		} else {			/* many notes */
			x1 = (g.next.x - g.x) * .5 + 4;
			y1 = (g.ys + g.next.ys) * .5 - g.y
			if (g.stem > 0)
				y1 -= 1
			else
				y1 += 1
		}
		note = g.notes[g.stem < 0 ? 0 : g.nhd];
		out_acciac(x_head(g, note), y_head(g, note),
				x1, y1, g.stem > 0)
	}

	/* slur */
//fixme: have a full key symbol in voice
	if (s.p_v.key.k_bagpipe			/* no slur when bagpipe */
	 || !cfmt.graceslurs
	 || s.slur_start			/* explicit slur */
	 || !s.next
	 || s.next.type != C.NOTE)
		return
	last = g
	if (last.stem >= 0) {
		yy = 127
		for (g = s.extra; g; g = g.next) {
			if (g.y < yy) {
				yy = g.y;
				last = g
			}
		}
		x0 = last.x;
		y0 = last.y - 5
		if (s.extra != last) {
			x0 -= 4;
			y0 += 1
		}
		s = s.next;
		x3 = s.x - 1
		if (s.stem < 0)
			x3 -= 4;
		y3 = 3 * (s.notes[0].pit - 18) - 5;
		dy1 = (x3 - x0) * .4
		if (dy1 > 3)
			dy1 = 3;
		dy2 = dy1;
		bet1 = .2;
		bet2 = .8
		if (y0 > y3 + 7) {
			x0 = last.x - 1;
			y0 += .5;
			y3 += 6.5;
			x3 = s.x - 5.5;
			dy1 = (y0 - y3) * .8;
			dy2 = (y0 - y3) * .2;
			bet1 = 0
		} else if (y3 > y0 + 4) {
			y3 = y0 + 4;
			x0 = last.x + 2;
			y0 = last.y - 4
		}
	} else {
		yy = -127
		for (g = s.extra; g; g = g.next) {
			if (g.y > yy) {
				yy = g.y;
				last = g
			}
		}
		x0 = last.x;
		y0 = last.y + 5
		if (s.extra != last) {
			x0 -= 4;
			y0 -= 1
		}
		s = s.next;
		x3 = s.x - 1
		if (s.stem >= 0)
			x3 -= 2;
		y3 = 3 * (s.notes[s.nhd].pit - 18) + 5;
		dy1 = (x0 - x3) * .4
		if (dy1 < -3)
			dy1 = -3;
		dy2 = dy1;
		bet1 = .2;
		bet2 = .8
		if (y0 < y3 - 7) {
			x0 = last.x - 1;
			y0 -= .5;
			y3 -= 6.5;
			x3 = s.x - 5.5;
			dy1 = (y0 - y3) * .8;
			dy2 = (y0 - y3) * .2;
			bet1 = 0
		} else if (y3 < y0 - 4) {
			y3 = y0 - 4;
			x0 = last.x + 2;
			y0 = last.y + 4
		}
	}

	x1 = bet1 * x3 + (1 - bet1) * x0 - x0;
	y1 = bet1 * y3 + (1 - bet1) * y0 - dy1 - y0;
	x2 = bet2 * x3 + (1 - bet2) * x0 - x0;
	y2 = bet2 * y3 + (1 - bet2) * y0 - dy2 - y0;

	anno_start(s, 'slur');
	xypath(x0, y0 + staff_tb[s.st].y);
	output += 'c' + x1.toFixed(2) + ' ' + (-y1).toFixed(2) +
		' ' + x2.toFixed(2) + ' ' + (-y2).toFixed(2) +
		' ' + (x3 - x0).toFixed(2) + ' ' + (-y3 + y0).toFixed(2) + '"/>\n';
	anno_stop(s, 'slur')
}

/* -- set the y offset of the dots -- */
function setdoty(s, y_tb) {
	var m, m1, y

	/* set the normal offsets */
	for (m = 0; m <= s.nhd; m++) {
		y = 3 * (s.notes[m].pit - 18)	/* note height on staff */
		if ((y % 6) == 0) {
			if (s.dot_low)
				y -= 3
			else
				y += 3
		}
		y_tb[m] = y
	}
	/* dispatch and recenter the dots in the staff spaces */
	for (m = 0; m < s.nhd; m++) {
		if (y_tb[m + 1] > y_tb[m])
			continue
		m1 = m
		while (m1 > 0) {
			if (y_tb[m1] > y_tb[m1 - 1] + 6)
				break
			m1--
		}
		if (3 * (s.notes[m1].pit - 18) - y_tb[m1]
				< y_tb[m + 1] - 3 * (s.notes[m + 1].pit - 18)) {
			while (m1 <= m)
				y_tb[m1++] -= 6
		} else {
			y_tb[m + 1] = y_tb[m] + 6
		}
	}
}

// get the x and y position of a note head
// (when the staves are defined)
function x_head(s, note) {
	return s.x + note.shhd * stv_g.scale
}
function y_head(s, note) {
	return staff_tb[s.st].y + 3 * (note.pit - 18)
}

/* -- draw m-th head with accidentals and dots -- */
/* (the staves are defined) */
// sets {x,y}_note
function draw_basic_note(x, s, m, y_tb) {
	var	i, k, p, yy, dotx, doty,
		old_color = false,
		note = s.notes[m],
		staffb = staff_tb[s.st].y,	/* bottom of staff */
		y = 3 * (note.pit - 18),	/* note height on staff */
		shhd = note.shhd * stv_g.scale,
		x_note = x + shhd,
		y_note = y + staffb

//	/* special case for voice unison */
//	if (s.nohdi1 != undefined
//	 && m >= s.nohdi1 && m < s.nohdi2)
//		return

	var	elts = identify_note(s, note.dur),
		head = elts[0],
		dots = elts[1],
		nflags = elts[2]

	/* output a ledger line if horizontal shift / chord
	 * and note on a line */
	if (y % 6 == 0
	 && shhd != (s.stem > 0 ? s.notes[0].shhd : s.notes[s.nhd].shhd)) {
		yy = 0
		if (y >= 30) {
			yy = y
			if (yy % 6)
				yy -= 3
		} else if (y <= -6) {
			yy = y
			if (yy % 6)
				yy += 3
		}
		if (yy)
			xygl(x_note, yy + staffb, "hl")
	}

	/* draw the head */
	if (note.invis) {
		;
	} else if (s.grace) {			// don't apply %%map to grace notes
		p = "ghd";
		x_note -= 4.5 * stv_g.scale
	} else if (note.map && note.map[0]) {
		i = s.head;
		p = note.map[0][i]		// heads
		if (!p)
			p = note.map[0][note.map[0].length - 1]
		i = p.indexOf('/')
		if (i >= 0) {			// stem dependant
			if (s.stem >= 0)
				p = p.slice(0, i)
			else
				p = p.slice(i + 1)
		}
	} else if (s.type == C.CUSTOS) {
		p = "custos"
	} else {
		switch (head) {
		case C.OVAL:
			p = "HD"
			break
		case C.OVALBARS:
			if (s.head != C.SQUARE) {
				p = "HDD"
				break
			}
			// fall thru
		case C.SQUARE:
			p = note.dur < C.BLEN * 4 ? "breve" : "longa"

			/* don't display dots on last note of the tune */
			if (!tsnext && s.next
			 && s.next.type == C.BAR && !s.next.next)
				dots = 0
			break
		case C.EMPTY:
			p = "Hd"		// white note
			break
		default:			// black note
			p = "hd"
			break
		}
	}
	if (note.color != undefined)
		old_color = set_color(note.color)
	else if (note.map && note.map[2])
		old_color = set_color(note.map[2])
	if (p) {
		if (!psxygl(x_note, y_note, p))
			xygl(x_note, y_note, p)
	}

	/* draw the dots */
/*fixme: to see for grace notes*/
	if (dots) {
		dotx = x + (7.7 + s.xmx) * stv_g.scale
		if (y_tb[m] == undefined) {
			y_tb[m] = 3 * (s.notes[m].pit - 18)
			if ((s.notes[m].pit & 1) == 0)
				y_tb[m] += 3
		}
		doty = y_tb[m] + staffb
		while (--dots >= 0) {
			xygl(dotx, doty, "dot");
			dotx += 3.5
		}
	}

	/* draw the accidental */
	if (note.acc) {
		x -= note.shac * stv_g.scale
		if (!s.grace) {
			draw_acc(x, y + staffb,
				 note.acc, note.micro_n, note.micro_d)
		} else {
			g_open(x, y + staffb, 0, .75);
			draw_acc(0, 0, note.acc, note.micro_n, note.micro_d);
			g_close()
		}
	}
	if (old_color != undefined)
		set_color(old_color)
}

/* -- draw a note or a chord -- */
/* (the staves are defined) */
function draw_note(s,
		   fl) {		// draw flags
	var	s2, i, m, y, staffb, slen, c, hltype, nflags,
		x, y, note,
		y_tb = new Array(s.nhd + 1)

	if (s.dots)
		setdoty(s, y_tb)

	note = s.notes[s.stem < 0 ? s.nhd : 0];	// master note head
	x = x_head(s, note);
	staffb = staff_tb[s.st].y

	/* output the ledger lines */
	if (s.grace) {
		hltype = "ghl"
	} else {
		switch (s.head) {
		default:
			hltype = "hl"
			break
		case C.OVAL:
		case C.OVALBARS:
			hltype = "hl1"
			break
		case C.SQUARE:
			hltype = "hl2"
			break
		}
	}
	draw_hl(x, 3 * (s.notes[0].pit - 18), 3 * (s.notes[s.nhd].pit - 18),
		s.st, hltype)

	/* draw the stem and flags */
	y = y_head(s, note)
	if (!s.stemless) {
		slen = s.ys - s.y;
		nflags = s.nflags
		if (s.ntrem)
			nflags -= s.ntrem
		if (!fl || nflags <= 0) {	/* stem only */
			if (s.nflags > 0) {	/* (fix for PS low resolution) */
				if (s.stem >= 0)
					slen -= 1
				else
					slen += 1
			}
			out_stem(x, y, slen, s.grace)
		} else {				/* stem and flags */
			out_stem(x, y, slen, s.grace,
				 nflags, cfmt.straightflags)
		}
	} else if (s.xstem) {				/* cross-staff stem */
		s2 = s.ts_prev;
		slen = (s2.stem > 0 ? s2.y : s2.ys) - s.y;
		slen += staff_tb[s2.st].y - staffb;
/*fixme:KO when different scales*/
		slen /= s.p_v.scale;
		out_stem(x, y, slen)
	}

	/* draw the tremolo bars */
	if (fl && s.trem1) {
		var	ntrem = s.ntrem || 0,
			x1 = x;
		slen = 3 * (s.notes[s.stem > 0 ? s.nhd : 0].pit - 18)
		if (s.head == C.FULL || s.head == C.EMPTY) {
			x1 += (s.grace ? GSTEM_XOFF : 3.5) * s.stem
			if (s.stem > 0)
				slen += 6 + 5.4 * ntrem
			else
				slen -= 6 + 5.4
		} else {
			if (s.stem > 0)
				slen += 5 + 5.4 * ntrem
			else
				slen -= 5 + 5.4
		}
		slen /= s.p_v.scale;
		out_trem(x1, staffb + slen, ntrem)
	}

	/* draw the note heads */
	x = s.x
	for (m = 0; m <= s.nhd; m++)
		draw_basic_note(x, s, m, y_tb)
}

/* -- find where to terminate/start a slur -- */
function next_scut(s) {
	var prev = s

	for (s = s.next; s; s = s.next) {
		if (s.rbstop)
			return s
		prev = s
	}
	/*fixme: KO when no note for this voice at end of staff */
	return prev
}

function prev_scut(s) {
	while (s.prev) {
		s = s.prev
		if (s.rbstart)
			return s
	}

	/* return a symbol of any voice starting before the start of the voice */
	s = s.p_v.sym
	while (s.type != C.CLEF)
		s = s.ts_prev		/* search a main voice */
	if (s.next && s.next.type == C.KEY)
		s = s.next
	if (s.next && s.next.type == C.METER)
		return s.next
	return s
}

/* -- decide whether a slur goes up or down -- */
function slur_direction(k1, k2) {
	var s, some_upstem, low

	if (k1.grace && k1.stem > 0)
		return -1

	for (s = k1; ; s = s.next) {
		if (s.type == C.NOTE) {
			if (!s.stemless) {
				if (s.stem < 0)
					return 1
				some_upstem = true
			}
			if (s.notes[0].pit < 22)	/* if under middle staff */
				low = true
		}
		if (s == k2)
			break
	}
	if (!some_upstem && !low)
		return 1
	return -1
}

/* -- output a slur / tie -- */
function slur_out(x1, y1, x2, y2, dir, height, dotted) {
	var	dx, dy, dz,
		alfa = .3,
		beta = .45;

	/* for wide flat slurs, make shape more square */
	dy = y2 - y1
	if (dy < 0)
		dy = -dy;
	dx = x2 - x1
	if (dx > 40. && dy / dx < .7) {
		alfa = .3 + .002 * (dx - 40.)
		if (alfa > .7)
			alfa = .7
	}

	/* alfa, beta, and height determine Bezier control points pp1,pp2
	 *
	 *           X====alfa===|===alfa=====X
	 *	    /		 |	       \
	 *	  pp1		 |	        pp2
	 *	  /	       height		 \
	 *	beta		 |		 beta
	 *      /		 |		   \
	 *    p1		 m		     p2
	 *
	 */

	var	mx = .5 * (x1 + x2),
		my = .5 * (y1 + y2),
		xx1 = mx + alfa * (x1 - mx),
		yy1 = my + alfa * (y1 - my) + height;
	xx1 = x1 + beta * (xx1 - x1);
	yy1 = y1 + beta * (yy1 - y1)

	var	xx2 = mx + alfa * (x2 - mx),
		yy2 = my + alfa * (y2 - my) + height;
	xx2 = x2 + beta * (xx2 - x2);
	yy2 = y2 + beta * (yy2 - y2);

	dx = .03 * (x2 - x1);
//	if (dx > 10.)
//		dx = 10.
//	dy = 1.6 * dir
	dy = 2 * dir;
	dz = .2 + .001 * (x2 - x1)
	if (dz > .6)
		dz = .6;
	dz *= dir
	
	var scale_y = stv_g.v ? stv_g.scale : 1
	if (!dotted)
		output += '<path class="fill" d="M'
	else
		output += '<path class="stroke" stroke-dasharray="5,5" d="M';
	out_sxsy(x1, ' ', y1);
	output += 'c' +
		((xx1 - x1) / stv_g.scale).toFixed(2) + ' ' +
		((y1 - yy1) / scale_y).toFixed(2) + ' ' +
		((xx2 - x1) / stv_g.scale).toFixed(2) + ' ' +
		((y1 - yy2) / scale_y).toFixed(2) + ' ' +
		((x2 - x1) / stv_g.scale).toFixed(2) + ' ' +
		((y1 - y2) / scale_y).toFixed(2)

	if (!dotted)
		output += '\n\tv' +
			(-dz).toFixed(2) + 'c' +
			((xx2 - dx - x2) / stv_g.scale).toFixed(2) + ' ' +
			((y2 + dz - yy2 - dy) / scale_y).toFixed(2) + ' ' +
			((xx1 + dx - x2) / stv_g.scale).toFixed(2) + ' ' +
			((y2 + dz - yy1 - dy) / scale_y).toFixed(2) + ' ' +
			((x1 - x2) / stv_g.scale).toFixed(2) + ' ' +
			((y2 + dz - y1) / scale_y).toFixed(2);
	output += '"/>\n'
}

/* -- check if slur sequence in a multi-voice staff -- */
function slur_multi(k1, k2) {
	while (1) {
		if (k1.multi)		/* if multi voice */
			/*fixme: may change*/
			return k1.multi
		if (k1 == k2)
			break
		k1 = k1.next
	}
	return 0
}

/* -- draw a phrasing slur between two symbols -- */
/* (the staves are not yet defined) */
/* (delayed output) */
/* (not a pretty routine, this) */
function draw_slur(k1_o, k2, m1, m2, slur_type) {
	var	k1 = k1_o,
		k, g, x1, y1, x2, y2, height, addy,
		a, y, z, h, dx, dy, dir

	while (k1.v != k2.v)
		k1 = k1.ts_next
/*fixme: if two staves, may have upper or lower slur*/
	switch (slur_type & 0x07) {	/* (ignore dotted flag) */
	case C.SL_ABOVE: dir = 1; break
	case C.SL_BELOW: dir = -1; break
	default:
		dir = slur_multi(k1, k2)
		if (!dir)
			dir = slur_direction(k1, k2)
		break
	}

	var	nn = 1,
		upstaff = k1.st,
		two_staves = false

	if (k1 != k2) {
		k = k1.next
		while (1) {
			if (k.type == C.NOTE || k.type == C.REST) {
				nn++
				if (k.st != upstaff) {
					two_staves = true
					if (k.st < upstaff)
						upstaff = k.st
				}
			}
			if (k == k2)
				break
			k = k.next
		}
	}
/*fixme: KO when two staves*/
if (two_staves) error(2, k1, "*** multi-staves slurs not treated yet");

	/* fix endpoints */
	x1 = k1_o.x
	if (k1_o.notes && k1_o.notes[0].shhd)
		x1 += k1_o.notes[0].shhd
	if (k1_o != k2) {
		x2 = k2.x
		if (k2.notes)
			x2 += k2.notes[0].shhd
	} else {		/* (the slur starts on last note of the line) */
		for (k = k2.ts_next; k; k = k.ts_next)
//fixme: must check if the staff continues
			if (k.type == C.STAVES)
				break
		x2 = k ? k.x : realwidth
	}

	if (m1 >= 0) {
		y1 = 3 * (k1.notes[m1].pit - 18) + 5 * dir
	} else {
		y1 = dir > 0 ? k1.ymx + 2 : k1.ymn - 2
		if (k1.type == C.NOTE) {
			if (dir > 0) {
				if (k1.stem > 0) {
					x1 += 5
					if (k1.beam_end
					 && k1.nflags >= -1	/* if with a stem */
//fixme: check if at end of tuplet
					 && !k1.in_tuplet) {
//					  || k1.ys > y1 - 3)) {
						if (k1.nflags > 0) {
							x1 += 2;
							y1 = k1.ys - 3
						} else {
							y1 = k1.ys - 6
						}
// don't clash with decorations
//					} else {
//						y1 = k1.ys + 3
					}
//				} else {
//					y1 = k1.y + 8
				}
			} else {
				if (k1.stem < 0) {
					x1 -= 1
					if (k2.grace) {
						y1 = k1.y - 8
					} else if (k1.beam_end
						&& k1.nflags >= -1
						&& (!k1.in_tuplet
						 || k1.ys < y1 + 3)) {
						if (k1.nflags > 0) {
							x1 += 2;
							y1 = k1.ys + 3
						} else {
							y1 = k1.ys + 6
						}
//					} else {
//						y1 = k1.ys - 3
					}
//				} else {
//					y1 = k1.y - 8
				}
			}
		}
	}
	if (m2 >= 0) {
		y2 = 3 * (k2.notes[m2].pit - 18) + 5 * dir
	} else {
		y2 = dir > 0 ? k2.ymx + 2 : k2.ymn - 2
		if (k2.type == C.NOTE) {
			if (dir > 0) {
				if (k2.stem > 0) {
					x2 += 1
					if (k2.beam_st
					 && k2.nflags >= -1
					 && !k2.in_tuplet)
//						|| k2.ys > y2 - 3))
						y2 = k2.ys - 6
//					else
//						y2 = k2.ys + 3
//				} else {
//					y2 = k2.y + 8
				}
			} else {
				if (k2.stem < 0) {
					x2 -= 5
					if (k2.beam_st
					 && k2.nflags >= -1
					 && !k2.in_tuplet)
//						|| k2.ys < y2 + 3))
						y2 = k2.ys + 6
//					else
//						y2 = k2.ys - 3
//				} else {
//					y2 = k2.y - 8
				}
			}
		}
	}

	if (k1.type != C.NOTE) {
		y1 = y2 + 1.2 * dir;
		x1 = k1.x + k1.wr * .5
		if (x1 > x2 - 12)
			x1 = x2 - 12
	}

	if (k2.type != C.NOTE) {
		if (k1.type == C.NOTE)
			y2 = y1 + 1.2 * dir
		else
			y2 = y1
		if (k1 != k2)
			x2 = k2.x - k2.wl * .3
	}

	if (nn >= 3) {
		if (k1.next.type != C.BAR
		 && k1.next.x < x1 + 48) {
			if (dir > 0) {
				y = k1.next.ymx - 2
				if (y1 < y)
					y1 = y
			} else {
				y = k1.next.ymn + 2
				if (y1 > y)
					y1 = y
			}
		}
		if (k2.prev
		 && k2.prev.type != C.BAR
		 && k2.prev.x > x2 - 48) {
			if (dir > 0) {
				y = k2.prev.ymx - 2
				if (y2 < y)
					y2 = y
			} else {
				y = k2.prev.ymn + 2
				if (y2 > y)
					y2 = y
			}
		}
	}

	a = (y2 - y1) / (x2 - x1)		/* slur steepness */
	if (a > SLUR_SLOPE || a < -SLUR_SLOPE) {
		a = a > SLUR_SLOPE ? SLUR_SLOPE : -SLUR_SLOPE
		if (a * dir > 0)
			y1 = y2 - a * (x2 - x1)
		else
			y2 = y1 + a * (x2 - x1)
	}

	/* for big vertical jump, shift endpoints */
	y = y2 - y1
	if (y > 8)
		y = 8
	else if (y < -8)
		y = -8
	z = y
	if (z < 0)
		z = -z;
	dx = .5 * z;
	dy = .3 * y
	if (y * dir > 0) {
		x2 -= dx;
		y2 -= dy
	} else {
		x1 += dx;
		y1 += dy
	}

	/* special case for grace notes */
	if (k1.grace)
		x1 = k1.x - GSTEM_XOFF * .5
	if (k2.grace)
		x2 = k2.x + GSTEM_XOFF * 1.5;

	h = 0;
	a = (y2 - y1) / (x2 - x1)
	if (k1 != k2
	 && k1.v == k2.v) {
	    addy = y1 - a * x1
	    for (k = k1.next; k != k2 ; k = k.next) {
		if (k.st != upstaff)
			continue
		switch (k.type) {
		case C.NOTE:
		case C.REST:
			if (dir > 0) {
				y = 3 * (k.notes[k.nhd].pit - 18) + 6
				if (y < k.ymx)
					y = k.ymx;
				y -= a * k.x + addy
				if (y > h)
					h = y
			} else {
				y = 3 * (k.notes[0].pit - 18) - 6
				if (y > k.ymn)
					y = k.ymn;
				y -= a * k.x + addy
				if (y < h)
					h = y
			}
			break
		case C.GRACE:
			for (g = k.extra; g; g = g.next) {
				if (dir > 0) {
					y = 3 * (g.notes[g.nhd].pit - 18) + 6
					if (y < g.ymx)
						y = g.ymx;
					y -= a * g.x + addy
					if (y > h)
						h = y
				} else {
					y = 3 * (g.notes[0].pit - 18) - 6
					if (y > g.ymn)
						y = g.ymn;
					y -= a * g.x + addy
					if (y < h)
						h = y
				}
			}
			break
		}
	    }
	    y1 += .45 * h;
	    y2 += .45 * h;
	    h *= .65
	}

	if (nn > 3)
		height = (.08 * (x2 - x1) + 12) * dir
	else
		height = (.03 * (x2 - x1) + 8) * dir
	if (dir > 0) {
		if (height < 3 * h)
			height = 3 * h
		if (height > 40)
			height = 40
	} else {
		if (height > 3 * h)
			height = 3 * h
		if (height < -40)
			height = -40
	}

	y = y2 - y1
	if (y < 0)
		y = -y
	if (dir > 0) {
		if (height < .8 * y)
			height = .8 * y
	} else {
		if (height > -.8 * y)
			height = -.8 * y
	}
	height *= cfmt.slurheight;

//	anno_start(k1_o, 'slur');
	slur_out(x1, y1, x2, y2, dir, height, slur_type & C.SL_DOTTED);
//	anno_stop(k1_o, 'slur');

	/* have room for other symbols */
	dx = x2 - x1;
	a = (y2 - y1) / dx;
/*fixme: it seems to work with .4, but why?*/
	addy = y1 - a * x1 + .4 * height
	if (k1.v == k2.v)
	    for (k = k1; k != k2; k = k.next) {
		if (k.st != upstaff)
			continue
		y = a * k.x + addy
		if (k.ymx < y)
			k.ymx = y
		else if (k.ymn > y)
			k.ymn = y
		if (k.next == k2) {
			dx = x2
			if (k2.sl1)
				dx -= 5
		} else {
			dx = k.next.x
		}
		if (k != k1)
			x1 = k.x;
		dx -= x1;
		y_set(upstaff, dir > 0, x1, dx, y)
	}
	return (dir > 0 ? C.SL_ABOVE : C.SL_BELOW) | (slur_type & C.SL_DOTTED)
}

/* -- draw the slurs between 2 symbols --*/
function draw_slurs(first, last) {
	var	s1, k, gr1, gr2, i, m1, m2, slur_type, cont,
		s = first

	while (1) {
		if (!s || s == last) {
			if (!gr1
			 || !(s = gr1.next)
			 || s == last)
				break
			gr1 = null
		}
		if (s.type == C.GRACE) {
			gr1 = s;
			s = s.extra
			continue
		}
		if ((s.type != C.NOTE && s.type != C.REST
		  && s.type != C.SPACE)
		 || (!s.slur_start && !s.sl1)) {
			s = s.next
			continue
		}
		k = null;		/* find matching slur end */
		s1 = s.next
		var gr1_out = false
		while (1) {
			if (!s1) {
				if (gr2) {
					s1 = gr2.next;
					gr2 = null
					continue
				}
				if (!gr1 || gr1_out)
					break
				s1 = gr1.next;
				gr1_out = true
				continue
			}
			if (s1.type == C.GRACE) {
				gr2 = s1;
				s1 = s1.extra
				continue
			}
			if (s1.type == C.BAR
			 && (s1.bar_type[0] == ':'
			  || s1.bar_type == "|]"
			  || s1.bar_type == "[|"
			  || (s1.text && s1.text[0] != '1'))) {
				k = s1
				break
			}
			if (s1.type != C.NOTE && s1.type != C.REST
			 && s1.type != C.SPACE) {
				s1 = s1.next
				continue
			}
			if (s1.slur_end || s1.sl2) {
				k = s1
				break
			}
			if (s1.slur_start || s1.sl1) {
				if (gr2) {	/* if in grace note sequence */
					for (k = s1; k.next; k = k.next)
						;
					k.next = gr2.next
					if (gr2.next)
						gr2.next.prev = k;
//					gr2.slur_start = C.SL_AUTO
					k = null
				}
				draw_slurs(s1, last)
				if (gr2
				 && gr2.next) {
					gr2.next.prev.next = null;
					gr2.next.prev = gr2
				}
			}
			if (s1 == last)
				break
			s1 = s1.next
		}
		if (!s1) {
			k = next_scut(s)
		} else if (!k) {
			s = s1
			if (s == last)
				break
			continue
		}

		/* if slur in grace note sequence, change the linkages */
		if (gr1) {
			for (s1 = s; s1.next; s1 = s1.next)
				;
			s1.next = gr1.next
			if (gr1.next)
				gr1.next.prev = s1;
			gr1.slur_start = C.SL_AUTO
		}
		if (gr2) {
			gr2.prev.next = gr2.extra;
			gr2.extra.prev = gr2.prev;
			gr2.slur_start = C.SL_AUTO
		}
		if (s.slur_start) {
			slur_type = s.slur_start & 0x0f;
			s.slur_start >>= 4;
			m1 = -1
		} else {
			for (m1 = 0; m1 <= s.nhd; m1++)
				if (s.notes[m1].sl1)
					break
			slur_type = s.notes[m1].sl1 & 0x0f;
			s.notes[m1].sl1 >>= 4;
			s.sl1--
		}
		m2 = -1;
		cont = 0
		if ((k.type == C.NOTE || k.type == C.REST || k.type == C.SPACE) &&
		    (k.slur_end || k.sl2)) {
			if (k.slur_end) {
				k.slur_end--
			} else {
				for (m2 = 0; m2 <= k.nhd; m2++)
					if (k.notes[m2].sl2)
						break
				k.notes[m2].sl2--;
				k.sl2--
			}
		} else {
			if (k.type != C.BAR
			 || (k.bar_type[0] != ':'
			  && k.bar_type != "|]"
			  && k.bar_type != "[|"
			  && (!k.text || k.text[0] == '1')))
				cont = 1
		}
		slur_type = draw_slur(s, k, m1, m2, slur_type)
		if (cont) {
			if (!k.p_v.slur_start)
				k.p_v.slur_start = 0;
			k.p_v.slur_start <<= 4;
			k.p_v.slur_start += slur_type
		}

		/* if slur in grace note sequence, restore the linkages */
		if (gr1
		 && gr1.next) {
			gr1.next.prev.next = null;
			gr1.next.prev = gr1
		}
		if (gr2) {
			gr2.prev.next = gr2;
			gr2.extra.prev = null
		}

		if (s.slur_start || s.sl1)
			continue
		if (s == last)
			break
		s = s.next
	}
}

/* -- draw a tuplet -- */
/* (the staves are not yet defined) */
/* (delayed output) */
/* See http://moinejf.free.fr/abcm2ps-doc/tuplets.xhtml
 * for the value of 'tf' */
function draw_tuplet(s1,
			lvl) {	// nesting level
	var	s2, s3, g, upstaff, nb_only, some_slur,
		x1, x2, y1, y2, xm, ym, a, s0, yy, yx, dy, a, b, dir,
		p, q, r

	// check if some slurs and treat the nested tuplets
	upstaff = s1.st
	for (s2 = s1; s2; s2 = s2.next) {
		if (s2.type != C.NOTE && s2.type != C.REST) {
			if (s2.type == C.GRACE) {
				for (g = s2.extra; g; g = g.next) {
					if (g.slur_start || g.sl1)
						some_slur = true
				}
			}
			continue
		}
		if (s2.slur_start || s2.slur_end /* if slur start/end */
		 || s2.sl1 || s2.sl2)
			some_slur = true
		if (s2.st < upstaff)
			upstaff = s2.st
		if (lvl == 0) {
			if (s2.tp1)
				draw_tuplet(s2, 1)
			if (s2.te0)
				break
		} else if (s2.te1)
			break
	}

	if (!s2) {
		error(1, s1, "No end of tuplet in this music line")
		if (lvl == 0)
			s1.tp0 = 0
		else
			s1.tp1 = 0
		return
	}

	/* draw the slurs fully inside the tuplet */
	if (some_slur) {
		draw_slurs(s1, s2)

		// don't draw the tuplet when a slur starts or stops inside it
		if (s1.slur_start || s1.sl1)
			return
		for (s3 = s1.next; s3 != s2; s3 = s3.next) {
			if (s3.slur_start || s3.slur_end
			 || s3.sl1 || s3.sl2)
				return
		}

		if (s2.slur_end || s2.sl2)
			return
	}

	if (lvl == 0) {
		p = s1.tp0;
		s1.tp0 = 0;
		q = s1.tq0
	} else {
		p = s1.tp1;
		s1.tp1 = 0
		q = s1.tq1
	}

	if (s1.tf[0] == 1)			/* if 'when' == never */
		return

	dir = s1.tf[3]				/* 'where' (C.SL_xxx) */
	if (!dir)
		dir = s1.stem > 0 ? C.SL_ABOVE : C.SL_BELOW

	if (s1 == s2) {				/* tuplet with 1 note (!) */
		nb_only = true
	} else if (s1.tf[1] == 1) {			/* 'what' == slur */
		nb_only = true;
		draw_slur(s1, s2, -1, -1, dir)
	} else {

		/* search if a bracket is needed */
		if (s1.tf[0] == 2		/* if 'when' == always */
		 || s1.type != C.NOTE || s2.type != C.NOTE) {
			nb_only = false
		} else {
			nb_only = true
			for (s3 = s1; ; s3 = s3.next) {
				if (s3.type != C.NOTE
				 && s3.type != C.REST) {
					if (s3.type == C.GRACE
					 || s3.type == C.SPACE)
						continue
					nb_only = false
					break
				}
				if (s3 == s2)
					break
				if (s3.beam_end) {
					nb_only = false
					break
				}
			}
			if (nb_only
			 && !s1.beam_st
			 && !s1.beam_br1
			 && !s1.beam_br2) {
				for (s3 = s1.prev; s3; s3 = s3.prev) {
					if (s3.type == C.NOTE
					 || s3.type == C.REST) {
						if (s3.nflags >= s1.nflags)
							nb_only = false
						break
					}
				}
			}
			if (nb_only && !s2.beam_end) {
				for (s3 = s2.next; s3; s3 = s3.next) {
					if (s3.type == C.NOTE
					 || s3.type == C.REST) {
						if (!s3.beam_br1
						 && !s3.beam_br2
						 && s3.nflags >= s2.nflags)
							nb_only = false
						break
					}
				}
			}
		}
	}

	/* if number only, draw it */
	if (nb_only) {
		if (s1.tf[2] == 1)		/* if 'which' == none */
			return
		xm = (s2.x + s1.x) / 2
		if (s1 == s2)			/* tuplet with 1 note */
			a = 0
		else
			a = (s2.ys - s1.ys) / (s2.x - s1.x);
		b = s1.ys - a * s1.x;
		yy = a * xm + b
		if (dir == C.SL_ABOVE) {
			ym = y_get(upstaff, 1, xm - 4, 8)
			if (ym > yy)
				b += ym - yy;
			b += 2
		} else {
			ym = y_get(upstaff, 0, xm - 4, 8)
			if (ym < yy)
				b += ym - yy;
			b -= 10
		}
		for (s3 = s1; ; s3 = s3.next) {
			if (s3.x >= xm)
				break
		}
		if (s1.stem * s2.stem > 0) {
			if (s1.stem > 0)
				xm += 1.5
			else
				xm -= 1.5
		}
		ym = a * xm + b
		if (s1.tf[2] == 0)		/* if 'which' == number */
			out_bnum(xm, ym, p)
		else
			out_bnum(xm, ym, p + ':' +  q)
		if (dir == C.SL_ABOVE) {
			ym += 10
			if (s3.ymx < ym)
				s3.ymx = ym;
			y_set(upstaff, true, xm - 3, 6, ym)
		} else {
			if (s3.ymn > ym)
				s3.ymn = ym;
			y_set(upstaff, false, xm - 3, 6, ym)
		}
		return
	}

	if (s1.tf[1] != 0)				/* if 'what' != square */
		error(2, s1, "'what' value of %%tuplets not yet coded")

/*fixme: two staves not treated*/
/*fixme: to optimize*/
	dir = s1.tf[3]				// 'where'
	if (!dir)
		dir = s1.multi >= 0 ? C.SL_ABOVE : C.SL_BELOW
    if (dir == C.SL_ABOVE) {

	/* sole or upper voice: the bracket is above the staff */
	if (s1.st == s2.st) {
		y1 = y2 = staff_tb[upstaff].topbar + 4
	} else {
		y1 = s1.ymx;
		y2 = s2.ymx
	}

	x1 = s1.x - 4;
	if (s1.st == upstaff) {
		for (s3 = s1; !s3.dur; s3 = s3.next)
			;
		ym = y_get(upstaff, 1, s3.x - 4, 8)
		if (ym > y1)
			y1 = ym
		if (s1.stem > 0)
			x1 += 3
	}

	if (s2.st == upstaff) {
		for (s3 = s2; !s3.dur; s3 = s3.prev)
			;
		ym = y_get(upstaff, 1, s3.x - 4, 8)
		if (ym > y2)
			y2 = ym
	}

	/* end the backet according to the last note duration */
	if (s2.dur > s2.prev.dur) {
		if (s2.next)
			x2 = s2.next.x - s2.next.wl - 5
		else
			x2 = realwidth - 6
	} else {
		x2 = s2.x + 4;
		r = s2.stem >= 0 ? 0 : s2.nhd
		if (s2.notes[r].shhd > 0)
			x2 += s2.notes[r].shhd
		if (s2.st == upstaff
		 && s2.stem > 0)
			x2 += 3.5
	}

	xm = .5 * (x1 + x2);
	ym = .5 * (y1 + y2);

	a = (y2 - y1) / (x2 - x1);
	s0 = 3 * (s2.notes[s2.nhd].pit - s1.notes[s1.nhd].pit) / (x2 - x1)
	if (s0 > 0) {
		if (a < 0)
			a = 0
		else if (a > s0)
			a = s0
	} else {
		if (a > 0)
			a = 0
		else if (a < s0)
			a = s0
	}
	if (a * a < .1 * .1)
		a = 0

	/* shift up bracket if needed */
	dy = 0
	for (s3 = s1; ; s3 = s3.next) {
		if (!s3.dur			/* not a note or a rest */
		 || s3.st != upstaff) {
			if (s3 == s2)
				break
			continue
		}
		yy = ym + (s3.x - xm) * a;
		yx = y_get(upstaff, 1, s3.x - 4, 8) + 2
		if (yx - yy > dy)
			dy = yx - yy
		if (s3 == s2)
			break
	}

	ym += dy;
	y1 = ym + a * (x1 - xm);
	y2 = ym + a * (x2 - xm);

	/* shift the slurs / decorations */
	ym += 8
	for (s3 = s1; ; s3 = s3.next) {
		if (s3.st == upstaff) {
			yy = ym + (s3.x - xm) * a
			if (s3.ymx < yy)
				s3.ymx = yy
			if (s3 == s2)
				break
			y_set(upstaff, true, s3.x, s3.next.x - s3.x, yy)
		} else if (s3 == s2) {
			break
		}
	}

    } else {	/* lower voice of the staff: the bracket is below the staff */
/*fixme: think to all of that again..*/
	x1 = s1.x - 7
	if (s2.dur > s2.prev.dur) {
		if (s2.next)
			x2 = s2.next.x - s2.next.wl - 8
		else
			x2 = realwidth - 6
	} else {
		x2 = s2.x + 2
		if (s2.notes[s2.nhd].shhd > 0)
			x2 += s2.notes[s2.nhd].shhd
	}
	if (s1.stem >= 0) {
		x1 += 2;
		x2 += 2
	}

	if (s1.st == upstaff) {
		for (s3 = s1; !s3.dur; s3 = s3.next)
			;
		y1 = y_get(upstaff, 0, s3.x - 4, 8)
	} else {
		y1 = 0
	}
	if (s2.st == upstaff) {
		for (s3 = s2; !s3.dur; s3 = s3.prev)
			;
		y2 = y_get(upstaff, 0, s3.x - 4, 8)
	} else {
		y2 = 0
	}

	xm = .5 * (x1 + x2);
	ym = .5 * (y1 + y2);

	a = (y2 - y1) / (x2 - x1);
	s0 = 3 * (s2.notes[0].pit - s1.notes[0].pit) / (x2 - x1)
	if (s0 > 0) {
		if (a < 0)
			a = 0
		else if (a > s0)
			a = s0
	} else {
		if (a > 0)
			a = 0
		else if (a < s0)
			a = s0
	}
	if (a * a < .1 * .1)
		a = 0

	/* shift down the bracket if needed */
	dy = 0
	for (s3 = s1; ; s3 = s3.next) {
		if (!s3.dur			/* not a note nor a rest */
		 || s3.st != upstaff) {
			if (s3 == s2)
				break
			continue
		}
		yy = ym + (s3.x - xm) * a;
		yx = y_get(upstaff, 0, s3.x - 4, 8)
		if (yx - yy < dy)
			dy = yx - yy
		if (s3 == s2)
			break
	}

	ym += dy - 10;
	y1 = ym + a * (x1 - xm);
	y2 = ym + a * (x2 - xm);

	/* shift the slurs / decorations */
	ym -= 2
	for (s3 = s1; ; s3 = s3.next) {
		if (s3.st == upstaff) {
			if (s3 == s2)
				break
			yy = ym + (s3.x - xm) * a
			if (s3.ymn > yy)
				s3.ymn = yy;
			y_set(upstaff, false, s3.x, s3.next.x - s3.x, yy)
		}
		if (s3 == s2)
			break
	}
    } /* lower voice */

	if (s1.tf[2] == 1) {			/* if 'which' == none */
		out_tubr(x1, y1 + 4, x2 - x1, y2 - y1, dir == C.SL_ABOVE);
		return
	}
	out_tubrn(x1, y1, x2 - x1, y2 - y1, dir == C.SL_ABOVE,
		s1.tf[2] == 0 ? p.toString() : p + ':' +  q);

	yy = .5 * (y1 + y2)
	if (dir == C.SL_ABOVE)
		y_set(upstaff, true, xm - 3, 6, yy + 9)
	else
		y_set(upstaff, false, xm - 3, 6, yy)
}

/* -- draw the ties between two notes/chords -- */
function draw_note_ties(k1, k2, mhead1, mhead2, job) {
	var i, dir, m1, m2, p, p2, y, st, k, x1, x2, h, sh, time

	for (i = 0; i < mhead1.length; i++) {
		m1 = mhead1[i];
		p = k1.notes[m1].pit;
		m2 = mhead2[i];
		p2 = job != 2 ? k2.notes[m2].pit : p;
		dir = (k1.notes[m1].ti1 & 0x07) == C.SL_ABOVE ? 1 : -1;

		x1 = k1.x;
		sh = k1.notes[m1].shhd		/* head shift */
		if (dir > 0) {
			if (m1 < k1.nhd && p + 1 == k1.notes[m1 + 1].pit)
				if (k1.notes[m1 + 1].shhd > sh)
					sh = k1.notes[m1 + 1].shhd
		} else {
			if (m1 > 0 && p == k1.notes[m1 - 1].pit + 1)
				if (k1.notes[m1 - 1].shhd > sh)
					sh = k1.notes[m1 - 1].shhd
		}
		x1 += sh * .6;

		x2 = k2.x
		if (job != 2) {
			sh = k2.notes[m2].shhd
			if (dir > 0) {
				if (m2 < k2.nhd && p2 + 1 == k2.notes[m2 + 1].pit)
					if (k2.notes[m2 + 1].shhd < sh)
						sh = k2.notes[m2 + 1].shhd
			} else {
				if (m2 > 0 && p2 == k2.notes[m2 - 1].pit + 1)
					if (k2.notes[m2 - 1].shhd < sh)
						sh = k2.notes[m2 - 1].shhd
			}
			x2 += sh * .6
		}

		st = k1.st
		switch (job) {
		case 0:
			if (p != p2 && !(p & 1))
				p = p2
			break
		case 3:				/* clef or staff change */
			dir = -dir
			// fall thru
		case 1:				/* no starting note */
			x1 = k1.x
			if (x1 > x2 - 20)
				x1 = x2 - 20;
			p = p2;
			st = k2.st
			break
/*		case 2:				 * no ending note */
		default:
			if (k1 != k2) {
				x2 -= k2.wl
				if (k2.type == C.BAR)
					x2 += 5
			} else {
				time = k1.time + k1.dur
				for (k = k1.ts_next; k; k = k.ts_next)
//(fixme: must check if the staff continues??)
					if (k.time > time)
						break
				x2 = k ? k.x : realwidth
			}
			if (x2 < x1 + 16)
				x2 = x1 + 16
			break
		}
		if (x2 - x1 > 20) {
			x1 += 3.5;
			x2 -= 3.5
		} else {
			x1 += 1.5;
			x2 -= 1.5
		}

		y = 3 * (p - 18)

		h = (.04 * (x2 - x1) + 10) * dir;
//		anno_start(k1, 'slur');
		slur_out(x1, staff_tb[st].y + y,
			 x2, staff_tb[st].y + y,
			 dir, h, k1.notes[m1].ti1 & C.SL_DOTTED)
//		anno_stop(k1, 'slur')
	}
}

/* -- draw ties between neighboring notes/chords -- */
function draw_ties(k1, k2,
			job) {	// 0: normal
				// 1: no starting note
				// 2: no ending note
				// 3: no start for clef or staff change
	var	k3, i, j, m1, pit, tie2,
		mhead1 = [],
		mhead2 = [],
		mhead3 = [],
		nh1 = k1.nhd,
		time = k1.time + k1.dur

	/* half ties from last note in line or before new repeat */
	if (job == 2) {
		for (i = 0; i <= nh1; i++) {
			if (k1.notes[i].ti1)
				mhead3.push(i)
		}
		draw_note_ties(k1, k2 || k1, mhead3, mhead3, job)
		return
	}

	/* set up list of ties to draw */
	for (i = 0; i <= nh1; i++) {
		if (!k1.notes[i].ti1)
			continue
		tie2 = -1;
		pit = k1.notes[i].apit
		for (m1 = k2.nhd; m1 >= 0; m1--) {
			switch (k2.notes[m1].apit - pit) {
			case 1:			/* maybe ^c - _d */
			case -1:		/* _d - ^c */
				if (k1.notes[i].acc != k2.notes[m1].acc)
					tie2 = m1
			default:
				continue
			case 0:
				tie2 = m1
				break
			}
			break
		}
		if (tie2 >= 0) {		/* 1st or 2nd choice */
			mhead1.push(i);
			mhead2.push(tie2)
		} else {
			mhead3.push(i)		/* no match */
		}
	}

	/* draw the ties */
	draw_note_ties(k1, k2, mhead1, mhead2, job)

	/* if any bad tie, try an other voice of the same staff */
	if (!mhead3.length)
		return				/* no bad tie */

	k3 = k1.ts_next
	while (k3 && k3.time < time)
		k3 = k3.ts_next
	while (k3 && k3.time == time) {
		if (k3.type != C.NOTE
		 || k3.st != k1.st) {
			k3 = k3.ts_next
			continue
		}
		mhead1.length = 0;
		mhead2.length = 0
		for (i = mhead3.length; --i >= 0; ) {
			j = mhead3[i];
			pit = k1.notes[j].apit
			for (m1 = k3.nhd; m1 >= 0; m1--) {
				if (k3.notes[m1].apit == pit) {
					mhead1.push(j);
					mhead2.push(m1);
					mhead3[i] = mhead3.pop()
					break
				}
			}
		}
		if (mhead1.length > 0) {
			draw_note_ties(k1, k3,
					mhead1, mhead2,
					job == 1 ? 1 : 0)
			if (mhead3.length == 0)
				return
		}
		k3 = k3.ts_next
	}

	if (mhead3.length != 0)
		error(1, k1, "Bad tie")
}

/* -- try to get the symbol of a ending tie when combined voices -- */
function tie_comb(s) {
	var	s1, time, st;

	time = s.time + s.dur;
	st = s.st
	for (s1 = s.ts_next; s1; s1 = s1.ts_next) {
		if (s1.st != st)
			continue
		if (s1.time == time) {
			if (s1.type == C.NOTE)
				return s1
			continue
		}
		if (s1.time > time)
			return s		// bad tie
	}
	return //null				// no ending tie
}

/* -- draw all ties between neighboring notes -- */
function draw_all_ties(p_voice) {
	var s1, s2, s3, clef_chg, time, s_rtie, s_tie, x, dx

	function draw_ties_g(s1, s2, job) {
		var g

		if (s1.type == C.GRACE) {
			for (g = s1.extra; g; g = g.next) {
				if (g.ti1)
					draw_ties(g, s2, job)
			}
		} else {
			draw_ties(s1, s2, job)
		}
	} // draw_ties_g()

	for (s1 = p_voice.sym; s1; s1 = s1.next) {
		switch (s1.type) {
		case C.CLEF:
		case C.KEY:
		case C.METER:
			continue
		}
		break
	}
	s_rtie = p_voice.s_rtie			/* tie from 1st repeat bar */
	for (s2 = s1; s2; s2 = s2.next) {
		if (s2.dur
		 || s2.type == C.GRACE)
			break
		if (s2.type != C.BAR
		 || !s2.text)			// not a repeat bar
			continue
		if (s2.text[0] == '1')		/* 1st repeat bar */
			s_rtie = p_voice.s_tie
		else
			p_voice.s_tie = s_rtie
	}
	if (!s2)
		return
	if (p_voice.s_tie) {			/* tie from previous line */
		p_voice.s_tie.x = s1.x + s1.wr;
		s1 = p_voice.s_tie;
		p_voice.s_tie = null;
		s1.st = s2.st;
		s1.ts_next = s2.ts_next;	/* (for tie to other voice) */
		s1.time = s2.time - s1.dur;	/* (if after repeat sequence) */
		draw_ties(s1, s2, 1)		/* tie to 1st note */
	}

	/* search the start of ties */
//	clef_chg = false
	while (1) {
		for (s1 = s2; s1; s1 = s1.next) {
			if (s1.ti1)
				break
			if (!s_rtie)
				continue
			if (s1.type != C.BAR
			 || !s1.text)			// not a repeat bar
				continue
			if (s1.text[0] == '1') {	/* 1st repeat bar */
				s_rtie = null
				continue
			}
			if (s1.bar_type == '|')
				continue		// not a repeat
			for (s2 = s1.next; s2; s2 = s2.next)
				if (s2.type == C.NOTE)
					break
			if (!s2) {
				s1 = null
				break
			}
			s_tie = clone(s_rtie);
			s_tie.x = s1.x;
			s_tie.next = s2;
			s_tie.st = s2.st;
			s_tie.time = s2.time - s_tie.dur;
			draw_ties(s_tie, s2, 1)
		}
		if (!s1)
			break

		/* search the end of the tie
		 * and notice the clef changes (may occur in an other voice) */
		time = s1.time + s1.dur
		for (s2 = s1.next; s2; s2 = s2.next) {
			if (s2.dur)
				break
			if (s2.text) {			// repeat bar
				if (s2.text[0] != '1')
					break
				s_rtie = s1		/* 1st repeat bar */
			}
		}
		if (!s2) {
			for (s2 = s1.ts_next; s2; s2 = s2.ts_next) {
				if (s2.st != s1.st)
					continue
				if (s2.time < time)
					continue
				if (s2.time > time) {
					s2 = null
					break
				}
				if (s2.dur)
					break
			}
			if (!s2) {
				draw_ties_g(s1, null, 2);
				p_voice.s_tie = s1
				break
			}
		} else {
			if (s2.type != C.NOTE
			 && s2.type != C.BAR) {
				error(1, s1, "Bad tie")
				continue
			}
			if (s2.time != time) {
				s3 = tie_comb(s1)
				if (s3 == s1) {
					error(1, s1, "Bad tie")
					continue
				}
				s2 = s3
			}
		}
		for (s3 = s1.ts_next; s3; s3 = s3.ts_next) {
			if (s3.st != s1.st)
				continue
			if (s3.time > time)
				break
			if (s3.type == C.CLEF) {
				clef_chg = true
				continue
			}
		}

		/* ties with clef or staff change */
		if (clef_chg || s1.st != s2.st) {
			clef_chg = false;
			dx = (s2.x - s1.x) * .4;
			x = s2.x;
			s2.x -= dx
			if (s2.x > s1.x + 32.)
				s2.x = s1.x + 32.;
			draw_ties_g(s1, s2, 2);
			s2.x = x;
			x = s1.x;
			s1.x += dx
			if (s1.x < s2.x - 24.)
				s1.x = s2.x - 24.;
			draw_ties(s1, s2, 3);
			s1.x = x
			continue
		}
		draw_ties_g(s1, s2, s2.type == C.NOTE ? 0 : 2)
	}
	p_voice.s_rtie = s_rtie
}

/* -- draw all phrasing slurs for one staff -- */
/* (the staves are not yet defined) */
function draw_all_slurs(p_voice) {
	var	k, i, m2,
		s = p_voice.sym,
		slur_type = p_voice.slur_start,
		slur_st = 0

	if (!s)
		return

	/* the starting slur types are inverted */
	if (slur_type) {
		p_voice.slur_start = 0
		while (slur_type != 0) {
			slur_st <<= 4;
			slur_st |= (slur_type & 0x0f);
			slur_type >>= 4
		}
	}

	/* draw the slurs inside the music line */
	draw_slurs(s, undefined)

	/* do unbalanced slurs still left over */
	for ( ; s; s = s.next) {
		while (s.slur_end || s.sl2) {
			if (s.slur_end) {
				s.slur_end--;
				m2 = -1
			} else {
				for (m2 = 0; m2 <= s.nhd; m2++)
					if (s.notes[m2].sl2)
						break
				s.notes[m2].sl2--;
				s.sl2--
			}
			slur_type = slur_st & 0x0f;
			k = prev_scut(s);
			draw_slur(k, s, -1, m2, slur_type)
			if (k.type != C.BAR
			 || (k.bar_type[0] != ':'
			  && k.bar_type != "|]"
			  && k.bar_type != "[|"
			  && (!k.text || k.text[0] == '1')))
				slur_st >>= 4
		}
	}
	s = p_voice.sym
	while (slur_st != 0) {
		slur_type = slur_st & 0x0f;
		slur_st >>= 4;
		k = next_scut(s);
		draw_slur(s, k, -1, -1, slur_type)
		if (k.type != C.BAR
		 || (k.bar_type[0] != ':'
		  && k.bar_type != "|]"
		  && k.bar_type != "[|"
		  && (!k.text || k.text[0] == '1'))) {
			if (!p_voice.slur_start)
				p_voice.slur_start = 0;
			p_voice.slur_start <<= 4;
			p_voice.slur_start += slur_type
		}
	}
}

/* -- draw the symbols near the notes -- */
/* (the staves are not yet defined) */
/* order:
 * - scaled
 *   - beams
 *   - decorations near the notes
 *   - measure bar numbers
 *   - n-plets
 *   - decorations tied to the notes
 *   - slurs
 * - not scaled
 *   - guitar chords
 *   - staff decorations
 *   - lyrics
 *   - measure numbers
 * The buffer output is delayed until the definition of the staff system
 */
function draw_sym_near() {
	var p_voice, p_st, s, v, st, y, g, w, i, st, dx, top, bot, output_sav;

	output_sav = output;
	output = ""

	/* calculate the beams but don't draw them (the staves are not yet defined) */
	for (v = 0; v < voice_tb.length; v++) {
		var	bm = {},
			first_note = true;

		p_voice = voice_tb[v]
		for (s = p_voice.sym; s; s = s.next) {
			switch (s.type) {
			case C.GRACE:
				for (g = s.extra; g; g = g.next) {
					if (g.beam_st && !g.beam_end)
						calculate_beam(bm, g)
				}
				break
			case C.NOTE:
				if ((s.beam_st && !s.beam_end)
				 || (first_note && !s.beam_st)) {
					first_note = false;
					calculate_beam(bm, s)
				}
				break
			}
		}
	}

	/* initialize the min/max vertical offsets */
	for (st = 0; st <= nstaff; st++) {
		p_st = staff_tb[st]
		if (!p_st.top) {
			p_st.top = new Float32Array(YSTEP);
			p_st.bot = new Float32Array(YSTEP)
		}
		for (i = 0; i < YSTEP; i++) {
			p_st.top[i] = 0;
			p_st.bot[i] = 24
		}
//		p_st.top.fill(0.);
//		p_st.bot.fill(24.)
	}

	set_tie_room();
	draw_deco_near()

	/* set the min/max vertical offsets */
	for (s = tsfirst; s; s = s.ts_next) {
		if (s.invis)
			continue
		switch (s.type) {
		case C.GRACE:
			for (g = s.extra; g; g = g.next) {
				y_set(s.st, true, g.x - 2, 4, g.ymx + 1);
				y_set(s.st, false, g.x - 2, 4, g.ymn - 1)
			}
			continue
		case C.MREST:
			y_set(s.st, true, s.x + 16, 32, s.ymx + 2)
			continue
		default:
			y_set(s.st, true, s.x - s.wl, s.wl + s.wr, s.ymx + 2);
			y_set(s.st, false, s.x - s.wl, s.wl + s.wr, s.ymn - 2)
			continue
		case C.NOTE:
			break
		}

		// (permit closer staves)
		if (s.stem > 0) {
			if (s.beam_st) {
				dx = 3;
				w = s.beam_end ? 4 : 10
			} else {
				dx = -8;
				w = s.beam_end ? 11 : 16
			}
			y_set(s.st, true, s.x + dx, w, s.ymx);
			y_set(s.st, false, s.x - s.wl, s.wl + s.wr, s.ymn)
		} else {
			y_set(s.st, true, s.x - s.wl, s.wl + s.wr, s.ymx);
			if (s.beam_st) {
				dx = -6;
				w = s.beam_end ? 4 : 10
			} else {
				dx = -8;
				w = s.beam_end ? 5 : 16
			}
			dx += s.notes[0].shhd;
			y_set(s.st, false, s.x + dx, w, s.ymn)
		}

		/* have room for the accidentals */
		if (s.notes[s.nhd].acc) {
			y = s.y + 8
			if (s.ymx < y)
				s.ymx = y;
			y_set(s.st, true, s.x, 0, y)
		}
		if (s.notes[0].acc) {
			y = s.y
			if (s.notes[0].acc == 1		// sharp
			 || s.notes[0].acc == 3)	// natural
				y -= 7
			else
				y -= 5
			if (s.ymn > y)
				s.ymn = y;
			y_set(s.st, false, s.x, 0, y)
		}
	}

	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v];
		s = p_voice.sym
		if (!s)
			continue
		set_color(s.color);
		st = p_voice.st;
//  if (st == undefined) {
//error(1, s, "BUG: no staff for voice " + p_voice.id)
//    continue
//  }
		set_dscale(st)

		/* draw the tuplets near the notes */
		for ( ; s; s = s.next) {
			if (s.tp0)
				draw_tuplet(s, 0)
		}
		draw_all_slurs(p_voice)

		/* draw the tuplets over the slurs */
		for (s = p_voice.sym; s; s = s.next) {
			if (s.tp0)
				draw_tuplet(s, 0)
		}
	}

	/* set the top and bottom out of the staves */
	for (st = 0; st <= nstaff; st++) {
		p_st = staff_tb[st];
		top = p_st.topbar + 2;
		bot = p_st.botbar - 2
/*fixme:should handle stafflines changes*/
		for (i = 0; i < YSTEP; i++) {
			if (top > p_st.top[i])
				p_st.top[i] = top
			if (bot < p_st.bot[i])
				p_st.bot[i] = bot
		}
	}

	set_color(undefined);
	draw_deco_note()
	draw_deco_staff();

	/* if any lyric, draw them now as unscaled */
	set_dscale(-1)
//	set_sscale(-1)
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (p_voice.have_ly) {
			draw_all_lyrics()
			break
		}
	}

	if (cfmt.measurenb >= 0)
		draw_measnb();

	set_dscale(-1);
	output = output_sav
}

/* -- draw the name/subname of the voices -- */
function draw_vname(indent) {
	var	p_voice, n, st, v, a_p, p, y, name_type,
		staff_d = []

	for (st = cur_sy.nstaff; st >= 0; st--) {
		if (cur_sy.st_print[st])
			break
	}
	if (st < 0)
		return

	// check if full or sub names
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (!p_voice.sym)
			continue
		st = cur_sy.voices[v].st
		if (!cur_sy.st_print[st])
			continue
		if (p_voice.new_name) {
			name_type = 2
			break
		}
		if (p_voice.snm)
			name_type = 1
	}
	if (!name_type)
		return
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (!p_voice.sym)
			continue
		st = cur_sy.voices[v].st
		if (!cur_sy.st_print[st])
			continue
		if (p_voice.new_name)
			delete p_voice.new_name;
		p = name_type == 2 ? p_voice.nm : p_voice.snm
		if (!p)
			continue
		if (cur_sy.staves[st].flags & CLOSE_BRACE2) {
			while (!(cur_sy.staves[st].flags & OPEN_BRACE2))
				st--
		} else if (cur_sy.staves[st].flags & CLOSE_BRACE) {
			while (!(cur_sy.staves[st].flags & OPEN_BRACE))
				st--
		}
		if (!staff_d[st])
			staff_d[st] = p
		else
			staff_d[st] += "\\n" + p
	}
	if (staff_d.length == 0)
		return
	set_font("voice");
	indent = -indent * .5			/* center */
	for (st = 0; st < staff_d.length; st++) {
		if (!staff_d[st])
			continue
		a_p = staff_d[st].split('\\n');
		y = staff_tb[st].y
			+ staff_tb[st].topbar * .5
				* staff_tb[st].staffscale
			+ 9 * (a_p.length - 1)
			- gene.curfont.size * .3;
		n = st
		if (cur_sy.staves[st].flags & OPEN_BRACE2) {
			while (!(cur_sy.staves[n].flags & CLOSE_BRACE2))
				n++
		} else if (cur_sy.staves[st].flags & OPEN_BRACE) {
			while (!(cur_sy.staves[n].flags & CLOSE_BRACE))
				n++
		}
		if (n != st)
			y -= (staff_tb[st].y - staff_tb[n].y) * .5
		for (n = 0; n < a_p.length; n++) {
			p = a_p[n];
			xy_str(indent, y, p, "c");
			y -= 18
		}
	}
}

// -- set the y offset of the staves and return the height of the whole system --
function set_staff() {
	var	s, i, st, prev_staff, v,
		y, staffsep, dy, maxsep, mbot, val, p_voice, p_staff

	/* set the scale of the voices */
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (p_voice.scale != 1)
			p_voice.scale_str = 
				'transform="scale(' + p_voice.scale.toFixed(2) + ')"'
	}

	// search the top staff
	for (st = 0; st <= nstaff; st++) {
		if (gene.st_print[st])
			break
	}
	y = 0
	if (st > nstaff) {
		st--;			/* one staff, empty */
		p_staff = staff_tb[st]
	} else {
		p_staff = staff_tb[st]
		for (i = 0; i < YSTEP; i++) {
			val = p_staff.top[i]
			if (y < val)
				y = val
		}
	}

	/* draw the parts and tempo indications if any */
	y += draw_partempo(st, y)

	if (!gene.st_print[st])
		return y;

	/* set the vertical offset of the 1st staff */
	y *= p_staff.staffscale;
	staffsep = cfmt.staffsep * .5 +
			p_staff.topbar * p_staff.staffscale
	if (y < staffsep)
		y = staffsep
	if (y < p_staff.ann_top)	// absolute annotation
		y = p_staff.ann_top;
	p_staff.y = -y;

	/* set the offset of the other staves */
	prev_staff = st
	var sy_staff_prev = cur_sy.staves[prev_staff]
	for (st++; st <= nstaff; st++) {
		p_staff = staff_tb[st]
		if (!gene.st_print[st])
			continue
		staffsep = sy_staff_prev.sep || cfmt.sysstaffsep;
		maxsep = sy_staff_prev.maxsep || cfmt.maxsysstaffsep;

		dy = 0
		if (p_staff.staffscale == staff_tb[prev_staff].staffscale) {
			for (i = 0; i < YSTEP; i++) {
				val = p_staff.top[i] -
						staff_tb[prev_staff].bot[i]
				if (dy < val)
					dy = val
			}
			dy *= p_staff.staffscale
		} else {
			for (i = 0; i < YSTEP; i++) {
				val = p_staff.top[i] * p_staff.staffscale
				  - staff_tb[prev_staff].bot[i]
					* staff_tb[prev_staff].staffscale
				if (dy < val)
					dy = val
			}
		}
		staffsep += p_staff.topbar * p_staff.staffscale
		if (dy < staffsep)
			dy = staffsep;
		maxsep += p_staff.topbar * p_staff.staffscale
		if (dy > maxsep)
			dy = maxsep;
		y += dy;
		p_staff.y = -y;

		prev_staff = st;
		sy_staff_prev = cur_sy.staves[prev_staff]
	}
	mbot = 0
	for (i = 0; i < YSTEP; i++) {
		val = staff_tb[prev_staff].bot[i]
		if (mbot > val)
			mbot = val
	}
	if (mbot > p_staff.ann_bot) 	// absolute annotation
		mbot = p_staff.ann_bot;
	mbot *= staff_tb[prev_staff].staffscale

	/* output the staff offsets */
	for (st = 0; st <= nstaff; st++) {
		p_staff = staff_tb[st];
		dy = p_staff.y
		if (p_staff.staffscale != 1) {
			p_staff.scale_str =
				'transform="translate(0,' +
					(posy - dy).toFixed(2) + ') ' +
				'scale(' + p_staff.staffscale.toFixed(2) + ')"'
		}
	}

	if (mbot == 0) {
		for (st = nstaff; st >= 0; st--) {
			if (gene.st_print[st])
				break
		}
		if (st < 0)		/* no symbol in this system ! */
			return y
	}
	dy = -mbot;
	staffsep = cfmt.staffsep * .5
	if (dy < staffsep)
		dy = staffsep;
	maxsep = cfmt.maxstaffsep * .5
	if (dy > maxsep)
		dy = maxsep;

	// return the height of the whole staff system
	return y + dy
}

/* -- draw the staff systems and the measure bars -- */
function draw_systems(indent) {
	var	s, s2, st, x, x2, res, sy,
		staves_bar, bar_force,
		xstaff = [],
		bar_bot = [],
		bar_height = []

	/* -- set the bottom and height of the measure bars -- */
	function bar_set() {
		var	st, staffscale, top, bot,
			dy = 0

		for (st = 0; st <= cur_sy.nstaff; st++) {
			if (xstaff[st] < 0) {
				bar_bot[st] = bar_height[st] = 0
				continue
			}
			staffscale = staff_tb[st].staffscale;
			top = staff_tb[st].topbar * staffscale;
			bot = staff_tb[st].botbar * staffscale
			if (dy == 0)
				dy = staff_tb[st].y + top;
			bar_bot[st] = staff_tb[st].y + bot;
			bar_height[st] = dy - bar_bot[st];
			dy = (cur_sy.staves[st].flags & STOP_BAR) ?
					0 : bar_bot[st]
		}
	} // bar_set()

	/* -- draw a staff -- */
	function draw_staff(st, x1, x2) {
		var	w, ws, i, dy, ty,
			y = 0,
			ln = "",
			stafflines = cur_sy.staves[st].stafflines,
			l = stafflines.length

		if (!/[\[|]/.test(stafflines))
			return				// no line
		w = x2 - x1;
		set_sscale(st);
		ws = w / stv_g.scale

		// check if default staff
		if (cache && cache.st_l == stafflines && cache.st_ws == ws) {
			xygl(x1, staff_tb[st].y, 'stdef' + cfmt.fullsvg)
			return
		}
		for (i = 0; i < l; i++, y -= 6) {
			if (stafflines[i] == '.')
				continue
			dy = 0
			for (; i < l; i++, y -= 6, dy -= 6) {
				switch (stafflines[i]) {
				case '.':
				case '-':
					continue
				case ty:
					ln += 'm-' + ws.toFixed(2) +
						' ' + dy +
						'h' + ws.toFixed(2);
					dy = 0
					continue
				}
				if (ty != undefined)
					ln += '"/>\n';
				ty = stafflines[i]
				ln += '<path class="stroke"'
				if (ty == '[')
					ln += ' stroke-width="1.5"';
				ln += ' d="m0 ' + y + 'h' + ws.toFixed(2);
				dy = 0
			}
			ln += '"/>\n'
		}
		y = staff_tb[st].y
		if (!cache
		 && w == get_lwidth()) {
			cache = {
				st_l: stafflines,
				st_ws: ws
			}
			i = 'stdef' + cfmt.fullsvg;
			glyphs[i] = '<g id="' + i + '">\n' + ln + '</g>';
			xygl(x1, y, i)
			return
		}
		out_XYAB('<g transform="translate(X, Y)">\n' + ln + '</g>\n', x1, y)
	} // draw_staff()

	draw_vname(indent)

	/* draw the staff, skipping the staff breaks */
	for (st = 0; st <= nstaff; st++)
		xstaff[st] = !cur_sy.st_print[st] ? -1 : 0;
	bar_set();
	draw_lstaff(0)
	for (s = tsfirst; s; s = s.ts_next) {
		if (bar_force && s.time != bar_force) {
			bar_force = 0
			for (st = 0; st <= nstaff; st++) {
				if (!cur_sy.st_print[st])
					xstaff[st] = -1
			}
			bar_set()
		}
		switch (s.type) {
		case C.STAVES:
			staves_bar = s.ts_prev.type == C.BAR ? s.ts_prev.x : 0
		    if (!staves_bar) {
			for (s2 = s.ts_next; s2; s2 = s2.ts_next) {
				if (s2.time != s.time)
					break
				switch (s2.type) {
				case C.BAR:
				case C.CLEF:
				case C.KEY:
				case C.METER:
					staves_bar = s2.x
					continue
				}
				break
			}
			if (!s2)
				staves_bar = realwidth;
		    }
			sy = s.sy
			for (st = 0; st <= nstaff; st++) {
				x = xstaff[st]
				if (x < 0) {		// no staff yet
					if (sy.st_print[st])
						xstaff[st] = staves_bar ?
							staves_bar : (s.x - s.wl - 2)
					continue
				}
				if (sy.st_print[st]	// if not staff stop
				 && sy.staves[st].stafflines ==
						cur_sy.staves[st].stafflines)
					continue
				if (staves_bar) {
					x2 = staves_bar;
					bar_force = s.time
				} else {
					x2 = s.x - s.wl - 2;
					xstaff[st] = -1
				}
				draw_staff(st, x, x2)
				if (sy.st_print[st])
					xstaff[st] = x2
			}
			cur_sy = sy;
			bar_set()
			continue
		case C.BAR:
			st = s.st
			if (s.second || s.invis)
				break
			draw_bar(s, bar_bot[st], bar_height[st]);
			break
		case C.STBRK:
			if (cur_sy.voices[s.v].range == 0) {
				if (s.xmx > 14) {

					/* draw the left system if stbrk in all voices */
					var nv = 0
					for (var i = 0; i < voice_tb.length; i++) {
						if (cur_sy.voices[i].range > 0)
							nv++
					}
					for (s2 = s.ts_next; s2; s2 = s2.ts_next) {
						if (s2.type != C.STBRK)
							break
						nv--
					}
					if (nv == 0)
						draw_lstaff(s.x)
				}
			}
			s2 = s.prev
			if (!s2)
				break
			x2 = s2.x
			if (s2.type != C.BAR)
				x2 += s2.wr;
			st = s.st;
			x = xstaff[st]
			if (x >= 0) {
				if (x >= x2)
					continue
				draw_staff(st, x, x2)
			}
			xstaff[st] = s.x
			break
//		default:
//fixme:does not work for "%%staves K: M: $" */
//removed for K:/M: in empty staves
//			if (!cur_sy.st_print[st])
//				s.invis = true
//			break
		}
	}

	// draw the end of the staves
	for (st = 0; st <= nstaff; st++) {
		if (bar_force && !cur_sy.st_print[st])
			continue
		x = xstaff[st]
		if (x < 0 || x >= realwidth)
			continue
		draw_staff(st, x, realwidth)
	}
//	set_sscale(-1)
}

/* -- draw remaining symbols when the staves are defined -- */
function draw_symbols(p_voice) {
	var	bm = {},
		s, g, x, y, st;

//	bm.s2 = undefined
	for (s = p_voice.sym; s; s = s.next) {
		if (s.invis) {
			switch (s.type) {
			case C.KEY:
				p_voice.key = s
			default:
				continue
			case C.NOTE:	// (beams may start on invisible notes)
				break
			}
		}
		x = s.x;
		set_color(s.color)
		switch (s.type) {
		case C.NOTE:
//--fixme: recall set_scale if different staff
			set_scale(s)
			if (s.beam_st && !s.beam_end) {
				if (calculate_beam(bm, s))
					draw_beams(bm)
			}
			if (!s.invis) {
				anno_start(s);
				draw_note(s, !bm.s2);
				anno_stop(s)
			}
			if (s == bm.s2)
				bm.s2 = null
			break
		case C.REST:
			draw_rest(s);
			break
		case C.BAR:
			break			/* drawn in draw_systems */
		case C.CLEF:
			st = s.st
			if (s.time > staff_tb[st].clef.time)
				staff_tb[st].clef = s
			if (s.second)
/*			 || p_voice.st != st)	*/
				break		/* only one clef per staff */
			if (!staff_tb[s.st].topbar)
				break
			set_color(undefined);
			set_sscale(st);
			anno_start(s);
			y = staff_tb[st].y
			if (s.clef_name)
				xygl(x, y + s.y, s.clef_name)
			else if (!s.clef_small)
				xygl(x, y + s.y, s.clef_type + "clef")
			else
				xygl(x, y + s.y, "s" + s.clef_type + "clef")
			if (s.clef_octave) {
/*fixme:break the compatibility and avoid strange numbers*/
				if (s.clef_octave > 0) {
					y += s.ymx - 10
					if (s.clef_small)
						y -= 1
				} else {
					y += s.ymn + 2
					if (s.clef_small)
						y += 1
				}
				xygl(x - 2, y, "oct")
			}
			anno_stop(s)
			break
		case C.METER:
			p_voice.meter = s
			if (s.second
			 || !staff_tb[s.st].topbar)
				break
			if (cfmt.alignbars && s.st != 0)
				break
			set_color(undefined);
			set_sscale(s.st);
			anno_start(s);
			draw_meter(x, s);
			anno_stop(s)
			break
		case C.KEY:
			p_voice.key = s
			if (s.second
			 || !staff_tb[s.st].topbar)
				break
			set_color(undefined);
			set_sscale(s.st);
			anno_start(s);
			draw_keysig(p_voice, x, s);
			anno_stop(s)
			break
		case C.MREST:
			set_scale(s);
			x += 32;
			anno_start(s);
			xygl(x, staff_tb[s.st].y + 12, "mrest");
			out_XYAB('<text style="font-family:serif; font-weight:bold; font-size: 15px"\n\
	x ="X" y="Y" text-anchor="middle">A</text>\n',
				x, staff_tb[s.st].y + 28, s.nmes);
			anno_stop(s)
			break
		case C.GRACE:
			set_scale(s);
			draw_gracenotes(s)
			break
		case C.SPACE:
		case C.STBRK:
			break			/* nothing */
		case C.CUSTOS:
			set_scale(s);
			draw_note(s, 0)
			break
		case C.BLOCK:			// no width
		case C.PART:
		case C.REMARK:
		case C.STAVES:
		case C.TEMPO:
			break
		default:
			error(2, s, "draw_symbols - Cannot draw symbol " + s.type)
			break
		}
	}
	set_scale(p_voice.sym);
	draw_all_ties(p_voice);
// no need to reset the scale as in abcm2ps
	set_color(undefined)
}

/* -- draw all symbols -- */
function draw_all_sym() {
	var	p_voice, v,
		n = voice_tb.length

	for (v = 0; v < n; v++) {
		p_voice = voice_tb[v]
		if (p_voice.sym
		 && p_voice.sym.x != undefined)
			draw_symbols(p_voice)
	}

	draw_all_deco();
	set_sscale(-1)				/* restore the scale */
}

/* -- set the tie directions for one voice -- */
function set_tie_dir(sym) {
	var s, i, ntie, dir, sec, pit, ti

	for (s = sym; s; s = s.next) {
		if (!s.ti1)
			continue

		/* if other voice, set the ties in opposite direction */
		if (s.multi != 0) {
			dir = s.multi > 0 ? C.SL_ABOVE : C.SL_BELOW
			for (i = 0; i <= s.nhd; i++) {
				ti = s.notes[i].ti1;
				if (!((ti & 0x07) == C.SL_AUTO))
					continue
				s.notes[i].ti1 = (ti & C.SL_DOTTED) | dir
			}
			continue
		}

		/* if one note, set the direction according to the stem */
		sec = ntie = 0;
		pit = 128
		for (i = 0; i <= s.nhd; i++) {
			if (s.notes[i].ti1) {
				ntie++
				if (pit < 128
				 && s.notes[i].pit <= pit + 1)
					sec++;
				pit = s.notes[i].pit
			}
		}
		if (ntie <= 1) {
			dir = s.stem < 0 ? C.SL_ABOVE : C.SL_BELOW
			for (i = 0; i <= s.nhd; i++) {
				ti = s.notes[i].ti1
				if (ti) {
					if ((ti & 0x07) == C.SL_AUTO)
						s.notes[i].ti1 =
							(ti & C.SL_DOTTED) | dir
					break
				}
			}
			continue
		}
		if (sec == 0) {
			if (ntie & 1) {
/* in chords with an odd number of notes, the outer noteheads are paired off
 * center notes are tied according to their position in relation to the
 * center line */
				ntie = (ntie - 1) / 2;
				dir = C.SL_BELOW
				for (i = 0; i <= s.nhd; i++) {
					ti = s.notes[i].ti1
					if (ti == 0)
						continue
					if (ntie == 0) {	/* central tie */
						if (s.notes[i].pit >= 22)
							dir = C.SL_ABOVE
					}
					if ((ti & 0x07) == C.SL_AUTO)
						s.notes[i].ti1 =
							(ti & C.SL_DOTTED) | dir
					if (ntie-- == 0)
						dir = C.SL_ABOVE
				}
				continue
			}
/* even number of notes, ties divided in opposite directions */
			ntie /= 2;
			dir = C.SL_BELOW
			for (i = 0; i <= s.nhd; i++) {
				ti = s.notes[i].ti1
				if (ti == 0)
					continue
				if ((ti & 0x07) == C.SL_AUTO)
					s.notes[i].ti1 =
						(ti & C.SL_DOTTED) | dir
				if (--ntie == 0)
					dir = C.SL_ABOVE
			}
			continue
		}
/*fixme: treat more than one second */
/*		if (nsec == 1) {	*/
/* When a chord contains the interval of a second, tie those two notes in
 * opposition; then fill in the remaining notes of the chord accordingly */
			pit = 128
			for (i = 0; i <= s.nhd; i++) {
				if (s.notes[i].ti1) {
					if (pit < 128
					 && s.notes[i].pit <= pit + 1) {
						ntie = i
						break
					}
					pit = s.notes[i].pit
				}
			}
			dir = C.SL_BELOW
			for (i = 0; i <= s.nhd; i++) {
				ti = s.notes[i].ti1
				if (ti == 0)
					continue
				if (ntie == i)
					dir = C.SL_ABOVE
				if ((ti & 0x07) == C.SL_AUTO)
					s.notes[i].ti1 = (ti & C.SL_DOTTED) | dir
			}
/*fixme..
			continue
		}
..*/
/* if a chord contains more than one pair of seconds, the pair farthest
 * from the center line receives the ties drawn in opposition */
	}
}

/* -- have room for the ties out of the staves -- */
function set_tie_room() {
	var p_voice, s, s2, v, dx, y, dy

	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v];
		s = p_voice.sym
		if (!s)
			continue
		s = s.next
		if (!s)
			continue
		set_tie_dir(s)
		for ( ; s; s = s.next) {
			if (!s.ti1)
				continue
			if (s.notes[0].pit < 20
			 && (s.notes[0].ti1 & 0x07) == C.SL_BELOW)
				;
			else if (s.notes[s.nhd].pit > 24
			      && (s.notes[s.nhd].ti1 & 0x07) == C.SL_ABOVE)
				;
			else
				continue
			s2 = s.next
			while (s2 && s2.type != C.NOTE)
				s2 = s2.next
			if (s2) {
				if (s2.st != s.st)
					continue
				dx = s2.x - s.x - 10
			} else {
				dx = realwidth - s.x - 10
			}
			if (dx < 100)
				dy = 9
			else if (dx < 300)
				dy = 12
			else
				dy = 16
			if (s.notes[s.nhd].pit > 24) {
				y = 3 * (s.notes[s.nhd].pit - 18) + dy
				if (s.ymx < y)
					s.ymx = y
				if (s2 && s2.ymx < y)
					s2.ymx = y;
				y_set(s.st, true, s.x + 5, dx, y)
			}
			if (s.notes[0].pit < 20) {
				y = 3 * (s.notes[0].pit - 18) - dy
				if (s.ymn > y)
					s.ymn = y
				if (s2 && s2.ymn > y)
					s2.ymn = y;
				y_set(s.st, false, s.x + 5, dx, y)
			}
		}
	}
}
// abc2svg music font
var musicfont = 'url("data:application/font-ttf;base64,\
AAEAAAANAIAAAwBQRkZUTX30pOoAACfYAAAAHE9TLzJYnlnxAAABWAAAAFZjbWFwN+qJgQAAAsAA\
AAIqY3Z0IAAiAogAAATsAAAABGdhc3D//wADAAAn0AAAAAhnbHlmirg/swAABXwAAB4caGVhZAsO\
geEAAADcAAAANmhoZWEIoQEcAAABFAAAACRobXR4cVoAlAAAAbAAAAEObG9jYQpbAnAAAATwAAAA\
im1heHAAiwDcAAABOAAAACBuYW1lNpjajAAAI5gAAAGDcG9zdA9CdgsAACUcAAACsQABAAAAAQAA\
tjNVVF8PPPUACwQAAAAAANGXIhcAAAAA1qodLf+6/QwD9ASUAAAACAACAAAAAAAAAAEAAASU/QwA\
XAQN/7r/vwP0AAEAAAAAAAAAAAAAAAAAAABDAAEAAABEAKsABQAAAAAAAgAAAAEAAQAAAEAALgAA\
AAAAAQG7AZAABQAIApkCzAAAAI8CmQLMAAAB6wAzAQkAAAIABQMAAAAAAAAAAAAAEAAAAAAAAAAA\
AAAAUGZFZABAAADpXAMz/zMAXASUAvQAAAABAAAAAAAAAXYAIgAAAAABVQAAAZAAAABXAAAB4P/c\
A14AegMLAAAC0gAAAr//ugHWAAADCwAAAw4AAAMn/8gBrgAAASIAAAGQAAABfAAAAZAAAAGQAAAB\
gQAAAZAAAAGQAAABgQAAAZkACQGYAAkB9AAAAQQAFAEEAAoCEQAAAhwAAAHAAAABSQAAAUoAAAFK\
//4BLAAAAjAAAAHgAAABDQAyAMgAAAENAAABCwAUAW4AAAENADIBQP/9ARgAAAJYAAAAtgAAAIIA\
AACCAAABLAAAASwAAADuAAAA/wAAAUkAAAGPAAAB2AAAAdgAAANTAAACM//wAyD/4QG1AAABtQAA\
AkQADQJEAA0EDQAAAhwADAAAAAAAAAADAAAAAwAAABwAAQAAAAABJAADAAEAAAAcAAQBCAAAAD4A\
IAAEAB4AAOAA4EjgUOBc4GLgaeB84IzgleCk4Kngs+EB4efiZOKA5KDkrOTA5M7k6uTu5QHlZ+Vp\
5W3mUOZV6Vz//wAAAADgAOBH4FDgXOBi4GngeuCA4JTgoOCp4LPhAeHn4mDigOSg5KzkwOTO5OHk\
7uUA5WflaeVs5lDmVelc//8AAyAEH74ftx+sH6cfoR+RH44fhx99H3kfcB8jHj4dxh2rG4wbgRtu\
G2EbTxtMGzsa1hrVGtMZ8RntFucAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBgAAAwAAAAAAAAABAgAAAAIAAAAAAAAAAAAA\
AAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAACICiAAAACoAKgAqADYAZgDOARABpgI4ApICpgNCA9QELAROBGIEtAUEBSQFagWqBeQG\
MAZwBrYHEAckB0oHcAesB8gH9ggiCDwIVgiMCJoIrAjSCOwJHAlGCaIJyAnwCgAKKApOCloKZgpy\
Cn4KoArGCvwLSguqDB4MNAxaDIgMzA0WDTANVA40DvAPDgAAAAIAIgAAATICqgADAAcALrEBAC88\
sgcEAO0ysQYF3DyyAwIA7TIAsQMALzyyBQQA7TKyBwYB/DyyAQIA7TIzESERJzMRIyIBEO7MzAKq\
/VYiAmYAAAEAAAAAAZEBkAADAAAxESERAZEBkP5wAAEAAAAAAFcEAwAgAAARNTY1NCcmNTQ3BhUU\
FxYVFAcWFRQHBhUUFyY1NDc2NTQ1IxJXPxUlTU0lFT9XEiMCAwIYQzZgOTRmOjJLIjlhTWEYGGZM\
YDklSjI6ZjQ5YDZIAAP/3AACAd4CswAHAA8ARwAAACImNDYyFhQEIiY0NjIWFBc0NjMyFhUUBxYz\
MjY1NCcmJwMnEyY1NDc2MhYVFAYjIiY1NDcmIyIGFRQXFhcTFwMWFRQHBiImAZ4gGBggGP5+IBgY\
IBhbGxQTHiwYKCdBMDxBzyvTmDgoYDgbFBMeLBgoJ0EwQTvUK9eYOChgOAFSGCAYGCBUGCAYGCDY\
EhwaER0OGC8lKDAtOP7eIAEmj2A1LxQzIRIcGhEdDhgvJSgwMTQBJh/+1pBgNS8UMwAFAHr/NANe\
AlQAFwAbAB8AIwAnAAABMxUeARczFSMOAQcVIzUuAScjNTM+ATcRIxYXNxU2NyczJicHNQYHAdgo\
VXgHiooHeFUoVXgHiooHeFVwBWsoawVwcAVrKGsFAlSJCItgKGCLCImJCItgKGKJCP7lug7IyA66\
KLoOyMkOuwAAAAAEAAD9gQKnBJQAPwBGAFoAZwAAATYzMhYXFhUUBwYHFxYVFAYjIiY1NDYzMhYV\
FAYHFjMyNTQvAQYjIiY1NDc+ATc+AjcuAjU0NjceARUUBgcbATY1NCYjCwEOARUUFy4BNTQ2NycO\
AQcSITIDBhUUFz4BNTQmJw4BAY8SCzVnID98QisQAkVPUWBAMi5CPjAbKmUBEQscr8E5El4mBi0w\
FwMKBW9ROx5beR8fq25OFSA3Ry8yM2BJEY9sAQUBLwQpBAdJcBgaO0UBCgIqJkR7lDwiBLsgDlBN\
WEEsQEQtKzIBD4ASCr4Bt6yEZiNkHgUoKBEhdUgdip4YQHlyiahf/rX+nieRQGr+ngFeCkAwLToM\
WjpGYhS9cpdn/tYEDiEuUiMxj0gpTw8HdwACAAD9/ALSAgAAZABoAAABMjY1NCcmIyIHDgIHJicm\
JxEjETMRNjc2Nx4DFxYzMjY1NCcmIyIHFhcUFhUUBisBJjU0NzY3NjMyFxYXFRQGBwYjIicHFzYz\
MhYXFh0BBgcGIyImNTQ3MzIWFRQGFQYHFgEzESMB3j5KDRpJRjwCBgoEIhoeLhwcLh4aIgYUDBkP\
JyUxPRIkUi8xMg0CMyEFRAUaVScjXlU3CFpIHy00PyIiPzRCZh4oCDdWXUxyRAUhMwIPMDX+TXt7\
/iB4Si0tbEkFDhsKYicrH/4EBAD+ER8rJ2ILKhcdCRt7QjE2YhoQKAMNBB4rGTIUC0QZDU80UxJO\
bxwNF0tKFz4sOUMSUzRQTjwyGSseBA4EJhAcA978AAAAA/+6/aUCwwD/ACYAMQA9AAA3NDYzMhcW\
FRQHDgEHNjc2NzY1NCcuASMiBgc+ATMyFhUUBwYjIiYFIiY1NDYyFhUUBiciJjU0NjMyFhUUBhOM\
ZqNLLJdU9oTwdVskCzgeOSg8Zg0XGxwuRychLThGAoIWHRkqHhoaFxsaFxQcGylgdm1Bb/aISm4H\
QH1erj0xfkEhGFJEHRBLLzIgHmeSHBcWHB0VFh3yHhkWGRsUGR4AAAAAAgAA/wYBcgD6AAMABwAA\
NzMTIwMzEyPclAKW3JQClvr+DAH0/gwAAAQAAP4KAh8DqgAJACAAYgBtAAAlFhc+ATU0JiMiAwIn\
DgEVFBcuATU0NjcmJw4BBx4BMzIXHgEfAR0BFCMiJjU0NjMyFhUUBgcWMzI2NTQvAQYjIiY1NDc+\
ATc+AjcmNTQ2Nx4BFRQGBx4BFzYzMhcWFRQHBgMGFRQXPgE1NCcGAUkTBk1HVkIODRgBLDkfICpM\
OwUJcVUBBW2CAyIDBgICejZTMyglNTEnFSIjLAENCRWNmS4OTB4FIycSDllALxlJYQIIBBIIXDky\
YzZkAwY3XilfdcRbEk8zNlb+4AELEAk0JykmEkEpOE4QPlpaeVNxfhogQBcXGwd/SDEkMzckIigB\
DDM1DwmNAZKKalEcUBgEICENwgdufxMzYltth0wRbiQCQzZidzAbA1YeIjkkJXszRiYmAAIAAP5j\
AkIBmgBjAGcAAAEyNjU0JyYjIgcOAQcmJyYnESMRMxE2NzY3HgMXFjMyNjU0JyYjIgcWFxQWFRQG\
KwEmNTQ3Njc2MzIXFhcVFAYHBiMiJwcXNjMyFhcWHQEGBwYjIiY1NDczMhYVFAYVBgcWATMRIwF+\
MjsKFTo4MAIMBB0TGCUWFiUYEx0EEQoTDCAdJzEOHEMlJygKAioaBDYEFUQjGElGLQZIOhglKzEb\
GzQoNVIYIAYtRkk9WzYEGioCDCYr/qNiYv6AYDskJFc7BR0LUhwiGf5qAzP+dBkiHFIIIhIXCBZi\
NSsoThUNIAILAxgiFCgQCTUVC0ArQQ4+WhYKEjw7EzIjLjUPQStAPzAoFCMYAwsDHw0WAxj8zQAA\
AAAD/8j+HgI2AMwAJgAvADsAADc0NjMyFxYVFAcOAQc2NzY3NjU0Jy4BIyIGBz4BMzIWFRQHBiMi\
JgUiJjQ2MhYUBiciJjU0NjMyFhUUBg9wUoI8I3hDxmnAXkceCS0YLSAwUgoSFhYlOSAZJSw5AgIS\
FxQiGBUVEhYVEhEWFSFNXlczWsZsO1cGM2RKjC8pZjMaFEI2Fw08JigaGFN1FyQWFyIYwhgUERQV\
EBMZAAAAAAIAAP8GAa4A+gALABQAADMUFjMyNjU0JiMiBgc0NjIWFAYiJooqIyIrJyYlKIp9tH19\
tH1ieHlhZXV2YWeQkdKRkgAAAQAA/wYBIgD6AAkAADE3MxEXFSM1NxFkfUHwQfr+Ph4UFB4BLAAA\
AAEAAP8GAY8A+gA8AAA3MhUUBw4DBzYzMhYzMjc+AjMOAgcGBwYjIiYjIgYjIjU0Jz4FNTQnIgcy\
FhUUBiMiNTQ+AcfIBQ02QG82EyAbZBwYHgUQDAEBBQUBBxAaKRp0FR9WAgcBAiw+RzwoU04aHCk3\
Hkw8WPp+Gg4hLh1ELQwjDgMNCwUWFgMpDhgnJhABAiFFODwyOBhiATUlHh8pZyg5GQAAAQAA/wYB\
dQD6ADkAADcyFhUUBiMiJjU0NzYzMhcWFRQGBx4BFRQHBiMiJicmNDYzMhYVFAYjFjMyNjU0Jicm\
NDc+ATQmIyJmGyInIRsyHzNZRiZERj0+UUskTSdXGCMyICIqJRsMPyQrSC4WFi9LKSQ8qhwXGyMr\
Iy8aKhMiSC5ECwtFLUMnExYUHUwuIRsZHikxJyY6CAQiBAk3UDAAAAEAAP8GAZAA+gARAAAFFyM3\
NSM1NjUzATM/AREzFSMBRTLIMuGTo/77sAFjS0vRKSkxKPKA/o6Wkf7ZKAAAAAABAAD/BwF+APoA\
LwAAFzYzMhYVFAYjFjMyNz4BNTQnJiMiBxMhDgErAQc2MzIXHgEVFAcOAiMiJy4BNTQSHCEbKiAc\
GiQxHBMJHhwoTkgKAWILNSXVBjlCUzEhK0MWQCslPCsQHl8gIBccICEeFB8gORwaNQEiJDp5Hh8V\
QSVPLxAQAhQJMhIjAAAAAAIAAP8GAYEA+gAJACwAABcyNjU0JiMiBxYTFhUUBiMiJjU0NjMmIyIG\
FT4CMzIWFRQGIyImJz4BMzIWyCktKigsMAfdGyMYHiIbEBY3NS8VGC0eTE9xSGFmAQFsWzA/0kUs\
IjAlngGfGiYZKB4bDB4jeF8LCglANkRZgnhpkRIAAQAA/wYBkAD7ACgAADciDgMHNz4IMzIWMzI2\
Nw4EFSM2NzY3NjcGIyImYRQaFAkRBQoBDAILBQsJDRAJL3UjGjsRG0UaHgiCAQgRaB4tER4lYKEF\
DgkbBnQBCwIJAQYBAwEmFw5Dp0FcQitFGzaHJzkKKAADAAD/BgGEAPoADgAcADQAABcOARUUFjMy\
NjU0LgM3PgE1NCYiBhUUHgMHLgE1NDY3MhYVFAYHHgEVFAYjIiY1NDaaNixYLCo/DyAdMT4zI0RS\
MwocEjFwMSlmSktlKjA6MnVNTHY5KhkkGx0wKR8OFxINE1oaIhwdMCggDxcTChU/GDw1M00BRjIn\
NBcaOjU3SkgwJDUAAAIAAP8GAYEA+gAJACwAADciBhUUFjMyNyYDJjU0NjMyFhUUBiMWMzI2NQ4C\
IyImNTQ2MzIWFw4BIyImuSktKigsMAfdGyMYHiIbEBY3NS8VGC0eTE9xSGFmAQFsWzA/0kUsIjAl\
nv5hGiYZKB4bDB4jeF8LCglANkRZgnhpkRIAAQAJ/woBmQD5ADAAACUwFzY1NCYjDgEVFBcWMzI3\
NjcUHgEVDgEHIicmJzQmNTQ3MhYXFhUUBiMiJjU+ATMBLxIEPB8yQSchMCsoHCoJCBtVVk87OwQB\
2yRAESIkHCApAiAapAMFCBQiAmVrjjMqIhhYAQQDAVVQATk5ZgIrAuYCHhQnJCU5LhwWJgACAAn+\
ogGZAV4AOAA/AAAlMBc2NTQmIyIHERYzMjc2NxQeARUOAQcjFSM1JicmJzQmNTQ3NTMVMjYzMhYX\
FhUUBiMiJjU+ATMDEQYVFBcWAS8SBDwfAxAMDCsoHCoJCBtRVQEjPS47BAGrIwMHAyRAESIkHCAp\
AiAaej0nCqQDBQgUIgT+SwQiGFgBBAMBVFEBaGsJLTlmAisCyxlpZgEeFCckJTkuHBYm/pcBli6R\
jjMNAAABAAD/BgH0APoACwAANTM1MxUzFSMVIzUj10bX10bXI9fXRtfXAAAAAQAU/gYA4wIAABMA\
ABMWBwYnJgI1NBI3NhcWBwYCFRQS3AcNCQVJa2tJCQsGBjxGR/4WCAUDBlcBIH18ASJWCwcGCEn+\
54iG/uUAAAEACv4CANwB/QATAAATNhI1NAInJjc2FxYSFRQCBwYnJhQ7R0Y8CQwKB0lra0kICwb+\
FkkBG4aIARlJCwQECVb+3nx9/uBXCQkEAAAEAAD/TAIRAKoAAwAHABsAJQAAJTMRIwEzESM3BhUU\
Fx4BFzMyNzY0Jy4BJzAjIgQUBiMiJjU0NjIB6Sgo/hcnJ5cFAwpVLg0zEwUDCVYuDTYBQXlnZnp5\
zqr+ogFe/qLzDA4LCyJHBCMJHAsiRwQmeEVEOD9HAAACAAD/JAIcANwAAwAPAAA3FSE1JTMVITUz\
ESM1IRUjGQHq/f0ZAeoZGf4WGUaMjJYyMv5IMjIAAAIAAP9/AcAAgQATAB0AADcGFRQXHgEXMzI3\
NjQnLgEnMCMiBBQGIyImNTQ2Mm8FAwpVLg0zEwUDCVYuDTYBQXlnZnp5zj8MDgsLIkcEIwkcCyJH\
BCZ4RUQ4P0cAAgAA/2wBSACUAA0AGwAAJSYjIgYVFBcWMzI2NTQ3FhUUBiMiJyY1NDYzMgEkDSU8\
lwYLJjyXEA9+SE8kD35IT0QXYSsKCRdhKwkXHh1DZ0MeHUNnAAAAAAEAAP90AUoAiwAOAAAVNDY3\
NjMyFhUUBwYjIiZdSB4RM0OlGBsxQSE+VBMHODJ1MAg5AAAB//7/bwFMAJEACwAAJzcXNxcHFwcn\
Byc3AhuMjBuGhhyLixyGcSB2dSBwcCF1dSFwAAAABQAA/2oBLACWAAUACwARABcAHwAAFwcWMzI3\
LwEGFRQXPwEmIyIHHwE2NTQnBjQ2MhYUBiKWRx0qKR9dRx0dXEgfKSodXEcdHfJYfFhYfBJIHR1a\
SR8pKh1YSB0dWkgfKSodhXxYWHxYAAAAAQAA/wYCMAD6AAMAABUBMwEBuHj+R/oB9P4MAAEAAP/O\
AGQAMgAHAAAWIiY0NjIWFEcqHR0qHTIdKh0dKgAAAAIAMv9kAQ0BsAAKABYAADciBh0BNjc2NTQm\
NzIWFRQHBiMRMxE2lBUqHCwuIAciOU9SOiMjeh4SywNCPzYbJiYyI0VQUgJM/rw0AAACAAD+hgDF\
AXoAAwAMAAAXNzUHERU3ESM1BxE3HJCQqRmsAWUtli0BSeg0/cDiMwJDAQAAAgAA/o8BDAF1AAMA\
HwAANxU3NQMjNQc1NzUHNTc1MxU3NTMVNxUHFTcVBxUjNQdSZmYZOTk5ORlmGDw8PDwYZk20HLX+\
Ja8RVQ63EFcOsqoat68PUxK0D1MPsaodAAAAAQAU/4QBCwB6AB4AABc1JicHMBUjNTM3JzAjNTMV\
Fhc3MDUzFSMGBxcwMxXDKAwzSDkzMzlIIRI0SDkhEzQ5fDsmDTM7SjIySDkiETM5RyIRNEgABAAA\
/2oBbAGwABAAHgAtADwAADcOAR0BMjc2NzY3NjU0JyYjNzIWFRQHBgcGIxEzETYXDgEdATI3Njc2\
NTQnJiM3MhYVFAcGBw4BIxEzETZOER4LGwQCHwwEChARGR0rCRgrNS8fGdERHQ0hHQsGCxAPFh8q\
CxkoFjcWHht9AR4QyyYFAys0DRkeFBUmOSESIDk0QAJG/sEyJgEdEcsuLzATExwWFSY2JBYcPi8b\
JQJG/sEyAAAAAAIAMv9kAQ0BsAAKABYAADciBhUUFxYXNTQmJzIXETMRIicmNTQ2qxcgLi4aKjM6\
IyM6Uk85eiYbMEVCA8sSHiY0AUT9tFJQRSMyAAAB//0AAAE/APQAGAAANwYjIiY1ND8BNi8BJjU0\
NjMyMRcFFhUUBxICAwcJBs8ODs0ICwcBAgEfDg4BARAICgNJBwZPAwsKEgFrBg4NBQAAAAEAAAAA\
ARgBNQAFAAAxGwEjJweMjEFYWgE1/svGxgAAAgAAAAACWAFKAA4AGQAAMTQ2MzIeAhUjLgEiBgch\
IiY0NjMyFhUUBrN5OWtVMwoLpuKmCwEhFyUlFxkjI5iyLFGATW6Ghm4kMCQkGBkjAAABAAAAAAC2\
AS0AFwAAEzIWFxYVFAcOASMnJjU0NjU0Iy4BNTQ2VhsbEBoyGUQQBgFHFBsoLQEtDBEdMD08HS0D\
AQIIaxMPASYcHjEAAQAA/wYAggD6AAMAADUzEyOAAoL6/gwAAQAAAAAAggD6AAMAADUzFSOCgvr6\
AAAAAQAA/4MBLAAAAAMAADEhFSEBLP7UfQAAAQAAAAABLAB9AAMAADUhFSEBLP7UfX0AAQAA/n4A\
6wGHABMAABMXBxcmIyIGFRQXJjU0NjMyFyc3Kb1nbDI0HyY4eDQlIiKHZAGH5dnPLiQdNTRLTSMt\
Fby0AAABAAD/DQEAAMAAFgAANw4CIyImNTQ2MhYVFAcyNjc2MhcDJ6sDGRoTKzcmOCkXIjMhAhUD\
ljA8AQcEKSgfIB4ZHRshLAIC/m8QAAAAAQAA/gwBSADAACQAABcGIyImNTQ2MzIWFRQHMj8BBiMi\
JjU0NjMyFhUUBzI3NjIXAyerKCErNycbHCkXQQs8NhgrNycbHCkXSC4CFQPFLcQMKCggIB8ZHRsi\
ygwpKB8gHhkdG00CAv1uDAAAAQAA/gwBjwHAADYAADcGIyImNTQ2MzIWFRQHMj8BIg4BIyImNTQ2\
MzIWFRQHMjc2MhcBJxMGIyImNTQ2MzIWFRQHMjf2KB8rNycbHCkXPws6ASAcEys3JxscKRdILgEW\
A/70LVUoISs3JxscKRdBCzwMKCggIB8ZHRsiywkEKSgfIB4ZHRtNAgL8bgwBJAwoKCAgHxkdGyIA\
AAAAAQAA/QwB2gHAAEUAABMGIyImNTQ2MzIWFRQHMj8BBiMiJjU0NjMyFhUUBzI/AQYjIiY1NDYz\
MhYVFAcyPwEiDgEjIiY1NDYyFhUUBzI3NjIXASerKCErNycbHCkXQQs6KCErNycbHCkXQQs6KB8r\
NycbHCkXPws6ASAcEys3JjgpF0guAhUD/qkt/jwMKCggIB8ZHRsiygwoKCAgHxkdGyLKDCgoICAf\
GR0bIssJBCkoHyAeGR0bTQIC+24MAAAAAQAA/QwCGQKuAFYAACUGIyImNTQ2MzIWFRQHMj8BBiMi\
JjU0NjMyFhUUBzI/ASIOASMiJjU0NjMyFhUUBzI3NjIXAScTBiMiJjU0NjMyFhUUBzI/AQYjIiY1\
NDYzMhYVFAcyNwE/KCErNycbHCkXQQs2KB8rNycbHCkXPws0ASAcEys3JxscKRdILgEWA/5qLVUo\
ISs3JxscKRdBCzooISs3JxscKRdBCzQMKCggIB8ZHRsixAwoKCAgHxkdGyLHCQQpKB8gHhkdG00C\
AvqADAEkDCgoICAfGR0bIsgMKCggIB8ZHRsiAAEAAP8aA1IA5gALAAA1MxUhNTMRIzUhFSMZAyAZ\
GfzgGeZ9ff40fX0AAAAAA//w/wYCJgD6AAcADwATAAA2IiY0NjIWFAAiJjQ2MhYUBQEzAVAyIyMy\
IwGIMiMjMiP90gG4fv5HSyMyIyMy/s8jMiMjMloB9P4MAAT/4f8GAwcA+gAHAA8AEwAXAAA2IiY0\
NjIWFAAiJjQ2MhYUBQEzATMBMwFBMiMjMiMCdzIjIzIj/OMBuHv+R3kBuHv+R0sjMiMjMv7PIzIj\
IzJaAfT+DAH0/gwAAQAA//0BtQDUAC8AACUyNjU0JwYjIjU+ATMyFhUUBwYjIi8BJiMiBhUUFzYz\
MhUUByInJjU0NzYzFh8BFgF2FRwWFBIcAQ8JIC0pFxwkHqggDxYcFRQTHBkZGBwoFiAoF6giJSkc\
JxAMGw8VQiYzJBUVghYoHicPDB0gAxoiLTMkEwIQghcAAAEAAP/NAbUBAwA2AAAXIiY1NDc2MxYf\
ATUzFRcWMzI2NTQnBiMiNT4BMzIWFRQHBiMiLwEVIzUnJiMiBhUUFzYzMhUUTSAtKBYgKBcuHlwi\
DxUcFhQSHAEPCSAtKRccJB4uHlwgDxYcFRQTHANDJjMkEwIQJGmARxcpHCcQDBsPFUImMyQVFSRs\
g0cWKB4nDwwdIAABAA0AAAJFAOAACwAANyc3FzcXNxcHJwcnIhWOZXhqTRaSaXRpLhmZfHx8VBeh\
fHx8AAAAAQAN/8sCRQERABMAACUHJwcnNxc3NTMXNxc3FwcnBxUjARZAaUsVjmUWGwFGak8UkmkZ\
G0ZGfE4ZmXwXlntKfFUYoXwblgAABAAA//wD9AJ/AAkAlACgAKoAAAUiJjQ2MzIWFAYlJjU0NzYz\
MhYVFAcOBwcWMzI2NTQ2Ny4CPQEeARUUBiMiJwYjIiYnDgEiJicmIyIGBwYjIjU0Njc+CTc2NTQm\
NTQ/AQ4BFDMyNxcOASMiJjU0PgIzMhYVFAYjIiYnNxYzMjY1NCYnBwYVFBYVFA8BHgEzMj4GNz4B\
NTQnJiMiBhUUBTY1NCYnDgEVFAPWCxMTCwwSEf3pIxwgThsjCgQMCxAKEgcSASosFTJDXSCBXrq0\
UUJBIyQ8IkETMCYgGxwaEg0tA1csCjohDhsPEQYKAwcDCQMCQgI0WnIgNRwQKTYwFBcfPXFIfntC\
JR05EQ0aNCEsXF8mAkYBJhE7DwQHBwkHDAgSLDUiBAQWHC8BPFoXEj8zAhIYEhIYEl84JTUlKykf\
IRMJEQ4QCg8GDgEzMBpSXxksWTQGATyxa0ZfOTooGCkbFiAtIwE6BwszFAgRBgwCEAMZDCkOCAIW\
QR4HDNcHWFAwCEUsIRofSEcvXDwlPispDC0dGyNJBaAIBhlEGggEowxYAgIHBAsHDyAwLyAHDhI5\
KyJwBYEiSRUdWUM+AAIADAAKAdMBzwAKAI8AACU0JiMiBhQWMzI2Jw4BIyImNDYzMhYXNjU0JyYj\
IiY0NjMyFx4BFxYzMjU0Jy4BNTQ2MzIWFRQGBxQzMjc+ATc2MzIWFRQGIyIGBwYVFDMyNjMyFhQG\
IyImIyIGFRQXHgEXFhUUBiMiJy4BJyYjIhUUFhUUBiMiJjQ2NTQjIgcOAQcGIyImNTQ3NjMyNzY1\
NAEWGA8QFRYPEBeJGSYOGRsaGQ0qGCUMFBgdHBkXEhALAxQLEhQBAiceFBIbIwEWEA0RAQ0MGhMe\
GxIbFQ0QIRsrDhwbHRkPJxQXEgsUOA0OGRcTFAwBExEKEiogExIdJhcNDhIDERIMFBoNDBYjEg3u\
EBQTIhYVCgElGSobJQIDFg4KExwoHQwLPhYNGA0IFycPFxobFhEjGSoQEzgPDhsUESMGCw4PFicd\
KBomCAoWChIDCw0ZExsOCzkVDx8eMBMUGBokMRckDhI9DAcWFBgODRINDBoAAAACAAD95AIdANwA\
AwAPAAA3FSE1JTMVITUzEyMDIRUjGQHq/f0ZAeoZARkB/hYZRoyMljIy/QgBcjIAAAAAAAwAlgAB\
AAAAAAABAAcAEAABAAAAAAACAAcAKAABAAAAAAADACIAdgABAAAAAAAEAAcAqQABAAAAAAAFAAsA\
yQABAAAAAAAGAAcA5QADAAEECQABAA4AAAADAAEECQACAA4AGAADAAEECQADAEQAMAADAAEECQAE\
AA4AmQADAAEECQAFABYAsQADAAEECQAGAA4A1QBhAGIAYwAyAHMAdgBnAABhYmMyc3ZnAABSAGUA\
ZwB1AGwAYQByAABSZWd1bGFyAABGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAOgAgAGEAYgBj\
ADIAcwB2AGcAIAA6ACAAOQAtADMALQAyADAAMQA4AABGb250Rm9yZ2UgMi4wIDogYWJjMnN2ZyA6\
IDktMy0yMDE4AABhAGIAYwAyAHMAdgBnAABhYmMyc3ZnAABWAGUAcgBzAGkAbwBuACAAMQAuADAA\
AFZlcnNpb24gMS4wAABhAGIAYwAyAHMAdgBnAABhYmMyc3ZnAAAAAgAAAAAAAAAAAAAAAAAAAAAA\
AAAAAAAAAAAAAAAAAABEAAAAAQACAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgET\
ARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAElASYBJwEoASkBKgErASwBLQEuAS8B\
MAExATIBMwE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgYubm9kZWYHdW5pRTAwMAd1bmlF\
MDQ3B3VuaUUwNDgHdW5pRTA1MAd1bmlFMDVDB3VuaUUwNjIHdW5pRTA2OQd1bmlFMDdBB3VuaUUw\
N0IHdW5pRTA3Qwd1bmlFMDgwB3VuaUUwODEHdW5pRTA4Mgd1bmlFMDgzB3VuaUUwODQHdW5pRTA4\
NQd1bmlFMDg2B3VuaUUwODcHdW5pRTA4OAd1bmlFMDg5B3VuaUUwOEEHdW5pRTA4Qgd1bmlFMDhD\
B3VuaUUwOTQHdW5pRTA5NQd1bmlFMEEwB3VuaUUwQTEHdW5pRTBBMgd1bmlFMEEzB3VuaUUwQTQH\
dW5pRTBBOQd1bmlFMEIzB3VuaUUxMDEHdW5pRTFFNwd1bmlFMjYwB3VuaUUyNjEHdW5pRTI2Mgd1\
bmlFMjYzB3VuaUUyNjQHdW5pRTI4MAd1bmlFNEEwB3VuaUU0QUMHdW5pRTRDMAd1bmlFNENFB3Vu\
aUU0RTEHdW5pRTRFMgd1bmlFNEUzB3VuaUU0RTQHdW5pRTRFNQd1bmlFNEU2B3VuaUU0RTcHdW5p\
RTRFOAd1bmlFNEU5B3VuaUU0RUEHdW5pRTRFRQd1bmlFNTAwB3VuaUU1MDEHdW5pRTU2Nwd1bmlF\
NTY5B3VuaUU1NkMHdW5pRTU2RAd1bmlFNjUwB3VuaUU2NTUHdW5pRTk1QwAAAAAAAAH//wACAAAA\
AQAAAADVs2WlAAAAANGXIhcAAAAA1qodLQ==\
")'
// abc2svg - format.js - formatting functions
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

var	defined_font = {},
	font_tb = {},
	fid = 1,
	font_scale_tb = {
		serif: 1.05,
		serifBold: 1.05,
		'sans-serif': 1.1,
		'sans-serifBold': 1.1,
		Palatino: 1.1,
		Mono: 1.35
	},
	fmt_lock = {}

var cfmt = {
	aligncomposer: 1,
//	botmargin: .7 * IN,		// != 1.8 * CM,
	breaklimit: .7,
	breakoneoln: true,
	cancelkey: true,
	composerspace: 6,
//	contbarnb: false,
	dblrepbar: ':][:',
	decoerr: true,
	dynalign: true,
	fullsvg: '',
	gracespace: new Float32Array([4, 8, 11]), // left, inside, right
	graceslurs: true,
	hyphencont: true,
	indent: 0,
	infoname: 'R "Rhythm: "\n\
B "Book: "\n\
S "Source: "\n\
D "Discography: "\n\
N "Notes: "\n\
Z "Transcription: "\n\
H "History: "',
	infospace: 0,
	keywarn: true,
	leftmargin: 1.4 * CM,
	lineskipfac: 1.1,
	linewarn: true,
	maxshrink: .65,
	maxstaffsep: 2000,
	maxsysstaffsep: 2000,
	measurefirst: 1,
	measurenb: -1,
	musicspace: 6,
//	notespacingfactor: 1.414,
	parskipfac: .4,
	partsspace: 8,
//	pageheight: 29.7 * CM,
	pagewidth: 21 * CM,
//	pos: {
//		dyn: 0,
//		gch: 0,
//		gst: 0,
//		orn: 0,
//		stm: 0,
//		voc: 0,
//		vol: 0
//	},
	printmargin: 0,
	rightmargin: 1.4 * CM,
	rbdbstop: true,
	rbmax: 4,
	rbmin: 2,
	scale: 1,
	slurheight: 1.0,
	staffsep: 46,
	stemheight: 21,			// one octave
	stretchlast: .25,
	stretchstaff: true,
	subtitlespace: 3,
	sysstaffsep: 34,
//	textoption: undefined,
	textspace: 14,
//	titleleft: false,
	titlespace: 6,
	titletrim: true,
//	transp: 0,			// global transpose
//	topmargin: .7 * IN,
	topspace: 22,
	tuplets: [0, 0, 0, 0],
	vocalspace: 10,
//	voicescale: 1,
	writefields: "CMOPQsTWw",
	wordsspace: 5
}

function get_bool(param) {
	return !param || !/^(0|n|f)/i.test(param) // accept void as true !
}

// %%font <font> [<encoding>] [<scale>]
function get_font_scale(param) {
	var	a = param.split(/\s+/)	// a[0] = font name

	if (a.length <= 1)
		return
	var scale = parseFloat(a[a.length - 1])

	if (isNaN(scale) || a <= 0) {
		syntax(1, "Bad scale value in %%font")
		return
	}
	font_scale_tb[a[0]] = scale
	for (var fn in font_tb) {
		if (!font_tb.hasOwnProperty(fn))
			continue
		var font = font_tb[fn]
		if (font.name == a[0])
			font.swfac = font.size * scale
	}
}

// %%xxxfont fontname|* [encoding] [size|*]
function param_set_font(xxxfont, param) {
	var font, fn, old_fn, n, a, new_name, new_fn, new_size, scale, cl

	// "setfont-<n>" goes to "u<n>font"
	if (xxxfont[xxxfont.length - 2] == '-') {
		n = xxxfont[xxxfont.length - 1]
		if (n < '1' || n > '9')
			return
		xxxfont = "u" + n + "font"
	}
	fn = cfmt[xxxfont]
	if (fn) {
		font = font_tb[fn]
		if (font) {
			old_fn = font.name + "." + font.size
			if (font.class)
				old_fn += '.' + font.class
		}
	}

	n = param.indexOf('class=')
	if (n >= 0) {
		n += 6;
		a = param.indexOf(' ', n)
		if (a > 0)
			cl = param.slice(n, a)
		else
			cl = param.slice(n);
		param = param.replace(new RegExp('class=' + cl), '').trim()
	}

	a = param.split(/\s+/);
	new_name = a[0]
	if (new_name == "*"
	 && font) {
		new_name = font.name
	} else {
		new_name = new_name.replace('Times-Roman', 'serif');
		new_name = new_name.replace('Times', 'serif');
		new_name = new_name.replace('Helvetica', 'sans-serif');
		new_name = new_name.replace('Courier', 'monospace')
	}
	if (a.length > 1) {
		new_size = a[a.length - 1]
		if (new_size == '*' && font)
			new_size = font.size
	} else if (font) {
		new_size = font.size
	}
	if (!new_size) {
		// error ?
		return
	}
	new_fn = new_name + "." + new_size
	if (cl)
		new_fn += '.' + cl
	if (new_fn == old_fn)
		return
	font = font_tb[new_fn]
	if (!font) {
		scale = font_scale_tb[new_name]
		if (!scale)
			scale = 1.1;
		font = {
			name: new_name,
			size: Number(new_size),
			swfac: new_size * scale
		}
		font_tb[new_fn] = font
	}
	if (cl)
		font.class = cl;
	cfmt[xxxfont] = new_fn
}

// get a length with a unit - return the number of pixels
function get_unit(param) {
	var v = parseFloat(param)

	switch (param.slice(-2)) {
	case "CM":
	case "cm":
		v *= CM
		break
	case "IN":
	case "in":
		v *= IN
		break
	case "PT":		// paper point in 1/72 inch
	case "pt":
		v *= .75
		break
//	default:  // ('px')	// screen pixel in 1/96 inch
	}
	return v
}

// set the infoname
function set_infoname(param) {
//fixme: check syntax: '<letter> ["string"]'
	var	tmp = cfmt.infoname.split("\n"),
		letter = param[0]

	for (var i = 0; i < tmp.length; i++) {
		var infoname = tmp[i]
		if (infoname[0] != letter)
			continue
		if (param.length == 1)
			tmp.splice(i, 1)
		else
			tmp[i] = param
		cfmt.infoname = tmp.join('\n')
		return
	}
	cfmt.infoname += "\n" + param
}

// get the text option
var textopt = {
	align: 'j',
	center: 'c',
	fill: 'f',
	justify: 'j',
	ragged: 'f',
	right: 'r',
	skip: 's'
}
function get_textopt(param) {
	return textopt[param]
}

/* -- position of a voice element -- */
var posval = {
	above: C.SL_ABOVE,
	auto: 0,		// !! not C.SL_AUTO !!
	below: C.SL_BELOW,
	down: C.SL_BELOW,
	hidden: C.SL_HIDDEN,
	opposite: C.SL_HIDDEN,
	under: C.SL_BELOW,
	up: C.SL_ABOVE
}

/* -- set the position of elements in a voice -- */
function set_pos(k, v) {		// keyword, value
	k = k.slice(0, 3)
	if (k == "ste")
		k = "stm"
	set_v_param("pos", k + ' ' + v)
}

// set/unset the fields to write
function set_writefields(parm) {
	var	c, i,
		a = parm.split(/\s+/)

	if (get_bool(a[1])) {
		for (i = 0; i < a[0].length; i++) {	// set
			c = a[0][i]
			if (cfmt.writefields.indexOf(c) < 0)
				cfmt.writefields += c
		}
	} else {
		for (i = 0; i < a[0].length; i++) {	// unset
			c = a[0][i]
			if (cfmt.writefields.indexOf(c) >= 0)
				cfmt.writefields = cfmt.writefields.replace(c, '')
		}
	}
}

// set a voice specific parameter
function set_v_param(k, v) {
	if (curvoice) {
		set_vp([k + '=', v])
		return
	}
	k = [k + '=', v];
	var vid = '*'
	if (!info.V)
		info.V = {}
	if (info.V[vid])
		Array.prototype.push.apply(info.V[vid], k)
	else
		info.V[vid] = k
}

function set_page() {
	if (!img.chg)
		return
	img.chg = false;
	img.lm = cfmt.leftmargin - cfmt.printmargin
	if (img.lm < 0)
		img.lm = 0;
	img.rm = cfmt.rightmargin - cfmt.printmargin
	if (img.rm < 0)
		img.rm = 0;
	img.width = cfmt.pagewidth - 2 * cfmt.printmargin

	// must have 100pt at least as the staff width
	if (img.width - img.lm - img.rm < 100) {
		error(0, undefined, "Bad staff width");
		img.width = img.lm + img.rm + 150
	}
	set_posx()
} // set_page()

// set a format parameter
function set_format(cmd, param, lock) {
	var f, f2, v, box, i

//fixme: should check the type and limits of the parameter values
	if (lock) {
		fmt_lock[cmd] = true
	} else if (fmt_lock[cmd])
		return

	if (/.+font(-[\d])?$/.test(cmd)) {
		if (param.slice(-4) == " box") {
			box = true;
			param = param.slice(0, -4)
		}
		param_set_font(cmd, param)
		switch (cmd) {
		case "gchordfont":
			cfmt.gchordbox = box
			break
//		case "annotationfont":
//			cfmt.annotationbox = box
//			break
		case "measurefont":
			cfmt.measurebox = box
			break
		case "partsfont":
			cfmt.partsbox = box
			break
		}
		return
	}

	switch (cmd) {
	case "aligncomposer":
	case "barsperstaff":
	case "infoline":
	case "measurefirst":
	case "measurenb":
	case "rbmax":
	case "rbmin":
	case "shiftunison":
		v = parseInt(param)
		if (isNaN(v)) {
			syntax(1, "Bad integer value");
			break
		}
		cfmt[cmd] = v
		break
	case "microscale":
		f = parseInt(param)
		if (isNaN(f) || f < 4 || f > 256 || f % 1) {
			syntax(1, errs.bad_val, "%%" + cmd)
			break
		}
		set_v_param("uscale", f)
		break
	case "bgcolor":
	case "dblrepbar":
	case "titleformat":
		cfmt[cmd] = param
		break
	case "breaklimit":			// float values
	case "lineskipfac":
	case "maxshrink":
	case "pagescale":
	case "parskipfac":
	case "scale":
	case "slurheight":
	case "stemheight":
	case "stretchlast":
		f = parseFloat(param)
		if (isNaN(f)) {
			syntax(1, errs.bad_val, '%%' + cmd)
			break
		}
		switch (cmd) {
		case "scale":			// old scale
			f /= .75
		case "pagescale":
			cmd = "scale";
			img.chg = true
			break
		}
		cfmt[cmd] = f
		break
	case "bstemdown":
	case "breakoneoln":
	case "cancelkey":
	case "contbarnb":
	case "custos":
	case "decoerr":
	case "dynalign":
	case "flatbeams":
	case "gchordbox":
	case "graceslurs":
	case "graceword":
	case "hyphencont":
	case "keywarn":
	case "linewarn":
	case "measurebox":
	case "partsbox":
	case "rbdbstop":
	case "singleline":
	case "squarebreve":
	case "straightflags":
	case "stretchstaff":
	case "timewarn":
	case "titlecaps":
	case "titleleft":
		cfmt[cmd] = get_bool(param)
		break
	case "chordnames":
		v = param.split(',')
		cfmt.chordnames = {}
		for (i = 0; i < v.length; i++)
			cfmt.chordnames['CDEFGAB'[i]] = v[i]
		break
	case "composerspace":
	case "indent":
	case "infospace":
	case "maxstaffsep":
	case "maxsysstaffsep":
	case "musicspace":
	case "partsspace":
	case "staffsep":
	case "subtitlespace":
	case "sysstaffsep":
	case "textspace":
	case "titlespace":
	case "topspace":
	case "vocalspace":
	case "wordsspace":
		f = get_unit(param)	// normally, unit in points - 72 DPI accepted
		if (isNaN(f))
			syntax(1, errs.bad_val, '%%' + cmd)
		else
			cfmt[cmd] = f
		break
	case "print-leftmargin":	// to remove
		syntax(0, "$1 is deprecated - use %%printmargin instead", '%%' + cmd)
		cmd = "printmargin"
		// fall thru
	case "printmargin":
//	case "botmargin":
	case "leftmargin":
//	case "pageheight":
	case "pagewidth":
	case "rightmargin":
//	case "topmargin":
		f = get_unit(param)	// normally unit in cm or in - 96 DPI
		if (isNaN(f)) {
			syntax(1, errs.bad_val, '%%' + cmd)
			break
		}
		cfmt[cmd] = f;
		img.chg = true
		break
	case "concert-score":
		cfmt.sound = "concert"
		break
	case "writefields":
		set_writefields(param)
		break
	case "dynamic":
	case "gchord":
	case "gstemdir":
	case "ornament":
	case "stemdir":
	case "vocal":
	case "volume":
		set_pos(cmd, param)
		break
	case "font":
		get_font_scale(param)
		break
	case "fullsvg":
		if (parse.state != 0) {
			syntax(1, "Cannot have %%fullsvg inside a tune")
			break
		}
//fixme: should check only alpha, num and '_' characters
		cfmt[cmd] = param
		break
	case "gracespace":
		v = param.split(/\s+/)
		for (i = 0; i < 3; i++)
			if (isNaN(Number(v[i]))) {
				syntax(1, errs.bad_val, "%%gracespace")
				break
			}
		for (i = 0; i < 3; i++)
			cfmt[cmd] = Number(v[i])
		break
		break
	case "tuplets":
		cfmt[cmd] = param.split(/\s+/);
		v = cfmt[cmd][3]
		if (v			// if 'where'
		 && (posval[v]))	// translate the keyword
			cfmt[cmd][3] = posval[v]
		break
	case "infoname":
		set_infoname(param)
		break
	case "notespacingfactor":
		f = parseFloat(param)
		if (isNaN(f) || f < 1 || f > 2) {
			syntax(1, errs.bad_val, "%%" + cmd)
			break
		}
		i = 5;				// index of crotchet
		f2 = space_tb[i]
		for ( ; --i >= 0; ) {
			f2 /= f;
			space_tb[i] = f2
		}
		i = 5;
		f2 = space_tb[i]
		for ( ; ++i < space_tb.length; ) {
			f2 *= f;
			space_tb[i] = f2
		}
		break
	case "play":
		cfmt.sound = "play"		// without clef
		break
	case "pos":
		cmd = param.split(/\s+/);
		set_pos(cmd[0], cmd[1])
		break
	case "sounding-score":
		cfmt.sound = "sounding"
		break
	case "staffwidth":
		v = get_unit(param)
		if (isNaN(v)) {
			syntax(1, errs.bad_val, '%%' + cmd)
			break
		}
		if (v < 100) {
			syntax(1, "%%staffwidth too small")
			break
		}
		v = cfmt.pagewidth - v - cfmt.leftmargin
		if (v < 2) {
			syntax(1, "%%staffwidth too big")
			break
		}
		cfmt.rightmargin = v;
		img.chg = true
		break
	case "textoption":
		cfmt[cmd] = get_textopt(param)
		break
	case "titletrim":
		v = Number(param)
		if (isNaN(v))
			cfmt[cmd] = get_bool(param)
		else
			cfmt[cmd] = v
		break
	case "combinevoices":
		syntax(1, "%%combinevoices is deprecated - use %%voicecombine instead")
		break
	case "voicemap":
		set_v_param("map", param)
		break
	case "voicescale":
		set_v_param("scale", param)
		break
	default:		// memorize all global commands
		if (parse.state == 0)		// (needed for modules)
			cfmt[cmd] = param
		break
	}
}

// font stuff

// initialize the default fonts
function font_init() {
	param_set_font("annotationfont", "sans-serif 12");
	param_set_font("composerfont", "serifItalic 14");
	param_set_font("footerfont", "serif 16");
	param_set_font("gchordfont", "sans-serif 12");
	param_set_font("headerfont", "serif 16");
	param_set_font("historyfont", "serif 16");
	param_set_font("infofont", "serifItalic 14");
	param_set_font("measurefont", "serifItalic 14");
	param_set_font("partsfont", "serif 15");
	param_set_font("repeatfont", "serif 13");
	param_set_font("subtitlefont", "serif 16");
	param_set_font("tempofont", "serifBold 15");
	param_set_font("textfont", "serif 16");
	param_set_font("titlefont", "serif 20");
	param_set_font("vocalfont", "serifBold 13");
	param_set_font("voicefont", "serifBold 13");
	param_set_font("wordsfont", "serif 16")
}

// build a font style
function style_font(fn) {		// 'font_name'.'size'
	var	r = fn.split('.'),
		sz = r[1],
		i = fn.indexOf("Italic"),
		j = 100,
		o = fn.indexOf("Oblique"),
		b = fn.indexOf("Bold");

	fn = r[0];
	r = ''
	if (b > 0) {
		r += "font-weight:bold; ";
		j = b
	}
	if (i > 0 || o > 0) {
		if (i > 0) {
			r += "font-style:italic; "
			if (i < j)
				j = i
		}
		if (o > 0) {
			r += "font-style:oblique; "
			if (o < j)
				j = o
		}
	}
	if (j != 100) {
		if (fn[j - 1] == '-')
			j--;
		fn = fn.slice(0, j)
	}
	return 'font-family:' + fn + '; ' + r + 'font-size:' + sz + 'px'
}
Abc.prototype.style_font = style_font

// build a font class
function font_class(font) {
	if (font.class)
		return 'f' + font.fid + cfmt.fullsvg + ' ' + font.class
	return 'f' + font.fid + cfmt.fullsvg
}

// output a font style
function style_add_font(font) {
	font_style += "\n.f" + font.fid + cfmt.fullsvg +
			" {" + style_font(font.name + '.' + font.size) + "}"
}

// use the font
function use_font(font) {
	if (!defined_font[font.fid]) {
		defined_font[font.fid] = true;
		style_add_font(font)
	}
}

// get the font of the 'xxxfont' parameter
function get_font(xxx) {
	xxx += "font"
	var	fn = cfmt[xxx],
		font = font_tb[fn]
	if (!font) {
		syntax(1, "Unknown font $1", xxx);
		font = gene.curfont
	}
	if (!font.fid)
		font.fid = fid++;
	use_font(font)
	return font
}
// abc2svg - front.js - ABC parsing front-end
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

// translation table from the ABC draft version 2.2
var abc_utf = {
	"=D": "Đ",
	"=H": "Ħ",
	"=T": "Ŧ",
	"=d": "đ",
	"=h": "ħ",
	"=t": "ŧ",
	"/O": "Ø",
	"/o": "ø",
//	"/D": "Đ",
//	"/d": "đ",
	"/L": "Ł",
	"/l": "ł",
	"vL": "Ľ",
	"vl": "ľ",
	"vd": "ď",
	".i": "ı",
	"AA": "Å",
	"aa": "å",
	"AE": "Æ",
	"ae": "æ",
	"DH": "Ð",
	"dh": "ð",
//	"ng": "ŋ",
	"OE": "Œ",
	"oe": "œ",
	"ss": "ß",
	"TH": "Þ",
	"th": "þ"
}

// accidentals as octal values (abcm2ps compatibility)
var oct_acc = {
	"1": "\u266f",
	"2": "\u266d",
	"3": "\u266e",
	"4": "&#x1d12a;",
	"5": "&#x1d12b;"
}

// convert the escape sequences to utf-8
function cnv_escape(src) {
	var	c, c2,
		dst = "",
		i, j = 0, codeUnits

	while (1) {
		i = src.indexOf('\\', j)
		if (i < 0)
			break
		dst += src.slice(j, i);
		c = src[++i]
		if (!c)
			return dst + '\\'
		switch (c) {
		case '0':
		case '2':
			if (src[i + 1] != '0')
				break
			c2 = oct_acc[src[i + 2]]
			if (c2) {
				dst += c2;
				j = i + 3
				continue
			}
			break
		case 'u':
			j = Number("0x" + src.slice(i + 1, i + 5));
			if (isNaN(j) || j < 0x20) {
				dst += src[++i] + "\u0306"	// breve
				j = i + 1
				continue
			}
			codeUnits = [j]
			if (j >= 0xd800 && j <= 0xdfff) {	// surrogates
				j = Number("0x" + src.slice(i + 7, i + 11));
				if (isNaN(j))
					break		// bad surrogate
				codeUnits.push(j);
				j = i + 11
			} else {
				j = i + 5
			}
			dst += String.fromCharCode.apply(null, codeUnits)
			continue
		case 't':			// TAB
			dst += ' ';
			j = i + 1
			continue
		default:
			c2 = abc_utf[src.slice(i, i + 2)]
			if (c2) {
				dst += c2;
				j = i + 2
				continue
			}

			// try unicode combine characters
			switch (c) {
			case '`':
				dst += src[++i] + "\u0300"	// grave
				j = i + 1
				continue
			case "'":
				dst += src[++i] + "\u0301"	// acute
				j = i + 1
				continue
			case '^':
				dst += src[++i] + "\u0302"	// circumflex
				j = i + 1
				continue
			case '~':
				dst += src[++i] + "\u0303"	// tilde
				j = i + 1
				continue
			case '=':
				dst += src[++i] + "\u0304"	// macron
				j = i + 1
				continue
			case '_':
				dst += src[++i] + "\u0305"	// overline
				j = i + 1
				continue
			case '.':
				dst += src[++i] + "\u0307"	// dot
				j = i + 1
				continue
			case '"':
				dst += src[++i] + "\u0308"	// dieresis
				j = i + 1
				continue
			case 'o':
				dst += src[++i] + "\u030a"	// ring
				j = i + 1
				continue
			case 'H':
				dst += src[++i] + "\u030b"	// hungarumlaut
				j = i + 1
				continue
			case 'v':
				dst += src[++i] + "\u030c"	// caron
				j = i + 1
				continue
//			case ',':
//				dst += src[++i] + "\u0326"	// comma below
//				j = i + 1
//				continue
			case 'c':
				dst += src[++i] + "\u0327"	// cedilla
				j = i + 1
				continue
			case ';':
				dst += src[++i] + "\u0328"	// ogonek
				j = i + 1
				continue
			}
			break
		}
		dst += '\\' + c;
		j = i + 1
	}
	return dst + src.slice(j)
}

// ABC include
var include = 0

function do_include(fn) {
	var file, parse_sav

	if (!user.read_file) {
		syntax(1, "No read_file support")
		return
	}
	if (include > 2) {
		syntax(1, "Too many include levels")
		return
	}
	include++;
	file = user.read_file(fn)
	if (!file) {
		syntax(1, "Cannot read file '$1'", fn)
		return
	}
	parse_sav = clone(parse);
	tosvg(fn, file);
	parse = parse_sav;
	include--
}

// parse ABC code
function tosvg(in_fname,		// file name
		file,			// file content
		bol, eof) {		// beginning/end of file
	var	i, c, bol, eol, end,
		ext, select,
		line0, line1,
		last_info, opt, text, a, b, s,
		cfmt_sav, info_sav, char_tb_sav, glovar_sav, maps_sav,
		mac_sav, maci_sav,
		pscom,
		txt_add = '\n'		// for "+:"

	// check if a tune is selected
	function tune_selected() {
		var	re, res,
			i = file.indexOf('K:', bol)

		if (i < 0) {
//			syntax(1, "No K: in tune")
			return false
		}
		i = file.indexOf('\n', i)
		if (parse.select.test(file.slice(parse.bol, i)))
			return true
		re = /\n\w*\n/;
		re.lastIndex = i;
		res = re.exec(file)
		if (res)
			eol = re.lastIndex
		else
			eol = eof
		return false
	} // tune_selected()

	// remove the comment at end of text
	function uncomment(src, do_escape) {
	    var i
		if (src.indexOf('%') >= 0)
			src = src.replace(/([^\\])%.*/, '$1')
				 .replace(/\\%/g, '%');
		src = src.replace(/\s+$/, '')
		if (do_escape && src.indexOf('\\') >= 0)
			return cnv_escape(src)
		return src
	} // uncomment()

	function end_tune() {
		generate()
		if (info.W)
			put_words(info.W);
		put_history();
		blk_flush();
		parse.state = 0;		// file header
		cfmt = cfmt_sav;
		info = info_sav;
		char_tb = char_tb_sav;
		glovar = glovar_sav;
		maps = maps_sav;
		mac = mac_sav;
		maci = maci_sav;
		init_tune()
		img.chg = true;
		set_page();
	} // end_tune()

	// export functions and/or set module hooks
	if (abc2svg.modules
	 && (abc2svg.modules.hooks.length || abc2svg.modules.g_hooks.length))
		set_hooks()

	// initialize
	parse.file = file;		// used for errors
	parse.fname = in_fname

	// scan the file
	if (bol == undefined)
		bol = 0
	if (!eof)
		eof = file.length
	for ( ; bol < eof; bol = parse.eol + 1) {
		eol = file.indexOf('\n', bol)	// get a line
		if (eol < 0 || eol > eof)
			eol = eof;
		parse.eol = eol

		// remove the ending white spaces
		while (1) {
			eol--
			switch (file[eol]) {
			case ' ':
			case '\t':
				continue
			}
			break
		}
		eol++
		if (eol == bol) {		// empty line
			if (parse.state == 1) {
				parse.istart = bol;
				syntax(1, "Empty line in tune header - ignored")
			} else if (parse.state >= 2) {
				end_tune()
				if (parse.select) {	// skip to next tune
					eol = file.indexOf('\nX:', parse.eol)
					if (eol < 0)
						eol = eof
					parse.eol = eol
				}
			}
			continue
		}
		parse.istart = parse.bol = bol;
		parse.iend = eol;
		parse.line.index = 0;

		// check if the line is a pseudo-comment or I:
		line0 = file[bol];
		line1 = file[bol + 1]
		if (line0 == '%') {
			if (parse.prefix.indexOf(line1) < 0)
				continue		// comment

			// change "%%abc xxxx" to "xxxx"
			if (file[bol + 2] == 'a'
			 && file[bol + 3] == 'b'
			 && file[bol + 4] == 'c'
			 && file[bol + 5] == ' ') {
				bol += 6;
				line0 = file[bol];
				line1 = file[bol + 1]
			} else {
				pscom = true
			}
		} else if (line0 == 'I' && line1 == ':') {
			pscom = true
		}

		// pseudo-comments
		if (pscom) {
			pscom = false;
			bol += 2		// skip %%/I:
			while (1) {
				switch (file[bol]) {
				case ' ':
				case '\t':
					bol++
					continue
				}
				break
			}
			text = file.slice(bol, eol)
			if (!text || text[0] == '%')
				continue
			a = text.split(/\s+/, 2)
			if (!a[0])
				a.shift()
			switch (a[0]) {
			case "abcm2ps":
			case "ss-pref":
				parse.prefix = a[1]
				continue
			case "abc-include":
				ext = a[1].match(/.*\.(.*)/)
				if (ext && ext[1] == "abc")
					do_include(a[1])
				continue
			}

			// beginxxx/endxxx
			if (a[0].slice(0, 5) == 'begin') {
				b = a[0].substr(5);
				end = '\n' + line0 + line1 + "end" + b;
				i = file.indexOf(end, eol)
				if (i < 0) {
					syntax(1, "No $1 after %%$2",
							end.slice(1), a[0]);
					parse.eol = eof
					continue
				}
				do_begin_end(b, a[1],
					file.slice(eol + 1, i).replace(
						new RegExp('^' + line0 + line1, 'gm'),
										''));
				parse.eol = file.indexOf('\n', i + 6)
				if (parse.eol < 0)
					parse.eol = eof
				continue
			}
			switch (a[0]) {
			case "select":
				if (parse.state != 0) {
					syntax(1, "%%select ignored")
					continue
				}
				select = uncomment(text.slice(7), false)
				if (select[0] == '"')
					select = select.slice(1, -1);
				if (!select) {
					delete parse.select
					continue
				}
				select = select.replace(/\(/g, '\\(');
				select = select.replace(/\)/g, '\\)');
//				select = select.replace(/\|/g, '\\|');
				parse.select = new RegExp(select, 'm')
				continue
			case "tune":
				syntax(1, "%%tune not treated yet")
				continue
			case "voice":
				if (parse.state != 0) {
					syntax(1, "%%voice ignored")
					continue
				}
				select = uncomment(text.slice(6), false)

				/* if void %%voice, free all voice options */
				if (!select) {
					if (parse.cur_tune_opts)
						parse.cur_tune_opts.voice_opts = null
					else
						parse.voice_opts = null
					continue
				}
				
				if (select == "end")
					continue	/* end of previous %%voice */

				/* get the voice options */
				if (parse.cur_tune_opts) {
					if (!parse.cur_tune_opts.voice_opts)
						parse.cur_tune_opts.voice_opts = {}
					opt = parse.cur_tune_opts.voice_opts
				} else {
					if (!parse.voice_opts)
						parse.voice_opts = {}
					opt = parse.voice_opts
				}
				opt[select] = []
				while (1) {
					bol = ++eol
					if (file[bol] != '%')
						break
					eol = file.indexOf('\n', eol);
					if (file[bol + 1] != line1)
						continue
					bol += 2
					if (eol < 0)
						text = file.slice(bol)
					else
						text = file.slice(bol, eol);
					a = text.match(/\S+/)
					switch (a[0]) {
					default:
						opt[select].push(
							uncomment(text, true))
						continue
					case "score":
					case "staves":
					case "tune":
					case "voice":
						bol -= 2
						break
					}
					break
				}
				parse.eol = bol - 1
				continue
			}
			do_pscom(uncomment(text, true))
			continue
		}

		// music line (or free text)
		if (line1 != ':' || !/[A-Za-z+]/.test(line0)) {
			last_info = undefined;
			if (parse.state < 2)
				continue
			parse.line.buffer = uncomment(file.slice(bol, eol), true);
			parse_music_line()
			continue
		}

		// information fields
		bol += 2
		while (1) {
			switch (file[bol]) {
			case ' ':
			case '\t':
				bol++
				continue
			}
			break
		}
		text = uncomment(file.slice(bol, eol), true)
		if (line0 == '+') {
			if (!last_info) {
				syntax(1, "+: without previous info field")
				continue
			}
			txt_add = ' ';		// concatenate
			line0 = last_info
		}

		switch (line0) {
		case 'X':			// start of tune
			if (parse.state != 0) {
				syntax(1, errs.ignored, line0)
				continue
			}
			if (parse.select
			 && !tune_selected()) {	// skip to the next tune
				eol = file.indexOf('\nX:', parse.eol)
				if (eol < 0)
					eol = eof;
				parse.eol = eol
				continue
			}

			cfmt_sav = clone(cfmt);
			cfmt.pos = clone(cfmt.pos);
			info_sav = clone(info, 1);
			char_tb_sav = clone(char_tb);
			glovar_sav = clone(glovar);
			maps_sav = clone(maps, 1);
			mac_sav = clone(mac);
			maci_sav = new Int8Array(maci);
			info.X = text;
			parse.state = 1			// tune header
			continue
		case 'T':
			switch (parse.state) {
			case 0:
				continue
			case 1:
				if (info.T == undefined)	// (keep empty T:)
					info.T = text
				else
					info.T += "\n" + text
				continue
			}
			s = new_block("title");
			s.text = text
			continue
		case 'K':
			switch (parse.state) {
			case 0:
				continue
			case 1:				// tune header
				info.K = text
				break
			}
			do_info(line0, text)
			continue
		case 'W':
			if (parse.state == 0
			 || cfmt.writefields.indexOf(line0) < 0)
				break
			if (info.W == undefined)
				info.W = text
			else
				info.W += txt_add + text
			break

		case 'm':
			if (parse.state >= 2) {
				syntax(1, errs.ignored, line0)
				continue
			}
			if ((!cfmt.sound || cfmt.sound != "play")
			 && cfmt.writefields.indexOf(line0) < 0)
				break
			a = text.match(/(.*?)[= ]+(.*)/)
			if (!a || !a[2]) {
				syntax(1, errs.bad_val, "m:")
				continue
			}
			mac[a[1]] = a[2];
			maci[a[1].charCodeAt(0)] = 1	// first letter
			break

		// info fields in tune body only
		case 's':
			if (parse.state != 3
			 || cfmt.writefields.indexOf(line0) < 0)
				break
			get_sym(text, txt_add == ' ')
			break
		case 'w':
			if (parse.state != 3
			 || cfmt.writefields.indexOf(line0) < 0)
				break
			get_lyrics(text, txt_add == ' ')
			if (text.slice(-1) == '\\') {	// old continuation
				txt_add = ' ';
				last_info = line0
				continue
			}
			break
		case '|':			// "|:" starts a music line
			if (parse.state < 2)
				continue
			parse.line.buffer = uncomment(file.slice(bol, eol), true);
			parse_music_line()
			continue
		default:
			if ("ABCDFGHOSZ".indexOf(line0) >= 0) {
				if (parse.state >= 2) {
					syntax(1, errs.ignored, line0)
					continue
				}
//				if (cfmt.writefields.indexOf(c) < 0)
//					break
				if (!info[line0])
					info[line0] = text
				else
					info[line0] += txt_add + text
				break
			}

			// info field which may be embedded
			do_info(line0, text)
			continue
		}
		txt_add = '\n';
		last_info = line0
	}
	if (include)
		return
	if (parse.state >= 2)
		end_tune();
	parse.state = 0
}
Abc.prototype.tosvg = tosvg
// abc2svg - music.js - music generation
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

var	gene,
	staff_tb,
	nstaff,			// current number of staves
	tsnext,			// next line when cut
	realwidth,		// real staff width while generating
	insert_meter,		// insert time signature (1) and indent 1st line (2)
	spf_last,		// spacing for last short line

/* width of notes indexed by log2(note_length) */
	space_tb = new Float32Array([
		7, 10, 14.15, 20, 28.3,
		40,			/* crotchet (whole note / 4) */
		56.6, 80, 100, 120
	]),
	smallest_duration

/* -- decide whether to shift heads to other side of stem on chords -- */
/* this routine is called only once per tune */

// distance for no overlap - index: [prev acc][cur acc]
//var dt_tb = [
//	[5, 5, 5, 5],		/* dble sharp */
//	[5, 6, 6, 6],		/* sharp */
//	[5, 6, 5, 6],		/* natural */
//	[5, 5, 5, 5]		/* flat / dble flat */
//]

// accidental x offset - index = note head type
var dx_tb = new Float32Array([
	10,		// FULL
	10,		// EMPTY
	11,		// OVAL
	13,		// OVALBARS
	13		// SQUARE
])

// head width  - index = note head type
var hw_tb = new Float32Array([
	4.5,		// FULL
	5,		// EMPTY
	6,		// OVAL
	7,		// OVALBARS
	8		// SQUARE
])

/* head width for voice overlap - index = note head type */
var w_note = new Float32Array([
	3.5,		// FULL
	3.7,		// EMPTY
	5,		// OVAL
	6,		// OVALBARS
	7		// SQUARE
])

function set_head_shift(s) {
	var	i, i1, i2, d, ps, dx,
		dx_head = dx_tb[s.head],
		dir = s.stem,
		n = s.nhd

	if (n == 0)
		return			// single note

	/* set the head shifts */
	dx = dx_head * .78
	if (s.grace)
		dx *= .5
	if (dir >= 0) {
		i1 = 1;
		i2 = n + 1;
		ps = s.notes[0].pit
	} else {
		dx = -dx;
		i1 = n - 1;
		i2 = -1;
		ps = s.notes[n].pit
	}
	var	shift = false,
		dx_max = 0
	for (i = i1; i != i2; i += dir) {
		d = s.notes[i].pit - ps;
		ps = s.notes[i].pit
		if (d == 0) {
			if (shift) {		/* unison on shifted note */
				var new_dx = s.notes[i].shhd =
						s.notes[i - dir].shhd + dx
				if (dx_max < new_dx)
					dx_max = new_dx
				continue
			}
			if (i + dir != i2	/* second after unison */
//fixme: should handle many unisons after second
			 && ps + dir == s.notes[i + dir].pit) {
				s.notes[i].shhd = -dx
				if (dx_max < -dx)
					dx_max = -dx
				continue
			}
		}
		if (d < 0)
			d = -d
		if (d > 3 || (d >= 2 && s.head != C.SQUARE)) {
			shift = false
		} else {
			shift = !shift
			if (shift) {
				s.notes[i].shhd = dx
				if (dx_max < dx)
					dx_max = dx
			}
		}
	}
	s.xmx = dx_max				/* shift the dots */
}

// set the accidental shifts for a set of chords
function acc_shift(notes, dx_head) {
	var	i, i1, dx, dx1, ps, p1, acc,
		n = notes.length

	// set the shifts from the head shifts
	for (i = n - 1; --i >= 0; ) {	// (no shift on top)
		dx = notes[i].shhd
		if (!dx || dx > 0)
			continue
		dx = dx_head - dx;
		ps = notes[i].pit
		for (i1 = n; --i1 >= 0; ) {
			if (!notes[i1].acc)
				continue
			p1 = notes[i1].pit
			if (p1 < ps - 3)
				break
			if (p1 > ps + 3)
				continue
			if (notes[i1].shac < dx)
				notes[i1].shac = dx
		}
	}

	// set the shifts from accidental shifts
	for (i = n; --i >= 0; ) {		// from top to bottom
		acc = notes[i].acc
		if (!acc)
			continue
		dx = notes[i].shac
		if (!dx) {
			dx = notes[i].shhd
			if (dx < 0)
				dx = dx_head - dx
			else
				dx = dx_head
		}
		ps = notes[i].pit
		for (i1 = n; --i1 > i; ) {
			if (!notes[i1].acc)
				continue
			p1 = notes[i1].pit
			if (p1 >= ps + 4) {	// pitch far enough
				if (p1 > ps + 4	// if more than a fifth
				 || acc < 0	// if flat/dble flat
				 || notes[i1].acc < 0)
					continue
			}
			if (dx > notes[i1].shac - 6) {
				dx1 = notes[i1].shac + 7
				if (dx1 > dx)
					dx = dx1
			}
		}
		notes[i].shac = dx
	}
}

/* set the horizontal shift of accidentals */
/* this routine is called only once per tune */
function set_acc_shft() {
	var s, s2, st, i, acc, st, t, dx_head;

	// search the notes with accidentals at the same time
	s = tsfirst
	while (s) {
		if (s.type != C.NOTE
		 || s.invis) {
			s = s.ts_next
			continue
		}
		st = s.st;
		t = s.time;
		acc = false
		for (s2 = s; s2; s2 = s2.ts_next) {
			if (s2.time != t
			 || s2.type != C.NOTE
			 || s2.st != st)
				break
			if (acc)
				continue
			for (i = 0; i <= s2.nhd; i++) {
				if (s2.notes[i].acc) {
					acc = true
					break
				}
			}
		}
		if (!acc) {
			s = s2
			continue
		}

		dx_head = dx_tb[s.head]
//		if (s.dur >= C.BLEN * 2 && s.head == C.OVAL)
//		if (s.dur >= C.BLEN * 2)
//			dx_head = 15.8;

		// build a pseudo chord and shift the accidentals
		st = {
			notes: []
		}
		for ( ; s != s2; s = s.ts_next)
			st.notes = st.notes.concat(s.notes);
		sort_pitch(st);
		acc_shift(st.notes, dx_head)
	}
}

// link a symbol before an other one
function lkvsym(s, next) {	// voice linkage
	s.next = next;
	s.prev = next.prev
	if (s.prev)
		s.prev.next = s
	else
		s.p_v.sym = s;
	next.prev = s
}
function lktsym(s, next) {	// time linkage
	if (next) {
		s.ts_next = next;
		s.ts_prev = next.ts_prev
		if (s.ts_prev)
			s.ts_prev.ts_next = s;
		next.ts_prev = s
	} else {
		s.ts_next = s.ts_prev = null
	}
}

/* -- unlink a symbol -- */
function unlksym(s) {
	if (s.next)
		s.next.prev = s.prev
	if (s.prev)
		s.prev.next = s.next
	else
		s.p_v.sym = s.next
	if (s.ts_next) {
		if (s.seqst && !s.ts_next.seqst) {
			s.ts_next.seqst = true;
			s.ts_next.shrink = s.shrink;
			s.ts_next.space = s.space
		}
		s.ts_next.ts_prev = s.ts_prev
	}
	if (s.ts_prev)
		s.ts_prev.ts_next = s.ts_next
	if (tsfirst == s)
		tsfirst = s.ts_next
	if (tsnext == s)
		tsnext = s.ts_next
}

/* -- insert a clef change (treble or bass) before a symbol -- */
function insert_clef(s, clef_type, clef_line) {
	var	p_voice = s.p_v,
		new_s,
		st = s.st

	/* don't insert the clef between two bars */
	if (s.type == C.BAR && s.prev && s.prev.type == C.BAR)
		s = s.prev;

	/* create the symbol */
	p_voice.last_sym = s.prev
	if (!p_voice.last_sym)
		p_voice.sym = null;
	p_voice.time = s.time;
	new_s = sym_add(p_voice, C.CLEF);
	new_s.next = s;
	s.prev = new_s;

	new_s.clef_type = clef_type;
	new_s.clef_line = clef_line;
	new_s.st = st;
	new_s.clef_small = true
	delete new_s.second;
	new_s.notes = []
	new_s.notes[0] = {
		pit: s.notes[0].pit
	}
	new_s.nhd = 0;

	/* link in time */
	while (!s.seqst)
		s = s.ts_prev;
	lktsym(new_s, s)
	if (new_s.ts_prev.type != C.CLEF)
		new_s.seqst = true
	return new_s
}

/* -- set the staff of the floating voices -- */
/* this function is called only once per tune */
function set_float() {
	var p_voice, st, staff_chg, v, s, s1, up, down

	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
//		if (!p_voice.floating)
//			continue
		staff_chg = false;
		st = p_voice.st
		for (s = p_voice.sym; s; s = s.next) {
			if (!s.floating) {
				while (s && !s.floating)
					s = s.next
				if (!s)
					break
				staff_chg = false
			}
			if (!s.dur) {
				if (staff_chg)
					s.st++
				continue
			}
			if (s.notes[0].pit >= 19) {		/* F */
				staff_chg = false
				continue
			}
			if (s.notes[s.nhd].pit <= 12) {	/* F, */
				staff_chg = true
				s.st++
				continue
			}
			up = 127
			for (s1 = s.ts_prev; s1; s1 = s1.ts_prev) {
				if (s1.st != st
				 || s1.v == s.v)
					break
				if (s1.type == C.NOTE)
				    if (s1.notes[0].pit < up)
					up = s1.notes[0].pit
			}
			if (up == 127) {
				if (staff_chg)
					s.st++
				continue
			}
			if (s.notes[s.nhd].pit > up - 3) {
				staff_chg = false
				continue
			}
			down = -127
			for (s1 = s.ts_next; s1; s1 = s1.ts_next) {
				if (s1.st != st + 1
				 || s1.v == s.v)
					break
				if (s1.type == C.NOTE)
				    if (s1.notes[s1.nhd].pit > down)
					down = s1.notes[s1.nhd].pit
			}
			if (down == -127) {
				if (staff_chg)
					s.st++
				continue
			}
			if (s.notes[0].pit < down + 3) {
				staff_chg = true
				s.st++
				continue
			}
			up -= s.notes[s.nhd].pit
			down = s.notes[0].pit - down
			if (!staff_chg) {
				if (up < down + 3)
					continue
				staff_chg = true
			} else {
				if (up < down - 3) {
					staff_chg = false
					continue
				}
			}
			s.st++
		}
	}
}

/* -- set the x offset of the grace notes -- */
function set_graceoffs(s) {
	var	next, m, dx, x,
		gspleft = cfmt.gracespace[0],
		gspinside = cfmt.gracespace[1],
		gspright = cfmt.gracespace[2],
		g = s.extra;

	if (s.prev && s.prev.type == C.BAR)
		gspleft -= 3;
	x = gspleft;

	g.beam_st = true
	for ( ; ; g = g.next) {
		set_head_shift(g)
		acc_shift(g.notes, 7);
		dx = 0
		for (m = g.nhd; m >= 0; m--) {
			if (g.notes[m].shac > dx)
				dx = g.notes[m].shac
		}
		x += dx;
		g.x = x

		if (g.nflags <= 0) {
			g.beam_st = true;
			g.beam_end = true
		}
		next = g.next
		if (!next) {
			g.beam_end = true
			break
		}
		if (next.nflags <= 0)
			g.beam_end = true
		if (g.beam_end) {
			next.beam_st = true;
			x += gspinside / 4
		}
		if (g.nflags <= 0)
			x += gspinside / 4
		if (g.y > next.y + 8)
			x -= 1.5
		x += gspinside
	}

	next = s.next
	if (next
	 && next.type == C.NOTE) {	/* if before a note */
		if (g.y >= 3 * (next.notes[next.nhd].pit - 18))
			gspright -= 1		// above, a bit closer
		else if (g.beam_st
		      && g.y < 3 * (next.notes[next.nhd].pit - 18) - 4)
			gspright += 2		// below with flag, a bit further
	}
	x += gspright;

	/* return the whole width */
	return x
}

/* -- compute the width needed by the guitar chords / annotations -- */
function gchord_width(s, wlnote, wlw) {
	var	s2, gch, w, wl, ix,
		lspc = 0,
		rspc = 0,
		alspc = 0,
		arspc = 0

	for (ix = 0; ix < s.a_gch.length; ix++) {
		gch = s.a_gch[ix]
		switch (gch.type) {
		default:		/* default = above */
			wl = -gch.x
			if (wl > lspc)
				lspc = wl;
			w = gch.w + 2 - wl
			if (w > rspc)
				rspc = w
			break
		case '<':		/* left */
			w = gch.w + wlnote
			if (w > alspc)
				alspc = w
			break
		case '>':		/* right */
			w = gch.w + s.wr
			if (w > arspc)
				arspc = w
			break
		}
	}

	/* adjust width for no clash */
	s2 = s.prev
	if (s2) {
		if (s2.a_gch) {
			for (s2 = s.ts_prev; ; s2 = s2.ts_prev) {
				if (s2 == s.prev) {
					if (wlw < lspc)
						wlw = lspc
					break
				}
				if (s2.seqst)
					lspc -= s2.shrink
			}
		}
		if (alspc != 0)
			if (wlw < alspc)
				wlw = alspc
	}
	s2 = s.next
	if (s2) {
		if (s2.a_gch) {
			for (s2 = s.ts_next; ; s2 = s2.ts_next) {
				if (s2 == s.next) {
					if (s.wr < rspc)
						s.wr = rspc
					break
				}
				if (s2.seqst)
					rspc -= 8
			}
		}
		if (arspc != 0)
			if (s.wr < arspc)
				s.wr = alspc
	}
	return wlw
}

/* -- set the width of a symbol -- */
/* This routine sets the minimal left and right widths wl,wr
 * so that successive symbols are still separated when
 * no extra glue is put between them */
function set_width(s) {
	var s2, i, m, xx, w, wlnote, wlw, acc

	switch (s.type) {
	case C.NOTE:
	case C.REST:

		/* set the note widths */
		s.wr = wlnote = hw_tb[s.head]

		/* room for shifted heads and accidental signs */
		if (s.xmx > 0)
			s.wr += s.xmx + 4;
		for (s2 = s.prev; s2; s2 = s2.prev) {
			if (w_tb[s2.type] != 0)
				break
		}
		if (s2) {
			switch (s2.type) {
			case C.BAR:
			case C.CLEF:
			case C.KEY:
			case C.METER:
				wlnote += 3
				break
			}
		}
		for (m = 0; m <= s.nhd; m++) {
			xx = s.notes[m].shhd
			if (xx < 0) {
				if (wlnote < -xx + 5)
					wlnote = -xx + 5
			}
			if (s.notes[m].acc) {
				var tmp = s.notes[m].shac +
					(s.notes[m].micro ? 5.5 : 3.5)
				if (wlnote < tmp)
					wlnote = tmp
			}
		}
		if (s2) {
			switch (s2.type) {
			case C.BAR:
			case C.CLEF:
			case C.KEY:
			case C.METER:
				wlnote -= 3
				break
			}
		}

		/* room for the decorations */
		if (s.a_dd)
			wlnote += deco_width(s)

		/* space for flag if stem goes up on standalone note */
		if (s.beam_st && s.beam_end
		 && s.stem > 0 && s.nflags > 0) {
			if (s.wr < s.xmx + 9)
				s.wr = s.xmx + 9
		}

		/* leave room for dots and set their offset */
		if (s.dots > 0) {
		  if (s.wl == undefined)	// don't recompute if new music line
			switch (s.head) {
			case C.SQUARE:
				s.xmx += 4
				break
			case C.OVALBARS:
			case C.OVAL:
				s.xmx += 2
				break
			case C.EMPTY:
				s.xmx += 1
				break
			}
			if (s.wr < s.xmx + 8)
				s.wr = s.xmx + 8
			if (s.dots >= 2)
				s.wr += 3.5 * (s.dots - 1)
		}

		/* if a tremolo on 2 notes, have space for the small beam(s) */
		if (s.trem2 && s.beam_end
		 && wlnote < 20)
			wlnote = 20

		wlw = wlnote

		if (s2) {
			switch (s2.type) {
			case C.NOTE:	/* extra space when up stem - down stem */
				if (s2.stem > 0 && s.stem < 0) {
					if (wlw < 7)
						wlw = 7
				}

				/* make sure helper lines don't overlap */
				if ((s.y > 27 && s2.y > 27)
				 || (s.y < -3 && s2.y < -3)) {
					if (wlw < 6)
						wlw = 6
				}

				/* have ties wide enough */
				if (s2.ti1) {
					if (wlw < 14)
						wlw = 14
				}
				break
			case C.CLEF:		/* extra space at start of line */
				if (s2.second
				 || s2.clef_small)
					break
				wlw += 8
				break
			case C.KEY:
/*			case C.METER:	*/
				wlw += 4
				break
			}
		}

		/* leave room for guitar chord */
		if (s.a_gch)
			wlw = gchord_width(s, wlnote, wlw)

		/* leave room for vocals under note */
		/* related to draw_lyrics() */
		if (s.a_ly)
			wlw = ly_width(s, wlw)

		/* if preceeded by a grace note sequence, adjust */
		if (s2 && s2.type == C.GRACE)
			s.wl = wlnote - 4.5
		else
			s.wl = wlw
		return
	case C.SPACE:
		xx = s.width / 2;
		s.wr = xx
		if (s.a_gch)
			xx = gchord_width(s, xx, xx)
		if (s.a_dd)
			xx += deco_width(s);
		s.wl = xx
		return
	case C.BAR:
		if (s.norepbra)
			break
		if (!s.invis) {
			var bar_type = s.bar_type

			switch (bar_type) {
			case "|":
				w = 7		// 4 + 3
				break
			case "|:":
			case ":|":
				w = 15		// 4 + 5 + 6
				break
			case "::":
				w = 26		// 4 + 5 + 6 + 6 + 5
				break
			default:
				if (!bar_type)
					break
				w = 4 + 3 * bar_type.length
				for (i = 0; i < bar_type.length; i++) {
					switch (bar_type[i]) {
					case "[":
					case "]":
						w += 3
						break
					case ":":
						w += 2
						break
					}
				}
				break
			}
			s.wl = w
			if (s.next
			 && s.next.type != C.METER)
				s.wr = 7
			else
				s.wr = 5
//			s.notes[0].shhd = (w - 5) * -.5

			/* if preceeded by a grace note sequence, adjust */
			for (s2 = s.prev; s2; s2 = s2.prev) {
				if (w_tb[s2.type] != 0) {
					if (s2.type == C.GRACE)
						s.wl -= 8
					break
				}
			}
		} else {
			s.wl = s.wr = 0
		}
		if (s.a_dd)
			s.wl += deco_width(s)

		/* have room for the repeat numbers / chord indication */
		if (s.text && s.text.length < 4
		 && s.next && s.next.a_gch) {
			set_font("repeat");
			s.wr += strwh(s.text)[0] + 2
		}
		return
	case C.CLEF:
// (there may be invisible clefs in empty staves)
		if (s.invis) {
			s.wl = s.wr = 1		// (!! not 0 !!)
			return
		}
		s.wl = s.wr = s.clef_small ? 8 : 12
		return
	case C.KEY:
		var n1, n2, esp;

		s.wl = 3;
		esp = 4
		if (!s.k_a_acc) {
			n1 = s.k_sf			/* new key sig */
			if (s.k_old_sf && (cfmt.cancelkey || n1 == 0))
				n2 = s.k_old_sf	/* old key */
			else
				n2 = 0
			if (n1 * n2 >= 0) {		/* if no natural */
				if (n1 < 0)
					n1 = -n1
				if (n2 < 0)
					n2 = -n2
				if (n2 > n1)
					n1 = n2
			} else {
				n1 -= n2
				if (n1 < 0)
					n1 = -n1;
				esp += 3	/* see extra space in draw_keysig() */
			}
		} else {
			n1 = n2 = s.k_a_acc.length
			if (n2)
			    var	last_acc = s.k_a_acc[0].acc
			for (i = 1; i < n2; i++) {
				acc = s.k_a_acc[i]
				if (acc.pit > s.k_a_acc[i - 1].pit + 6
				 || acc.pit < s.k_a_acc[i - 1].pit - 6)
					n1--		// no clash
				else if (acc.acc != last_acc)
					esp += 3;
				last_acc = acc.acc
			}
		}
		s.wr = 5.5 * n1 + esp
		return
	case C.METER:
		wlw = 0;
		s.x_meter = []
		for (i = 0; i < s.a_meter.length; i++) {
			var meter = s.a_meter[i]
			if (meter.top[0] == "C") {
				s.x_meter[i] = wlw + 6;
				wlw += 12
			} else {
				w = 0
				if (!meter.bot
				 || meter.top.length > meter.bot.length)
					meter = meter.top
				else
					meter = meter.bot;
				for (m = 0; m < meter.length; m++) {
					switch (meter[m]) {
					case '(':
						wlw += 4
						// fall thru
					case ')':
					case '1':
						w += 4
						break
					default:
						w += 12
						break
					}
				}
				s.x_meter[i] = wlw + w / 2
				wlw += w
			}
		}
		s.wl = 0;
		s.wr = wlw + 6
		return
	case C.MREST:
		s.wl = 6;
		s.wr = 66
		return
	case C.GRACE:
		s.wl = set_graceoffs(s);
		s.wr = 0
		if (s.a_ly)
			ly_width(s, wlw)
		return
	case C.STBRK:
		s.wl = s.xmx
		if (s.next && s.next.type == C.CLEF) {
			s.wr = 2
			delete s.next.clef_small	/* big clef */
		} else {
			s.wr = 8
		}
		return
	case C.CUSTOS:
		s.wl = s.wr = 4
		return
	case C.BLOCK:				// no width
	case C.PART:
	case C.REMARK:
	case C.STAVES:
	case C.TEMPO:
		break
	default:
		error(2, s, "set_width - Cannot set width for symbol $1", s.type)
		break
	}
	s.wl = s.wr = 0
}

// convert delta time to natural spacing
function time2space(s, len) {
    var i, l, space

	if (smallest_duration >= C.BLEN / 2) {
		if (smallest_duration >= C.BLEN)
			len /= 4
		else
			len /= 2
	} else if (!s.next && len >= C.BLEN) {
		len /= 2
	}
	if (len >= C.BLEN / 4) {
		if (len < C.BLEN / 2)
			i = 5
		else if (len < C.BLEN)
			i = 6
		else if (len < C.BLEN * 2)
			i = 7
		else if (len < C.BLEN * 4)
			i = 8
		else
			i = 9
	} else {
		if (len >= C.BLEN / 8)
			i = 4
		else if (len >= C.BLEN / 16)
			i = 3
		else if (len >= C.BLEN / 32)
			i = 2
		else if (len >= C.BLEN / 64)
			i = 1
		else
			i = 0
	}
	l = len - ((C.BLEN / 16 / 8) << i)
	space = space_tb[i]
	if (l != 0) {
		if (l < 0) {
			space = space_tb[0] * len / (C.BLEN / 16 / 8)
		} else {
			if (i >= 9)
				i = 8
			space += (space_tb[i + 1] - space_tb[i]) * l / len
		}
	}
	return space
}

/* -- set the natural space -- */
function set_space(s) {
	var	s2, space,
		prev_time = s.ts_prev.time,
		len = s.time - prev_time		/* time skip */

	if (len == 0) {
		switch (s.type) {
		case C.MREST:
			return s.wl
///*fixme:do same thing at start of line*/
//		case C.NOTE:
//		case C.REST:
//			if (s.ts_prev.type == C.BAR) {
//				if (s.nflags < -2)
//					return space_tb[0]
//				return space_tb[2]
//			}
//			break
		}
		return 0
	}
	if (s.ts_prev.type == C.MREST)
//		return s.ts_prev.wr + 16
//				+ 3		// (bar wl=5 wr=8)
		return 71	// 66 (mrest.wl) + 5 (bar.wl)

	space = time2space(s, len)

	while (!s.dur) {
		switch (s.type) {
		case C.BAR:
			// (hack to have quite the same note widths between measures)
			return space * .9 - 7
		case C.CLEF:
			return space - s.wl - s.wr
		case C.BLOCK:			// no space
		case C.PART:
		case C.REMARK:
		case C.STAVES:
		case C.TEMPO:
			s = s.ts_next
			if (!s)
				return space
			continue
		}
		break
	}

	/* reduce spacing within a beam */
	if (!s.beam_st)
		space *= .9			// ex fnnp

	/* decrease spacing when stem down followed by stem up */
/*fixme:to be done later, after x computed in sym_glue*/
	if (s.type == C.NOTE && s.nflags >= -1
	 && s.stem > 0) {
		var stemdir = true

		for (s2 = s.ts_prev;
		     s2 && s2.time == prev_time;
		     s2 = s2.ts_prev) {
			if (s2.type == C.NOTE
			 && (s2.nflags < -1 || s2.stem > 0)) {
				stemdir = false
				break
			}
		}
		if (stemdir) {
			for (s2 = s.ts_next;
			     s2 && s2.time == s.time;
			     s2 = s2.ts_next) {
				if (s2.type == C.NOTE
				 && (s2.nflags < -1 || s2.stem < 0)) {
					stemdir = false
					break
				}
			}
			if (stemdir)
				space *= .9
		}
	}
	return space
}

// set the fixed spacing inside tuplets
function set_sp_tup(s, s2) {
    var	tim = s.time,
	ttim = s2.time - tim,
	space = time2space(s, ttim / s.tq0) * s.tq0;

	s = s.ts_next
	while (1) {
		if (s.seqst)
			s.space = (s.time - tim) / ttim * space;
		tim = s.time;
		if (s == s2)
			break
		s = s.ts_next
	}
}

// create an invisible bar for end of music lines
function add_end_bar(s) {
	return {
		type: C.BAR,
		bar_type: "|",
		fname: s.fname,
		istart: s.istart,
		iend: s.iend,
		v: s.v,
		p_v: s.p_v,
		st: s.st,
		dur: 0,
		seqst: true,
		invis: true,
		time: s.time + s.dur,
		nhd: 0,
		notes: [{
			pit: s.notes[0].pit
		}],
		wl:0,
		wr:0
	}
}

/* -- set the width and space of all symbols -- */
/* this function is called once for the whole tune
 * then, once per music line up to the first sequence */
function set_allsymwidth(last_s) {
	var	new_val, s_tupc, s_tupn,
		s = tsfirst,
		xa = 0,
		xl = [],
		tupfl = 0,
		ntup = 0

	/* loop on all symbols */
	while (1) {
		var	maxx = xa,
			s2 = s

		do {
			set_width(s);
			new_val = (xl[s.st] || 0) + s.wl
			if (new_val > maxx)
				maxx = new_val;
			if (s.tp0) {		// start of tuplet
				if (++ntup == 1) {
					s_tupn = s;
					tupfl |= 1
				}
			} else if (s.te0) {	// end of tuplet
				if (--ntup == 0)
					tupfl = 4
			}
			s = s.ts_next
		} while (s != last_s && !s.seqst);

		// set the spaces of the time sequence
		s2.shrink = maxx - xa

		if (!(tupfl & 14)) {		// if not in a tuplet sequence
			if (s2.ts_prev)
				s2.space = set_space(s2)
			else
				s2.space = 0
		}
		if (tupfl) {
			if (tupfl & 8) {
				set_sp_tup(s_tupc, s2);
				tupfl &= ~8
			}
			if (tupfl & 1) {
				s_tupc = s_tupn;
				tupfl++		// 1 => 2
			}
			if (tupfl & 4)
				tupfl += 4	// 4 => 8
		}

		if (s2.shrink == 0 && s2.space == 0 && s2.type == C.CLEF) {
			delete s2.seqst;		/* no space */
			s2.time = s2.ts_prev.time
		}
		if (s == last_s)
			break

		// update the min left space per staff
		xa = maxx;
		s = s2
		do {
			if (!xl[s.st] || xl[s.st] < xa + s.wr)
				xl[s.st] = xa + s.wr;
			s = s.ts_next
		} while (!s.seqst)
	}
}

/* change a symbol into a rest */
function to_rest(s) {
	s.type = C.REST
// just keep nl and seqst
	delete s.in_tuplet
	delete s.sl1
	delete s.sl2
	delete s.a_dd
	delete s.a_gch
	s.slur_start = s.slur_end = 0
/*fixme: should set many parameters for set_width*/
//	set_width(s)
}

/* -- set the repeat sequences / measures -- */
function set_repeat(s) {	// first note
	var	s2, s3,  i, j, dur,
		n = s.repeat_n,
		k = s.repeat_k,
		st = s.st,
		v = s.v

	s.repeat_n = 0				// treated

	/* treat the sequence repeat */
	if (n < 0) {				/* number of notes / measures */
		n = -n;
		i = n				/* number of notes to repeat */
		for (s3 = s.prev; s3; s3 = s3.prev) {
			if (!s3.dur) {
				if (s3.type == C.BAR) {
					error(1, s3, "Bar in repeat sequence")
					return
				}
				continue
			}
			if (--i <= 0)
				break
		}
		if (!s3) {
			error(1, s, errs.not_enough_n)
			return
		}
		dur = s.time - s3.time;

		i = k * n		/* whole number of notes/rests to repeat */
		for (s2 = s; s2; s2 = s2.next) {
			if (!s2.dur) {
				if (s2.type == C.BAR) {
					error(1, s2, "Bar in repeat sequence")
					return
				}
				continue
			}
			if (--i <= 0)
				break
		}
		if (!s2
		 || !s2.next) {		/* should have some symbol */
			error(1, s, errs.not_enough_n)
			return
		}
		for (s2 = s.prev; s2 != s3; s2 = s2.prev) {
			if (s2.type == C.NOTE) {
				s2.beam_end = true
				break
			}
		}
		for (j = k; --j >= 0; ) {
			i = n			/* number of notes/rests */
			if (s.dur)
				i--;
			s2 = s.ts_next
			while (i > 0) {
				if (s2.st == st) {
					unlksym(s2)
					if (s2.v == v
					 && s2.dur)
						i--
				}
				s2 = s2.ts_next
			}
			to_rest(s);
			s.dur = s.notes[0].dur = dur;
			s.rep_nb = -1;		// single repeat
			s.beam_st = true;
			set_width(s)
			if (s.seqst)
				s.space = set_space(s);
			s.head = C.SQUARE;
			for (s = s2; s; s = s.ts_next) {
				if (s.st == st
				 && s.v == v
				 && s.dur)
					break
			}
		}
		return
	}

	/* check the measure repeat */
	i = n				/* number of measures to repeat */
	for (s2 = s.prev.prev ; s2; s2 = s2.prev) {
		if (s2.type == C.BAR
		 || s2.time == tsfirst.time) {
			if (--i <= 0)
				break
		}
	}
	if (!s2) {
		error(1, s, errs.not_enough_m)
		return
	}

	dur = s.time - s2.time		/* repeat duration */

	if (n == 1)
		i = k			/* repeat number */
	else
		i = n			/* check only 2 measures */
	for (s2 = s; s2; s2 = s2.next) {
		if (s2.type == C.BAR) {
			if (--i <= 0)
				break
		}
	}
	if (!s2) {
		error(1, s, errs.not_enough_m)
		return
	}

	/* if many 'repeat 2 measures'
	 * insert a new %%repeat after the next bar */
	i = k				/* repeat number */
	if (n == 2 && i > 1) {
		s2 = s2.next
		if (!s2) {
			error(1, s, errs.not_enough_m)
			return
		}
		s2.repeat_n = n;
		s2.repeat_k = --i
	}

	/* replace */
	dur /= n
	if (n == 2) {			/* repeat 2 measures (once) */
		s3 = s
		for (s2 = s.ts_next; ; s2 = s2.ts_next) {
			if (s2.st != st)
				continue
			if (s2.v == v
			 && s2.type == C.BAR)
				break
			unlksym(s2)
		}
		to_rest(s3);
		s3.dur = s3.notes[0].dur = dur;
		s3.invis = true
		if (s3.seqst)
			s3.space = set_space(s3);
		s2.bar_mrep = 2
		if (s2.seqst)
			s2.space = set_space(s2);
		s3 = s2.next;
		for (s2 = s3.ts_next; ; s2 = s2.ts_next) {
			if (s2.st != st)
				continue
			if (s2.v == v
			 && s2.type == C.BAR)
				break
			unlksym(s2)
		}
		to_rest(s3);
		s3.dur = s3.notes[0].dur = dur;
		s3.invis = true;
		set_width(s3)
		if (s3.seqst)
			s3.space = set_space(s3)
		if (s2.seqst)
			s2.space = set_space(s2)
		return
	}

	/* repeat 1 measure */
	s3 = s
	for (j = k; --j >= 0; ) {
		for (s2 = s3.ts_next; ; s2 = s2.ts_next) {
			if (s2.st != st)
				continue
			if (s2.v == v
			 && s2.type == C.BAR)
				break
			unlksym(s2)
		}
		to_rest(s3);
		s3.dur = s3.notes[0].dur = dur;
		s3.beam_st = true
		if (s3.seqst)
			s3.space = set_space(s3)
		if (s2.seqst)
			s2.space = set_space(s2)
		if (k == 1) {
			s3.rep_nb = 1
			break
		}
		s3.rep_nb = k - j + 1;	// number to print above the repeat rest
		s3 = s2.next
	}
}

/* add a custos before the symbol of the next line */
function custos_add(s) {
	var	p_voice, new_s, i,
		s2 = s

	while (1) {
		if (s2.type == C.NOTE)
			break
		s2 = s2.next
		if (!s2)
			return
	}

	p_voice = s.p_v;
	p_voice.last_sym = s.prev;
//	if (!p_voice.last_sym)
//		p_voice.sym = null;
	p_voice.time = s.time;
	new_s = sym_add(p_voice, C.CUSTOS);
	new_s.next = s;
	s.prev = new_s;
	lktsym(new_s, s);

	new_s.seqst = true;
	new_s.shrink = s.shrink
	if (new_s.shrink < 8 + 4)
		new_s.shrink = 8 + 4;
	new_s.space = s2.space;
	new_s.wl = 0;
	new_s.wr = 4;

	new_s.nhd = s2.nhd;
	new_s.notes = []
	for (i = 0; i < s.notes.length; i++) {
		new_s.notes[i] = {
			pit: s2.notes[i].pit,
			shhd: 0,
			dur: C.BLEN / 4
		}
	}
	new_s.stemless = true
}

/* -- define the beginning of a new music line -- */
function set_nl(s) {
	var s2, p_voice, done

	// set the end of line marker and
	function set_eol(s) {
		if (cfmt.custos && voice_tb.length == 1)
			custos_add(s)

		// set the nl flag if more music
		for (var s2 = s.ts_next; s2; s2 = s2.ts_next) {
			if (s2.seqst) {
				s.nl = true
				break
			}
		}
	} // set_eol()

	// set the eol on the next symbol
	function set_eol_next(s) {
		if (!s.next) {		// special case: the voice stops here
			set_eol(s)
			return s
		}
		for (s = s.ts_next; s; s = s.ts_next) {
			if (s.seqst) {
				set_eol(s)
				break
			}
		}
		return s
	} // set_eol_next()

	/* if explicit EOLN, cut on the next symbol */
	if (s.eoln && !cfmt.keywarn && !cfmt.timewarn)
		return set_eol_next(s)

	/* if normal symbol, cut here */
	switch (s.type) {
	case C.CLEF:
	case C.BAR:
	case C.STAVES:
		break
	case C.KEY:
		if (cfmt.keywarn && !s.k_none)
			break
		return set_eol_next(s)
	case C.METER:
		if (cfmt.timewarn)
			break
		return set_eol_next(s)
	case C.GRACE:			/* don't cut on a grace note */
		s = s.next
		if (!s)
			return s
		/* fall thru */
	default:
		return set_eol_next(s)
	}

	/* go back to handle the staff breaks at end of line */
	for (; s; s = s.ts_prev) {
		if (!s.seqst)
			continue
		switch (s.type) {
		case C.KEY:
		case C.CLEF:
		case C.METER:
			continue
		}
		break
	}
	done = 0
	for ( ; ; s = s.ts_next) {
		if (!s)
			return s
		if (!s.seqst)
			continue
		if (done < 0)
			break
		switch (s.type) {
		case C.STAVES:
			if (s.ts_prev && s.ts_prev.type == C.BAR)
				break
			while (s.ts_next) {
				if (w_tb[s.ts_next.type] != 0
				 && s.ts_next.type != C.CLEF)
					break
				s = s.ts_next
			}
			if (!s.ts_next || s.ts_next.type != C.BAR)
				continue
			s = s.ts_next
			// fall thru
		case C.BAR:
			if (done)
				break
			done = 1;
			continue
		case C.STBRK:
			if (!s.stbrk_forced)
				unlksym(s)	/* remove */
			else
				done = -1	// keep the next symbols on the next line
			continue
		case C.METER:
			if (!cfmt.timewarn)
				break
			continue
		case C.CLEF:
			if (done)
				break
			continue
		case C.KEY:
			if (!cfmt.keywarn || s.k_none)
				break
			continue
		default:
			if (!done || (s.prev && s.prev.type == C.GRACE))
				continue
			break
		}
		break
	}
	set_eol(s)
	return s
}

/* get the width of the starting clef and key signature */
// return
//	r[0] = width of clef and key signature
//	r[1] = width of the meter
function get_ck_width() {
    var	r0, r1,
	p_voice = voice_tb[0]

	set_width(p_voice.clef);
	set_width(p_voice.key);
	set_width(p_voice.meter)
	return [p_voice.clef.wl + p_voice.clef.wr +
			p_voice.key.wl + p_voice.key.wr,
		p_voice.meter.wl + p_voice.meter.wr]
}

// get the width of the symbols up to the next eoln or eof
function get_width(s, last) {
	var	shrink, space,
		w = 0,
		sp_fac = (1 - cfmt.maxshrink)

	do {
		if (s.seqst) {
			shrink = s.shrink
			if ((space = s.space) < shrink)
				w += shrink
			else
				w += shrink * cfmt.maxshrink
					+ space * sp_fac
			s.x = w
		}
		if (s == last)
			break
		s = s.ts_next
	} while (s)
	return w;
}

/* -- search where to cut the lines according to the staff width -- */
function set_lines(	s,		/* first symbol */
			last,		/* last symbol / null */
			lwidth,		/* w - (clef & key sig) */
			indent) {	/* for start of tune */
	var	first, s2, s3, x, xmin, xmid, xmax, wwidth, shrink, space,
		nlines, cut_here;

	for ( ; last; last = last.ts_next) {
		if (last.eoln)
			break
	}

	/* calculate the whole size of the piece of tune */
	wwidth = get_width(s, last) + indent

	/* loop on cutting the tune into music lines */
	while (1) {
		nlines = Math.ceil(wwidth / lwidth)
		if (nlines <= 1) {
			if (last)
				last = set_nl(last)
			return last
		}

		s2 = first = s;
		xmin = s.x - s.shrink - indent;
		xmax = xmin + lwidth;
		xmid = xmin + wwidth / nlines;
		xmin += wwidth / nlines * cfmt.breaklimit;
		for (s = s.ts_next; s != last ; s = s.ts_next) {
			if (!s.x)
				continue
			if (s.type == C.BAR)
				s2 = s
			if (s.x >= xmin)
				break
		}
//fixme: can this occur?
		if (s == last) {
			if (last)
				last = set_nl(last)
			return last
		}

		/* try to cut on a measure bar */
		cut_here = false;
		s3 = null
		for ( ; s != last; s = s.ts_next) {
			x = s.x
			if (!x)
				continue
			if (x > xmax)
				break
			if (s.type != C.BAR)
				continue
			if (x < xmid) {
				s3 = s		// keep the last bar
				continue
			}

			// cut on the bar closest to the middle
			if (!s3 || s.x < xmid) {
				s3 = s
				continue
			}
			if (s3 > xmid)
				break
			if (xmid - s3.x < s.x - xmid)
				break
			s3 = s
			break
		}

		/* if a bar, cut here */
		if (s3) {
			s = s3;
			cut_here = true
		}

		/* try to avoid to cut a beam or a tuplet */
		if (!cut_here) {
			var	beam = 0,
				bar_time = s2.time;

			xmax -= 8; // (left width of the inserted bar in set_allsymwidth)
			s = s2;			// restart from start or last bar
			s3 = null
			for ( ; s != last; s = s.ts_next) {
				if (s.beam_st)
					beam++
				if (s.beam_end && beam > 0)
					beam--
				x = s.x
				if (!x)
					continue
				if (x + s.wr >= xmax)
					break
				if (beam || s.in_tuplet)
					continue
//fixme: this depends on the meter
				if ((s.time - bar_time) % (C.BLEN / 4) == 0) {
					s3 = s
					continue
				}
				if (!s3 || s.x < xmid) {
					s3 = s
					continue
				}
				if (s3 > xmid)
					break
				if (xmid - s3.x < s.x - xmid)
					break
				s3 = s
				break
			}
			if (s3) {
				s = s3;
				cut_here = true
			}
		}

		// cut anyhere
		if (!cut_here) {
			s3 = s = s2
			for ( ; s != last; s = s.ts_next) {
				x = s.x
				if (!x)
					continue
				if (s.x < xmid) {
					s3 = s
					continue
				}
				if (s3 > xmid)
					break
				if (xmid - s3.x < s.x - xmid)
					break
				s3 = s
				break
			}
			s = s3
		}

		if (s.nl) {		/* already set here - advance */
			error(0, s,
			    "Line split problem - adjust maxshrink and/or breaklimit");
			nlines = 2
			for (s = s.ts_next; s != last; s = s.ts_next) {
				if (!s.x)
					continue
				if (--nlines <= 0)
					break
			}
		}
		s = set_nl(s)
		if (!s
		 || (last && s.time >= last.time))
			break
		wwidth -= s.x - first.x;
		indent = 0
	}
	return s
}

/* -- cut the tune into music lines -- */
function cut_tune(lwidth, indent) {
	var	s, s2, s3, i, xmin,
//fixme: not usable yet
//		pg_sav = {
//			leftmargin: cfmt.leftmargin,
//			rightmargin: cfmt.rightmargin,
//			pagewidth: cfmt.pagewidth,
//			scale: cfmt.scale
//		},
		s = tsfirst

	// take care of the voice subnames
	if (indent != 0) {
		i = set_indent()
		lwidth -= i;
		indent -= i;
	}

	/* adjust the line width according to the starting clef
	 * and key signature */
/*fixme: may change in the tune*/
	i = get_ck_width();
	lwidth -= i[0];
	indent += i[1]

	if (cfmt.custos && voice_tb.length == 1)
		lwidth -= 12

	/* if asked, count the measures and set the EOLNs */
	if (cfmt.barsperstaff) {
		i = cfmt.barsperstaff;
		for (s2 = s; s2; s2 = s2.ts_next) {
			if (s2.type != C.BAR
			 || !s2.bar_num
			 || --i > 0)
				continue
			s2.eoln = true;
			i = cfmt.barsperstaff
		}
	}

	/* cut at explicit end of line, checking the line width */
	xmin = indent;
	s2 = s
	for ( ; s; s = s.ts_next) {
//fixme: not usable yet
//		if (s.type == C.BLOCK) {
//			switch (s.subtype) {
//			case "leftmargin":
//			case "rightmargin":
//			case "pagescale":
//			case "pagewidth":
//			case "scale":
//			case "staffwidth":
//				set_format(s.subtype, s.param)
//				break
//			}
//			continue
//		}
		if (!s.seqst && !s.eoln)
			continue
		xmin += s.shrink
		if (xmin > lwidth) {		// overflow
			s2 = set_lines(s2, s, lwidth, indent)
		} else {
			if (!s.eoln)
				continue
			delete s.eoln

			// if eoln on a note or a rest,
			// check for a smaller duration in an other voice
			if (s.dur) {
				for (s3 = s.ts_next; s3; s3 = s3.ts_next) {
					if (s3.seqst
					 || s3.dur < s.dur)
						break
				}
				if (s3 && !s3.seqst)
					s2 = set_lines(s2, s, lwidth, indent)
				else
					s2 = set_nl(s)
			} else {
				s2 = set_nl(s)
			}
		}
		if (!s2)
			break

		// (s2 may be tsfirst - no ts_prev - when only one
		//  embedded info in the first line after the first K:)
		if (!s2.ts_prev) {
			delete s2.nl
			continue
		}
		xmin = s2.shrink;
		s = s2.ts_prev;		// don't miss an eoln
		indent = 0
	}

//fixme: not usable yet
//	// restore the page parameters at start of line
//	cfmt.leftmargin = pg_sav.leftmargin;
//	cfmt.rightmargin = pg_sav.rightmargin;
//	cfmt.pagewidth = pg_sav.pagewidth;
//	cfmt.scale = pg_sav.scale
}

/* -- set the y values of some symbols -- */
function set_yval(s) {
//fixme: staff_tb is not yet defined
//	var top = staff_tb[s.st].topbar
//	var bot = staff_tb[s.st].botbar
	switch (s.type) {
	case C.CLEF:
		if (s.second
		 || s.invis) {
//			s.ymx = s.ymn = (top + bot) / 2
			s.ymx = s.ymn = 12
			break
		}
		s.y = (s.clef_line - 1) * 6
		switch (s.clef_type) {
		default:			/* treble / perc */
			s.ymx = s.y + 28
			s.ymn = s.y - 14
			break
		case "c":
			s.ymx = s.y + 13
			s.ymn = s.y - 11
			break
		case "b":
			s.ymx = s.y + 7
			s.ymn = s.y - 12
			break
		}
		if (s.clef_small) {
			s.ymx -= 2;
			s.ymn += 2
		}
		if (s.ymx < 26)
			s.ymx = 26
		if (s.ymn > -1)
			s.ymn = -1
//		s.y += s.clef_line * 6
//		if (s.y > 0)
//			s.ymx += s.y
//		else if (s.y < 0)
//			s.ymn += s.y
		if (s.clef_octave) {
			if (s.clef_octave > 0)
				s.ymx += 12
			else
				s.ymn -= 12
		}
		break
	case C.KEY:
		if (s.k_sf > 2)
			s.ymx = 24 + 10
		else if (s.k_sf > 0)
			s.ymx = 24 + 6
		else
			s.ymx = 24 + 2;
		s.ymn = -2
		break
	default:
//		s.ymx = top + 2;
		s.ymx = 24 + 2;
		s.ymn = -2
		break
	}
}

// set the clefs (treble or bass) in a 'auto clef' sequence
// return the starting clef type
function set_auto_clef(st, s_start, clef_type_start) {
	var s, min, max, time, s2, s3;

	/* get the max and min pitches in the sequence */
	max = 12;					/* "F," */
	min = 20					/* "G" */
	for (s = s_start; s; s = s.ts_next) {
		if (s.type == C.STAVES && s != s_start)
			break
		if (s.st != st)
			continue
		if (s.type != C.NOTE) {
			if (s.type == C.CLEF) {
				if (s.clef_type != 'a')
					break
				unlksym(s)
			}
			continue
		}
		if (s.notes[0].pit < min)
			min = s.notes[0].pit
		else if (s.notes[s.nhd].pit > max)
			max = s.notes[s.nhd].pit
	}

	if (min >= 19					/* upper than 'F' */
	 || (min >= 13 && clef_type_start != 'b'))	/* or 'G,' */
		return 't'
	if (max <= 13					/* lower than 'G,' */
	 || (max <= 19 && clef_type_start != 't'))	/* or 'F' */
		return 'b'

	/* set clef changes */
	if (clef_type_start == 'a') {
		if ((max + min) / 2 >= 16)
			clef_type_start = 't'
		else
			clef_type_start = 'b'
	}
	var	clef_type = clef_type_start,
		s_last = s,
		s_last_chg = null
	for (s = s_start; s != s_last; s = s.ts_next) {
		if (s.type == C.STAVES && s != s_start)
			break
		if (s.st != st || s.type != C.NOTE)
			continue

		/* check if a clef change may occur */
		time = s.time
		if (clef_type == 't') {
			if (s.notes[0].pit > 12		/* F, */
			 || s.notes[s.nhd].pit > 20) {	/* G */
				if (s.notes[0].pit > 20)
					s_last_chg = s
				continue
			}
			s2 = s.ts_prev
			if (s2
			 && s2.time == time
			 && s2.st == st
			 && s2.type == C.NOTE
			 && s2.notes[0].pit >= 19)	/* F */
				continue
			s2 = s.ts_next
			if (s2
			 && s2.st == st
			 && s2.time == time
			 && s2.type == C.NOTE
			 && s2.notes[0].pit >= 19)	/* F */
				continue
		} else {
			if (s.notes[0].pit < 12		/* F, */
			 || s.notes[s.nhd].pit < 20) {	/* G */
				if (s.notes[s.nhd].pit < 12)
					s_last_chg = s
				continue
			}
			s2 = s.ts_prev
			if (s2
			 && s2.time == time
			 && s2.st == st
			 && s2.type == C.NOTE
			 && s2.notes[0].pit <= 13)	/* G, */
				continue
			s2 = s.ts_next
			if (s2
			 && s2.st == st
			 && s2.time == time
			 && s2.type == C.NOTE
			 && s2.notes[0].pit <= 13)	/* G, */
				continue
		}

		/* if first change, change the starting clef */
		if (!s_last_chg) {
			clef_type = clef_type_start =
					clef_type == 't' ? 'b' : 't';
			s_last_chg = s
			continue
		}

		/* go backwards and search where to insert a clef change */
		s3 = s
		for (s2 = s.ts_prev; s2 != s_last_chg; s2 = s2.ts_prev) {
			if (s2.st != st)
				continue
			if (s2.type == C.BAR
			 && s2.v == s.v) {
				s3 = s2
				break
			}
			if (s2.type != C.NOTE)
				continue

			/* have a 2nd choice on beam start */
			if (s2.beam_st
			 && !s2.p_v.second)
				s3 = s2
		}

		/* no change possible if no insert point */
		if (s3.time == s_last_chg.time) {
			s_last_chg = s
			continue
		}
		s_last_chg = s;

		/* insert a clef change */
		clef_type = clef_type == 't' ? 'b' : 't';
		s2 = insert_clef(s3, clef_type, clef_type == "t" ? 2 : 4);
		s2.clef_auto = true
//		s3.prev.st = st
	}
	return clef_type_start
}

/* set the clefs */
/* this function is called once at start of tune generation */
/*
 * global variables:
 *	- staff_tb[st].clef = clefs at start of line (here, start of tune)
 *				(created here, updated on clef draw)
 *	- voice_tb[v].clef = clefs at end of generation
 *				(created on voice creation, updated here)
 */
function set_clefs() {
	var	s, s2, st, v, p_voice, g, new_type, new_line, p_staff, pit,
		staff_clef = new Array(nstaff),	// st -> { clef, autoclef }
		sy = cur_sy,
		mid = []

	// create the staff table
	staff_tb = new Array(nstaff)
	for (st = 0; st <= nstaff; st++) {
		staff_clef[st] = {
			autoclef: true
		}
		staff_tb[st] = {
			output: "",
			sc_out: ""
		}
	}

	// set the starting clefs of the staves
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (sy.voices[v].range < 0)
			continue
		st = sy.voices[v].st
		if (!sy.voices[v].second) {		// main voices
			if (p_voice.staffnonote != undefined)
				sy.staves[st].staffnonote = p_voice.staffnonote
			if (p_voice.staffscale)
				sy.staves[st].staffscale = p_voice.staffscale
			if (sy.voices[v].sep)
				sy.staves[st].sep = sy.voices[v].sep
			if (sy.voices[v].maxsep)
				sy.staves[st].maxsep = sy.voices[v].maxsep;
		}
		if (!sy.voices[v].second
		 && !p_voice.clef.clef_auto)
			staff_clef[st].autoclef = false
	}
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (sy.voices[v].range < 0
		 || sy.voices[v].second)		// main voices
			continue
		st = sy.voices[v].st;
		s = p_voice.clef
		if (staff_clef[st].autoclef) {
			s.clef_type = set_auto_clef(st,
						tsfirst,
						s.clef_type);
			s.clef_line = s.clef_type == 't' ? 2 : 4
		}
		staff_clef[st].clef = staff_tb[st].clef = s
	}
	for (st = 0; st <= sy.nstaff; st++)
		mid[st] = (sy.staves[st].stafflines.length - 1) * 3

	for (s = tsfirst; s; s = s.ts_next) {
		if (s.repeat_n)
			set_repeat(s)

		switch (s.type) {
		case C.STAVES:
			sy = s.sy
			for (st = 0; st <= nstaff; st++)
				staff_clef[st].autoclef = true
			for (v = 0; v < voice_tb.length; v++) {
				if (sy.voices[v].range < 0)
					continue
				p_voice = voice_tb[v];
				st = sy.voices[v].st
				if (!sy.voices[v].second) {
					if (p_voice.staffnonote != undefined)
						sy.staves[st].staffnonote = p_voice.staffnonote
					if (p_voice.staffscale)
						sy.staves[st].staffscale = p_voice.staffscale
					if (sy.voices[v].sep)
						sy.staves[st].sep = sy.voices[v].sep
					if (sy.voices[v].maxsep)
						sy.staves[st].maxsep = sy.voices[v].maxsep
				}
				s2 = p_voice.clef
				if (!s2.clef_auto)
					staff_clef[st].autoclef = false
			}
			for (st = 0; st <= sy.nstaff; st++)
				mid[st] = (sy.staves[st].stafflines.length - 1) * 3
			for (v = 0; v < voice_tb.length; v++) {
				if (sy.voices[v].range < 0
				 || sy.voices[v].second)	// main voices
					continue
				p_voice = voice_tb[v];
				st = sy.voices[v].st;
				s2 = p_voice.clef
				if (s2.clef_auto) {
//fixme: the staff may have other voices with explicit clefs...
//					if (!staff_clef[st].autoclef)
//						???
					new_type = set_auto_clef(st, s,
						staff_clef[st].clef ?
							staff_clef[st].clef.clef_type :
							'a');
					new_line = new_type == 't' ? 2 : 4
				} else {
					new_type = s2.clef_type;
					new_line = s2.clef_line
				}
				if (!staff_clef[st].clef) {	// new staff
					if (s2.clef_auto) {
						if (s2.type != 'a')
							p_voice.clef =
								clone(p_voice.clef);
						p_voice.clef.clef_type = new_type;
						p_voice.clef.clef_line = new_line
					}
					staff_tb[st].clef =
						staff_clef[st].clef = p_voice.clef
					continue
				}
								// old staff
				if (new_type == staff_clef[st].clef.clef_type
				 && new_line == staff_clef[st].clef.clef_line)
					continue
				g = s.ts_next
				while (g && (g.v != v || g.st != st))
					g = g.ts_next
				if (!g)				// ??
					continue
				if (g.type != C.CLEF) {
					g = insert_clef(g, new_type, new_line)
					if (s2.clef_auto)
						g.clef_auto = true
				}
				staff_clef[st].clef = p_voice.clef = g
			}
			continue
		default:
			s.mid = mid[s.st]
			continue
		case C.CLEF:
			break
		}

		if (s.clef_type == 'a') {
			s.clef_type = set_auto_clef(s.st,
						s.ts_next,
						staff_clef[s.st].clef.clef_type);
			s.clef_line = s.clef_type == 't' ? 2 : 4
		}

		p_voice = s.p_v;
		p_voice.clef = s
		if (s.second) {
/*fixme:%%staves:can this happen?*/
//			if (!s.prev)
//				break
			unlksym(s)
			continue
		}
		st = s.st
// may have been inserted on %%staves
//		if (s.clef_auto) {
//			unlksym(s)
//			continue
//		}

		if (staff_clef[st].clef) {
			if (s.clef_type == staff_clef[st].clef.clef_type
			 && s.clef_line == staff_clef[st].clef.clef_line) {
//				unlksym(s)
				continue
			}
		} else {

			// the voice moved to a new staff with a forced clef
			staff_tb[st].clef = s
		}
		staff_clef[st].clef = s
	}

	/* set a pitch to the symbols of voices with no note */
	sy = cur_sy
	for (v = 0; v < voice_tb.length; v++) {
		if (sy.voices[v].range < 0)
			continue
		s2 = voice_tb[v].sym
		if (!s2 || s2.notes[0].pit != 127)
			continue
		st = sy.voices[v].st
		switch (staff_tb[st].clef.clef_type) {
		default:
			pit = 22		/* 'B' */
			break
		case "c":
			pit = 16		/* 'C' */
			break
		case "b":
			pit = 10		/* 'D,' */
			break
		}
		for (s = s2; s; s = s.next)
			s.notes[0].pit = pit
	}
}

/* set the pitch of the notes according to the clefs
 * and set the vertical offset of the symbols */
/* this function is called at start of tune generation and
 * then, once per music line up to the old sequence */

var delta_tb = {
	t: 0 - 2 * 2,
	c: 6 - 3 * 2,
	b: 12 - 4 * 2,
	p: 0 - 3 * 2
}

/* upper and lower space needed by rests */
var rest_sp = [
	[18, 18],
	[12, 18],
	[12, 12],
	[0, 12],
	[6, 8],
	[10, 10],			/* crotchet */
	[6, 4],
	[10, 0],
	[10, 4],
	[10, 10]
]

function set_pitch(last_s) {
	var	s, s2, g, st, delta, m, pitch, note,
		dur = C.BLEN,
		staff_delta = new Array(nstaff),
		sy = cur_sy

	// set the starting clefs of the staves
	for (st = 0; st <= nstaff; st++) {
		s = staff_tb[st].clef;
		staff_delta[st] = delta_tb[s.clef_type] + s.clef_line * 2
		if (s.clefpit)
			staff_delta[st] += s.clefpit
		if (cfmt.sound) {
			if (s.clef_octave && !s.clef_oct_transp)
				staff_delta[st] += s.clef_octave
		} else {
			if (s.clef_oct_transp)
				staff_delta[st] -= s.clef_octave
		}
	}

	for (s = tsfirst; s != last_s; s = s.ts_next) {
		st = s.st
		switch (s.type) {
		case C.CLEF:
			staff_delta[st] = delta_tb[s.clef_type] +
						s.clef_line * 2
			if (s.clefpit)
				staff_delta[st] += s.clefpit
			if (cfmt.sound) {
				if (s.clef_octave && !s.clef_oct_transp)
					staff_delta[st] += s.clef_octave
			} else {
				if (s.clef_oct_transp)
					staff_delta[st] -= s.clef_octave
			}
			set_yval(s)
			break
		case C.GRACE:
			for (g = s.extra; g; g = g.next) {
				delta = staff_delta[g.st]
				if (delta != 0
				 && !s.p_v.key.k_drum) {
					for (m = 0; m <= g.nhd; m++) {
						note = g.notes[m];
						note.pit += delta
					}
				}
				g.ymn = 3 * (g.notes[0].pit - 18) - 2;
				g.ymx = 3 * (g.notes[g.nhd].pit - 18) + 2
			}
			set_yval(s)
			break
		case C.KEY:
			s.k_y_clef = staff_delta[st] /* keep the y delta */
			/* fall thru */
		default:
			set_yval(s)
			break
		case C.MREST:
			if (s.invis)
				break
			s.y = 12;
			s.ymx = 24 + 15;
			s.ymn = -2
			break
		case C.REST:
			if (voice_tb.length == 1) {
				s.y = 12;		/* rest single voice */
//				s.ymx = 12 + 8;
//				s.ymn = 12 - 8
				s.ymx = 24;
				s.ymn = 0
				break
			}
			// fall thru
		case C.NOTE:
			delta = staff_delta[st]
			if (delta != 0
			 && !s.p_v.key.k_drum) {
				for (m = s.nhd; m >= 0; m--)
					s.notes[m].pit += delta
			}
			if (s.type == C.NOTE) {
				s.ymx = 3 * (s.notes[s.nhd].pit - 18) + 4;
				s.ymn = 3 * (s.notes[0].pit - 18) - 4;
			} else {
				s.y = (((s.notes[0].pit - 18) / 2) | 0) * 6;
				s.ymx = s.y + rest_sp[5 - s.nflags][0];
				s.ymn = s.y - rest_sp[5 - s.nflags][1]
			}
			if (s.dur < dur)
				dur = s.dur
			break
		}
	}
	if (!last_s)
		smallest_duration = dur
}

/* -- set the stem direction when multi-voices -- */
/* this function is called only once per tune */
function set_stem_dir() {
	var	t, u, i, st, rvoice, v,
		v_st,			// voice -> staff 1 & 2
		st_v, vobj,		// staff -> (v, ymx, ymn)*
		v_st_tb,		// array of v_st
		st_v_tb = [],		// array of st_v
		s = tsfirst,
		sy = cur_sy,
		nst = sy.nstaff

	while (s) {
		for (st = 0; st <= nst; st++)
			st_v_tb[st] = []
		v_st_tb = []

		/* get the max/min offsets in the delta time */
/*fixme: the stem height is not calculated yet*/
		for (u = s; u; u = u.ts_next) {
			if (u.type == C.BAR)
				break;
			if (u.type == C.STAVES) {
				if (u != s)
					break
				sy = s.sy
				for (st = nst; st <= sy.nstaff; st++)
					st_v_tb[st] = []
				nst = sy.nstaff
				continue
			}
			if ((u.type != C.NOTE && u.type != C.REST)
			 || u.invis)
				continue
			st = u.st;
/*fixme:test*/
if (st > nst) {
	var msg = "*** fatal set_stem_dir(): bad staff number " + st +
			" max " + nst;
	error(2, null, msg);
	throw new Error(msg)
}
			v = u.v;
			v_st = v_st_tb[v]
			if (!v_st) {
				v_st = {
					st1: -1,
					st2: -1
				}
				v_st_tb[v] = v_st
			}
			if (v_st.st1 < 0) {
				v_st.st1 = st
			} else if (v_st.st1 != st) {
				if (st > v_st.st1) {
					if (st > v_st.st2)
						v_st.st2 = st
				} else {
					if (v_st.st1 > v_st.st2)
						v_st.st2 = v_st.st1;
					v_st.st1 = st
				}
			}
			st_v = st_v_tb[st];
			rvoice = sy.voices[v].range;
			for (i = st_v.length; --i >= 0; ) {
				vobj = st_v[i]
				if (vobj.v == rvoice)
					break
			}
			if (i < 0) {
				vobj = {
					v: rvoice,
					ymx: 0,
					ymn: 24
				}
				for (i = 0; i < st_v.length; i++) {
					if (rvoice < st_v[i].v) {
						st_v.splice(i, 0, vobj)
						break
					}
				}
				if (i == st_v.length)
					st_v.push(vobj)
			}

			if (u.type != C.NOTE)
				continue
			if (u.ymx > vobj.ymx)
				vobj.ymx = u.ymx
			if (u.ymn < vobj.ymn)
				vobj.ymn = u.ymn

			if (u.xstem) {
				if (u.ts_prev.st != st - 1
				 || u.ts_prev.type != C.NOTE) {
					error(1, s, "Bad !xstem!");
					u.xstem = false
/*fixme:nflags KO*/
				} else {
					u.ts_prev.multi = 1;
					u.multi = 1;
					u.stemless = true
				}
			}
		}

		for ( ; s != u; s = s.ts_next) {
			if (s.multi)
				continue
			switch (s.type) {
			default:
				continue
			case C.REST:
				// handle %%voicecombine 0
				if ((s.combine != undefined && s.combine < 0)
				 || !s.ts_next || s.ts_next.type != C.REST
				 || s.ts_next.st != s.st
				 || s.time != s.ts_next.time
				 || s.dur != s.ts_next.dur
				 || s.invis)
					break
				unlksym(s.ts_next)
				break
			case C.NOTE:
			case C.GRACE:
				break
			}

			st = s.st;
			v = s.v;
			v_st = v_st_tb[v];
			st_v = st_v_tb[st]
			if (v_st && v_st.st2 >= 0) {
				if (st == v_st.st1)
					s.multi = -1
				else if (st == v_st.st2)
					s.multi = 1
				continue
			}
			if (st_v.length <= 1) { /* voice alone on the staff */
//				if (s.multi)
//					continue
/*fixme:could be done in set_var()*/
				if (s.floating)
					s.multi = st == voice_tb[v].st ? -1 : 1
				continue
			}
			rvoice = sy.voices[v].range
			for (i = st_v.length; --i >= 0; ) {
				if (st_v[i].v == rvoice)
					break
			}
			if (i < 0)
				continue		/* voice ignored */
			if (i == st_v.length - 1) {
				s.multi = -1	/* last voice */
			} else {
				s.multi = 1	/* first voice(s) */

				/* if 3 voices, and vertical space enough,
				 * have stems down for the middle voice */
				if (i != 0 && i + 2 == st_v.length) {
					if (st_v[i].ymn - cfmt.stemheight
							> st_v[i + 1].ymx)
						s.multi = -1;

					/* special case for unison */
					t = s.ts_next
//fixme: pb with ../lacerda/evol-7.5.5.abc
					if (s.ts_prev
					 && s.ts_prev.time == s.time
					 && s.ts_prev.st == s.st
					 && s.notes[s.nhd].pit == s.ts_prev.notes[0].pit
					 && s.beam_st
					 && s.beam_end
					 && (!t
					  || t.st != s.st
					  || t.time != s.time))
						s.multi = -1
				}
			}
		}
		while (s && s.type == C.BAR)
			s = s.ts_next
	}
}

/* -- adjust the offset of the rests when many voices -- */
/* this function is called only once per tune */
function set_rest_offset() {
	var	s, s2, v, end_time, not_alone, v_s, y, ymax, ymin,
		shift, dots, dx,
		v_s_tb = [],
		sy = cur_sy

	for (s = tsfirst; s; s = s.ts_next) {
		if (s.invis)
			continue
		if (s.type == C.STAVES)
			sy = s.sy
		if (!s.dur)
			continue
		v_s = v_s_tb[s.v]
		if (!v_s) {
			v_s = {}
			v_s_tb[s.v] = v_s
		}
		v_s.s = s;
		v_s.st = s.st;
		v_s.end_time = s.time + s.dur
		if (s.type != C.REST)
			continue

		/* check if clash with previous symbols */
		ymin = -127;
		ymax = 127;
		not_alone = dots = false
		for (v = 0; v <= v_s_tb.length; v++) {
			v_s = v_s_tb[v]
			if (!v_s || !v_s.s
			 || v_s.st != s.st
			 || v == s.v)
				continue
			if (v_s.end_time <= s.time)
				continue
			not_alone = true;
			s2 = v_s.s
			if (sy.voices[v].range < sy.voices[s.v].range) {
				if (s2.time == s.time) {
					if (s2.ymn < ymax) {
						ymax = s2.ymn
						if (s2.dots)
							dots = true
					}
				} else {
					if (s2.y < ymax)
						ymax = s2.y
				}
			} else {
				if (s2.time == s.time) {
					if (s2.ymx > ymin) {
						ymin = s2.ymx
						if (s2.dots)
							dots = true
					}
				} else {
					if (s2.y > ymin)
						ymin = s2.y
				}
			}
		}

		/* check if clash with next symbols */
		end_time = s.time + s.dur
		for (s2 = s.ts_next; s2; s2 = s2.ts_next) {
			if (s2.time >= end_time)
				break
			if (s2.st != s.st
//			 || (s2.type != C.NOTE && s2.type != C.REST)
			 || !s2.dur
			 || s2.invis)
				continue
			not_alone = true
			if (sy.voices[s2.v].range < sy.voices[s.v].range) {
				if (s2.time == s.time) {
					if (s2.ymn < ymax) {
						ymax = s2.ymn
						if (s2.dots)
							dots = true
					}
				} else {
					if (s2.y < ymax)
						ymax = s2.y
				}
			} else {
				if (s2.time == s.time) {
					if (s2.ymx > ymin) {
						ymin = s2.ymx
						if (s2.dots)
							dots = true
					}
				} else {
					if (s2.y > ymin)
						ymin = s2.y
				}
			}
		}
		if (!not_alone) {
			s.y = 12;
			s.ymx = 24;
			s.ymn = 0
			continue
		}
		if (ymax == 127 && s.y < 12) {
			shift = 12 - s.y
			s.y += shift;
			s.ymx += shift;
			s.ymn += shift
		}
		if (ymin == -127 && s.y > 12) {
			shift = s.y - 12
			s.y -= shift;
			s.ymx -= shift;
			s.ymn -= shift
		}
		shift = ymax - s.ymx
		if (shift < 0) {
			shift = Math.ceil(-shift / 6) * 6
			if (s.ymn - shift >= ymin) {
				s.y -= shift;
				s.ymx -= shift;
				s.ymn -= shift
				continue
			}
			dx = dots ? 15 : 10;
			s.notes[0].shhd = dx;
			s.xmx = dx
			continue
		}
		shift = ymin - s.ymn
		if (shift > 0) {
			shift = Math.ceil(shift / 6) * 6
			if (s.ymx + shift <= ymax) {
				s.y += shift;
				s.ymx += shift;
				s.ymn += shift
				continue
			}
			dx = dots ? 15 : 10;
			s.notes[0].shhd = dx;
			s.xmx = dx
			continue
		}
	}
}

/* -- create a starting symbol -- */
function new_sym(type, p_voice,
			last_s) {	/* symbol at same time */
	var s = {
		type: type,
		fname: last_s.fname,
//		istart: last_s.istart,
//		iend: last_s.iend,
		v: p_voice.v,
		p_v: p_voice,
		st: p_voice.st,
		time: last_s.time,
		next: p_voice.last_sym.next
	}
	if (s.next)
		s.next.prev = s;
	p_voice.last_sym.next = s;
	s.prev = p_voice.last_sym;
	p_voice.last_sym = s;

	lktsym(s, last_s)
	if (s.ts_prev.type != type)
		s.seqst = true
	if (last_s.type == type && s.v != last_s.v) {
		delete last_s.seqst;
		last_s.shrink = 0
	}
	return s
}

/* -- init the symbols at start of a music line -- */
function init_music_line() {
	var	p_voice, s, s2, last_s, v, st,
		nv = voice_tb.length

	/* initialize the voices */
	for (v = 0; v < nv; v++) {
		if (cur_sy.voices[v].range < 0)
			continue
		p_voice = voice_tb[v];
		p_voice.second = cur_sy.voices[v].second;
		p_voice.last_sym = p_voice.sym;

		/* move the voice to a printed staff */
		st = cur_sy.voices[v].st
		while (st < nstaff && !cur_sy.st_print[st])
			st++;
		p_voice.st = st
	}

	/* add a clef at start of the main voices */
	last_s = tsfirst
	while (last_s.type == C.CLEF) {		/* move the starting clefs */
		v = last_s.v
		if (cur_sy.voices[v].range >= 0
		 && !cur_sy.voices[v].second) {
			delete last_s.clef_small;	/* normal clef */
			p_voice = last_s.p_v;
			p_voice.last_sym = p_voice.sym = last_s
		}
		last_s = last_s.ts_next
	}
	for (v = 0; v < nv; v++) {
		p_voice = voice_tb[v]
		if (p_voice.sym && p_voice.sym.type == C.CLEF)
			continue
		if (cur_sy.voices[v].range < 0
		 || (cur_sy.voices[v].second
		  && !p_voice.bar_start))	// needed for correct linkage
			continue
		st = cur_sy.voices[v].st
		if (!staff_tb[st]
		 || !staff_tb[st].clef)
			continue
		s = clone(staff_tb[st].clef);
		s.v = v;
		s.p_v = p_voice;
		s.st = st;
		s.time = tsfirst.time;
		s.prev = null;
		s.next = p_voice.sym
		if (s.next)
			s.next.prev = s;
		p_voice.sym = s;
		p_voice.last_sym = s;
		s.ts_next = last_s;
		if (last_s)
			s.ts_prev = last_s.ts_prev
		else
			s.ts_prev = null
		if (!s.ts_prev) {
			tsfirst = s;
			s.seqst = true
		} else {
			s.ts_prev.ts_next = s
			delete s.seqst
		}
		if (last_s) {
			last_s.ts_prev = s
			if (last_s.type == C.CLEF)
				delete last_s.seqst
		}
		delete s.clef_small;
		s.second = cur_sy.voices[v].second
// (fixme: needed for sample5 X:3 Fugue & staffnonote.xhtml)
		if (!cur_sy.st_print[st])
			s.invis = true
	}

	/* add keysig */
	for (v = 0; v < nv; v++) {
		if (cur_sy.voices[v].range < 0
		 || cur_sy.voices[v].second
		 || !cur_sy.st_print[cur_sy.voices[v].st])
			continue
		p_voice = voice_tb[v]
		if (last_s && last_s.v == v && last_s.type == C.KEY) {
			p_voice.last_sym = last_s;
			last_s.k_old_sf = last_s.k_sf;	// no key cancel
			last_s = last_s.ts_next
			continue
		}
		s2 = p_voice.key
		if (s2.k_sf || s2.k_a_acc) {
			s = new_sym(C.KEY, p_voice, last_s);
			s.k_sf = s2.k_sf;
			s.k_old_sf = s2.k_sf;	// no key cancel
			s.k_none = s2.k_none;
			s.k_a_acc = s2.k_a_acc;
			s.istart = s2.istart;
			s.iend = s2.iend
			if (s2.k_bagpipe) {
				s.k_bagpipe = s2.k_bagpipe
				if (s.k_bagpipe == 'p')
					s.k_old_sf = 3	/* "A" -> "D" => G natural */
			}
		}
	}

	/* add time signature (meter) if needed */
	if (insert_meter & 1) {
		for (v = 0; v < nv; v++) {
			p_voice = voice_tb[v];
			s2 = p_voice.meter
			if (cur_sy.voices[v].range < 0
			 || cur_sy.voices[v].second
			 || !cur_sy.st_print[cur_sy.voices[v].st]
			 || s2.a_meter.length == 0)
				continue
			if (last_s && last_s.v == v && last_s.type == C.METER) {
				p_voice.last_sym = last_s;
				last_s = last_s.ts_next
				continue
			}
			s = new_sym(C.METER, p_voice, last_s);
			s.istart = s2.istart;
			s.iend = s2.iend;
			s.wmeasure = s2.wmeasure;
			s.a_meter = s2.a_meter
		}
		insert_meter &= ~1		// no meter any more
	}

	/* add bar if needed (for repeat bracket) */
	for (v = 0; v < nv; v++) {

		// if bar already, keep it in sequence
		p_voice = voice_tb[v];
		if (last_s && last_s.v == v && last_s.type == C.BAR) {
			p_voice.last_sym = last_s;
			last_s = last_s.ts_next
			continue
		}

		s2 = p_voice.bar_start
		if (!s2)
			continue
		p_voice.bar_start = null
		if (cur_sy.voices[v].range < 0
		 || !cur_sy.st_print[cur_sy.voices[v].st])
			continue

		s2.next = p_voice.last_sym.next
		if (s2.next)
			s2.next.prev = s2;
		p_voice.last_sym.next = s2;
		s2.prev = p_voice.last_sym;
		p_voice.last_sym = s2;
		lktsym(s2, last_s);
		s2.time = tsfirst.time
		if (s2.ts_prev.type != s2.type)
			s2.seqst = true;
		if (last_s && last_s.type == s2.type && s2.v != last_s.v) {
			delete last_s.seqst;
			last_s.shrink = 0
		}
	}

	/* if initialization of a new music line, compute the spacing,
	 * including the first (old) sequence */
	set_pitch(last_s);
	for (s = last_s; s; s = s.ts_next) {
		if (s.seqst) {
			for (s = s.ts_next; s; s = s.ts_next)
				if (s.seqst)
					break
			break
		}
	}
	set_allsymwidth(s)	/* set the width of the added symbols */
}

/* -- set a pitch in all symbols and the start/stop of the beams -- */
function set_words(p_voice) {
	var	s, s2, nflags, lastnote,
		start_flag = true,
		pitch = 127			/* no note */

	for (s = p_voice.sym; s; s = s.next) {
		if (s.type == C.NOTE) {
			pitch = s.notes[0].pit
			break
		}
	}
	for (s = p_voice.sym; s; s = s.next) {
		switch (s.type) {
		case C.MREST:
			start_flag = true
			break
		case C.BAR:
			if (!s.beam_on)
				start_flag = true
			if (!s.next && s.prev
//			 && s.prev.type == C.NOTE
//			 && s.prev.dur >= C.BLEN * 2)
			 && s.prev.head == C.OVALBARS)
				s.prev.head = C.SQUARE
			break
		case C.NOTE:
		case C.REST:
			if (s.trem2)
				break
			nflags = s.nflags

			if (s.ntrem)
				nflags += s.ntrem
			if (s.type == C.REST && s.beam_end) {
				s.beam_end = false;
				start_flag = true
			}
			if (start_flag
			 || nflags <= 0) {
				if (lastnote) {
					lastnote.beam_end = true;
					lastnote = null
				}
				if (nflags <= 0) {
					s.beam_st = true;
					s.beam_end = true
				} else if (s.type == C.NOTE) {
					s.beam_st = true;
					start_flag = false
				}
			}
			if (s.beam_end)
				start_flag = true
			if (s.type == C.NOTE)
				lastnote = s
			break
		}
		if (s.type == C.NOTE) {
			if (s.nhd != 0)
				sort_pitch(s);
			pitch = s.notes[0].pit
//			if (s.prev
//			 && s.prev.type != C.NOTE) {
//				s.prev.notes[0].pit = (s.prev.notes[0].pit
//						    + pitch) / 2
			for (s2 = s.prev; s2; s2 = s2.prev) {
				if (s2.type != C.REST)
					break
				s2.notes[0].pit = pitch
			}
		} else {
			if (!s.notes) {
				s.notes = []
				s.notes[0] = {}
				s.nhd = 0
			}
			s.notes[0].pit = pitch
		}
	}
	if (lastnote)
		lastnote.beam_end = true
}

/* -- set the end of the repeat sequences -- */
function set_rb(p_voice) {
	var	s2, mx, n,
		s = p_voice.sym

	while (s) {
		if (s.type != C.BAR || !s.rbstart || s.norepbra) {
			s = s.next
			continue
		}

		mx = cfmt.rbmax

		/* if 1st repeat sequence, compute the bracket length */
		if (s.text && s.text[0] == '1') {
			n = 0;
			s2 = null
			for (s = s.next; s; s = s.next) {
				if (s.type != C.BAR)
					continue
				n++
				if (s.rbstop) {
					if (n <= cfmt.rbmax) {
						mx = n;
						s2 = null
					}
					break
				}
				if (n == cfmt.rbmin)
					s2 = s
			}
			if (s2) {
				s2.rbstop = 1;
				mx = cfmt.rbmin
			}
		}
		while (s) {

			/* check repbra shifts (:| | |2 in 2nd staves) */
			if (s.rbstart != 2) {
				s = s.next
				if (!s)
					break
				if (s.rbstart != 2) {
					s = s.next
					if (!s)
						break
					if (s.rbstart != 2)
						break
				}
			}
			n = 0;
			s2 = null
			for (s = s.next; s; s = s.next) {
				if (s.type != C.BAR)
					continue
				n++
				if (s.rbstop)
					break
				if (!s.next)
					s.rbstop = 2	// right repeat with end
				else if (n == mx)
					s.rbstop = 1	// right repeat without end
			}
		}
	}
}

/* -- initialize the generator -- */
/* this function is called only once per tune  */

var delpit = [0, -7, -14, 0]

function set_global() {
	var p_voice, st, v, nv, sy

	/* get the max number of staves */
	sy = cur_sy;
	st = sy.nstaff;
//	sy.st_print = new Uint8Array(sy.staves.length)
	while (1) {
		sy = sy.next
		if (!sy)
			break
//		sy.st_print = new Uint8Array(sy.staves.length)
		if (sy.nstaff > st)
			st = sy.nstaff
	}
	nstaff = st;

	/* set the pitches, the words (beams) and the repeat brackets */
	nv = voice_tb.length
	for (v = 0; v < nv; v++) {
		p_voice = voice_tb[v];
		set_words(p_voice)
// (test removed because v.second may change after %%staves)
//		if (!p_voice.second && !p_voice.norepbra)
			set_rb(p_voice)
	}

	/* set the staff of the floating voices */
	set_float();

	// set the clefs and adjust the pitches of all symbol
	set_clefs();
	set_pitch(null)
}

/* -- return the left indentation of the staves -- */
function set_indent(first) {
	var	st, v, w, p_voice, p, i, j, font,
		nv = voice_tb.length,
		maxw = 0

	for (v = 0; v < nv; v++) {
		p_voice = voice_tb[v]
		if (cur_sy.voices[v].range < 0)
			continue
		st = cur_sy.voices[v].st
//		if (!cur_sy.st_print[st])
//			continue
		p = ((first || p_voice.new_name) && p_voice.nm) ?
			p_voice.nm : p_voice.snm
		if (!p)
			continue
		if (!font) {
			font = get_font("voice");
			set_font(font);
		}
		i = 0
		while (1) {
			j = p.indexOf("\\n", i)
			if (j < 0)
				w = strwh(p.slice(i))
			else
				w = strwh(p.slice(i, j))
			w = w[0]
			if (w > maxw)
				maxw = w
			if (j < 0)
				break
			i = j + 1
		}
	}
	if (font)
		maxw += 4 * cwid(' ') * font.swfac;

	w = .5				// (width of left bar)
	for (st = 0; st <= cur_sy.nstaff; st++) {
		if (cur_sy.staves[st].flags
				& (OPEN_BRACE2 | OPEN_BRACKET2)) {
			w = 12
			break
		}
		if (cur_sy.staves[st].flags & (OPEN_BRACE | OPEN_BRACKET))
			w = 6
	}
	maxw += w

	if (first)			// if %%indent
		maxw += cfmt.indent
	return maxw
}

/* -- decide on beams and on stem directions -- */
/* this routine is called only once per tune */
function set_beams(sym) {
	var	s, t, g, beam, s_opp, dy, avg, n, m, mid_p, pu, pd,
		laststem = -1

	for (s = sym; s; s = s.next) {
		if (s.type != C.NOTE) {
			if (s.type != C.GRACE)
				continue
			g = s.extra
			if (g.stem == 2) {	/* opposite gstem direction */
				s_opp = s
				continue
			}
			if (!s.stem
			 && (s.stem = s.multi) == 0)
				s.stem = 1
			for (; g; g = g.next) {
				g.stem = s.stem;
				g.multi = s.multi
			}
			continue
		}

		if (!s.stem			/* if not explicitly set */
		 && (s.stem = s.multi) == 0) { /* and alone on the staff */
			mid_p = s.mid / 3 + 18

			/* notes in a beam have the same stem direction */
			if (beam) {
				s.stem = laststem
			} else if (s.beam_st && !s.beam_end) {	// beam start
				beam = true;
				pu = s.notes[s.nhd].pit;
				pd = s.notes[0].pit
				for (g = s.next; g; g = g.next) {
					if (g.type != C.NOTE)
						continue
					if (g.stem || g.multi) {
						s.stem = g.stem || g.multi
						break
					}
					if (g.notes[g.nhd].pit > pu)
						pu = g.notes[g.nhd].pit
					if (g.notes[0].pit < pd)
						pd = g.notes[0].pit
					if (g.beam_end)
						break
				}
				if (g.beam_end) {
					if ((pu + pd) / 2 < mid_p) {
						s.stem = 1
					} else if ((pu + pd) / 2 > mid_p) {
						s.stem = -1
					} else {
//--fixme: equal: check all notes of the beam
						if (cfmt.bstemdown)
							s.stem = -1
					}
				}
				if (!s.stem)
					s.stem = laststem
			} else {				// no beam
				n = (s.notes[s.nhd].pit + s.notes[0].pit) / 2
				if (n == mid_p) {
					n = 0
					for (m = 0; m <= s.nhd; m++)
						n += s.notes[m].pit;
					n /= (s.nhd + 1)
				}
//				s.stem = n < mid_p ? 1 : -1
				if (n < mid_p)
					s.stem = 1
				else if (n > mid_p)
					s.stem = -1
				else if (cfmt.bstemdown)
					s.stem = -1
				else
					s.stem = laststem
			}
		} else {			/* stem set by set_stem_dir */
			if (s.beam_st && !s.beam_end)
				beam = true
		}
		if (s.beam_end)
			beam = false;
		laststem = s.stem;

		if (s_opp) {			/* opposite gstem direction */
			for (g = s_opp.extra; g; g = g.next)
				g.stem = -laststem;
			s_opp.stem = -laststem;
			s_opp = null
		}
	}
}

// check if there may be one head for unison when voice overlap
function same_head(s1, s2) {
	var i1, i2, l1, l2, head, i11, i12, i21, i22, sh1, sh2

	if (s1.shiftunison && s1.shiftunison >= 3)
		return false
	if ((l1 = s1.dur) >= C.BLEN)
		return false
	if ((l2 = s2.dur) >= C.BLEN)
		return false
	if (s1.stemless && s2.stemless)
		return false
	if (s1.dots != s2.dots) {
		if ((s1.shiftunison && (s1.shiftunison & 1))
		 || s1.dots * s2.dots != 0)
			return false
	}
	if (s1.stem * s2.stem > 0)
		return false

	/* check if a common unison */
	i1 = i2 = 0
	if (s1.notes[0].pit > s2.notes[0].pit) {
//fixme:dots
		if (s1.stem < 0)
			return false
		while (s2.notes[i2].pit != s1.notes[0].pit) {
			if (++i2 > s2.nhd)
				return false
		}
	} else if (s1.notes[0].pit < s2.notes[0].pit) {
//fixme:dots
		if (s2.stem < 0)
			return false
		while (s2.notes[0].pit != s1.notes[i1].pit) {
			if (++i1 > s1.nhd)
				return false
		}
	}
	if (s2.notes[i2].acc != s1.notes[i1].acc)
		return false;
	i11 = i1;
	i21 = i2;
	sh1 = s1.notes[i1].shhd;
	sh2 = s2.notes[i2].shhd
	do {
//fixme:dots
		i1++;
		i2++
		if (i1 > s1.nhd) {
//fixme:dots
//			if (s1.notes[0].pit < s2.notes[0].pit)
//				return false
			break
		}
		if (i2 > s2.nhd) {
//fixme:dots
//			if (s1.notes[0].pit > s2.notes[0].pit)
//				return false
			break
		}
		if (s2.notes[i2].acc != s1.notes[i1].acc)
			return false
		if (sh1 < s1.notes[i1].shhd)
			sh1 = s1.notes[i1].shhd
		if (sh2 < s2.notes[i2].shhd)
			sh2 = s2.notes[i2].shhd
	} while (s2.notes[i2].pit == s1.notes[i1].pit)
//fixme:dots
	if (i1 <= s1.nhd) {
		if (i2 <= s2.nhd)
			return false
		if (s2.stem > 0)
			return false
	} else if (i2 <= s2.nhd) {
		if (s1.stem > 0)
			return false
	}
	i12 = i1;
	i22 = i2;

	head = 0
	if (l1 != l2) {
		if (l1 < l2) {
			l1 = l2;
			l2 = s1.dur
		}
		if (l1 < C.BLEN / 2) {
			if (s2.dots > 0)
				head = 2
			else if (s1.dots > 0)
				head = 1
		} else if (l2 < C.BLEN / 4) {	/* (l1 >= C.BLEN / 2) */
//			if ((s1.shiftunison && s1.shiftunison == 2)
//			 || s1.dots != s2.dots)
			if (s1.shiftunison && (s1.shiftunison & 2))
				return false
			head = s2.dur >= C.BLEN / 2 ? 2 : 1
		} else {
			return false
		}
	}
	if (head == 0)
		head = s1.p_v.scale < s2.p_v.scale ? 2 : 1
	if (head == 1) {
		for (i2 = i21; i2 < i22; i2++) {
			s2.notes[i2].invis = true
			delete s2.notes[i2].acc
		}
		for (i2 = 0; i2 <= s2.nhd; i2++)
			s2.notes[i2].shhd += sh1
	} else {
		for (i1 = i11; i1 < i12; i1++) {
			s1.notes[i1].invis = true
			delete s1.notes[i1].acc
		}
		for (i1 = 0; i1 <= s1.nhd; i1++)
			s1.notes[i1].shhd += sh2
	}
	return true
}

/* handle unison with different accidentals */
function unison_acc(s1, s2, i1, i2) {
	var m, d

	if (!s2.notes[i2].acc) {
		d = w_note[s2.head] * 2 + s2.xmx + s1.notes[i1].shac + 2
		if (s1.notes[i1].micro)
			d += 2
		if (s2.dots)
			d += 6
		for (m = 0; m <= s1.nhd; m++) {
			s1.notes[m].shhd += d;
			s1.notes[m].shac -= d
		}
		s1.xmx += d
	} else {
		d = w_note[s1.head] * 2 + s1.xmx + s2.notes[i2].shac + 2
		if (s2.notes[i2].micro)
			d += 2
		if (s1.dots)
			d += 6
		for (m = 0; m <= s2.nhd; m++) {
			s2.notes[m].shhd += d;
			s2.notes[m].shac -= d
		}
		s2.xmx += d
	}
}

var MAXPIT = 48 * 2

/* set the left space of a note/chord */
function set_left(s) {
	var	m, i, j, shift,
		w_base = w_note[s.head],
		w = w_base,
		left = []

	for (i = 0; i < MAXPIT; i++)
		left.push(-100)

	/* stem */
	if (s.nflags > -2) {
		if (s.stem > 0) {
			w = -w;
			i = s.notes[0].pit * 2;
			j = (Math.ceil((s.ymx - 2) / 3) + 18) * 2
		} else {
			i = (Math.ceil((s.ymn + 2) / 3) + 18) * 2;
			j = s.notes[s.nhd].pit * 2
		}
		if (i < 0)
			i = 0
		if (j >= MAXPIT)
			j = MAXPIT - 1
		while (i <= j)
			left[i++] = w
	}

	/* notes */
	shift = s.notes[s.stem > 0 ? 0 : s.nhd].shhd;	/* previous shift */
	for (m = 0; m <= s.nhd; m++) {
		w = -s.notes[m].shhd + w_base + shift;
		i = s.notes[m].pit * 2
		if (i < 0)
			i = 0
		else if (i >= MAXPIT - 1)
			i = MAXPIT - 2
		if (w > left[i])
			left[i] = w
		if (s.head != C.SQUARE)
			w -= 1
		if (w > left[i - 1])
			left[i - 1] = w
		if (w > left[i + 1])
			left[i + 1] = w
	}

	return left
}

/* set the right space of a note/chord */
function set_right(s) {
	var	m, i, j, k, shift,
		w_base = w_note[s.head],
		w = w_base,
		flags = s.nflags > 0 && s.beam_st && s.beam_end,
		right = []

	for (i = 0; i < MAXPIT; i++)
		right.push(-100)

	/* stem and flags */
	if (s.nflags > -2) {
		if (s.stem < 0) {
			w = -w;
			i = (Math.ceil((s.ymn + 2) / 3) + 18) * 2;
			j = s.notes[s.nhd].pit * 2;
			k = i + 4
		} else {
			i = s.notes[0].pit * 2;
			j = (Math.ceil((s.ymx - 2) / 3) + 18) * 2
		}
		if (i < 0)
			i = 0
		if (j > MAXPIT)
			j = MAXPIT
		while (i < j)
			right[i++] = w
	}

	if (flags) {
		if (s.stem > 0) {
			if (s.xmx == 0)
				i = s.notes[s.nhd].pit * 2
			else
				i = s.notes[0].pit * 2;
			i += 4
			if (i < 0)
				i = 0
			for (; i < MAXPIT && i <= j - 4; i++)
				right[i] = 11
		} else {
			i = k
			if (i < 0)
				i = 0
			for (; i < MAXPIT && i <= s.notes[0].pit * 2 - 4; i++)
				right[i] = 3.5
		}
	}

	/* notes */
	shift = s.notes[s.stem > 0 ? 0 : s.nhd].shhd	/* previous shift */
	for (m = 0; m <= s.nhd; m++) {
		w = s.notes[m].shhd + w_base - shift;
		i = s.notes[m].pit * 2
		if (i < 0)
			i = 0
		else if (i >= MAXPIT - 1)
			i = MAXPIT - 2
		if (w > right[i])
			right[i] = w
		if (s.head != C.SQUARE)
			w -= 1
		if (w > right[i - 1])
			right[i - 1] = w
		if (w > right[i + 1])
			right[i + 1] = w
	}

	return right
}

/* -- shift the notes horizontally when voices overlap -- */
/* this routine is called only once per tune */
function set_overlap() {
	var	s, s1, s2, s3, i, i1, i2, m, sd, t, dp,
		d, d2, dr, dr2, dx,
		left1, right1, left2, right2, right3, pl, pr

	// invert the voices
	function v_invert() {
		s1 = s2;
		s2 = s;
		d = d2;
		pl = left1;
		pr = right1;
		dr2 = dr
	}

	for (s = tsfirst; s; s = s.ts_next) {
		if (s.type != C.NOTE
		 || s.invis)
			continue

		/* treat the stem on two staves with different directions */
		if (s.xstem
		 && s.ts_prev.stem < 0) {
			for (m = 0; m <= s.nhd; m++) {
				s.notes[m].shhd -= 7;		// stem_xoff
				s.notes[m].shac += 16
			}
		}

		/* search the next note at the same time on the same staff */
		s2 = s
		while (1) {
			s2 = s2.ts_next
			if (!s2)
				break
			if (s2.time != s.time) {
				s2 = null
				break
			}
			if (s2.type == C.NOTE
			 && !s2.invis
			 && s2.st == s.st)
				break
		}
		if (!s2)
			continue
		s1 = s

		/* set the dot vertical offset */
		if (cur_sy.voices[s1.v].range < cur_sy.voices[s2.v].range)
			s2.dot_low = true
		else
			s1.dot_low = true

		/* no shift if no overlap */
		if (s1.ymn > s2.ymx
		 || s1.ymx < s2.ymn)
			continue

		if (same_head(s1, s2))
			continue

		/* compute the minimum space for 's1 s2' and 's2 s1' */
		right1 = set_right(s1);
		left2 = set_left(s2);

		s3 = s1.ts_prev
		if (s3 && s3.time == s1.time
		 && s3.st == s1.st && s3.type == C.NOTE && !s3.invis) {
			right3 = set_right(s3)
			for (i = 0; i < MAXPIT; i++) {
				if (right3[i] > right1[i])
					right1[i] = right3[i]
			}
		} else {
			s3 = null
		}
		d = -10
		for (i = 0; i < MAXPIT; i++) {
			if (left2[i] + right1[i] > d)
				d = left2[i] + right1[i]
		}
		if (d < -3) {			// no clash if no dots clash
			if (!s1.dots || !s2.dots
			 || !s2.dot_low
			 || s1.stem > 0 || s2.stem < 0
			 || s1.notes[s1.nhd].pit + 2 != s2.notes[0].pit
			 || (s2.notes[0].pit & 1))
				continue
		}

		right2 = set_right(s2);
		left1 = set_left(s1)
		if (s3) {
			right3 = set_left(s3)
			for (i = 0; i < MAXPIT; i++) {
				if (right3[i] > left1[i])
					left1[i] = right3[i]
			}
		}
		d2 = dr = dr2 = -100
		for (i = 0; i < MAXPIT; i++) {
			if (left1[i] + right2[i] > d2)
				d2 = left1[i] + right2[i]
			if (right2[i] > dr2)
				dr2 = right2[i]
			if (right1[i] > dr)
				dr = right1[i]
		}

		/* check for unison with different accidentals
		 * and clash of dots */
		t = 0;
		i1 = s1.nhd;
		i2 = s2.nhd
		while (1) {
			dp = s1.notes[i1].pit - s2.notes[i2].pit
			switch (dp) {
			case 0:
				if (s1.notes[i1].acc != s2.notes[i2].acc) {
					t = -1
					break
				}
				if (s2.notes[i2].acc)
					s2.notes[i2].acc = 0
				if (s1.dots && s2.dots
				 && (s1.notes[i1].pit & 1))
					t = 1
				break
			case -1:
//fixme:dots++
//				if (s1.dots && s2.dots)
//					t = 1
//++--
				if (s1.dots && s2.dots) {
					if (s1.notes[i1].pit & 1) {
						s1.dot_low = false;
						s2.dot_low = false
					} else {
						s1.dot_low = true;
						s2.dot_low = true
					}
				}
//fixme:dots--
				break
			case -2:
				if (s1.dots && s2.dots
				 && !(s1.notes[i1].pit & 1)) {
//fixme:dots++
//					t = 1
//++--
					s1.dot_low = false;
					s2.dot_low = false
//fixme:dots--
					break
				}
				break
			}
			if (t < 0)
				break
			if (dp >= 0) {
				if (--i1 < 0)
					break
			}
			if (dp <= 0) {
				if (--i2 < 0)
					break
			}
		}

		if (t < 0) {	/* unison and different accidentals */
			unison_acc(s1, s2, i1, i2)
			continue
		}

		sd = 0;
		if (s1.dots) {
			if (s2.dots) {
				if (!t)			/* if no dot clash */
					sd = 1		/* align the dots */
//fixme:dots
			}
		} else if (s2.dots) {
			if (d2 + dr < d + dr2)
				sd = 1		/* align the dots */
//fixme:dots
		}
		pl = left2;
		pr = right2
		if (!s3 && d2 + dr < d + dr2)
			v_invert()
		d += 3
		if (d < 0)
			d = 0;			// (not return!)

		/* handle the previous shift */
		m = s1.stem >= 0 ? 0 : s1.nhd;
		d += s1.notes[m].shhd;
		m = s2.stem >= 0 ? 0 : s2.nhd;
		d -= s2.notes[m].shhd

		/*
		 * room for the dots
		 * - if the dots of v1 don't shift, adjust the shift of v2
		 * - otherwise, align the dots and shift them if clash
		 */
		if (s1.dots) {
			dx = 7.7 + s1.xmx +		// x 1st dot
				3.5 * s1.dots - 3.5 +	// x last dot
				3;			// some space
			if (!sd) {
				d2 = -100;
				for (i1 = 0; i1 <= s1.nhd; i1++) {
					i = s1.notes[i1].pit
					if (!(i & 1)) {
						if (!s1.dot_low)
							i++
						else
							i--
					}
					i *= 2
					if (i < 1)
						i = 1
					else if (i >= MAXPIT - 1)
						i = MAXPIT - 2
					if (pl[i] > d2)
						d2 = pl[i]
					if (pl[i - 1] + 1 > d2)
						d2 = pl[i - 1] + 1
					if (pl[i + 1] + 1 > d2)
						d2 = pl[i + 1] + 1
				}
				if (dx + d2 + 2 > d)
					d = dx + d2 + 2
			} else {
				if (dx < d + dr2 + s2.xmx) {
					d2 = 0
					for (i1 = 0; i1 <= s1.nhd; i1++) {
						i = s1.notes[i1].pit
						if (!(i & 1)) {
							if (!s1.dot_low)
								i++
							else
								i--
						}
						i *= 2
						if (i < 1)
							i = 1
						else if (i >= MAXPIT - 1)
							i = MAXPIT - 2
						if (pr[i] > d2)
							d2 = pr[i]
						if (pr[i - 1] + 1 > d2)
							d2 = pr[i - 1] = 1
						if (pr[i + 1] + 1 > d2)
							d2 = pr[i + 1] + 1
					}
					if (d2 > 4.5
					 && 7.7 + s1.xmx + 2 < d + d2 + s2.xmx)
						s2.xmx = d2 + 3 - 7.7
				}
			}
		}

		for (m = s2.nhd; m >= 0; m--) {
			s2.notes[m].shhd += d
//			if (s2.notes[m].acc
//			 && s2.notes[m].pit < s1.notes[0].pit - 4)
//				s2.notes[m].shac -= d
		}
		s2.xmx += d
		if (sd)
			s1.xmx = s2.xmx		// align the dots
	}
}

/* -- set the stem height -- */
/* this routine is called only once per tune */
function set_stems() {
	var s, s2, g, slen, scale,ymn, ymx, nflags, ymin, ymax

	for (s = tsfirst; s; s = s.ts_next) {
		if (s.type != C.NOTE) {
			if (s.type != C.GRACE)
				continue
			ymin = ymax = s.mid
			for (g = s.extra; g; g = g.next) {
				slen = GSTEM
				if (g.nflags > 1)
					slen += 1.2 * (g.nflags - 1);
				ymn = 3 * (g.notes[0].pit - 18);
				ymx = 3 * (g.notes[g.nhd].pit - 18)
				if (s.stem >= 0) {
					g.y = ymn;
					g.ys = ymx + slen;
					ymx = Math.round(g.ys)
				} else {
					g.y = ymx;
					g.ys = ymn - slen;
					ymn = Math.round(g.ys)
				}
				ymx += 2;
				ymn -= 2
				if (ymn < ymin)
					ymin = ymn
				else if (ymx > ymax)
					ymax = ymx;
				g.ymx = ymx;
				g.ymn = ymn
			}
			s.ymx = ymax;
			s.ymn = ymin
			continue
		}

		/* shift notes in chords (need stem direction to do this) */
		set_head_shift(s);

		/* if start or end of beam, adjust the number of flags
		 * with the other end */
		nflags = s.nflags
		if (s.beam_st && !s.beam_end) {
			if (s.feathered_beam)
				nflags = ++s.nflags
			for (s2 = s.next; /*s2*/; s2 = s2.next) {
				if (s2.type == C.NOTE) {
					if (s.feathered_beam)
						s2.nflags++
					if (s2.beam_end)
						break
				}
			}
/*			if (s2) */
			    if (s2.nflags > nflags)
				nflags = s2.nflags
		} else if (!s.beam_st && s.beam_end) {
//fixme: keep the start of beam ?
			for (s2 = s.prev; /*s2*/; s2 = s2.prev) {
				if (s2.beam_st)
					break
			}
/*			if (s2) */
			    if (s2.nflags > nflags)
				nflags = s2.nflags
		}

		/* set height of stem end */
		slen = cfmt.stemheight
		switch (nflags) {
		case 2: slen += 2; break
		case 3:	slen += 5; break
		case 4:	slen += 10; break
		case 5:	slen += 16; break
		}
		if ((scale = s.p_v.scale) != 1)
			slen *= (scale + 1) * .5;
		ymn = 3 * (s.notes[0].pit - 18)
		if (s.nhd > 0) {
			slen -= 2;
			ymx = 3 * (s.notes[s.nhd].pit - 18)
		} else {
			ymx = ymn
		}
		if (s.ntrem)
			slen += 2 * s.ntrem		/* tremolo */
		if (s.stemless) {
			if (s.stem >= 0) {
				s.y = ymn;
				s.ys = ymx
			} else {
				s.ys = ymn;
				s.y = ymx
			}
			if (nflags == -4)		/* if longa */
				ymn -= 6;
			s.ymx = ymx + 4;
			s.ymn = ymn - 4
		} else if (s.stem >= 0) {
			if (nflags >= 2)
				slen -= 1
			if (s.notes[s.nhd].pit > 26
			 && (nflags <= 0
			  || !s.beam_st
			  || !s.beam_end)) {
				slen -= 2
				if (s.notes[s.nhd].pit > 28)
					slen -= 2
			}
			s.y = ymn
			if (s.notes[0].ti1)
				ymn -= 3;
			s.ymn = ymn - 4;
			s.ys = ymx + slen
			if (s.ys < s.mid)
				s.ys = s.mid;
			s.ymx = (s.ys + 2.5) | 0
		} else {			/* stem down */
			if (s.notes[0].pit < 18
			 && (nflags <= 0
			  || !s.beam_st || !s.beam_end)) {
				slen -= 2
				if (s.notes[0].pit < 16)
					slen -= 2
			}
			s.ys = ymn - slen
			if (s.ys > s.mid)
				s.ys = s.mid;
			s.ymn = (s.ys - 2.5) | 0;
			s.y = ymx
/*fixme:the tie may be lower*/
			if (s.notes[s.nhd].ti1)
				ymx += 3;
			s.ymx = ymx + 4
		}
	}
}

/* -- split up unsuitable bars at end of staff -- */
function check_bar(s) {
	var	bar_type, i, b1, b2,
		p_voice = s.p_v

	/* search the last bar */
	while (s.type == C.CLEF || s.type == C.KEY || s.type == C.METER) {
		if (s.type == C.METER
		 && s.time > p_voice.sym.time)	/* if not empty voice */
			insert_meter |= 1;	/* meter in the next line */
		s = s.prev
		if (!s)
			return
	}
	if (s.type != C.BAR)
		return

	if (s.text != undefined) {			// if repeat bar
		p_voice.bar_start = clone(s);
		p_voice.bar_start.bar_type = "["
		delete s.text
		delete s.a_gch
//		return
	}
	bar_type = s.bar_type
	if (bar_type == ":")
		return
	if (bar_type.slice(-1) != ':')	// if not left repeat bar
		return

	if (!p_voice.bar_start)
		p_voice.bar_start = clone(s)
	if (bar_type[0] != ':') {			/* 'xx:' (not ':xx:') */
		if (bar_type == "||:") {
			p_voice.bar_start.bar_type = "|:";
			s.bar_type = "||"
			return
		}
		p_voice.bar_start.bar_type = bar_type
		if (s.prev && s.prev.type == C.BAR)
			unlksym(s)
		else
			s.bar_type = "|"
		return
	}
	if (bar_type == "::") {
		p_voice.bar_start.bar_type = "|:";
		s.bar_type = ":|"
		return
	}
	if (bar_type == "||:") {
		p_voice.bar_start.bar_type = "|:";
		s.bar_type = "||"
		return
	}

	// '::xx::' -> '::|' and '|::'
//fixme: do the same in abcm2ps
	i = 0
	while (bar_type[i] == ':')
		i++
	if (i < bar_type.length) {
		s.bar_type = bar_type.slice(0, i) + '|';
		i = bar_type.length - 1
		while (bar_type[i] == ':')
			i--;
		p_voice.bar_start.bar_type = '|' + bar_type.slice(i + 1)
	} else {
		i = (bar_type.length / 2) |0;			// '::::' !
		s.bar_type = bar_type.slice(0, i) + '|';
		p_voice.bar_start.bar_type = '|' + bar_type.slice(i)
	}
}

/* -- move the symbols of an empty staff to the next one -- */
function sym_staff_move(st) {
	for (var s = tsfirst; s; s = s.ts_next) {
		if (s.nl)
			break
		if (s.st == st
		 && s.type != C.CLEF) {
			s.st++;
			s.invis = true
		}
	}
}

// generate a block symbol
var blocks = []		// array of delayed block symbols

function block_gen(s) {
	switch (s.subtype) {
	case "leftmargin":
	case "rightmargin":
	case "pagescale":
	case "pagewidth":
	case "scale":
	case "staffwidth":
		svg_flush();
		set_format(s.subtype, s.param);
		break
	case "ml":
		svg_flush();
		user.img_out(s.text)
		break
	case "newpage":
		blk_flush();
		block.newpage = true;
		blk_out()
		break
	case "sep":
		set_page();
		vskip(s.sk1);
		output += '<path class="stroke"\n\td="M';
		out_sxsy(s.x, ' ', 0);
		output += 'h' + s.l.toFixed(2) + '"/>\n';
		vskip(s.sk2);
		break
	case "text":
		write_text(s.text, s.opt)
		break
	case "title":
		write_title(s.text, true)
		break
	case "vskip":
		vskip(s.sk);
//		blk_out()
		break
	default:
		error(2, s, 'Block $1 not treated', s.subtype)
		break
	}
}

/* -- define the start and end of a piece of tune -- */
/* tsnext becomes the beginning of the next line */
function set_piece() {
	var	s, last, p_voice, st, v, nst, nv,
		non_empty = [],
		non_empty_gl = [],
		sy = cur_sy

	function reset_staff(st) {
		var	p_staff = staff_tb[st],
			sy_staff = sy.staves[st]

		if (!p_staff)
			p_staff = staff_tb[st] = {}
		p_staff.y = 0;			// staff system not computed yet
		p_staff.stafflines = sy_staff.stafflines;
		p_staff.staffscale = sy_staff.staffscale;
		p_staff.ann_top = p_staff.ann_bot = 0
	} // reset_staff()

	// adjust the empty flag of brace systems
	function set_brace() {
		var	st, i, empty_fl,
			n = sy.staves.length

		// if a system brace has empty and non empty staves, keep all staves
		for (st = 0; st < n; st++) {
			if (!(sy.staves[st].flags & (OPEN_BRACE | OPEN_BRACE2)))
				continue
			empty_fl = 0;
			i = st
			while (st < n) {
				empty_fl |= non_empty[st] ? 1 : 2
				if (sy.staves[st].flags & (CLOSE_BRACE | CLOSE_BRACE2))
					break
				st++
			}
			if (empty_fl == 3) {	// if both empty and not empty staves
				while (i <= st) {
					non_empty[i] = true;
					non_empty_gl[i++] = true
				}
			}
		}
	} // set_brace()

	// set the top and bottom of the staves
	function set_top_bot() {
		var st, p_staff, i, l, hole

		for (st = 0; st <= nstaff; st++) {
			p_staff = staff_tb[st]
			if (!non_empty_gl[st]) {
				p_staff.botbar = p_staff.topbar = 0
				continue
			}
			l = p_staff.stafflines.length;
			p_staff.topbar = 6 * (l - 1)

			for (i = 0; i < l - 1; i++)
				if (p_staff.stafflines[i] != '.')
					break
			p_staff.botline = p_staff.botbar = i * 6
			if (i >= l - 2) {		// 0, 1 or 2 lines
				if (p_staff.stafflines[i] != '.') {
					p_staff.botbar -= 6;
					p_staff.topbar += 6
				} else {		// no line: big bar
					p_staff.botbar -= 12;
					p_staff.topbar += 12
				}
			}
		}
	} // set_top_bot()

	/* reset the staves */
	nstaff = nst = sy.nstaff
	for (st = 0; st <= nst; st++)
		reset_staff(st);

	/*
	 * search the next end of line,
	 * and mark the empty staves
	 */
	for (s = tsfirst; s; s = s.ts_next) {
		if (s.nl) {
//fixme: not useful
//			// delay the next block symbols
//			while (s && s.type == C.BLOCK) {
//				blocks.push(s);
//				unlksym(s);
//				s = s.ts_next
//			}
			break
		}
		if (!s.ts_next)
			last = s		// keep the last symbol
		switch (s.type) {
		case C.STAVES:
			set_brace();
			sy.st_print = new Uint8Array(non_empty);
			sy = s.sy;
			nst = sy.nstaff
			if (nstaff < nst) {
				for (st = nstaff + 1; st <= nst; st++)
					reset_staff(st);
				nstaff = nst
			}
			non_empty = []
			continue

		// the block symbols will be treated after music line generation
		case C.BLOCK:
			blocks.push(s);
			unlksym(s)
			if (last)
				last = s.ts_prev
			continue
		}
		st = s.st
		if (non_empty[st])
			continue
		switch (s.type) {
		case C.CLEF:
			if (st > nstaff) {	// if clef warning/change for new staff
				staff_tb[st].clef = s;
				unlksym(s)
			}
			break
		case C.BAR:
			if (!sy.staves[st].staffnonote	// default = 1
			 || sy.staves[st].staffnonote <= 1)
				break
			// fall thru
		case C.GRACE:
			non_empty_gl[st] = non_empty[st] = true
			break
		case C.NOTE:
		case C.REST:
		case C.SPACE:
		case C.MREST:
			if (sy.staves[st].staffnonote > 1) {
				non_empty_gl[st] = non_empty[st] = true
			} else if (!s.invis) {
				if (sy.staves[st].staffnonote != 0
				 || s.type == C.NOTE)
					non_empty_gl[st] = non_empty[st] = true
			}
			break
		}
	}
	tsnext = s;

	/* set the last empty staves */
	set_brace()
//	for (st = 0; st <= nstaff; st++)
//		sy.st_print[st] = non_empty[st];
	sy.st_print = new Uint8Array(non_empty);

	/* define the offsets of the measure bars */
	set_top_bot()

	/* move the symbols of the empty staves to the next staff */
//fixme: could be optimized (use a old->new staff array)
	for (st = 0; st < nstaff; st++) {
		if (!non_empty_gl[st])
			sym_staff_move(st)
	}

	/* let the last empty staff have a full height */
	if (!non_empty_gl[nstaff])
		staff_tb[nstaff].topbar = 0;

	/* initialize the music line */
	init_music_line();

	// keep the array of the staves to be printed
	gene.st_print = new Uint8Array(non_empty_gl)

	// if not the end of the tune, set the end of the music line
	if (tsnext) {
		s = tsnext;
		delete s.nl;
		last = s.ts_prev;
		last.ts_next = null;

		// and the end of the voices
		nv = voice_tb.length
		for (v = 0; v < nv; v++) {
			p_voice = voice_tb[v]
			if (p_voice.sym
			 && p_voice.sym.time <= tsnext.time) {
				for (s = tsnext.ts_prev; s; s = s.ts_prev) {
					if (s.v == v) {
						p_voice.s_next = s.next;
						s.next = null;
						check_bar(s)
						break
					}
				}
				if (s)
					continue
			}
			p_voice.s_next = p_voice.sym;
			p_voice.sym = null
		}
	}

	// if the last symbol is not a bar, add an invisible bar
	if (last.type != C.BAR) {
		s = add_end_bar(last);
		s.prev = s.ts_prev = last;
		last.ts_next = last.next = s;
		s.shrink = last.wr + 2;	// just a small space before end of staff
		s.space = set_space(s)
		if (s.space < s.shrink
		 && last.type != C.KEY)
			s.space = s.shrink
	}
}

/* -- position the symbols along the staff -- */
function set_sym_glue(width) {
    var	s, g,
	some_grace,
	spf,			// spacing factor
	xmin = 0,		// sigma shrink = minimum spacing
	xx = 0,			// sigma natural spacing
	x = 0,			// sigma expandable elements
	xs = 0,			// sigma unexpandable elements with no space
	xse = 0			// sigma unexpandable elements with space

	/* calculate the whole space of the symbols */
	for (s = tsfirst; s; s = s.ts_next) {
		if (s.type == C.GRACE && !some_grace)
			some_grace = s
		if (s.seqst) {
			xmin += s.shrink
			if (s.space) {
				if (s.space < s.shrink) {
					xse += s.shrink;
					xx += s.shrink
				} else {
					xx += s.space
				}
			} else {
				xs += s.shrink
			}
		}
	}

	// can occur when bar alone in a staff system
	if (xx == 0) {
		realwidth = 0
		return
	}

	// strong shrink
	if (xmin >= width
	 || xx == xse) {		// no space
		if (xmin > width)
			error(1, s, "Line too much shrunk $1 $2 $3",
				xmin.toFixed(2),
				xx.toFixed(2),
				width.toFixed(2));
		x = 0
		for (s = tsfirst; s; s = s.ts_next) {
			if (s.seqst)
				x += s.shrink;
			s.x = x
		}
//		realwidth = width
		spf_last = 0
	} else if (xx + xs > width * (1 - cfmt.stretchlast)
		 || (tsnext			// if not last line
		  && blocks.length == 0		// and no following text
		  && tsnext.type != C.BLOCK	//	(abcm2ps compatibility)
		  && cfmt.stretchstaff)) {
		for (var cnt = 4; --cnt >= 0; ) {
			spf = (width - xs - xse) / (xx - xse);
			xx = 0;
			xse = 0;
			x = 0
			for (s = tsfirst; s; s = s.ts_next) {
				if (s.seqst) {
					if (s.space) {
						if (s.space * spf <= s.shrink) {
							xse += s.shrink;
							xx += s.shrink;
							x += s.shrink
						} else {
							xx += s.space;
							x += s.space * spf
						}
					} else {
						x += s.shrink
					}
				}
				s.x = x
			}
			if (Math.abs(x - width) < 0.1)
				break
		}
		spf_last = spf
	} else {			// shorter line
		spf = (width - xs - xse) / xx
		if (spf_last < spf)
			spf = spf_last
		for (s = tsfirst; s; s = s.ts_next) {
			if (s.seqst)
				x += s.space * spf <= s.shrink ?
						s.shrink : s.space * spf
			s.x = x
		}
	}
	realwidth = x

	/* set the x offsets of the grace notes */
	for (s = some_grace; s; s = s.ts_next) {
		if (s.type != C.GRACE)
			continue
		if (s.gr_shift)
			x = s.prev.x + s.prev.wr
		else
			x = s.x - s.wl
		for (g = s.extra; g; g = g.next)
			g.x += x
	}
}

// set the starting symbols of the voices for the new music line
function set_sym_line() {
	var	p_voice, s, v,
		nv = voice_tb.length

	// set the first symbol of each voice
	for (v = 0; v < nv; v++) {
		p_voice = voice_tb[v];
		s = p_voice.s_next;		// (set in set_piece)
		p_voice.sym = s
		if (s)
			s.prev = null
	}
}

// set the left offset the images
function set_posx() {
	posx = img.lm / cfmt.scale
}

// initialize the start of generation / new music line
// and output the inter-staff blocks if any
function gen_init() {
	var	s = tsfirst,
		tim = s.time

	for ( ; s; s = s.ts_next) {
		if (s.time != tim) {
			set_page()
			return
		}
		switch (s.type) {
		case C.NOTE:
		case C.REST:
		case C.MREST:
			set_page()
			return
		default:
			continue
		case C.STAVES:
			cur_sy = s.sy
			break
		case C.BLOCK:
			block_gen(s)
			break
		}
		unlksym(s)
		if (s.p_v.s_next == s)
			s.p_v.s_next = s.next
	}
	tsfirst = null			/* no more notes */
}

/* -- generate the music -- */
function output_music() {
	var v, lwidth, indent, line_height

	gen_init()
	if (!tsfirst)
		return
	set_global()
	if (voice_tb.length > 1) {	/* if many voices */
		set_stem_dir()		/* set the stems direction in 'multi' */
	}

	for (v = 0; v < voice_tb.length; v++)
		set_beams(voice_tb[v].sym);	/* decide on beams */

	set_stems()			/* set the stem lengths */
	if (voice_tb.length > 1) {	/* if many voices */
		set_rest_offset();	/* set the vertical offset of rests */
		set_overlap();		/* shift the notes on voice overlap */
//		set_rp_bars()		// set repeat bars
	}
	set_acc_shft();			// set the horizontal offset of accidentals

	set_allsymwidth(null);		/* set the width of all symbols */

	indent = set_indent(true)

	/* if single line, adjust the page width */
	if (cfmt.singleline) {
		v = get_ck_width();
		lwidth = indent + v[0] + v[1] + get_width(tsfirst, null);
		img.width = lwidth * cfmt.scale + img.lm + img.rm + 2
	} else {

	/* else, split the tune into music lines */
		lwidth = get_lwidth();
		cut_tune(lwidth, indent)
	}

	spf_last = 1.2				// last spacing factor
	while (1) {				/* loop per music line */
		set_piece();
		set_sym_glue(lwidth - indent)
		if (realwidth != 0) {
			if (indent != 0)
				posx += indent;
			draw_sym_near();		// delayed output
			line_height = set_staff();
			delayed_update();
			draw_systems(indent);
			draw_all_sym();
			vskip(line_height)
			if (indent != 0) {
				posx -= indent;
				insert_meter &= ~2	// no more indentation
			}
			while (blocks.length != 0)
				block_gen(blocks.shift())
		}

		tsfirst = tsnext
		svg_flush()
		if (!tsnext)
			break

		// next line
		gen_init()
		if (!tsfirst)
			break
		tsfirst.ts_prev = null;
		set_sym_line();
		lwidth = get_lwidth()	// the image size may have changed
		indent = set_indent()
	}
}

/* -- reset the generator -- */
function reset_gen() {
	insert_meter = cfmt.writefields.indexOf('M') >= 0 ?
				3 :	/* insert meter and indent */
				2	/* indent only */
}
// abc2svg - parse.js - ABC parse
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

var	a_gch,		// array of parsed guitar chords
	a_dcn,		// array of parsed decoration names
	multicol,	// multi column object
	maps = {}	// maps object - hashcode = map name
			//	-> object - hashcode = note
			//	[0] array of heads
			//	[1] print
			//	[2] color
var	qplet_tb = new Int8Array([ 0, 1, 3, 2, 3, 0, 2, 0, 3, 0 ]),
	ntb = "CDEFGABcdefgab"


// set the source references of a symbol
function set_ref(s) {
	s.fname = parse.fname;
	s.istart = parse.istart;
	s.iend = parse.iend
}

// -- %% pseudo-comment

// clef definition (%%clef, K: and V:)
function new_clef(clef_def) {
	var	s = {
			type: C.CLEF,
			clef_line: 2,
			clef_type: "t",
			v: curvoice.v,
			p_v: curvoice,
			time: curvoice.time,
			dur: 0
		},
		i = 1

	set_ref(s)

	switch (clef_def[0]) {
	case '"':
		i = clef_def.indexOf('"', 1);
		s.clef_name = clef_def.slice(1, i);
		i++
		break
	case 'a':
		if (clef_def[1] == 'u') {	// auto
			s.clef_type = "a";
			s.clef_auto = true;
			i = 4
			break
		}
		i = 4				// alto
	case 'C':
		s.clef_type = "c";
		s.clef_line = 3
		break
	case 'b':				// bass
		i = 4
	case 'F':
		s.clef_type = "b";
		s.clef_line = 4
		break
	case 'n':				// none
		i = 4
		s.invis = true
		break
	case 't':
		if (clef_def[1] == 'e') {	// tenor
			s.clef_type = "c";
			s.clef_line = 4
			break
		}
		i = 6
	case 'G':
//		s.clef_type = "t"		// treble
		break
	case 'p':
		i = 4
	case 'P':				// perc
		s.clef_type = "p";
		s.clef_line = 3;
		curvoice.key.k_sf = 0		// no accidental
		break
	default:
		syntax(1, "Unknown clef '$1'", clef_def)
		return //undefined
	}
	if (clef_def[i] >= '1' && clef_def[i] <= '9') {
		s.clef_line = Number(clef_def[i]);
		i++
	}
	if (clef_def[i + 1] != '8')
		return s
	switch (clef_def[i]) {			// octave
	case '^':
		s.clef_oct_transp = true
	case '+':
		s.clef_octave = 7
		break
	case '_':
		s.clef_oct_transp = true
	case '-':
		s.clef_octave = -7
		break
	}
	return s
}

var note_pit = new Int8Array([0, 2, 4, 5, 7, 9, 11])

// get a transposition value
function get_transp(param,
			type) {		// undefined or "instr"
	var	i, val, tmp, note,
		pit = []

	if (param[0] == '0')
		return 0
	if ("123456789-+".indexOf(param[0]) >= 0) {	// by semi-tone
		val = parseInt(param) * 3
		if (isNaN(val) || val < -108 || val > 108) {
//fixme: no source reference...
			syntax(1, "Bad transpose value")
			return
		}
		switch (param.slice(-1)) {
		default:
			return val
		case '#':
			val++
			break
		case 'b':
			val += 2
			break
		}
		if (val > 0)
			return val
		return val - 3
	}

	// by music interval
	if (type == "instr") {	// convert instrument= into score= or sound=
		tmp = param.indexOf('/')
		if (!cfmt.sound) {
			if (tmp < 0)
				return 0	// written pitch
			param = param.replace('/', '')
		} else {
			if (tmp < 0)
				param = 'c' + param
			else
				param = param.replace(/.*\//, 'c')
		}
	}

	tmp = new scanBuf();
	tmp.buffer = param
	for (i = 0; i < 2; i++) {
		note = parse_acc_pit(tmp)
		if (!note) {
			syntax(1, "Bad transpose value")
			return
		}
		note.pit += 124;	// 126 - 2 for value > 0 and 'C' % 7 == 0
		val = ((note.pit / 7) | 0) * 12 + note_pit[note.pit % 7]
		if (note.acc && note.acc != 3)		// if not natural
			val += note.acc;
		pit[i] = val
	}
	if (cfmt.sound)
		pit[0] = 252;			// 'c'

	val = (pit[1] - pit[0]) * 3
	if (note) {
		switch (note.acc) {
		default:
			return val
		case 2:
		case 1:
			val++
			break
		case -1:
		case -2:
			val += 2
			break
		}
	}
	if (val > 0)
		return val
	return val - 3
}

// set the linebreak character
function set_linebreak(param) {
	var i, item

	for (i = 0; i < 128; i++) {
		if (char_tb[i] == "\n")
			char_tb[i] = nil	// remove old definition
	}
	param = param.split(/\s+/)
	for (i = 0; i < param.length; i++) {
		item = param[i]
		switch (item) {
		case '!':
		case '$':
		case '*':
		case ';':
		case '?':
		case '@':
			break
		case "<none>":
			continue
		case "<EOL>":
			item = '\n'
			break
		default:
			syntax(1, "Bad value '$1' in %%linebreak - ignored",
					item)
			continue
		}
		char_tb[item.charCodeAt(0)] = '\n'
	}
}

// set a new user character (U: or %%user)
function set_user(parm) {
    var	k, c, v,
	a = parm.match(/(.*?)[= ]*([!"].*[!"])/)

	if (!a) {
		syntax(1, 'Lack of starting ! or " in U: / %%user')
		return
	}
	c = a[1];
	v = a[2]
	if (v.slice(-1) != v[0]) {
		syntax(1, "Lack of ending $1 in U:/%%user", v[0])
		return
	}
	if (c[0] == '\\') {
		if (c[1] == 't')
			c = '\t'
		else if (!c[1])
			c = ' '
	}

	k = c.charCodeAt(0)
	if (k >= 128) {
		syntax(1, errs.not_ascii)
		return
	}
	switch (char_tb[k][0]) {
	case '0':			// nil
	case 'd':
	case 'i':
	case ' ':
		break
	case '"':
	case '!':
		if (char_tb[k].length > 1)
			break
		// fall thru
	default:
		syntax(1, "Bad user character '$1'", c)
		return
	}
	switch (v) {
	case "!beambreak!":
		v = " "
		break
	case "!ignore!":
		v = "i"
		break
	case "!nil!":
	case "!none!":
		v = "d"
		break
	}
	char_tb[k] = v
}

// get a stafflines value
function get_st_lines(param) {
	var n, val

	if (!param)
		return
	if (/^[\]\[|.-]+$/.test(param))
		return param.replace(/\]/g, '[')

	n = parseInt(param)
	switch (n) {
	case 0: return "..."
	case 1: return "..|"
	case 2: return ".||"
	case 3: return ".|||"
	}
	if (isNaN(n) || n < 0 || n > 16)
		return //undefined
	val = '|'
	while (--n > 0)
		val += '|'
	return val
}

// create a block symbol in the tune body
function new_block(subtype) {
	var	s = {
			type: C.BLOCK,
			subtype: subtype,
			dur: 0
		}

	if (parse.state == 2)
		goto_tune()
	var voice_s = curvoice;
	curvoice = voice_tb[par_sy.top_voice]
	sym_link(s);
	curvoice = voice_s
	return s
}

// set the voice parameters
function set_vp(a) {
    var	s, item, pos, val, clefpit

	while (1) {
		item = a.shift()
		if (!item)
			break
		if (item[item.length - 1] == '='
		 && a.length == 0) {
			syntax(1, errs.bad_val, item)
			break
		}
		switch (item) {
		case "clef=":
			s = a.shift()		// keep last clef
			break
		case "clefpitch=":
			item = a.shift()		// (<note><octave>)
			if (item) {
				val = ntb.indexOf(item[0])
				if (val >= 0) {
					switch (item[1]) {
					case "'":
						val += 7
						break
					case ',':
						val -= 7
						if (item[2] == ',')
							val -= 7
						break
					}
					clefpit = 4 - val	// 4 = 'G'
					break
				}
			}
			syntax(1, errs.bad_val, item)
			break
		case "octave=":
		case "uscale=":			// %%microscale
			val = parseInt(a.shift())
			if (isNaN(val))
				syntax(1, errs.bad_val, item)
			else
				curvoice[item.slice(0, -1)] = val
			break
		case "cue=":
			curvoice.scale = a.shift() == 'on' ? .7 : 1
			break
		case "instrument=":
			curvoice.transp = get_transp(a.shift(), 'instr')
			break
		case "map=":			// %%voicemap
			if (cfmt.sound != "play")
				curvoice.map = a.shift()
			break
		case "name=":
		case "nm=":
			curvoice.nm = a.shift()
			if (curvoice.nm[0] == '"')
				curvoice.nm = curvoice.nm.slice(1, -1);
			curvoice.new_name = true
			break
		case "stem=":
		case "pos=":
			if (item == "pos=")
				item = a.shift().split(' ')
			else
				item = ["stm", a.shift()];
			val = posval[item[1]]
			if (val == undefined) {
				syntax(1, errs.bad_val, item[0])
				break
			}
			if (!pos)
				pos = {}
			pos[item[0]] = val
			break
		case "scale=":			// %%voicescale
			val = parseFloat(a.shift())
			if (isNaN(val) || val < .6 || val > 1.5)
				syntax(1, errs.bad_val, "%%voicescale")
			else
				curvoice.scale = val
			break
		case "score=":
			if (cfmt.sound)
				break
			item = a.shift()
			if (item.indexOf('/') < 0)
				item += '/c';
			curvoice.transp = get_transp(item)
			break
		case "shift=":
			curvoice.shift = get_transp(a.shift())
			break
		case "sound=":
		case "transpose=":		// (abcMIDI compatibility)
			if (!cfmt.sound)
				break
			curvoice.transp = get_transp(a.shift())
			break
		case "subname=":
		case "sname=":
		case "snm=":
			curvoice.snm = a.shift()
			if (curvoice.snm[0] == '"')
				curvoice.snm = curvoice.snm.slice(1, -1);
			break
		case "stafflines=":
			val = get_st_lines(a.shift())
			if (val == undefined)
				syntax(1, "Bad %%stafflines value")
			else if (curvoice.st != undefined)
				par_sy.staves[curvoice.st].stafflines = val
			else
				curvoice.stafflines = val
			break
		case "staffnonote=":
			val = parseInt(a.shift())
			if (isNaN(val))
				syntax(1, "Bad %%staffnonote value")
			else
				curvoice.staffnonote = val
			break
		case "staffscale=":
			val = parseFloat(a.shift())
			if (isNaN(val) || val < .3 || val > 2)
				syntax(1, "Bad %%staffscale value")
			else
				curvoice.staffscale = val
			break
		default:
			switch (item.slice(0, 4)) {
			case "treb":
			case "bass":
			case "alto":
			case "teno":
			case "perc":
				s = item
				break
			default:
				if ("GFC".indexOf(item[0]) >= 0)
					s = item
				else if (item.slice(-1) == '=')
					a.shift()
				break
			}
			break
		}
	}
	if (pos) {
		curvoice.pos = clone(curvoice.pos)
		for (item in pos)
			if (pos.hasOwnProperty(item))
				curvoice.pos[item] = pos[item]
	}

	if (s) {
		s = new_clef(s)
		if (s) {
			if (clefpit)
				s.clefpit = clefpit
			get_clef(s)
		}
	}
} // set_vp()

// set the K: / V: parameters
function set_kv_parm(a) {	// array of items
	if (!curvoice.init) {	// add the global parameters if not done yet
		curvoice.init = true
		if (info.V) {
			if (info.V['*'])
				a = info.V['*'].concat(a)
			if (info.V[curvoice.id])
				a = info.V[curvoice.id].concat(a)
		}
	}
	if (a.length != 0)
		set_vp(a)
} // set_kv_parm()

// memorize the K:/V: parameters
function memo_kv_parm(vid,	// voice ID (V:) / '*' (K:/V:*)
			a) {	// array of items
	if (a.length == 0)
		return
	if (!info.V)
		info.V = {}
	if (info.V[vid])
		Array.prototype.push.apply(info.V[vid], a)
	else
		info.V[vid] = a
}

// K: key signature
// return the key and the voice/clef parameters
function new_key(param) {
	var	i, clef, key_end, c, tmp,
		mode = 0,
		s = {
			type: C.KEY,
			k_delta: 0,
			dur:0
		}

	set_ref(s);

	// tonic
	i = 1
	switch (param[0]) {
	case 'A': s.k_sf = 3; break
	case 'B': s.k_sf = 5; break
	case 'C': s.k_sf = 0; break
	case 'D': s.k_sf = 2; break
	case 'E': s.k_sf = 4; break
	case 'F': s.k_sf = -1; break
	case 'G': s.k_sf = 1; break
	case 'H':				// bagpipe
		switch (param[1]) {
		case 'P':
		case 'p':
			s.k_bagpipe = param[1];
			s.k_sf = param[1] == 'P' ? 0 : 2;
			i++
			break
		default:
			syntax(1, "Unknown bagpipe-like key")
			break
		}
		break
	case 'P':
		s.k_drum = true;
		key_end = true
		break
	case 'n':				// none
		if (param.indexOf("none") == 0) {
			s.k_sf = 0;
			s.k_none = true;
			i = 4
		}
		// fall thru
	default:
		key_end = true
		break
	}

	if (!key_end) {
		switch (param[i]) {
		case '#': s.k_sf += 7; i++; break
		case 'b': s.k_sf -= 7; i++; break
		}
		param = param.slice(i).trim()
		switch (param.slice(0, 3).toLowerCase()) {
		default:
			if (param[0] != 'm'
			 || (param[1] != ' ' && param[1] != '\t'
			  && param[1] != '\n')) {
				key_end = true
				break
			}
			// fall thru ('m')
		case "aeo":
		case "m":
		case "min": s.k_sf -= 3;
			mode = 5
			break
		case "dor": s.k_sf -= 2;
			mode = 1
			break
		case "ion":
		case "maj": break
		case "loc": s.k_sf -= 5;
			mode = 6
			break
		case "lyd": s.k_sf += 1;
			mode = 3
			break
		case "mix": s.k_sf -= 1;
			mode = 4
			break
		case "phr": s.k_sf -= 4;
			mode = 2
			break
		}
		if (!key_end)
			param = param.replace(/\w+\s*/, '')

		// [exp] accidentals
		if (param.indexOf("exp ") == 0) {
			param = param.replace(/\w+\s*/, '')
			if (!param)
				syntax(1, "No accidental after 'exp'");
			s.k_exp = true
		}
		c = param[0]
		if (c == '^' || c == '_' || c == '=') {
			s.k_a_acc = [];
			tmp = new scanBuf();
			tmp.buffer = param
			do {
				var note = parse_acc_pit(tmp)
				if (!note)
					return [s, null]
				s.k_a_acc.push(note);
				c = param[tmp.index]
				while (c == ' ')
					c = param[++tmp.index]
			} while (c == '^' || c == '_' || c == '=');
			param = param.slice(tmp.index)
		} else if (s.k_exp && param.indexOf("none") == 0) {
			s.k_sf = 0;
			param = param.replace(/\w+\s*/, '')
		}
	}

	s.k_delta = cgd2cde[(s.k_sf + 7) % 7];
	s.k_mode = mode

	return [s, info_split(param, 0)]
}

// M: meter
function new_meter(text) {
	var	s = {
			type: C.METER,
			dur: 0,
			a_meter: []
		},
		meter = {},
		val, v,
		m1 = 0, m2,
		i = 0, j,
		wmeasure,
		p = text,
		in_parenth;

	set_ref(s)

	if (p.indexOf("none") == 0) {
		i = 4;				/* no meter */
		wmeasure = 1;	// simplify measure numbering and C.MREST conversion
	} else {
		wmeasure = 0
		while (i < text.length) {
			if (p[i] == '=')
				break
			switch (p[i]) {
			case 'C':
				meter.top = p[i++]
				if (p[i] == '|')
					meter.top += p[i++];
				m1 = 4;
				m2 = 4
				break
			case 'c':
			case 'o':
				m1 = p[i] == 'c' ? 4 : 3;
				m2 = 4;
				meter.top = p[i++]
				if (p[i] == '.')
					meter.top += p[i++]
				break
			case '(':
				if (p[i + 1] == '(') {	/* "M:5/4 ((2+3)/4)" */
					in_parenth = true;
					meter.top = p[i++];
					s.a_meter.push(meter);
					meter = {}
				}
				j = i + 1
				while (j < text.length) {
					if (p[j] == ')' || p[j] == '/')
						break
					j++
				}
				if (p[j] == ')' && p[j + 1] == '/') {	/* "M:5/4 (2+3)/4" */
					i++		/* remove the parenthesis */
					continue
				}			/* "M:5 (2+3)" */
				/* fall thru */
			case ')':
				in_parenth = p[i] == '(';
				meter.top = p[i++];
				s.a_meter.push(meter);
				meter = {}
				continue
			default:
				if (p[i] <= '0' || p[i] > '9') {
					syntax(1, "Bad char '$1' in M:", p[i])
					return
				}
				m2 = 2;			/* default when no bottom value */
				meter.top = p[i++]
				for (;;) {
					while (p[i] >= '0' && p[i] <= '9')
						meter.top += p[i++]
					if (p[i] == ')') {
						if (p[i + 1] != '/')
							break
						i++
					}
					if (p[i] == '/') {
						i++;
						if (p[i] <= '0' || p[i] > '9') {
							syntax(1, "Bad char '$1' in M:", p[i])
							return
						}
						meter.bot = p[i++]
						while (p[i] >= '0' && p[i] <= '9')
							meter.bot += p[i++]
						break
					}
					if (p[i] != ' ' && p[i] != '+')
						break
					if (i >= text.length
					 || p[i + 1] == '(')	/* "M:5 (2/4+3/4)" */
						break
					meter.top += p[i++]
				}
				m1 = parseInt(meter.top)
				break
			}
			if (!in_parenth) {
				if (meter.bot)
					m2 = parseInt(meter.bot);
				wmeasure += m1 * C.BLEN / m2
			}
			s.a_meter.push(meter);
			meter = {}
			while (p[i] == ' ')
				i++
			if (p[i] == '+') {
				meter.top = p[i++];
				s.a_meter.push(meter);
				meter = {}
			}
		}
	}
	if (p[i] == '=') {
		val = p.substring(++i).match(/^(\d+)\/(\d+)$/)
		if (!val) {
			syntax(1, "Bad duration '$1' in M:", p.substring(i))
			return
		}
		wmeasure = C.BLEN * val[1] / val[2]
	}
	s.wmeasure = wmeasure

	if (parse.state != 3) {
		info.M = text;
		glovar.meter = s
		if (parse.state >= 1) {

			/* in the tune header, change the unit note length */
			if (!glovar.ulen) {
				if (wmeasure <= 1
				 || wmeasure >= C.BLEN * 3 / 4)
					glovar.ulen = C.BLEN / 8
				else
					glovar.ulen = C.BLEN / 16
			}
			for (v = 0; v < voice_tb.length; v++) {
				voice_tb[v].meter = s;
				voice_tb[v].wmeasure = wmeasure
			}
		}
	} else {
		curvoice.wmeasure = wmeasure
		if (is_voice_sig()) {
			curvoice.meter = s;
			reset_gen()
		} else {
			sym_link(s)
		}
	}
}

/* Q: tempo */
function new_tempo(text) {
	var	i = 0, j, c, nd, tmp,
		s = {
			type: C.TEMPO,
			dur: 0
		}

	set_ref(s)

	if (cfmt.writefields.indexOf('Q') < 0)
		s.del = true			// don't display

	/* string before */
	if (text[0] == '"') {
		i = text.indexOf('"', 1)
		if (i < 0) {
			syntax(1, "Unterminated string in Q:")
			return
		}
		s.tempo_str1 = text.slice(1, i);
		i++
		while (text[i] == ' ')
			i++
	}

	/* beat */
	tmp = new scanBuf();
	tmp.buffer = text;
	tmp.index = i
	while (1) {
//		c = tmp.char()
		c = text[tmp.index]
		if (c == undefined || c <= '0' || c > '9')
			break
		nd = parse_dur(tmp)
		if (!s.tempo_notes)
			s.tempo_notes = []
		s.tempo_notes.push(C.BLEN * nd[0] / nd[1])
		while (1) {
//			c = tmp.char()
			c = text[tmp.index]
			if (c != ' ')
				break
			tmp.index++
		}
	}

	/* tempo value */
	if (c == '=') {
		c = text[++tmp.index]
		while (c == ' ')
			c = text[++tmp.index];
		i = tmp.index
		if (c == 'c' && text[i + 1] == 'a'
		 && text[i + 2] == '.' && text[i + 3] == ' ') {
			s.tempo_ca = 'ca. ';
			tmp.index += 4;
//			c = text[tmp.index]
		}
		if (text[tmp.index + 1] != '/') {
			s.tempo = tmp.get_int()
		} else {
			nd = parse_dur(tmp);
			s.new_beat = C.BLEN * nd[0] / nd[1]
		}
		c = text[tmp.index]
		while (c == ' ')
			c = text[++tmp.index]
	}

	/* string after */
	if (c == '"') {
		tmp.index++;
		i = text.indexOf('"', tmp.index + 1)
		if (i < 0) {
			syntax(1, "Unterminated string in Q:")
			return
		}
		s.tempo_str2 = text.slice(tmp.index, i)
	}

	if (parse.state != 3) {
		if (parse.state == 1) {			// tune header
			info.Q = text;
			glovar.tempo = s
			return
		}
		goto_tune()
	}
	if (curvoice.v == par_sy.top_voice) {	/* tempo only for first voice */
		sym_link(s)
		if (glovar.tempo && curvoice.time == 0)
			glovar.tempo.del = true
	}
}

// treat the information fields which may embedded
function do_info(info_type, text) {
	var s, d1, d2, a, vid

	switch (info_type) {

	// info fields in any state
	case 'I':
		do_pscom(text)
		break
	case 'L':
//fixme: ??
		if (parse.state == 2)
			goto_tune();
		a = text.match(/^1\/(\d+)(=(\d+)\/(\d+))?$/)
		if (a) {
			d1 = Number(a[1])
			if (!d1 || (d1 & (d1 - 1)) != 0)
				break
			d1 = C.BLEN / d1
			if (a[2]) {
				d2 = Number(a[4])
				if (!d2 || (d2 & (d2 - 1)) != 0) {
					d2 = 0
					break
				}
				d2 = Number(a[3]) / d2 * C.BLEN
			} else {
				d2 = d1
			}
		} else if (text == "auto") {
			d1 = d2 = -1
		}
		if (!d2) {
			syntax(1, "Bad L: value")
			break
		}
		if (parse.state < 2) {
			glovar.ulen = d1
		} else {
			curvoice.ulen = d1;
			curvoice.dur_fact = d2 / d1
		}
		break
	case 'M':
		new_meter(text)
		break
	case 'U':
		set_user(text)
		break

	// fields in tune header or tune body
	case 'P':
		if (parse.state == 0)
			break
		if (parse.state == 1) {
			info.P = text
			break
		}
		if (parse.state == 2)
			goto_tune()
		if (cfmt.writefields.indexOf(info_type) < 0)
			break
		s = {
			type: C.PART,
			text: text,
			dur: 0
		}

		/*
		 * If not in the main voice, then,
		 * if the voices are synchronized and no P: yet in the main voice,
		 * the misplaced P: goes into the main voice.
		 */
		var p_voice = voice_tb[par_sy.top_voice]
		if (curvoice.v != p_voice.v) {
			if (curvoice.time != p_voice.time)
				break
			if (p_voice.last_sym && p_voice.last_sym.type == C.PART)
				break		// already a P:
			var voice_sav = curvoice;
			curvoice = p_voice;
			sym_link(s);
			curvoice = voice_sav
		} else {
			sym_link(s)
		}
		break
	case 'Q':
		if (parse.state == 0)
			break
		new_tempo(text)
		break
	case 'V':
		get_voice(text)
		break

	// key signature at end of tune header on in tune body
	case 'K':
		if (parse.state == 0)
			break
		get_key(text)
		break

	// info in any state
	case 'N':
	case 'R':
		if (!info[info_type])
			info[info_type] = text
		else
			info[info_type] += '\n' + text
		break
	case 'r':
		if (!user.keep_remark
		 || parse.state != 3)
			break
		s = {
			type: C.REMARK,
			text: text,
			dur: 0
		}
		sym_link(s)
		break
	default:
		syntax(0, "'$1:' line ignored", info_type)
		break
	}
}

// music line parsing functions

/* -- adjust the duration and time of symbols in a measure when L:auto -- */
function adjust_dur(s) {
	var s2, time, auto_time, i, res;

	/* search the start of the measure */
	s2 = curvoice.last_sym
	if (!s2)
		return;

	/* the bar time is correct if there are multi-rests */
	if (s2.type == C.MREST
	 || s2.type == C.BAR)			/* in second voice */
		return
	while (s2.type != C.BAR && s2.prev)
		s2 = s2.prev;
	time = s2.time;
	auto_time = curvoice.time - time

	/* remove the invisible rest at start of tune */
	if (time == 0) {
		while (s2 && !s2.dur)
			s2 = s2.next
		if (s2 && s2.type == C.REST
		 && s2.invis) {
			time += s2.dur * curvoice.wmeasure / auto_time
			if (s2.prev)
				s2.prev.next = s2.next
			else
				curvoice.sym = s2.next
			if (s2.next)
				s2.next.prev = s2.prev;
			s2 = s2.next
		}
	}
	if (curvoice.wmeasure == auto_time)
		return				/* already good duration */

	for ( ; s2; s2 = s2.next) {
		s2.time = time
		if (!s2.dur || s2.grace)
			continue
		s2.dur = s2.dur * curvoice.wmeasure / auto_time;
		s2.dur_orig = s2.dur_orig * curvoice.wmeasure / auto_time;
		time += s2.dur
		if (s2.type != C.NOTE && s2.type != C.REST)
			continue
		for (i = 0; i <= s2.nhd; i++)
			s2.notes[i].dur = s2.notes[i].dur
					 * curvoice.wmeasure / auto_time;
		res = identify_note(s2, s2.dur_orig);
		s2.head = res[0];
		s2.dots = res[1];
		s2.nflags = res[2]
		if (s2.nflags <= -2)
			s2.stemless = true
		else
			delete s2.stemless
	}
	curvoice.time = s.time = time
}

/* -- parse a bar -- */
function new_bar() {
	var	s2, c, bar_type,
		line = parse.line,
		s = {
			type: C.BAR,
			fname: parse.fname,
			istart: parse.bol + line.index,
			dur: 0,
			multi: 0		// needed for decorations
		}

	if (vover && vover.bar)			// end of voice overlay
		get_vover('|')
	if (glovar.new_nbar) {			// %%setbarnb
		s.bar_num = glovar.new_nbar;
		glovar.new_nbar = 0
	}
	bar_type = line.char()
	while (1) {
		c = line.next_char()
		switch (c) {
		case '|':
		case '[':
		case ']':
		case ':':
			bar_type += c
			continue
		}
		break
	}
	if (bar_type[0] == ':') {
		if (bar_type.length == 1) {	// ":" alone
			bar_type = '|';
			s.bar_dotted = true
		} else {
			s.rbstop = 2		// right repeat with end
		}
	}

	// set the guitar chord and the decorations
	if (a_gch)
		gch_build(s)
	if (a_dcn) {
		deco_cnv(a_dcn, s);
		a_dcn = null
	}

	/* if the last element is '[', it may start
	 * a chord or an embedded header */
	switch (bar_type.slice(-1)) {
	case '[':
		if (/[0-9" ]/.test(c))		// "
			break
		bar_type = bar_type.slice(0, -1);
		line.index--;
		c = '['
		break
	case ':':				// left repeat
		s.rbstop = 2			// with bracket end
		break
	}

	// check if repeat bar
	if (c > '0' && c <= '9') {
		if (bar_type.slice(-1) == '[')
			bar_type = bar_type.slice(0, -1);
		s.text = c
		while (1) {
			c = line.next_char()
			if ("0123456789,.-".indexOf(c) < 0)
				break
			s.text += c
		}
		s.rbstop = 2;
		s.rbstart = 2
	} else if (c == '"' && bar_type.slice(-1) == '[') {
		bar_type = bar_type.slice(0, -1);
		s.text = ""
		while (1) {
			c = line.next_char()
			if (!c) {
				syntax(1, "No end of repeat string")
				return
			}
			if (c == '"') {
				line.index++
				break
			}
			if (c == '\\') {
				s.text += c;
				c = line.next_char()
			}
			s.text += c
		}
		s.text = cnv_escape(s.text);
		s.rbstop = 2;
		s.rbstart = 2
	}

	// ']' as the first character indicates a repeat bar stop
	if (bar_type[0] == ']') {
		s.rbstop = 2			// with end
		if (bar_type.length != 1)
			bar_type = bar_type.slice(1)
		else
			s.invis = true
	}

	s.iend = parse.bol + line.index

	if (s.rbstart
	 && curvoice.norepbra
	 && !curvoice.second)
		s.norepbra = true

	if (curvoice.ulen < 0)			// L:auto
		adjust_dur(s);

	s2 = curvoice.last_sym
	if (s2 && s2.type == C.SPACE) {
		s2.time--		// keep the space at the right place
	} else if (s2 && s2.type == C.BAR) {
//fixme: why these next lines?
//		&& !s2.a_gch && !s2.a_dd
//		&& !s.a_gch && !s.a_dd) {

		/* remove the invisible repeat bars when no shift is needed */
		if (bar_type == "["
		 && !s2.text
		 && (curvoice.st == 0
		  || (par_sy.staves[curvoice.st - 1].flags & STOP_BAR)
		  || s.norepbra)) {
			if (s.text)
				s2.text = s.text
			if (s.a_gch)
				s2.a_gch = s.a_gch
			if (s.norepbra)
				s2.norepbra = s.norepbra
			if (s.rbstart)
				s2.rbstart = s.rbstart
			if (s.rbstop)
				s2.rbstop = s.rbstop
//--fixme: pb when on next line and empty staff above
			return
		}

		/* merge back-to-back repeat bars */
		if (bar_type == "|:") {
			if (s2.bar_type == ":|") {
				s2.bar_type = "::";
				s2.rbstop = 2
				return
			}
			if (s2.bar_type == "||") {
				s2.bar_type = "||:";
				s2.rbstop = 2
				return
			}
		}
	}

	/* set some flags */
	switch (bar_type) {
	case "[":
		s.rbstop = 2
	case "[]":
	case "[|]":
		s.invis = true;
		bar_type = "[]"
		break
	case ":|:":
	case ":||:":
		bar_type = "::"
		break
	case "||":
		if (!cfmt.rbdbstop)
			break
	case "[|":
	case "|]":
		s.rbstop = 2
		break
	}
	s.bar_type = bar_type
	if (!curvoice.lyric_restart)
		curvoice.lyric_restart = s
	if (!curvoice.sym_restart)
		curvoice.sym_restart = s

	/* the bar must appear before a key signature */
	if (s2 && s2.type == C.KEY
	 && (!s2.prev || s2.prev.type != C.BAR)) {
		curvoice.last_sym = s2.prev
		if (!s2.prev)
			curvoice.sym = s2.prev;	// null
		sym_link(s);
		s.next = s2;
		s2.prev = s;
		curvoice.last_sym = s2
	} else {
		sym_link(s)
	}
	s.st = curvoice.st			/* original staff */

	/* if repeat bar and shift, add a repeat bar */
	if (s.rbstart
	 && !curvoice.norepbra
	 && curvoice.st > 0
	 && !(par_sy.staves[curvoice.st - 1].flags & STOP_BAR)) {
		s2 = {
			type: C.BAR,
			fname: s.fname,
			istart: s.istart,
			iend: s.iend,
			bar_type: "[",
			multi: 0,
			invis: true,
			text: s.text,
			rbstart: 2
		}
		sym_link(s2);
		s2.st = curvoice.st
		delete s.text;
		s.rbstart = 0
	}
}

// parse %%staves / %%score
// return an array of [vid, flags] / null
function parse_staves(p) {
	var	v, vid,
		a_vf = [],
		err = false,
		flags = 0,
		brace = 0,
		bracket = 0,
		parenth = 0,
		flags_st = 0,
		i = 0

	/* parse the voices */
	while (i < p.length) {
		switch (p[i]) {
		case ' ':
		case '\t':
			break
		case '[':
			if (parenth || brace + bracket >= 2) {
				syntax(1, errs.misplaced, '[');
				err = true
				break
			}
			flags |= brace + bracket == 0 ? OPEN_BRACKET : OPEN_BRACKET2;
			bracket++;
			flags_st <<= 8;
			flags_st |= OPEN_BRACKET
			break
		case '{':
			if (parenth || brace || bracket >= 2) {
				syntax(1, errs.misplaced, '{');
				err = true
				break
			}
			flags |= !bracket ? OPEN_BRACE : OPEN_BRACE2;
			brace++;
			flags_st <<= 8;
			flags_st |= OPEN_BRACE
			break
		case '(':
			if (parenth) {
				syntax(1, errs.misplaced, '(');
				err = true
				break
			}
			flags |= OPEN_PARENTH;
			parenth++;
			flags_st <<= 8;
			flags_st |= OPEN_PARENTH
			break
		case '*':
			if (brace && !parenth && !(flags & (OPEN_BRACE | OPEN_BRACE2)))
				flags |= FL_VOICE
			break
		case '+':
			flags |= MASTER_VOICE
			break
		default:
			if (!/\w/.test(p[i])) {
				syntax(1, "Bad voice ID in %%staves");
				err = true
				break
			}

			/* get / create the voice in the voice table */
			vid = ""
			while (i < p.length) {
				if (" \t()[]{}|*".indexOf(p[i]) >= 0)
					break
				vid += p[i++]
			}
			for ( ; i < p.length; i++) {
				switch (p[i]) {
				case ' ':
				case '\t':
					continue
				case ']':
					if (!(flags_st & OPEN_BRACKET)) {
						syntax(1, errs.misplaced, ']');
						err = true
						break
					}
					bracket--;
					flags |= brace + bracket == 0 ?
							CLOSE_BRACKET :
							CLOSE_BRACKET2;
					flags_st >>= 8
					continue
				case '}':
					if (!(flags_st & OPEN_BRACE)) {
						syntax(1, errs.misplaced, '}');
						err = true
						break
					}
					brace--;
					flags |= !bracket ?
							CLOSE_BRACE :
							CLOSE_BRACE2;
					flags &= ~FL_VOICE;
					flags_st >>= 8
					continue
				case ')':
					if (!(flags_st & OPEN_PARENTH)) {
						syntax(1, errs.misplaced, ')');
						err = true
						break
					}
					parenth--;
					flags |= CLOSE_PARENTH;
					flags_st >>= 8
					continue
				case '|':
					flags |= STOP_BAR
					continue
				}
				break
			}
			a_vf.push([vid, flags]);
			flags = 0
			continue
		}
		i++
	}
	if (flags_st != 0) {
		syntax(1, "'}', ')' or ']' missing in %%staves");
		err = true
	}
	if (err || a_vf.length == 0)
		return //null
	return a_vf
}

// split an info string
function info_split(text) {
	if (!text)
		return []
    var	a = text.match(/(".+?"|.+?)(\s+|=|$)/g)
	if (!a) {
		syntax(1, "Unterminated string")
		return []
	}
	for (var i = 0; i < a.length; i++)
		a[i] = a[i].trim()
	return a
}

/* -- get head type, dots, flags of note/rest for a duration -- */
function identify_note(s, dur) {
	var head, dots, flags

	if (dur % 12 != 0)
		syntax(1, "Invalid note duration $1", dur);
	dur /= 12			/* see C.BLEN for values */
	if (dur == 0)
		syntax(1, "Note too short")
	for (flags = 5; dur != 0; dur >>= 1, flags--) {
		if (dur & 1)
			break
	}
	dur >>= 1
	switch (dur) {
	case 0: dots = 0; break
	case 1: dots = 1; break
	case 3: dots = 2; break
//	case 7: dots = 3; break
	default:
		dots = 3
		break
	}
	flags -= dots
//--fixme: is 'head' useful?
	if (flags >= 0) {
		head = C.FULL
	} else switch (flags) {
	default:
		syntax(1, "Note too long");
		flags = -4
		/* fall thru */
	case -4:
		head = C.SQUARE
		break
	case -3:
		head = cfmt.squarebreve ? C.SQUARE : C.OVALBARS
		break
	case -2:
		head = C.OVAL
		break
	case -1:
		head = C.EMPTY
		break
	}
	return [head, dots, flags]
}

// parse a duration and return [numerator, denominator]
// 'line' is not always 'parse.line'
var reg_dur = /(\d*)(\/*)(\d*)/g		/* (stop comment) */

function parse_dur(line) {
	var res, num, den;

	reg_dur.lastIndex = line.index;
	res = reg_dur.exec(line.buffer)
	if (!res[0])
		return [1, 1];
	num = res[1] || 1;
	den = res[3] || 1
	if (!res[3])
		den *= 1 << res[2].length;
	line.index = reg_dur.lastIndex
	return [num, den]
}

// parse the note accidental and pitch
function parse_acc_pit(line) {
	var	note, acc, micro_n, micro_d, pit, nd,
		c = line.char()

	// optional accidental
	switch (c) {
	case '^':
		c = line.next_char()
		if (c == '^') {
			acc = 2;
			c = line.next_char()
		} else {
			acc = 1
		}
		break
	case '=':
		acc = 3;
		c = line.next_char()
		break
	case '_':
		c = line.next_char()
		if (c == '_') {
			acc = -2;
			c = line.next_char()
		} else {
			acc = -1
		}
		break
	}

	/* look for microtone value */
	if (acc && acc != 3 && (c >= '1' && c <= '9')
	 || c == '/') {				// compatibility
		nd = parse_dur(line);
		micro_n = nd[0];
		micro_d = nd[1]
		if (micro_d == 1)
			micro_d = curvoice ? curvoice.uscale : 1
		else
			micro_d *= 2;	// 1/2 tone fraction -> tone fraction
		c = line.char()
	}

	/* get the pitch */
	pit = ntb.indexOf(c) + 16;
	c = line.next_char()
	if (pit < 16) {
		syntax(1, "'$1' is not a note", line.buffer[line.index - 1])
		return //undefined
	}

	// octave
	while (c == "'") {
		pit += 7;
		c = line.next_char()
	}
	while (c == ',') {
		pit -= 7;
		c = line.next_char()
	}
	note = {
		pit: pit,
		apit: pit,
		shhd: 0,
		shac: 0,
		ti1: 0
	}
	if (acc) {
		note.acc = acc
		if (micro_n) {
			note.micro_n = micro_n;
			note.micro_d = micro_d
		}
	}
	return note
}

/* set the mapping of a note */
function set_map(note) {
	var	bn, an, nn, i,
		map = maps[curvoice.map]	// never null

	bn = 'abcdefg'[(note.pit + 77) % 7]
	if (note.acc)
		an = ['__', '_', '', '^', '^^', '='][note.acc + 2]
	else
		an = ''
//fixme: treat microtone
	nn = an + bn
	for (i = note.pit; i >= 28; i -= 7)
		nn += "'"
	for (i = note.pit; i < 21; i += 7)
		nn += ",";

	if (!map[nn]) {
		nn = 'octave,' + an + bn		// octave
		if (!map[nn]) {
			nn = 'key,' +			// 'key,'
				'abcdefg'[(note.pit + 77 -
						curvoice.ckey.k_delta) % 7]
			if (!map[nn]) {
				nn = 'all'		// 'all'
				if (!map[nn])
					return
			}
		}
	}
	note.map = map[nn]
	if (note.map[1]) {
		note.apit = note.pit = note.map[1].pit;	// print
		note.acc = note.map[1].acc
	}
}

/* -- parse note or rest with pitch and length -- */
// 'line' is not always 'parse.line'
function parse_basic_note(line, ulen) {
	var	nd,
		note = parse_acc_pit(line)

	if (!note)
		return //null

	// duration
	if (line.char() == '0') {		// compatibility
		parse.stemless = true;
		line.index++
	}
	nd = parse_dur(line);
	note.dur = ulen * nd[0] / nd[1]
	return note
}

function parse_vpos() {
	var	c,
		line = parse.line,
		ti1 = 0

	if (line.buffer[line.index - 1] == '.' && !a_dcn)
		ti1 = C.SL_DOTTED
	switch (line.next_char()) {
	case "'":
		line.index++
		return ti1 + C.SL_ABOVE
	case ",":
		line.index++
		return ti1 + C.SL_BELOW
	}
	return ti1 + C.SL_AUTO
}

var	cde2fcg = new Int8Array([0, 2, 4, -1, 1, 3, 5]),
	cgd2cde = new Int8Array([0, 4, 1, 5, 2, 6, 3]),
	acc2 = new Int8Array([-2, -1, 3, 1, 2])

/* transpose a note / chord */
function note_transp(s) {
	var	i, j, n, d, a, acc, i1, i3, i4, note,
		m = s.nhd,
		sf_old = curvoice.okey.k_sf,
		i2 = curvoice.ckey.k_sf - sf_old,
		dp = cgd2cde[(i2 + 4 * 7) % 7],
		t = curvoice.vtransp

	if (t < 0 && dp != 0)
		dp -= 7;
	dp += ((t / 3 / 12) | 0) * 7
	for (i = 0; i <= m; i++) {
		note = s.notes[i];

		// pitch
		n = note.pit;
		note.pit += dp;
		note.apit = note.pit;

		// accidental
		i1 = cde2fcg[(n + 5 + 16 * 7) % 7];	/* fcgdaeb */
		a = note.acc
		if (!a) {
			if (!curvoice.okey.a_acc) {
				if (sf_old > 0) {
					if (i1 < sf_old - 1)
						a = 1	// sharp
				} else if (sf_old < 0) {
					if (i1 >= sf_old + 6)
						a = -1	// flat
				}
			} else {
				for (j = 0; j < curvoice.okey.a_acc.length; j++) {
					acc = curvoice.okey.a_acc[j]
					if ((n + 16 * 7 - acc.pit) % 7 == 0) {
						a = acc.acc
						break
					}
				}
			}
		}
		i3 = i1 + i2
		if (a && a != 3)				// ! natural
			i3 += a * 7;

		i1 = ((((i3 + 1 + 21) / 7) | 0) + 2 - 3 + 32 * 5) % 5;
		a = acc2[i1]
		if (note.acc) {
			;
		} else if (curvoice.ckey.k_none) {
			if (a == 3		// natural
			 || acc_same_pitch(note.pit))
				continue
		} else if (curvoice.ckey.a_acc) {	/* acc list */
			i4 = cgd2cde[(i3 + 16 * 7) % 7]
			for (j = 0; j < curvoice.ckey.a_acc.length; j++) {
				if ((i4 + 16 * 7 - curvoice.ckey.a_acc[j].pits) % 7
							== 0)
					break
			}
			if (j < curvoice.ckey.a_acc.length)
				continue
		} else {
			continue
		}
		i1 = note.acc;
		d = note.micro_d
		if (d				/* microtone */
		 && i1 != a) {			/* different accidental type */
			n = note.micro_n
//fixme: double sharps/flats ?*/
//fixme: does not work in all cases (tied notes, previous accidental)
			switch (a) {
			case 3:			// natural
				if (n > d / 2) {
					n -= d / 2;
					note.micro_n = n;
					a = i1
				} else {
					a = -i1
				}
				break
			case 2:			// double sharp
				if (n > d / 2) {
					note.pit += 1;
					note.apit = note.pit;
					n -= d / 2
				} else {
					n += d / 2
				}
				a = i1;
				note.micro_n = n
				break
			case -2:		// double flat
				if (n >= d / 2) {
					note.pit -= 1;
					note.apit = note.pit;
					n -= d / 2
				} else {
					n += d / 2
				}
				a = i1;
				note.micro_n = n
				break
			}
		}
		note.acc = a
	}
}

/* sort the notes of the chord by pitch (lowest first) */
function sort_pitch(s) {
	s.notes = s.notes.sort(function(n1, n2) {
			return n1.pit - n2.pit
		})
}
function new_note(grace, tp_fact) {
	var	note, s, in_chord, c, dcn, type,
		i, n, s2, nd, res, num, dur,
		sl1 = 0,
		line = parse.line,
		a_dcn_sav = a_dcn;	// save parsed decoration names

	a_dcn = null;
	parse.stemless = false;
	s = {
		type: C.NOTE,
		fname: parse.fname,
		stem: 0,
		multi: 0,
		nhd: 0,
		xmx: 0
	}
	s.istart = parse.bol + line.index

	if (curvoice.color)
		s.color = curvoice.color

	if (grace) {
		s.grace = true
	} else {
		if (a_gch)
			gch_build(s)
		if (parse.repeat_n) {
			s.repeat_n = parse.repeat_n;
			s.repeat_k = parse.repeat_k;
			parse.repeat_n = 0
		}
	}
	c = line.char()
	switch (c) {
	case 'X':
		s.invis = true
	case 'Z':
		s.type = C.MREST;
		c = line.next_char()
		s.nmes = (c > '0' && c <= '9') ? line.get_int() : 1;
		s.dur = curvoice.wmeasure * s.nmes

		// ignore if in second voice
		if (curvoice.second) {
			curvoice.time += s.dur
			return //null
		}
		break
	case 'y':
		s.type = C.SPACE;
		s.invis = true;
		s.dur = 0;
		c = line.next_char()
		if (c >= '0' && c <= '9')
			s.width = line.get_int()
		else
			s.width = 10
		break
	case 'x':
		s.invis = true
	case 'z':
		s.type = C.REST;
		line.index++;
		nd = parse_dur(line);
		s.dur_orig = ((curvoice.ulen < 0) ?
					15120 :	// 2*2*2*2*3*3*3*5*7
					curvoice.ulen) * nd[0] / nd[1];
		s.dur = s.dur_orig * curvoice.dur_fact;
		s.notes = [{
			pit: 18,
			dur: s.dur_orig
		}]
		break
	case '[':			// chord
		in_chord = true;
		c = line.next_char()
		// fall thru
	default:			// accidental, chord, note
		if (curvoice.uscale)
			s.uscale = curvoice.uscale;
		s.notes = []

		// loop on the chord
		while (1) {

			// when in chord, get the slurs and decorations
			if (in_chord) {
				while (1) {
					if (!c)
						break
					i = c.charCodeAt(0);
					if (i >= 128) {
						syntax(1, errs.not_ascii)
						return //null
					}
					type = char_tb[i]
					switch (type[0]) {
					case '(':
						sl1 <<= 4;
						sl1 += parse_vpos();
						c = line.char()
						continue
					case '!':
						if (!a_dcn)
							a_dcn = []
						if (type.length > 1) {
							a_dcn.push(type.slice(1, -1))
						} else {
							dcn = ""
							while (1) {
								c = line.next_char()
								if (!c) {
									syntax(1, "No end of decoration")
									return //null
								}
								if (c == '!')
									break
								dcn += c
							}
							a_dcn.push(dcn)
						}
						c = line.next_char()
						continue
					}
					break
				}
			}
			note = parse_basic_note(line,
					s.grace ? C.BLEN / 4 :
					curvoice.ulen < 0 ?
						15120 :	// 2*2*2*2*3*3*3*5*7
						curvoice.ulen)
			if (!note)
				return //null

			// transpose
			if (curvoice.octave)
				note.apit = note.pit += curvoice.octave * 7
			if (curvoice.ottava)
				note.pit += curvoice.ottava
			if (sl1) {
				note.sl1 = sl1
				if (s.sl1)
					s.sl1++
				else
					s.sl1 = 1;
				sl1 = 0
			}
			if (a_dcn) {
				note.a_dcn = a_dcn;
				a_dcn = null
			}
			s.notes.push(note)
			if (!in_chord)
				break

			// in chord: get the ending slurs and the ties
			c = line.char()
			while (1) {
				switch (c) {
				case ')':
					if (note.sl2)
						note.sl2++
					else
						note.sl2 = 1
					if (s.sl2)
						s.sl2++
					else
						s.sl2 = 1;
					c = line.next_char()
					continue
				case '-':
					note.ti1 = parse_vpos();
					s.ti1 = true;
					c = line.char()
					continue
				case '.':
					c = line.next_char()
					if (c != '-') {
						syntax(1, "Misplaced dot")
						break
					}
					continue
				}
				break
			}
			if (c == ']') {
				line.index++;

				// adjust the chord duration
				nd = parse_dur(line);
				s.nhd = s.notes.length - 1
				for (i = 0; i <= s.nhd ; i++) {
					note = s.notes[i];
					note.dur = note.dur * nd[0] / nd[1]
				}
				break
			}
		}

		// the duration of the chord is the duration of the 1st note
		s.dur_orig = s.notes[0].dur;
		s.dur = s.notes[0].dur * curvoice.dur_fact
	}
	if (s.grace && s.type != C.NOTE) {
		syntax(1, "Not a note in grace note sequence")
		return //null
	}

	if (s.notes) {				// if note or rest
		if (!s.grace) {
			switch (curvoice.pos.stm) {
			case C.SL_ABOVE: s.stem = 1; break
			case C.SL_BELOW: s.stem = -1; break
			case C.SL_HIDDEN: s.stemless = true; break
			}

			// adjust the symbol duration
			s.dur *= tp_fact;
			num = curvoice.brk_rhythm
			if (num) {
				curvoice.brk_rhythm = 0;
				s2 = curvoice.last_note
				if (num > 0) {
					n = num * 2 - 1;
					s.dur = s.dur * n / num;
					s.dur_orig = s.dur_orig * n / num
					for (i = 0; i <= s.nhd; i++)
						s.notes[i].dur =
							s.notes[i].dur * n / num;
					s2.dur /= num;
					s2.dur_orig /= num
					for (i = 0; i <= s2.nhd; i++)
						s2.notes[i].dur /= num
				} else {
					num = -num;
					n = num * 2 - 1;
					s.dur /= num;
					s.dur_orig /= num
					for (i = 0; i <= s.nhd; i++)
						s.notes[i].dur /= num;
					s2.dur = s2.dur * n / num;
					s2.dur_orig = s2.dur_orig * n / num
					for (i = 0; i <= s2.nhd; i++)
						s2.notes[i].dur =
							s2.notes[i].dur * n / num
				}
				curvoice.time = s2.time + s2.dur;
				res = identify_note(s2, s2.dur_orig);
				s2.head = res[0];
				s2.dots = res[1];
				s2.nflags = res[2]
				if (s2.nflags <= -2)
					s2.stemless = true
				else
					delete s2.stemless

				// adjust the time of the grace notes, bars...
				for (s2 = s2.next; s2; s2 = s2.next)
					s2.time = curvoice.time
			}
		} else {		/* grace note - adjust its duration */
			var div = curvoice.key.k_bagpipe ? 8 : 4

			for (i = 0; i <= s.nhd; i++)
				s.notes[i].dur /= div;
			s.dur /= div;
			s.dur_orig /= div
			if (grace.stem)
				s.stem = grace.stem
		}

		// set the symbol parameters
		if (s.type == C.NOTE) {
			res = identify_note(s, s.dur_orig);
			s.head = res[0];
			s.dots = res[1];
			s.nflags = res[2]
			if (s.nflags <= -2)
				s.stemless = true
		} else {					// rest

			/* change the figure of whole measure rests */
//--fixme: does not work in sample.abc because broken rhythm on measure bar
			dur = s.dur_orig
			if (dur == curvoice.wmeasure) {
				if (dur < C.BLEN * 2)
					dur = C.BLEN
				else if (dur < C.BLEN * 4)
					dur = C.BLEN * 2
				else
					dur = C.BLEN * 4
			}
			res = identify_note(s, dur);
			s.head = res[0];
			s.dots = res[1];
			s.nflags = res[2]
		}
		curvoice.last_note = s
	}

	sym_link(s)

	if (s.type == C.NOTE) {
		if (curvoice.vtransp)
			note_transp(s)
		if (curvoice.map
		 && maps[curvoice.map]) {
			for (i = 0; i <= s.nhd; i++)
				set_map(s.notes[i])
		}
	}

	if (cfmt.shiftunison)
		s.shiftunison = cfmt.shiftunison
	if (!grace) {
		if (!curvoice.lyric_restart)
			curvoice.lyric_restart = s
		if (!curvoice.sym_restart)
			curvoice.sym_restart = s
	}

	if (a_dcn_sav)
		deco_cnv(a_dcn_sav, s, s.prev)
	if (parse.stemless)
		s.stemless = true
	s.iend = parse.bol + line.index
	return s
}

// characters in the music line (ASCII only)
var nil = ["0"]
var char_tb = [
	nil, nil, nil, nil,		/* 00 - .. */
	nil, nil, nil, nil,
	nil, " ", "\n", nil,		/* . \t \n . */
	nil, nil, nil, nil,
	nil, nil, nil, nil,
	nil, nil, nil, nil,
	nil, nil, nil, nil,
	nil, nil, nil, nil,		/* .. - 1f */
	" ", "!", '"', "i",		/* (sp) ! " # */
	"\n", nil, "&", nil,		/* $ % & ' */
	"(", ")", "i", nil,		/* ( ) * + */
	nil, "-", "!dot!", nil,		/* , - . / */
	nil, nil, nil, nil, 		/* 0 1 2 3 */
	nil, nil, nil, nil, 		/* 4 5 6 7 */
	nil, nil, "|", "i",		/* 8 9 : ; */
	"<", "n", "<", "i",		/* < = > ? */
	"i", "n", "n", "n",		/* @ A B C */
	"n", "n", "n", "n", 		/* D E F G */
	"!fermata!", "d", "d", "d",	/* H I J K */
	"!emphasis!", "!lowermordent!",
		"d", "!coda!",		/* L M N O */
	"!uppermordent!", "d",
		"d", "!segno!",		/* P Q R S */
	"!trill!", "d", "d", "d",	/* T U V W */
	"n", "d", "n", "[",		/* X Y Z [ */
	"\\","|", "n", "n",		/* \ ] ^ _ */
	"i", "n", "n", "n",	 	/* ` a b c */
	"n", "n", "n", "n",	 	/* d e f g */
	"d", "d", "d", "d",		/* h i j k */
	"d", "d", "d", "d",		/* l m n o */
	"d", "d", "d", "d",		/* p q r s */
	"d", "!upbow!",
		"!downbow!", "d",	/* t u v w */
	"n", "n", "n", "{",		/* x y z { */
	"|", "}", "!gmark!", nil,	/* | } ~ (del) */
]

function parse_music_line() {
	var	grace, last_note_sav, a_dcn_sav, no_eol, s,
		tp_a = [], tp,
		tpn = -1,
		tp_fact = 1,
		slur_start = 0,
		line = parse.line

	// check if a transposing macro matches a source sequence
	// if yes return the base note
	function check_mac(m) {
	    var	i, j, b

		for (i = 1, j = line.index + 1; i < m.length; i++, j++) {
			if (m[i] == line.buffer[j])
				continue
			if (m[i] != 'n')		// search the base note
				return //null
			b = ntb.indexOf(line.buffer[j])
			if (b < 0)
				return //null
			while (line.buffer[j + 1] == "'") {
				b += 7;
				j++
			}
			while (line.buffer[j + 1] == ',') {
				b -= 7;
				j++
			}
		}
		line.index = j
		return b
	}

	// expand a transposing macro
	function expand(m, b) {
	    var	c, d,
		r = "",				// result
		n = m.length

		for (i = 0; i < n; i++) {
			c = m[i]
			if (c >= 'h' && c <= 'z') {
				d = b + c.charCodeAt(0) - 'n'.charCodeAt(0)
				c = ""
				while (d < 0) {
					d += 7;
					c += ','
				}
				while (d > 14) {
					d -= 7;
					c += "'"
				}
				r += ntb[d] + c
			} else {
				r += c
			}
		}
		return r
	} // expand()

	// parse a macro
	function parse_mac(m, b) {
	    var	seq,
		line_sav = line,
		istart_sav = parse.istart;

		parse.line = line = new scanBuf();
		parse.istart += line_sav.index;
		line.buffer = b ? expand(m, b) : m;
		parse_seq(true);
		parse.line = line = line_sav;
		parse.istart = istart_sav
	}

	// parse a music sequence
	function parse_seq(in_mac) {
	    var	c, idx, type, k, s, dcn, i, n, text

		while (1) {
			c = line.char()
			if (!c)
				break

			// special case for '.' (dot)
			if (c == '.') {
				switch (line.buffer[line.index + 1]) {
				case '(':
				case '-':
				case '|':
					c = line.next_char()
					break
				}
			}

			idx = c.charCodeAt(0);
			if (idx >= 128) {
				syntax(1, errs.not_ascii);
				line.index++
				break
			}

			// check if start of a macro
			if (!in_mac && maci[idx]) {
				n = 0
				for (k in mac) {
					if (!mac.hasOwnProperty(k)
					 || k[0] != c)
						continue
					if (k.indexOf('n') < 0) {
						if (line.buffer.indexOf(k, line.index)
								!= line.index)
							continue
						line.index += k.length
					} else {
						n = check_mac(k)
						if (!n)
							continue
					}
					parse_mac(mac[k], n);
					n = 1
					break
				}
				if (n)
					continue
			}

			type = char_tb[idx]
			switch (type[0]) {
			case ' ':			// beam break
				s = curvoice.last_note
				if (s) {
					s.beam_end = true
					if (grace)
						grace.gr_shift = true
				}
				break
			case '\n':			// line break
				if (cfmt.barsperstaff)
					break
				if (par_sy.voices[curvoice.v].range == 0
				 && curvoice.last_sym)
					curvoice.last_sym.eoln = true
				break
			case '&':			// voice overlay
				if (grace) {
					syntax(1, errs.bad_char, c)
					break
				}
				c = line.next_char()
				if (c == ')') {
					get_vover(')')
					break
				}
				get_vover('&')
				continue
			case '(':			// slur start - tuplet - vover
				c = line.next_char()
				if (c > '0' && c <= '9') {	// tuplet
				    var	pplet = line.get_int(),
					qplet = qplet_tb[pplet],
					rplet = pplet,
					c = line.char()

					if (c == ':') {
						c = line.next_char()
						if (c > '0' && c <= '9') {
							qplet = line.get_int();
							c = line.char()
						}
						if (c == ':') {
							c = line.next_char()
							if (c > '0' && c <= '9') {
								rplet = line.get_int();
								c = line.char()
							} else {
								syntax(1, "Invalid 'r' in tuplet")
								continue
							}
						}
					}
					if (qplet == 0 || qplet == undefined)
						qplet = (curvoice.wmeasure % 9) == 0 ?
									3 : 2;
					tp = tp_a[++tpn]
					if (!tp)
						tp_a[tpn] = tp = {}
					tp.p = pplet;
					tp.q = qplet;
					tp.r = rplet;
					tp.f = cfmt.tuplets;
					tp.fact	= tp_fact * qplet / pplet;
					tp_fact = tp.fact
					continue
				}
				if (c == '&') {		// voice overlay start
					if (grace) {
						syntax(1, errs.bad_char, c)
						break
					}
					get_vover('(')
					break
				}
				slur_start <<= 4;
				line.index--;
				slur_start += parse_vpos()
				continue
			case ')':			// slur end
				if (curvoice.ignore)
					break
				s = curvoice.last_sym
				if (s) {
					switch (s.type) {
					case C.NOTE:
					case C.REST:
					case C.SPACE:
						break
					default:
						s = null
						break
					}
				}
				if (!s) {
					syntax(1, errs.bad_char, c)
					break
				}
				if (s.slur_end)
					s.slur_end++
				else
					s.slur_end = 1
				break
			case '!':			// start of decoration
				if (!a_dcn)
					a_dcn = []
				if (type.length > 1) {	// decoration letter
					dcn = type.slice(1, -1)
				} else {
					dcn = "";
					i = line.index		// in case no deco end
					while (1) {
						c = line.next_char()
						if (!c)
							break
						if (c == '!')
							break
						dcn += c
					}
					if (!c) {
						line.index = i;
						syntax(1, "No end of decoration")
						break
					}
				}
				if (ottava[dcn])
					set_ottava(dcn)
				a_dcn.push(dcn)
				break
			case '"':
				parse_gchord(type)
				break
			case '-':
			    var tie_pos = 0

				if (!curvoice.last_note
				 || curvoice.last_note.type != C.NOTE) {
					syntax(1, "No note before '-'")
					break
				}
				tie_pos = parse_vpos();
				s = curvoice.last_note
				for (i = 0; i <= s.nhd; i++) {
					if (!s.notes[i].ti1)
						s.notes[i].ti1 = tie_pos
					else if (s.nhd == 0)
						syntax(1, "Too many ties")
				}
				s.ti1 = true
				if (grace)
					grace.ti1 = true
				continue
			case '[':
			    var c_next = line.buffer[line.index + 1]

				if ('|[]: "'.indexOf(c_next) >= 0
				 || (c_next >= '1' && c_next <= '9')) {
					if (grace) {
						syntax(1, errs.bar_grace)
						break
					}
					new_bar()
					continue
				}
				if (line.buffer[line.index + 2] == ':') {
					i = line.buffer.indexOf(']', line.index + 1)
					if (i < 0) {
						syntax(1, "Lack of ']'")
						break
					}
					text = line.buffer.slice(line.index + 3, i).trim()

					parse.istart = parse.bol + line.index;
					parse.iend = parse.bol + ++i;
					line.index = 0;
					do_info(c_next, text);
					line.index = i
					continue
				}
				// fall thru ('[' is start of chord)
			case 'n':				// note/rest
				s = new_note(grace, tp_fact)
				if (!s)
					continue
				if (s.type == C.NOTE) {
					if (slur_start) {
						s.slur_start = slur_start;
						slur_start = 0
					}
				}
				if (grace) {
//fixme: tuplets in grace notes?
					if (tpn >= 0)
						s.in_tuplet = true
					continue
				}

				// set the tuplet values
				if (tpn >= 0 && s.notes) {
					s.in_tuplet = true
//fixme: only one nesting level
					if (tpn > 0) {
						if (tp_a[0].p) {
							s.tp0 = tp_a[0].p;
							s.tq0 = tp_a[0].q;
							s.tf = tp_a[0].f;
							tp_a[0].p = 0
						}
						tp_a[0].r--
						if (tp.p) {
							s.tp1 = tp.p;
							s.tq1 = tp.q;
							s.tf = tp.f;
							tp.p = 0
						}
					} else if (tp.p) {
						s.tp0 = tp.p;
						s.tq0 = tp.q;
						s.tf = tp.f;	// %%tuplets
						tp.p = 0
					}
					tp.r--
					if (tp.r == 0) {
						if (tpn-- == 0) {
							s.te0 = true;
							tp_fact = 1;
							curvoice.time = Math.round(curvoice.time);
							s.dur = curvoice.time - s.time
						} else {
							s.te1 = true;
							tp = tp_a[0]
							if (tp.r == 0) {
								tpn--;
								s.te0 = true;
								tp_fact = 1;
								curvoice.time = Math.round(curvoice.time);
								s.dur = curvoice.time - s.time
							} else {
								tp_fact = tp.fact
							}
						}
					}
				}
				continue
			case '<':				/* '<' and '>' */
				if (!curvoice.last_note) {
					syntax(1, "No note before '<'")
					break
				}
				if (grace) {
					syntax(1, "Cannot have a broken rhythm in grace notes")
					break
				}
				n = c == '<' ? 1 : -1
				while (c == '<' || c == '>') {
					n *= 2;
					c = line.next_char()
				}
				curvoice.brk_rhythm = n
				continue
			case 'i':				// ignore
				break
			case '{':
				if (grace) {
					syntax(1, "'{' in grace note")
					break
				}
				last_note_sav = curvoice.last_note;
				curvoice.last_note = null;
				a_dcn_sav = a_dcn;
				a_dcn = undefined;
				grace = {
					type: C.GRACE,
					fname: parse.fname,
					istart: parse.bol + line.index,
					dur: 0,
					multi: 0
				}
				switch (curvoice.pos.gst) {
				case C.SL_ABOVE: grace.stem = 1; break
				case C.SL_BELOW: grace.stem = -1; break
				case C.SL_HIDDEN: grace.stem = 2; break	/* opposite */
				}
				sym_link(grace);
				c = line.next_char()
				if (c == '/') {
					grace.sappo = true	// acciaccatura
					break
				}
				continue
			case '|':
				if (grace) {
					syntax(1, errs.bar_grace)
					break
				}
				c = line.buffer[line.index - 1];
				new_bar()
				if (c == '.')
					curvoice.last_sym.bar_dotted = true
				continue
			case '}':
				s = curvoice.last_note
				if (!grace || !s) {
					syntax(1, errs.bad_char, c)
					break
				}
				if (a_dcn)
					syntax(1, "Decoration ignored");
				s.gr_end = true;
				grace.extra = grace.next;
				grace.extra.prev = null;
				grace.next = null;
				curvoice.last_sym = grace;
				grace = null
				if (!s.prev			// if one grace note
				 && !curvoice.key.k_bagpipe) {
					for (i = 0; i <= s.nhd; i++)
						s.notes[i].dur *= 2;
					s.dur *= 2;
					s.dur_orig *= 2
					var res = identify_note(s, s.dur_orig);
					s.head = res[0];
					s.dots = res[1];
					s.nflags = res[2]
				}
				curvoice.last_note = last_note_sav;
				a_dcn = a_dcn_sav
				break
			case "\\":
				c = line.buffer[line.index + 1]
				if (!c) {
					no_eol = true
					break
				}
				// fall thru
			default:
				syntax(1, errs.bad_char, c)
				break
			}
			line.index++
		}
	} // parse_seq()

	if (parse.state != 3) {		// if not in tune body
		if (parse.state != 2)
			return
		goto_tune()
	}

	parse_seq()

	if (tpn >= 0) {
		syntax(1, "No end of tuplet")
		for (s = curvoice.last_note; s; s = s.prev) {
			if (s.tp1)
				s.tp1 = 0
			if (s.tp0) {
				s.tp0 = 0
				break
			}
		}
	}
	if (grace) {
		syntax(1, "No end of grace note sequence");
		curvoice.last_sym = grace.prev;
		curvoice.last_note = last_note_sav
		if (grace.prev)
			grace.prev.next = null
	}
	if (cfmt.breakoneoln && curvoice.last_note)
		curvoice.last_note.beam_end = true
	if (no_eol || cfmt.barsperstaff)
		return
	if (char_tb['\n'.charCodeAt(0)] == '\n'
	 && par_sy.voices[curvoice.v].range == 0
	 && curvoice.last_sym)
		curvoice.last_sym.eoln = true
//--fixme: cfmt.alignbars
}
// abc2svg - subs.js - text output
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

/* width of characters according to the encoding */
/* these are the widths for Times-Roman, extracted from the 'a2ps' package */

var cw_tb = new Float32Array([
	.000,.000,.000,.000,.000,.000,.000,.000,	// 00
	.000,.000,.000,.000,.000,.000,.000,.000,
	.000,.000,.000,.000,.000,.000,.000,.000,	// 10
	.000,.000,.000,.000,.000,.000,.000,.000,
	.250,.333,.408,.500,.500,.833,.778,.333,	// 20
	.333,.333,.500,.564,.250,.564,.250,.278,
	.500,.500,.500,.500,.500,.500,.500,.500,	// 30
	.500,.500,.278,.278,.564,.564,.564,.444,
	.921,.722,.667,.667,.722,.611,.556,.722,	// 40
	.722,.333,.389,.722,.611,.889,.722,.722,
	.556,.722,.667,.556,.611,.722,.722,.944,	// 50
	.722,.722,.611,.333,.278,.333,.469,.500,
	.333,.444,.500,.444,.500,.444,.333,.500,	// 60
	.500,.278,.278,.500,.278,.778,.500,.500,
	.500,.500,.333,.389,.278,.500,.500,.722,	// 70
	.500,.500,.444,.480,.200,.480,.541,.500
])

/* -- return the character width -- */
function cwid(c) {
	var i = c.charCodeAt(0)		// utf-16

	if (i >= 0x80) {		// if not ASCII
		if (i >= 0x300 && i < 0x370)
			return 0;	// combining diacritical mark
		i = 0x61		// 'a'
	}
	return cw_tb[i]
}

// estimate the width and height of a string
function strwh(str) {
    var	font = gene.curfont,
	swfac = font.swfac,
	h = font.size,
	w = 0,
	i, j, c,
	n = str.length

	for (i = 0; i < n; i++) {
		c = str[i]
		switch (c) {
		case '$':
			c = str[i + 1]
			if (c == '0') {
				font = gene.deffont
			} else if (c >= '1' && c <= '9') {
				font = get_font("u" + c)
			} else {
				c = '$'
				break
			}
			i++;
			swfac = font.swfac
			if (font.size > h)
				h = font.size
			continue
		case '&':
			j = str.indexOf(';', i)
			if (j > 0 && j - i < 10) {
				i = j;
				c = 'a'		// XML character reference
			}
			break
		}
		w += cwid(c) * swfac
	}
	gene.curfont = font
	return [w, h]
}

// set the default and current font
function set_font(xxx) {
	if (typeof xxx == "string")
		xxx = get_font(xxx);
	gene.curfont = gene.deffont = xxx
}

// output a string handling the font changes
function out_str(str) {
	var	n_font,
		o_font = gene.curfont,
		c_font = o_font;

	output += str.replace(/<|>|&.*?;|&|  |\$./g, function(c){
			switch (c[0]) {
			case '<': return "&lt;"
			case '>': return "&gt;"
			case '&':
				if (c == '&')
					 return "&amp;"
				return c
			case ' ':
				return '  '		// space + nbspace
			case '$':
				if (c[1] == '0') {
					n_font = gene.deffont;
					use_font(n_font)
				} else if (c[1] >= '1' && c[1] <= '9')
					n_font = get_font("u" + c[1])
				else
					return c
				c = ''
				if (n_font == c_font)
					return c
				if (c_font != o_font)
					c = "</tspan>";
				c_font = n_font
				if (c_font == o_font)
					return c
				return c + '<tspan\n\tclass="' +
						font_class(n_font) + '">'
			}
		})
	if (c_font != o_font) {
		output += "</tspan>";
		gene.curfont = c_font	// keep current font for next paragraph
	}
}

// output a string, handling the font changes
// the action is:
//	'c' align center
//	'r' align right
//	'\t' handle the tabulations - dx is the space between the fields
//	'j' justify - line_w is the line width
//	otherwise align left
function xy_str(x, y, str,
		 action,
		 line_w) {
    var	h = strwh(str)[1];
	y += h * .2;			// a bit upper for the descent
	output += '<text class="' + font_class(gene.curfont) + '" x="';
	out_sxsy(x, '" y="', y)
	switch (action) {
	case 'c':
		output += '" text-anchor="middle">'
		break
	case 'j':
		output += '" textLength="' + line_w.toFixed(2) + '">'
		break
	case 'r':
		output += '" text-anchor="end">'
		break
	default:
		output += '">'
		break
	}
	out_str(str);
	output += "</text>\n"
}

// output a string in a box
function xy_str_b(x, y, str) {
// not in the SVG documentation,
// but this works for almost all browsers but firefox
//	output += '<g style="outline: solid black;\
// outline-width: 1px">\n';
//	xy_str(x, y, str, action, line_w);
//	output += '</g>\n'
    var	wh = strwh(str);

	output += '<rect class="stroke" x="';
	out_sxsy(x - 2, '" y="', y + wh[1] + 1);
	output += '" width="' + (wh[0] + 4).toFixed(2) +
		'" height="' + (wh[1] + 3).toFixed(2) +
		'"/>\n';
	xy_str(x, y, str)
}

/* -- move trailing "The" to front, set to uppercase letters or add xref -- */
function trim_title(title, is_subtitle) {
	var i

	if (cfmt.titletrim) {
		i = title.lastIndexOf(", ")
		if (i < 0 || title[i + 2] < 'A' || title[i + 2] > 'Z') {
			i = 0
		} else if (cfmt.titletrim == true) {	// compatibility
			if (i < title.length - 7
			 || title.indexOf(' ', i + 3) >= 0)
				i = 0
		} else {
			if (i < title.length - cfmt.titletrim - 2)
				i = 0
		}
	}
	if (!is_subtitle
	 && cfmt.writefields.indexOf('X') >= 0)
		title = info.X + '.  ' + title
	if (i)
		title = title.slice(i + 2).trim() + ' ' + title.slice(0, i)
	if (cfmt.titlecaps)
		return title.toUpperCase()
	return title
}

// return the width of the music line
function get_lwidth() {
	return (img.width - img.lm - img.rm
					- 2)	// for bar thickness at eol
			/ cfmt.scale
}

// header generation functions
function write_title(title, is_subtitle) {
    var	font, h

	if (!title)
		return
	set_page();
	title = trim_title(title, is_subtitle)
	if (is_subtitle) {
		set_font("subtitle");
		h = cfmt.subtitlespace
	} else {
		set_font("title");
		h = cfmt.titlespace
	}
	vskip(strwh(title)[1] + h)
	if (cfmt.titleleft)
		xy_str(0, 0, title)
	else
		xy_str(get_lwidth() / 2, 0, title, "c")
}

/* -- output a header format '111 (222)' -- */
function put_inf2r(x, y, str1, str2, action) {
	if (!str1) {
		if (!str2)
			return
		str1 = str2;
		str2 = null
	}
	if (!str2)
		xy_str(x, y, str1, action)
	else
		xy_str(x, y, str1 + ' (' + str2 + ')', action)
}

// let vertical room for a text line
function str_skip(str) {
	vskip(strwh(str)[1] * cfmt.lineskipfac)
}

/* -- write a text block (%%begintext / %%text / %%center) -- */
function write_text(text, action) {
	if (action == 's')
		return				// skip
	set_font("text");
	set_page();
	var	strlw = get_lwidth(),
		sz = gene.curfont.size,
		lineskip = sz * cfmt.lineskipfac,
		parskip = sz * cfmt.parskipfac,
		p_start = block.started ? function(){} : blk_out,
		p_flush = block.started ? svg_flush : blk_flush,
		i, j, x, words, w, k, ww, str;

	p_start()
	switch (action) {
	default:
//	case 'c':
//	case 'r':
		switch (action) {
		case 'c': x = strlw / 2; break
		case 'r': x = strlw; break
		default: x = 0; break
		}
		j = 0
		while (1) {
			i = text.indexOf('\n', j)
			if (i < 0) {
				str = text.slice(j);
				str_skip(str);
				xy_str(x, 0, str, action)
				break
			}
			if (i == j) {			// new paragraph
				vskip(parskip);
				p_flush();
				use_font(gene.curfont)
				while (text[i + 1] == '\n') {
					vskip(lineskip);
					i++
				}
				if (i == text.length)
					break
				p_start()
			} else {
				str = text.slice(j, i);
				str_skip(str);
				xy_str(x, 0, str, action)
			}
			j = i + 1
		}
		vskip(parskip);
		p_flush()
		break
	case 'f':
	case 'j':
		j = 0
		while (1) {
			i = text.indexOf('\n\n', j)
			if (i < 0)
				words = text.slice(j)
			else
				words = text.slice(j, i);
			words = words.split(/\s+/);
			w = k = 0
			for (j = 0; j < words.length; j++) {
				ww = strwh(words[j] + ' ')[0];
				w += ww
				if (w >= strlw) {
					str = words.slice(k, j).join(' ');
					str_skip(str);
					xy_str(0, 0, str, action, strlw);
					k = j;
					w = ww
				}
			}
			if (w != 0) {
				str = words.slice(k).join(' ');
				str_skip(str);
				xy_str(0, 0, str)
			}
			vskip(parskip);
			p_flush()
			if (i < 0)
				break
			while (text[i + 2] == '\n') {
				vskip(lineskip);
				i++
			}
			if (i == text.length)
				break
			p_start();
			use_font(gene.curfont);
			j = i + 2
		}
		break
	}
}

/* -- output the words after tune -- */
function put_words(words) {
	var p, i, j, n, nw, i2, i_end, have_text;

	// output a line of words after tune
	function put_wline(p, x, right) {
		var i = 0, j, k

		if (p[i] == '$' && p[i +  1] >= '0' && p[i + 1] <= '9')
			i += 2;
		k = 0;
		j = i
		if ((p[i] >= '0' && p[i] <= '9') || p[i + 1] == '.') {
			while (i < p.length) {
				i++
				if (p[i] == ' '
				 || p[i - 1] == ':'
				 || p[i - 1] == '.')
					break
			}
			k = i
			while (p[i] == ' ')
				i++
		}

		if (k != 0)
			xy_str(x, 0, p.slice(j, k), 'r')
		if (i < p.length)
			xy_str(x + 5, 0, p.slice(i), 'l')
		return i >= p.length && k == 0
	} // put_wline()

	blk_out();
	set_font("words")

	/* see if we may have 2 columns */
	var	middle = get_lwidth() / 2,
		max2col = (middle - 45.) / (cwid('a') * gene.curfont.swfac);
	n = 0;
	words = words.split('\n');
	nw = words.length
	for (i = 0; i < nw; i++) {
		p = words[i]
/*fixme:utf8*/
		if (p.length > max2col) {
			n = 0
			break
		}
		if (!p) {
			if (have_text) {
				n++;
				have_text = false
			}
		} else {
			have_text = true
		}
	}
	if (n > 0) {
		i = n = ((n + 1) / 2) | 0;
		have_text = false
		for (i_end = 0; i_end < nw; i_end++) {
			p = words[i_end];
			j = 0
			while (p[j] == ' ')
				j++
			if (j == p.length) {
				if (have_text && --i <= 0)
					break
				have_text = false
			} else {
				have_text = true
			}
		}
		i2 = i_end + 1
	} else {
		i2 = i_end = nw
	}

	/* output the text */
	vskip(cfmt.wordsspace)

	for (i = 0; i < i_end || i2 < nw; i++) {
//fixme:should also permit page break on stanza start
		if (i < i_end && words[i].length == 0) {
			blk_out();
			use_font(gene.curfont)
		}
		vskip(cfmt.lineskipfac * gene.curfont.size)
		if (i < i_end)
			put_wline(words[i], 45., 0)
		if (i2 < nw) {
			if (put_wline(words[i2], 20. + middle, 1)) {
				if (--n == 0) {
					if (i < i_end) {
						n++
					} else if (i2 < words.length - 1) {

						/* center the last words */
/*fixme: should compute the width average.. */
						middle *= .6
					}
				}
			}
			i2++
		}
	}
}

/* -- output history -- */
function put_history() {
	var	i, j, c, str, font, h, w, head,
		names = cfmt.infoname.split("\n"),
		n = names.length

	for (i = 0; i < n; i++) {
		c = names[i][0]
		if (cfmt.writefields.indexOf(c) < 0)
			continue
		str = info[c]
		if (!str)
			continue
		if (!font) {
			font = true;
			set_font("history");
			vskip(cfmt.textspace);
			h = gene.curfont.size * cfmt.lineskipfac
		}
		head = names[i].slice(2)
		if (head[0] == '"')
			head = head.slice(1, -1);
		vskip(h);
		xy_str(0, 0, head);
		w = strwh(head)[0];
		str = str.split('\n');
		xy_str(w, 0, str[0])
		for (j = 1; j < str.length; j++) {
			vskip(h);
			xy_str(w, 0, str[j])
		}
		vskip(h * .3);
		blk_out();
		use_font(gene.curfont)
	}
}

/* -- write heading with format -- */
var info_font_init = {
	A: "info",
	C: "composer",
	O: "composer",
	P: "parts",
	Q: "tempo",
	R: "info",
	T: "title",
	X: "title"
}
function write_headform(lwidth) {
	var	c, font, font_name, align, x, y, sz,
		info_val = {},
		info_font = clone(info_font_init),
		info_sz = {
			A: cfmt.infospace,
			C: cfmt.composerspace,
			O: cfmt.composerspace,
			R: cfmt.infospace
		},
		info_nb = {}

	// compress the format
	var	fmt = "",
		p = cfmt.titleformat,
		j = 0,
		i = 0

	while (1) {
		while (p[i] == ' ')
			i++
		if (i >= p.length)
			break
		c = p[i++]
		if (c < 'A' || c > 'Z') {
			if (c == '+') {
				if (fmt.length == 0
				 || fmt.slice(-1) == '+')
					continue
				fmt = fmt.slice(0, -1) + '+'
			} else if (c == ',') {
				if (fmt.slice(-1) == '+')
					fmt = fmt.slice(0, -1) + 'l'
				fmt += '\n'
			}
			continue
		}
		if (!info_val[c]) {
			if (!info[c])
				continue
			info_val[c] = info[c].split('\n');
			info_nb[c] = 1
		} else {
			info_nb[c]++
		}
		fmt += c
		switch (p[i]) {
		case '-':
			fmt += 'l'
			i++
			break
		case '0':
			fmt += 'c'
			i++
			break
		case '1':
			fmt += 'r'
			i++
			break
		default:
			fmt += 'c'
			break
		}
	}
	if (fmt.slice(-1) == '+')
		fmt = fmt.slice(0, -1) + 'l';
	fmt += '\n'

	// loop on the blocks
	var	ya = {
			l: cfmt.titlespace,
			c: cfmt.titlespace,
			r: cfmt.titlespace
		},
		xa = {
			l: 0,
			c: lwidth * .5,
			r: lwidth
		},
		yb = {},
		str;
	p = fmt;
	i = 0
	while (1) {

		// get the y offset of the top text
		yb.l = yb.c = yb.r = y = 0;
		j = i
		while (1) {
			c = p[j++]
			if (c == '\n')
				break
			align = p[j++]
			if (align == '+')
				align = p[j + 1]
			else if (yb[align] != 0)
				continue
			str = info_val[c]
			if (!str)
				continue
			font_name = info_font[c]
			if (!font_name)
				font_name = "history";
			font = get_font(font_name);
			sz = font.size * 1.1
			if (info_sz[c])
				sz += info_sz[c]
			if (y < sz)
				y = sz;
			yb[align] = sz
		}
		ya.l += y - yb.l;
		ya.c += y - yb.c;
		ya.r += y - yb.r
		while (1) {
			c = p[i++]
			if (c == '\n')
				break
			align = p[i++]
			if (info_val[c].length == 0)
				continue
			str = info_val[c].shift()
			if (align == '+') {
				info_nb[c]--;
				c = p[i++];
				align = p[i++]
				if (info_val[c].length > 0) {
					if (str)
						str += ' ' + info_val[c].shift()
					else
						str = ' ' + info_val[c].shift()
				}
			}
			font_name = info_font[c]
			if (!font_name)
				font_name = "history";
			font = get_font(font_name);
			sz = font.size * 1.1
			if (info_sz[c])
				sz += info_sz[c];
			set_font(font);
			x = xa[align];
			y = ya[align] + sz

			if (c == 'Q') {			/* special case for tempo */
				if (!glovar.tempo.del) {
					if (align != 'l') {
						var w = tempo_width(glovar.tempo)

						if (align == 'c')
							w *= .5;
						x -= w
					}
					write_tempo(glovar.tempo, x, -y)
				}
			} else if (str) {
				xy_str(x, -y, str, align)
			}

			if (c == 'T') {
				font_name = info_font.T = "subtitle";
				info_sz.T = cfmt.subtitlespace
			}
			if (info_nb[c] <= 1) {
				if (c == 'T') {
					font = get_font(font_name);
					sz = font.size * 1.1
					if (info_sz[c])
						sz += info_sz[c];
					set_font(font)
				}
				while (info_val[c].length > 0) {
					y += sz;
					str = info_val[c].shift();
					xy_str(x, -y, str, align)
				}
			}
			info_nb[c]--;
			ya[align] = y
		}
		if (ya.c > ya.l)
			ya.l = ya.c
		if (ya.r > ya.l)
			ya.l = ya.r
		if (i >= fmt.length)
			break
		ya.c = ya.r = ya.l
	}
	vskip(ya.l)
}

/* -- output the tune heading -- */
function write_heading() {
	var	i, j, area, composer, origin, rhythm, down1, down2,
		lwidth = get_lwidth()

	blk_out();
	vskip(cfmt.topspace)

	if (cfmt.titleformat) {
		write_headform(lwidth);
		vskip(cfmt.musicspace)
		return
	}

	/* titles */
	if (info.T
	 && cfmt.writefields.indexOf('T') >= 0) {
		i = 0
		while (1) {
			j = info.T.indexOf("\n", i)
			if (j < 0) {
				write_title(info.T.substring(i), i != 0)
				break
			}
			write_title(info.T.slice(i, j), i != 0);
			i = j + 1
		}
	}

	/* rhythm, composer, origin */
	set_font("composer");
//	down1 = cfmt.composerspace + gene.curfont.size
	down1 = down2 = 0
	if (parse.ckey.k_bagpipe
	 && !cfmt.infoline
	 && cfmt.writefields.indexOf('R') >= 0)
		rhythm = info.R
	if (rhythm) {
		xy_str(0, -cfmt.composerspace, rhythm);
		down1 = cfmt.composerspace
	}
	area = info.A
	if (cfmt.writefields.indexOf('C') >= 0)
		composer = info.C
	if (cfmt.writefields.indexOf('O') >= 0)
		origin = info.O
	if (composer || origin || cfmt.infoline) {
		var xcomp, align;

		vskip(cfmt.composerspace)
		if (cfmt.aligncomposer < 0) {
			xcomp = 0;
			align = ' '
		} else if (cfmt.aligncomposer == 0) {
			xcomp = lwidth * .5;
			align = 'c'
		} else {
			xcomp = lwidth;
			align = 'r'
		}
		down2 = down1
		if (composer || origin) {
			if (cfmt.aligncomposer >= 0
			 && down1 != down2)
				vskip(down1 - down2);
			i = 0
			while (1) {
				vskip(gene.curfont.size)
				if (composer)
					j = composer.indexOf("\n", i)
				else
					j = -1
				if (j < 0) {
					put_inf2r(xcomp, 0,
						composer ? composer.substring(i) : null,
						origin,
						align)
					break
				}
				xy_str(xcomp, 0, composer.slice(i, j), align);
				down1 += gene.curfont.size;
				i = j + 1
			}
			if (down2 > down1)
				vskip(down2 - down1)
		}

		rhythm = rhythm ? null : info.R
		if ((rhythm || area) && cfmt.infoline) {

			/* if only one of rhythm or area then do not use ()'s
			 * otherwise output 'rhythm (area)' */
			set_font("info");
			vskip(gene.curfont.size + cfmt.infospace);
			put_inf2r(lwidth, 0, rhythm, area, 'r');
			down1 += gene.curfont.size + cfmt.infospace
		}
//		down2 = 0
	} else {
		down2 = cfmt.composerspace
	}

	/* parts */
	if (info.P
	 && cfmt.writefields.indexOf('P') >= 0) {
		set_font("parts");
		down1 = cfmt.partsspace + gene.curfont.size - down1
		if (down1 > 0)
			down2 += down1
		if (down2 > .01)
			vskip(down2);
		xy_str(0, 0, info.P);
		down2 = 0
	}
	vskip(down2 + cfmt.musicspace)
}
// abc2svg - svg.js - svg functions
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

var	output = "",		// output buffer
	style = '\n.fill {fill: currentColor}\
\n.stroke {stroke: currentColor; fill: none}\
\n.music text, .music tspan {fill:currentColor}',
	font_style = '',
	posx = cfmt.leftmargin / cfmt.scale,	// default x offset of the images
	posy = 0,		// y offset in the block
	img = {			// image
		width: cfmt.pagewidth,	// width
		lm: cfmt.leftmargin,	// left and right margins
		rm: cfmt.rightmargin
//		chg: false
	},
	defined_glyph = {},
	defs = '',
	fulldefs = '',		// unreferenced defs as <filter>
	stv_g = {		/* staff/voice graphic parameters */
		scale: 1,
		dy: 0,
		st: -1,
		v: 0,
		g: 0
//		color: undefined
	},
	block = {}		/* started & newpage */

// glyphs in music font
var tgls = {
  brace: {x:0, y:0, c:"\ue000"},
  sgno: {x:-6, y:0, c:"\ue047"},
  coda: {x:-12, y:6, c:"\ue048"},
  tclef: {x:-8, y:0, c:"\ue050"},
  cclef: {x:-8, y:0, c:"\ue05c"},
  bclef: {x:-8, y:0, c:"\ue062"},
  pclef: {x:-6, y:0, c:"\ue069"},
  stclef: {x:-8, y:0, c:"\ue07a"},
  scclef: {x:-8, y:0, c:"\ue07b"},
  sbclef: {x:-7, y:0, c:"\ue07c"},
  spclef: {x:-6, y:0, c:"\ue069"},
  meter0: {c:"\ue080"},
  meter1: {c:"\ue081"},
  meter2: {c:"\ue082"},
  meter3: {c:"\ue083"},
  meter4: {c:"\ue084"},
  meter5: {c:"\ue085"},
  meter6: {c:"\ue086"},
  meter7: {c:"\ue087"},
  meter8: {c:"\ue088"},
  meter9: {c:"\ue089"},
  "meter+": {c:"\ue08c"},
  "meter(": {c:"\ue094"},
  "meter)": {c:"\ue095"},
  csig: {x:0, y:0, c:"\ue08a"},
  ctsig: {x:0, y:0, c:"\ue08b"},
  HDD: {x:-7, y:0, c:"\ue0a0"},
  breve: {x:-6, y:0, c:"\ue0a1"},
  HD: {x:-5.2, y:0, c:"\ue0a2"},
  Hd: {x:-3.8, y:0, c:"\ue0a3"},
  hd: {x:-3.7, y:0, c:"\ue0a4"},
  ghd: {x:2, y:0, c:"\ue0a4", sc:.66},
  pshhd: {x:-3.7, y:0, c:"\ue0a9"},
  pfthd: {x:-3.7, y:0, c:"\ue0b3"},
  x: {x:-3.7, y:0, c:"\ue0a9"},
  "circle-x": {x:-3.7, y:0, c:"\ue0b3"},
  srep: {x:-5, y:0, c:"\ue101"},
  dot: {x:-2, y:0, c:"\ue1e7"},
 "acc-1": {x:-3, y:0, c:"\ue260"},
  acc3: {x:-2, y:0, c:"\ue261"},
  acc1: {x:-3, y:0, c:"\ue262"},
  acc2: {x:-3, y:0, c:"\ue263"},
 "acc-2": {x:-3, y:0, c:"\ue264"},
 "acc-1_1_4": {x:-3, y:0, c:"\ue280"},
  accent: {x:-3, y:2, c:"\ue4a0"},
  marcato: {x:-3, y:0, c:"\ue4ac"},
  hld: {x:-7, y:0, c:"\ue4c0"},
  brth: {x:0, y:0, c:"\ue4ce"},
  r00: {x:-1.5, y:0, c:"\ue4e1"},
  r0: {x:-1.5, y:0, c:"\ue4e2"},
  r1: {x:-3.5, y:6, c:"\ue4e3"},
  r2: {x:-3.2, y:0, c:"\ue4e4"},
  r4: {x:-3, y:0, c:"\ue4e5"},
  r8: {x:-3, y:0, c:"\ue4e6"},
  r16: {x:-4, y:0, c:"\ue4e7"},
  r32: {x:-4, y:0, c:"\ue4e8"},
  r64: {x:-4, y:0, c:"\ue4e9"},
  r128: {x:-4, y:0, c:"\ue4ea"},
  mrest: {x:-10, y:0, c:"\ue4ee"},
  mrep: {x:-6, y:0, c:"\ue500"},
  mrep2: {x:-9, y:0, c:"\ue501"},
  turn: {x:-5, y:4, c:"\ue567"},
  turnx: {x:-5, y:4, c:"\ue569"},
  umrd: {x:-7, y:2, c:"\ue56c"},
  lmrd: {x:-7, y:2, c:"\ue56d"},
  ped: {x:-10, y:0, c:"\ue650"},
  pedoff: {x:-5, y:0, c:"\ue655"},
  longa: {x:-6, y:0, c:"\ue95c"}
}

// glyphs to put in <defs>
var glyphs = {
  acc1_1_4: '<g id="acc1_1_4">\n\
	<path d="m0 7.8v-15.4" class="stroke"/>\n\
	<path class="fill" d="M-1.8 2.7l3.6 -1.1v2.2l-3.6 1.1v-2.2z\n\
		M-1.8 -3.7l3.6 -1.1v2.2l-3.6 1.1v-2.2"/>\n\
</g>',
  acc1_3_4: '<g id="acc1_3_4">\n\
	<path d="m-2.5 8.7v-15.4M0 7.8v-15.4M2.5 6.9v-15.4" class="stroke"/>\n\
	<path class="fill" d="m-3.7 3.1l7.4 -2.2v2.2l-7.4 2.2v-2.2z\n\
		M-3.7 -3.2l7.4 -2.2v2.2l-7.4 2.2v-2.2"/>\n\
</g>',
 "acc-1_3_4": '<g id="acc-1_3_4">\n\
    <path class="fill" d="m0.6 -2.7\n\
	c-5.7 -3.1 -5.7 3.6 0 6.7c-3.9 -4 -4 -7.6 0 -5.8\n\
	M1 -2.7c5.7 -3.1 5.7 3.6 0 6.7c3.9 -4 4 -7.6 0 -5.8"/>\n\
    <path d="m1.6 3.5v-13M0 3.5v-13" class="stroke" stroke-width=".6"/>\n\
</g>',
  pmsig: '<path id="pmsig" class="stroke" stroke-width="0.8"\n\
	d="m0 -7a5 5 0 0 1 0 -10a5 5 0 0 1 0 10"/>',
  pMsig: '<g id="pMsig">\n\
	<use xlink:href="#pmsig"/>\n\
	<path class="fill" d="m0 -10a2 2 0 0 1 0 -4a2 2 0 0 1 0 4"/>\n\
</g>',
  imsig: '<path id="imsig" class="stroke" stroke-width="0.8"\n\
	d="m3 -8a5 5 0 1 1 0 -8"/>',
  iMsig: '<g id="iMsig">\n\
	<use xlink:href="#imsig"/>\n\
	<path class="fill" d="m0 -10a2 2 0 0 1 0 -4a2 2 0 0 1 0 4"/>\n\
</g>',
  hl: '<path id="hl" class="stroke" stroke-width="1" d="m-6 0h12"/>',
  hl1: '<path id="hl1" class="stroke" stroke-width="1" d="m-7 0h14"/>',
  hl2: '<path id="hl2" class="stroke" stroke-width="1" d="m-9 0h18"/>',
  ghl: '<path id="ghl" class="stroke" d="m-3.5 0h7"/>',
  rdots: '<g id="rdots" class="fill">\n\
	<circle cx="0" cy="-9" r="1.2"/>\n\
	<circle cx="0" cy="-15" r="1.2"/>\n\
</g>',
  grm: '<path id="grm" class="fill" d="m-5 -2.5\n\
	c5 -8.5 5.5 4.5 10 -2 -5 8.5 -5.5 -4.5 -10 2"/>',
  stc: '<circle id="stc" class="fill" cx="0" cy="-3" r="1.2"/>',
  sld: '<path id="sld" class="fill" d="m-7.2 4.8\n\
	c1.8 .7 4.5 -.2 7.2 -4.8 -2.1 5 -5.4 6.8 -7.6 6"/>',
  emb: '<path id="emb" class="stroke" stroke-width="1.2" stroke-linecap="round"\n\
	d="m-2.5 -3h5"/>',
  roll: '<path id="roll" class="fill" d="m-6 0\n\
	c0.4 -7.3 11.3 -7.3 11.7 0 -1.3 -6 -10.4 -6 -11.7 0"/>',
  upb: '<path id="upb" class="stroke" d="m-2.6 -9.4\n\
	l2.6 8.8 2.6 -8.8"/>',
  dnb: '<g id="dnb">\n\
	<path d="M-3.2 -2v-7.2m6.4 0v7.2" class="stroke"/>\n\
	<path d="M-3.2 -6.8v-2.4l6.4 0v2.4" class="fill"/>\n\
</g>',
  dplus: '<path id="dplus" class="stroke" stroke-width="1.7"\n\
	d="m0 -.5v-6m-3 3h6"/>',
  lphr: '<path id="lphr" class="stroke" stroke-width="1.2"\n\
	d="m0 0v18"/>',
  mphr: '<path id="mphr" class="stroke" stroke-width="1.2"\n\
	d="m0 0v12"/>',
  sphr: '<path id="sphr" class="stroke" stroke-width="1.2"\n\
	d="m0 0v6"/>',
  sfz: '<text id="sfz" x="-5" y="-7" \
style="font-family:serif; font-style:italic; font-size:14px">\n\
	s<tspan font-size="16" font-weight="bold">f</tspan>z</text>',
  trl: '<text id="trl" x="-2" y="-4"\n\
	style="font-family:serif; font-weight:bold; \
font-style:italic; font-size:16px">tr</text>',
  opend: '<circle id="opend" class="stroke"\n\
	cx="0" cy="-3" r="2.5"/>',
  snap: '<path id="snap" class="stroke" d="m-3 -6\n\
	c0 -5 6 -5 6 0 0 5 -6 5 -6 0\n\
	M0 -5v6"/>',
  thumb: '<path id="thumb" class="stroke" d="m-2.5 -7\n\
	c0 -6 5 -6 5 0 0 6 -5 6 -5 0\n\
	M-2.5 -9v4"/>',
  wedge: '<path id="wedge" class="fill" d="m0 -1l-1.5 -5h3l-1.5 5"/>',
  ltr: '<path id="ltr" class="fill"\n\
	d="m0 -.4c2 -1.5 3.4 -1.9 3.9 .4 0.2 .8 .7 .7 2.1 -.4\n\
	v0.8c-2 1.5 -3.4 1.9 -3.9 -.4 -.2 -.8 -.7 -.7 -2.1 .4z"/>',
  custos: '<g id="custos">\n\
	<path class="fill" d="m-4 0l2 2.5 2 -2.5 2 2.5 2 -2.5\n\
		-2 -2.5 -2 2.5 -2 -2.5 -2 2.5"/>\n\
	<path class="stroke" d="m3.5 0l5 -7"/>\n\
</g>',
  triangle: '<path id="triangle" class="fill" d="m-3.7 -3.2l7.4 0 -3.7 6.4 -3.7 -6.4"/>',
  diamond: '<path id="diamond" class="fill" d="m0 3.5l-3.7 -3.5 3.7 -3.5 3.7 3.5z"/>',
  oct: '<text id="oct" style="font-family:serif; font-size:12px">8</text>'
}

// mark a glyph as used and add it in <defs>
function def_use(gl) {
	var	i, j, g

	if (defined_glyph[gl])
		return
	defined_glyph[gl] = true;
	g = glyphs[gl]
	if (!g) {
//throw new Error("unknown glyph: " + gl)
		error(1, null, "Unknown glyph: '$1'", gl)
		return	// fixme: the xlink is set
	}
	j = 0
	while (1) {
		i = g.indexOf('xlink:href="#', j)
		if (i < 0)
			break
		i += 13;
		j = g.indexOf('"', i);
		def_use(g.slice(i, j))
	}
	defs += '\n' + g
}

// add user defs from %%beginsvg
function defs_add(text) {
	var	i, j, gl, tag, is,
		ie = 0

	// remove XML comments
	text = text.replace(/<!--.*?-->/g, '')

	while (1) {
		is = text.indexOf('<', ie);
		if (is < 0)
			break
		i = text.indexOf('id="', is)
		if (i < 0)
			break
		i += 4;
		j = text.indexOf('"', i);
		if (j < 0)
			break
		gl = text.slice(i, j);
		ie = text.indexOf('>', j);
		if (ie < 0)
			break
		if (text[ie - 1] == '/') {
			ie++
		} else {
			i = text.indexOf(' ', is);
			if (i < 0)
				break
			tag = text.slice(is + 1, i);
			ie = text.indexOf('</' + tag + '>', ie)
			if (ie < 0)
				break
			ie += 3 + tag.length
		}
		if (text.substr(is, 7) == '<filter')
			fulldefs += '\n' + text.slice(is, ie)
		else
			glyphs[gl] = text.slice(is, ie)
	}
}

// output the stop/start of a graphic sequence
function set_g() {

	// close the previous sequence
	if (stv_g.started) {
		stv_g.started = false;
		output += "</g>\n"
	}

	// check if new sequence needed
	if (stv_g.scale == 1 && !stv_g.color)
		return

	// open the new sequence
	output += '<g '
	if (stv_g.scale != 1) {
		if (stv_g.st >= 0)
			output += staff_tb[stv_g.st].scale_str
		else
			output += voice_tb[stv_g.v].scale_str
	}
	if (stv_g.color) {
		if (stv_g.scale != 1)
			output += ' ';
		output += 'style="color:' + stv_g.color + '"'
	}
	output += ">\n";
	stv_g.started = true
}

/* set the color */
function set_color(color) {
	if (color == stv_g.color)
		return undefined	// same color
	var	old_color = stv_g.color;
	stv_g.color = color;
	set_g()
	return old_color
}

/* -- set the staff scale (only) -- */
function set_sscale(st) {
	var	new_scale, dy

	if (st != stv_g.st && stv_g.scale != 1)
		stv_g.scale = 0;
	new_scale = st >= 0 ? staff_tb[st].staffscale : 1
	if (st >= 0 && new_scale != 1)
		dy = staff_tb[st].y
	else
		dy = posy
	if (new_scale == stv_g.scale && dy == stv_g.dy)
		return
	stv_g.scale = new_scale;
	stv_g.dy = dy;
	stv_g.st = st;
	set_g()
}

/* -- set the voice or staff scale -- */
function set_scale(s) {
	var	new_scale = s.p_v.scale

	if (new_scale == 1) {
		set_sscale(s.st)
		return
	}
/*fixme: KO when both staff and voice are scaled */
	if (new_scale == stv_g.scale && stv_g.dy == posy)
		return
	stv_g.scale = new_scale;
	stv_g.dy = posy;
	stv_g.st = -1;
	stv_g.v = s.v;
	set_g()
}

// -- set the staff output buffer and scale when delayed output
function set_dscale(st, no_scale) {
	if (output) {
		if (stv_g.st < 0) {
			staff_tb[0].output += output
		} else if (stv_g.scale == 1) {
			staff_tb[stv_g.st].output += output
		} else {
			staff_tb[stv_g.st].sc_out += output
		}
		output = ""
	}
	if (st < 0)
		stv_g.scale = 1
	else
		stv_g.scale = no_scale ? 1 : staff_tb[st].staffscale;
	stv_g.st = st;
	stv_g.dy = 0
}

// update the y offsets of delayed output
function delayed_update() {
	var st, new_out, text

	for (st = 0; st <= nstaff; st++) {
		if (staff_tb[st].sc_out) {
			output += '<g transform="translate(0,' +
					(posy - staff_tb[st].y).toFixed(2) +
					') scale(' +
					 staff_tb[st].staffscale.toFixed(2) +
					')">\n' +
				staff_tb[st].sc_out +
				'</g>\n';
			staff_tb[st].sc_out = ""
		}
		if (!staff_tb[st].output)
			continue
		output += '<g transform="translate(0,' +
				(-staff_tb[st].y).toFixed(2) +
				')">\n' +
			staff_tb[st].output +
			'</g>\n';
		staff_tb[st].output = ""
	}
}

// output the annotations
// !! tied to the symbol types in abc2svg.js !!
var anno_type = ['bar', 'clef', 'custos', '', 'grace',
		'key', 'meter', 'Zrest', 'note', 'part',
		'rest', 'yspace', 'staves', 'Break', 'tempo',
		'', 'block', 'remark']

function anno_out(s, t, f) {
	if (s.istart == undefined)
		return
	var	type = s.type,
		h = s.ymx - s.ymn + 4,
		wl = s.wl || 2,
		wr = s.wr || 2

	if (s.grace)
		type = C.GRACE

	f(t || anno_type[type], s.istart, s.iend,
		s.x - wl - 2, staff_tb[s.st].y + s.ymn + h - 2,
		wl + wr + 4, h, s);
}

function a_start(s, t) {
	anno_out(s, t, user.anno_start)
}
function a_stop(s, t) {
	anno_out(s, t, user.anno_stop)
}
function empty_function() {
}
var	anno_start = user.anno_start ? a_start : empty_function,
	anno_stop = user.anno_stop ? a_stop : empty_function

// output a string with x, y, a and b
// In the string,
//	X and Y are replaced by scaled x and y
//	A and B are replaced by a and b as string
//	F and G are replaced by a and b as float
function out_XYAB(str, x, y, a, b) {
	x = sx(x);
	y = sy(y);
	output += str.replace(/X|Y|A|B|F|G/g, function(c) {
		switch (c) {
		case 'X': return x.toFixed(2)
		case 'Y': return y.toFixed(2)
		case 'A': return a
		case 'B': return b
		case 'F': return a.toFixed(2)
//		case 'G':
		default: return b.toFixed(2)
		}
		})
}

// open / close containers
function g_open(x, y, rot, sx, sy) {
	out_XYAB('<g transform="translate(X,Y', x, y);
	if (rot)
		output += ') rotate(' + rot.toFixed(2)
	if (sx) {
		if (sy)
			output += ') scale(' + sx.toFixed(2) +
						', ' + sy.toFixed(2)
		else
			output += ') scale(' + sx.toFixed(2)
	}
	output += ')">\n';
	stv_g.g++
}
function g_close() {
	stv_g.g--;
	output += '</g>\n'
}

// external SVG string
Abc.prototype.out_svg = function(str) { output += str }

// exported functions for the annotation
function sx(x) {
	if (stv_g.g)
		return x
	return (x + posx) / stv_g.scale
}
Abc.prototype.sx = sx
function sy(y) {
	if (stv_g.g)
		return y
	if (stv_g.scale == 1)
		return posy - y
	if (stv_g.st < 0)
		return (posy - y) / stv_g.scale	// voice scale
	return stv_g.dy - y			// staff scale
}
Abc.prototype.sy = sy;
Abc.prototype.sh = function(h) {
	if (stv_g.st < 0)
		return h / stv_g.scale
	return h
}
// for absolute X,Y coordinates
Abc.prototype.ax = function(x) { return x + posx }
Abc.prototype.ay = function(y) {
	if (stv_g.st < 0)
		return posy - y
	return posy + (stv_g.dy - y) * stv_g.scale - stv_g.dy
}
Abc.prototype.ah = function(h) {
	if (stv_g.st < 0)
		return h
	return h * stv_g.scale
}
// output scaled (x + <sep> + y)
function out_sxsy(x, sep, y) {
	x = sx(x);
	y = sy(y);
	output += x.toFixed(2) + sep + y.toFixed(2)
}
Abc.prototype.out_sxsy = out_sxsy

// define the start of a path
function xypath(x, y, fill) {
	out_XYAB('<path class="A" d="mX Y\n', x, y, fill ? "fill" : "stroke")
}
Abc.prototype.xypath = xypath

// output a glyph
function xygl(x, y, gl) {
// (avoid ps<->js loop)
//	if (psxygl(x, y, gl))
//		return
	var 	tgl = tgls[gl]
	if (tgl && !glyphs[gl]) {
		x += tgl.x * stv_g.scale;
		y += tgl.y
		if (tgl.sc)
			out_XYAB('<text transform="translate(X,Y) scale(F)">B</text>\n',
				x, y, tgl.sc, tgl.c);
		else
			out_XYAB('<text x="X" y="Y">A</text>\n', x, y, tgl.c)
		return
	}
	if (!glyphs[gl]) {
		error(1, null, 'no definition of $1', gl)
		return
	}
	def_use(gl);
	out_XYAB('<use x="X" y="Y" xlink:href="#A"/>\n', x, y, gl)
}
// - specific functions -
// gua gda (acciaccatura)
function out_acciac(x, y, dx, dy, up) {
	if (up) {
		x -= 1;
		y += 4
	} else {
		x -= 5;
		y -= 4
	}
	out_XYAB('<path class="stroke" d="mX YlF G"/>\n',
		x, y, dx, -dy)
}
// simple /dotted measure bar
function out_bar(x, y, h, dotted) {
	output += '<path class="stroke" stroke-width="1" ' +
		(dotted ? 'stroke-dasharray="5,5" ' : '') +
		'd="m' + (x + posx).toFixed(2) +
		' ' + (posy - y).toFixed(2) + 'v' + (-h).toFixed(2) +
		'"/>\n'
}
// tuplet value - the staves are not defined
function out_bnum(x, y, str) {
	out_XYAB('<text style="font-family:serif; font-style:italic; font-size:12px"\n\
	x="X" y="Y" text-anchor="middle">A</text>\n',
		x, y, str.toString())
}
// staff system brace
function out_brace(x, y, h) {
//fixme: '-6' depends on the scale
	x += posx - 6;
	y = posy - y;
	h /= 24;
	output += '<text transform="translate(' +
				x.toFixed(2) + ',' + y.toFixed(2) +
			') scale(2.5,' + h.toFixed(2) +
			')">' + tgls.brace.c + '</text>\n'
}

// staff system bracket
function out_bracket(x, y, h) {
	x += posx - 5;
	y = posy - y - 3;
	h += 2;
	output += '<path class="fill"\n\
	d="m' + x.toFixed(2) + ' ' + y.toFixed(2) + '\n\
	c10.5 1 12 -4.5 12 -3.5c0 1 -3.5 5.5 -8.5 5.5\n\
	v' + h.toFixed(2) + '\n\
	c5 0 8.5 4.5 8.5 5.5c0 1 -1.5 -4.5 -12 -3.5"/>\n'
}
// hyphen
function out_hyph(x, y, w) {
	var	n, a_y,
		d = 25 + ((w / 20) | 0) * 3

	if (w > 15.)
		n = ((w - 15) / d) | 0
	else
		n = 0;
	x += (w - d * n - 5) / 2;
	out_XYAB('<path class="stroke" stroke-width="1.2"\n\
	stroke-dasharray="5,A"\n\
	d="mX YhB"/>\n',
		x, y + 6,		// set the line a bit upper
		Math.round((d - 5) / stv_g.scale), d * n + 5)
}
// stem [and flags]
// fixme: h is already scaled - change that?
function out_stem(x, y, h, grace,
		  nflags, straight) {	// optional
//fixme: dx KO with half note or longa
	var	dx = grace ? GSTEM_XOFF : 3.5,
		slen = -h

	if (h < 0)
		dx = -dx;		// down
	x += dx * stv_g.scale
	if (stv_g.st < 0)
		slen /= stv_g.scale;
	out_XYAB('<path class="stroke" d="mX YvF"/>\n',	// stem
		x, y, slen)
	if (!nflags)
		return

	output += '<path class="fill"\n\
	d="';
	y += h
	if (h > 0) {				// up
		if (!straight) {
			if (!grace) {
				if (nflags == 1) {
					out_XYAB('MX Yc0.6 5.6 9.6 9 5.6 18.4\n\
	1.6 -6 -1.3 -11.6 -5.6 -12.8\n', x, y)
				} else {
					while (--nflags >= 0) {
						out_XYAB('MX Yc0.9 3.7 9.1 6.4 6 12.4\n\
	1 -5.4 -4.2 -8.4 -6 -8.4\n', x, y);
						y -= 5.4
					}
				}
			} else {		// grace
				if (nflags == 1) {
					out_XYAB('MX Yc0.6 3.4 5.6 3.8 3 10\n\
	1.2 -4.4 -1.4 -7 -3 -7\n', x, y)
				} else {
					while (--nflags >= 0) {
						out_XYAB('MX Yc1 3.2 5.6 2.8 3.2 8\n\
	1.4 -4.8 -2.4 -5.4 -3.2 -5.2\n', x, y);
						y -= 3.5
					}
				}
			}
		} else {			// straight
			if (!grace) {
//fixme: check endpoints
				y += 1
				while (--nflags >= 0) {
					out_XYAB('MX Yl7 3.2 0 3.2 -7 -3.2z\n',
						x, y);
					y -= 5.4
				}
			} else {		// grace
				while (--nflags >= 0) {
					out_XYAB('MX Yl3 1.5 0 2 -3 -1.5z\n',
						x, y);
					y -= 3
				}
			}
		}
	} else {				// down
		if (!straight) {
			if (!grace) {
				if (nflags == 1) {
					out_XYAB('MX Yc0.6 -5.6 9.6 -9 5.6 -18.4\n\
	1.6 6 -1.3 11.6 -5.6 12.8\n', x, y)
				} else {
					while (--nflags >= 0) {
						out_XYAB('MX Yc0.9 -3.7 9.1 -6.4 6 -12.4\n\
	1 5.4 -4.2 8.4 -6 8.4\n', x, y);
						y += 5.4
					}
				}
			} else {		// grace
				if (nflags == 1) {
					out_XYAB('MX Yc0.6 -3.4 5.6 -3.8 3 -10\n\
	1.2 4.4 -1.4 7 -3 7\n', x, y)
				} else {
					while (--nflags >= 0) {
						out_XYAB('MX Yc1 -3.2 5.6 -2.8 3.2 -8\n\
	1.4 4.8 -2.4 5.4 -3.2 5.2\n', x, y);
						y += 3.5
					}
				}
			}
		} else {			// straight
			if (!grace) {
//fixme: check endpoints
				y += 1
				while (--nflags >= 0) {
					out_XYAB('MX Yl7 -3.2 0 -3.2 -7 3.2z\n',
						x, y);
					y += 5.4
				}
//			} else {		// grace
//--fixme: error?
			}
		}
	}
	output += '"/>\n'
}
// thick measure bar
function out_thbar(x, y, h) {
	x += posx + 1.5;
	y = posy - y;
	output += '<path class="stroke" stroke-width="3" d="m' +
		x.toFixed(2) + ' ' + y.toFixed(2) +
		'v' + (-h).toFixed(2) + '"/>\n'
}
// tremolo
function out_trem(x, y, ntrem) {
	out_XYAB('<path class="fill" d="mX Y\n\t', x - 4.5, y)
	while (1) {
		output += 'l9 -3v3l-9 3z'
		if (--ntrem <= 0)
			break
		output += 'm0 5.4'
	}
	output += '"/>\n'
}
// tuplet bracket - the staves are not defined
function out_tubr(x, y, dx, dy, up) {
	var	h = up ? -3 : 3;

	y += h;
	dx /= stv_g.scale;
	output += '<path class="stroke" d="m';
	out_sxsy(x, ' ', y);
	output += 'v' + h.toFixed(2) +
		'l' + dx.toFixed(2) + ' ' + (-dy).toFixed(2) +
		'v' + (-h).toFixed(2) + '"/>\n'
}
// tuplet bracket with number - the staves are not defined
function out_tubrn(x, y, dx, dy, up, str) {
    var	sw = str.length * 10,
	h = up ? -3 : 3;

	out_XYAB('<text style="font-family:serif; font-style:italic; font-size:12px"\n\
	x="X" y="Y" text-anchor="middle">A</text>\n',
		x + dx / 2, y + dy / 2, str);
	dx /= stv_g.scale
	if (!up)
		y += 6;
	output += '<path class="stroke" d="m';
	out_sxsy(x, ' ', y);
	output += 'v' + h.toFixed(2) +
		'm' + dx.toFixed(2) + ' ' + (-dy).toFixed(2) +
		'v' + (-h).toFixed(2) + '"/>\n' +
		'<path class="stroke" stroke-dasharray="' +
		((dx - sw) / 2).toFixed(2) + ' ' + sw.toFixed(2) +
		'" d="m';
	out_sxsy(x, ' ', y - h);
	output += 'l' + dx.toFixed(2) + ' ' + (-dy).toFixed(2) + '"/>\n'

}
// underscore line
function out_wln(x, y, w) {
	out_XYAB('<path class="stroke" stroke-width="0.8" d="mX YhF"/>\n',
		x, y + 3, w)
}

// decorations with string
var deco_str_style = {
crdc:	{
		dx: 0,
		dy: 5,
		style: 'font-family:serif; font-style:italic; font-size:14px'
	},
dacs:	{
		dx: 0,
		dy: 3,
		style: 'font-family:serif; font-size:16px',
		anchor: ' text-anchor="middle"'
	},
fng:	{
		dx: 0,
		dy: 1,
		style: 'font-family:Bookman; font-size:8px',
		anchor: ' text-anchor="middle"'
	},
pf:	{
		dx: 0,
		dy: 5,
		style: 'font-family:serif; font-weight:bold; font-style:italic; font-size:16px'
	},
'@':	{
		dx: 0,
		dy: 5,
		style: 'font-family:sans-serif; font-size:12px'
	}
}

function out_deco_str(x, y, name, str) {
	var	a, f,
		a_deco = deco_str_style[name]

	if (!a_deco) {
		xygl(x, y, name)
		return
	}
	x += a_deco.dx;
	y += a_deco.dy;
	if (!a_deco.def) {
		style += "\n." + name + " {" + a_deco.style + "}";
		a_deco.def = true
	}
	out_XYAB('<text x="X" y="Y" class="A"B>', x, y,
		name, a_deco.anchor || "");
	set_font("annotation");
	out_str(str);
	output += '</text>\n'
}

function out_arp(x, y, val) {
	g_open(x, y, 270);
	x = 0;
	y = -4;
	val = Math.ceil(val / 6)
	while (--val >= 0) {
		xygl(x, y, "ltr");
		x += 6
	}
	g_close()
}
function out_cresc(x, y, val, defl) {
	x += val;
	val = -val;
	out_XYAB('<path class="stroke"\n\
	d="mX YlA ', x, y + 5, val)
	if (defl.nost)
		output += '-2.2m0 -3.6l' + (-val).toFixed(2) + ' -2.2"/>\n'
	else
		output += '-4l' + (-val).toFixed(2) + ' -4"/>\n'

}
function out_dim(x, y, val, defl) {
	out_XYAB('<path class="stroke"\n\
	d="mX YlA ', x, y + 5, val)
	if (defl.noen)
		output += '-2.2m0 -3.6l' + (-val).toFixed(2) + ' -2.2"/>\n'
	else
		output += '-4l' + (-val).toFixed(2) + ' -4"/>\n'
}
function out_ltr(x, y, val) {
	y += 4;
	val = Math.ceil(val / 6)
	while (--val >= 0) {
		xygl(x, y, "ltr");
		x += 6
	}
}
function out_8va(x, y, val, defl) {
	if (!defl.nost) {
		out_XYAB('<text x="X" y="Y" \
style="font-family:serif; font-weight:bold; font-style:italic; font-size:12px">8\
<tspan dy="-4" style="font-size:10px">va</tspan></text>\n',
			x - 8, y);
		x += 12;
		val -= 12
	} else {
		val -= 5
	}
	y += 6;
	out_XYAB('<path class="stroke" stroke-dasharray="6,6" d="mX YhA"/>\n',
		x, y, val)
	if (!defl.noen)
		out_XYAB('<path class="stroke" d="mX Yv6"/>\n', x + val, y)
}
function out_8vb(x, y, val, defl) {
	if (!defl.nost) {
		out_XYAB('<text x="X" y="Y" \
style="font-family:serif; font-weight:bold; font-style:italic; font-size:12px">8\
<tspan dy="-4" style="font-size:10px">vb</tspan></text>\n',
			x - 8, y);
		x += 4;
		val -= 4
	} else {
		val -= 5
	}
//	y -= 2;
	out_XYAB('<path class="stroke" stroke-dasharray="6,6" d="mX YhA"/>\n',
		x, y, val)
	if (!defl.noen)
		out_XYAB('<path class="stroke" d="mX Yv-6"/>\n', x + val, y)
}
function out_15ma(x, y, val, defl) {
	if (!defl.nost) {
		out_XYAB('<text x="X" y="Y" \
style="font-family:serif; font-weight:bold; font-style:italic; font-size:12px">15\
<tspan dy="-4" style="font-size:10px">ma</tspan></text>\n',
			x - 10, y);
		x += 20;
		val -= 20
	} else {
		val -= 5
	}
	y += 6;
	out_XYAB('<path class="stroke" stroke-dasharray="6,6" d="mX YhA"/>\n',
		x, y, val)
	if (!defl.noen)
		out_XYAB('<path class="stroke" d="mX Yv6"/>\n', x + val, y)
}
function out_15mb(x, y, val, defl) {
	if (!defl.nost) {
		out_XYAB('<text x="X" y="Y" \
style="font-family:serif; font-weight:bold; font-style:italic; font-size:12px">15\
<tspan dy="-4" style="font-size:10px">mb</tspan></text>\n',
			x - 10, y);
		x += 7;
		val -= 7
	} else {
		val -= 5
	}
//	y -= 2;
	out_XYAB('<path class="stroke" stroke-dasharray="6,6" d="mX YhA"/>\n',
		x, y, val)
	if (!defl.noen)
		out_XYAB('<path class="stroke" d="mX Yv-6"/>\n', x + val, y)
}
var deco_val_tb = {
	arp:	out_arp,
	cresc:	out_cresc,
	dim:	out_dim,
	ltr:	out_ltr,
	"8va":	out_8va,
	"8vb":	out_8vb,
	"15ma":	out_15ma,
	"15mb": out_15mb
}

function out_deco_val(x, y, name, val, defl) {
	if (deco_val_tb[name])
		deco_val_tb[name](x, y, val, defl)
	else
		error(1, null, "No function for decoration '$1'", name)
}

function out_glisq(x2, y2, de) {
	var	de1 = de.start,
		x1 = de1.x,
		y1 = de1.y + staff_tb[de1.st].y,
		ar = -Math.atan2(y2 - y1, x2 - x1),
		a = ar / Math.PI * 180,
		len = (x2 - x1) / Math.cos(ar);

	g_open(x1, y1, a);
	x1 = de1.s.dots ? 13 + de1.s.xmx : 8;
	len = (len - x1 - 6) / 6 | 0
	if (len < 1)
		len = 1
	while (--len >= 0) {
		xygl(x1, 0, "ltr");
		x1 += 6
	}
	g_close()
}

function out_gliss(x2, y2, de) {
	var	de1 = de.start,
		x1 = de1.x,
		y1 = de1.y + staff_tb[de1.st].y,
		ar = -Math.atan2(y2 - y1, x2 - x1),
		a = ar / Math.PI * 180,
		len = (x2 - x1) / Math.cos(ar);

	g_open(x1, y1, a);
	x1 = de1.s.dots ? 13 + de1.s.xmx : 8;
	len -= x1 + 8;
	xypath(x1, 0);
	output += 'l' + len.toFixed(2) + ' 0" stroke-width="1"/>\n';
	g_close()
}

var deco_l_tb = {
	glisq: out_glisq,
	gliss: out_gliss
}

function out_deco_long(x, y, de) {
	var	name = de.dd.glyph

	if (deco_l_tb[name])
		deco_l_tb[name](x, y, de)
	else
		error(1, null, "No function for decoration '$1'", name)
}

// update the vertical offset
function vskip(h) {
	posy += h
}

// create the SVG image of the block
function svg_flush() {
	if (multicol || !output || !user.img_out || posy == 0)
		return

    var	head = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1"\n\
	xmlns:xlink="http://www.w3.org/1999/xlink"\n\
	color="black" class="music" stroke-width=".7"',
	g = ''

	if (cfmt.bgcolor)
		head += ' style="background-color: ' + cfmt.bgcolor + '"';

	posy *= cfmt.scale

	if (user.imagesize) {
		head += '\n' +
			user.imagesize +
			' viewBox="0 0 ' + img.width.toFixed(0) + ' ' +
			 posy.toFixed(0) + '">\n'
	} else {
		head += '\n\twidth="' + img.width.toFixed(0) +
			'px" height="' + posy.toFixed(0) + 'px">\n'
	}

	if (style || font_style || musicfont) {
		head += '<style type="text/css">' + style + font_style
		if (musicfont) {
			if (musicfont.indexOf('(') > 0) {
				head += '\n\
.music {font-family: music; font-size: 24px; fill: currentColor}\n\
@font-face {\n\
  font-family: music;\n\
  src: ' + musicfont + '}';
			} else {
				head += '\n\
.music {font-family: '+ musicfont +'; font-size: 24px; fill: currentColor}'
			}
		}
		head += '\n</style>\n'
	}
	defs += fulldefs
	if (defs)
		head += '<defs>' + defs + '\n</defs>\n'

	// if %%pagescale != 1, do a global scale
	// (with a container: transform scale in <svg> does not work
	//	the same in all browsers)
	// the class is used to know that the container is global
	if (cfmt.scale != 1) {
		head += '<g class="g" transform="scale(' +
			cfmt.scale.toFixed(2) + ')">\n';
		g = '</g>\n'
	}

	if (psvg)			// if PostScript support
		psvg.ps_flush(true);	// + setg(0)

	user.img_out(head + output + g + "</svg>");
	output = ""

	font_style = ''
	if (cfmt.fullsvg) {
		defined_glyph = {}
		defined_font = {}
	} else {
		musicfont = '';
		style = '';
		fulldefs = ''
	}
	defs = '';
	posy = 0
}

// output a part of a block of images
function blk_out() {
	if (multicol || !user.img_out)
		return
	blk_flush()
	if (user.page_format && !block.started) {
		block.started = true
		if (block.newpage) {
			block.newpage = false;
			user.img_out('<div class="nobrk newpage">')
		} else {
			user.img_out('<div class="nobrk">')
		}
	}
}
Abc.prototype.blk_out = blk_out

// output the end of a block (or tune)
function blk_flush() {
	svg_flush()
	if (block.started) {
		block.started = false;
		user.img_out('</div>')
	}
}
Abc.prototype.blk_flush = blk_flush
// abc2svg - tune.js - tune generation
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

var	par_sy,		// current staff system for parse
	cur_sy,		// current staff system for generation
	voice_tb,
	curvoice,
	staves_found,
	vover,		// voice overlay
	tsfirst

/* apply the %%voice options of the current voice */
function voice_filter() {
	var opt, sel, i

	for (opt in parse.voice_opts) {
		if (!parse.voice_opts.hasOwnProperty(opt))
			continue
		sel = new RegExp(opt)
		if (sel.test(curvoice.id)
		 || sel.test(curvoice.nm)) {
			for (i in parse.voice_opts[opt])
			    if (parse.voice_opts[opt].hasOwnProperty(i))
				do_pscom(parse.voice_opts[opt][i])
		}
	}
}

/* -- link a ABC symbol into the current voice -- */
function sym_link(s) {
	if (!s.fname)
		set_ref(s)
	if (!curvoice.ignore) {
		parse.last_sym = s;
		s.prev = curvoice.last_sym
		if (curvoice.last_sym)
			curvoice.last_sym.next = s
		else
			curvoice.sym = s;
		curvoice.last_sym = s
	}
	s.v = curvoice.v;
	s.p_v = curvoice;
	s.st = curvoice.cst;
	s.time = curvoice.time
	if (s.dur && !s.grace)
		curvoice.time += s.dur;
	s.pos = curvoice.pos
	if (curvoice.second)
		s.second = true
	if (curvoice.floating)
		s.floating = true
}

/* -- add a new symbol in a voice -- */
function sym_add(p_voice, type) {
	var	s = {
			type:type,
			dur:0
		},
		s2,
		p_voice2 = curvoice;

	curvoice = p_voice;
	sym_link(s);
	curvoice = p_voice2;
	s2 = s.prev
	if (!s2)
		s2 = s.next
	if (s2) {
		s.fname = s2.fname;
		s.istart = s2.istart;
		s.iend = s2.iend
	}
	return s
}

/* -- expand a multi-rest into single rests and measure bars -- */
function mrest_expand(s) {
	var	p_voice, s2, next,
		nb = s.nmes,
		dur = s.dur / nb

	/* change the multi-rest (type bar) to a single rest */
	var a_dd = s.a_dd;
	s.type = C.REST;
	s.dur = dur;
	s.head = C.FULL;
	s.nflags = -2;

	/* add the bar(s) and rest(s) */
	next = s.next;
	p_voice = s.p_v;
	p_voice.last_sym = s;
	p_voice.time = s.time + dur;
	p_voice.cst = s.st;
	s2 = s
	while (--nb > 0) {
		s2 = sym_add(p_voice, C.BAR);
		s2.bar_type = "|";
		s2 = sym_add(p_voice, C.REST);
		if (s.invis)
			s2.invis = true;
		s2.dur = dur;
		s2.head = C.FULL;
		s2.nflags = -2;
		p_voice.time += dur
	}
	s2.next = next
	if (next)
		next.prev = s2;

	/* copy the mrest decorations to the last rest */
	s2.a_dd = a_dd
}

/* -- sort all symbols by time and vertical sequence -- */
// weight of the symbols !! depends on the symbol type !!
var w_tb = new Uint8Array([
	2,	// bar
	1,	// clef
	8,	// custos
	0,	// (free)
	3,	// grace
	5,	// key
	6,	// meter
	9,	// mrest
	9,	// note
	0,	// part
	9,	// rest
	3,	// space
	0,	// staves
	7,	// stbrk
	0,	// tempo
	0,	// (free)
	0,	// block
	0	// remark
])

function sort_all() {
	var	s, s2, p_voice, v, time, w, wmin, ir, multi,
		prev, nb, ir2, v2, sy,
		nv = voice_tb.length,
		vtb = [],
		vn = [],			/* voice indexed by range */
		mrest_time = -1

	for (v = 0; v < nv; v++)
		vtb.push(voice_tb[v].sym)

	/* initialize the voice order */
	var	fl = 1,				// start a new time sequence
		new_sy = cur_sy

	while (1) {
		if (new_sy && fl) {
			sy = new_sy;
			new_sy = null;
			multi = -1;
			vn = []
			for (v = 0; v < nv; v++) {
				if (!sy.voices[v]) {
					sy.voices[v] = {
						range: -1
					}
					continue
				}
				ir = sy.voices[v].range
				if (ir < 0)
					continue
				vn[ir] = v;
				multi++
			}
		}

		/* search the min time and symbol weight */
		wmin = time = 1000000				/* big int */
		for (ir = 0; ir < nv; ir++) {
			v = vn[ir]
			if (v == undefined)
				break
			s = vtb[v]
			if (!s || s.time > time)
				continue
			w = w_tb[s.type]
			if (s.time < time) {
				time = s.time;
				wmin = w
			} else if (w < wmin) {
				wmin = w
			}
			if (s.type == C.MREST) {
				if (s.nmes == 1)
					mrest_expand(s)
				else if (multi > 0)
					mrest_time = time
			}
		}

		if (wmin > 127)
			break			// done

		/* if some multi-rest and many voices, expand */
		if (time == mrest_time) {
			nb = 0
			for (ir = 0; ir < nv; ir++) {
				v = vn[ir]
				if (v == undefined)
					break
				s = vtb[v]
				if (!s || s.time != time
				 || w_tb[s.type] != wmin)
					continue
				if (s.type != C.MREST) {
					mrest_time = -1 /* some note or rest */
					break
				}
				if (nb == 0) {
					nb = s.nmes
				} else if (nb != s.nmes) {
					mrest_time = -1	/* different duration */
					break
				}
			}
			if (mrest_time < 0) {
				for (ir = 0; ir < nv; ir++) {
					v = vn[ir]
					if (v == undefined)
						break
					s = vtb[v]
					if (s && s.type == C.MREST)
						mrest_expand(s)
				}
			}
		}

		/* link the vertical sequence */
		for (ir = 0; ir < nv; ir++) {
			v = vn[ir]
			if (v == undefined)
				break
			s = vtb[v]
			if (!s || s.time != time
			 || w_tb[s.type] != wmin)
				continue
			if (s.type == C.STAVES) {
				new_sy = s.sy;

				// set all voices of previous and next staff systems
				// as reachable
				for (ir2 = 0; ir2 < nv; ir2++) {
					if (vn[ir2] == undefined)
						break
				}
				for (v2 = 0; v2 < nv; v2++) {
					if (!new_sy.voices[v2])
						continue
					ir = new_sy.voices[v2].range
					if (ir < 0
					 || sy.voices[v2].range >= 0)
						continue
					vn[ir2++] = v2
				}
			}
			if (fl) {
				fl = 0;
				s.seqst = true
			}
			s.ts_prev = prev
			if (prev)
				prev.ts_next = s
			else
				tsfirst = s;
			prev = s

			vtb[v] = s.next
		}
		fl = wmin		/* start a new sequence if some width */
	}
}

// adjust some voice elements
function voice_adj() {
	var p_voice, s, s2, v

	// set the duration of the notes under a feathered beam
	function set_feathered_beam(s1) {
		var	s, s2, t, d, b, i, a,
			d = s1.dur,
			n = 1

		/* search the end of the beam */
		for (s = s1; s; s = s.next) {
			if (s.beam_end || !s.next)
				break
			n++
		}
		if (n <= 1) {
			delete s1.feathered_beam
			return
		}
		s2 = s;
		b = d / 2;		/* smallest note duration */
		a = d / (n - 1);	/* delta duration */
		t = s1.time
		if (s1.feathered_beam > 0) {	/* !beam-accel! */
			for (s = s1, i = n - 1;
			     s != s2;
			     s = s.next, i--) {
				d = ((a * i) | 0) + b;
				s.dur = d;
				s.time = t;
				t += d
			}
		} else {				/* !beam-rall! */
			for (s = s1, i = 0;
			     s != s2;
			     s = s.next, i++) {
				d = ((a * i) | 0) + b;
				s.dur = d;
				s.time = t;
				t += d
			}
		}
		s.dur = s.time + s.dur - t;
		s.time = t
	} // end set_feathered_beam()

	/* if Q: from tune header, put it at start of the music */
	s = glovar.tempo
	if (s && staves_found <= 0) {	// && !s.del) {		- play problem
		v = par_sy.top_voice;
		p_voice = voice_tb[v];
		if (p_voice.sym && p_voice.sym.type != C.TEMPO) {
			s = clone(s);
			s.v = v;
			s.p_v = p_voice;
			s.st = p_voice.st;
			s.time = 0;
			s.next = p_voice.sym
			if (s.next)
				s.next.prev = s;
			p_voice.sym = s
		}
	}

	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (p_voice.ignore)
			p_voice.ignore = false
		for (s = p_voice.sym; s; s = s.next) {
			if (s.time >= staves_found)
				break
		}
		for ( ; s; s = s.next) {
			switch (s.type) {
			case C.GRACE:
				// with w_tb[C.BAR] = 2,
				// the grace notes go after the bar;
				// if before a bar, change the grace time
				if (s.next && s.next.type == C.BAR)
					s.time--

				if (!cfmt.graceword)
					continue
				for (s2 = s.next; s2; s2 = s2.next) {
					switch (s2.type) {
					case C.SPACE:
						continue
					case C.NOTE:
						if (!s2.a_ly)
							break
						s.a_ly = s2.a_ly;
						s2.a_ly = null
						break
					}
					break
				}
				continue
			}

			if (s.feathered_beam)
				set_feathered_beam(s)
		}
	}
}

/* -- duplicate the voices as required -- */
function dupl_voice() {
	var	p_voice, p_voice2, s, s2, g, g2, v, i,
		nv = voice_tb.length

	for (v = 0; v < nv; v++) {
		p_voice = voice_tb[v];
		p_voice2 = p_voice.clone
		if (!p_voice2)
			continue
		p_voice.clone = null
		for (s = p_voice.sym; s; s = s.next) {
//fixme: there may be other symbols before the %%staves at this same time
			if (s.time >= staves_found)
				break
		}
		p_voice2.clef = clone(p_voice.clef);
		curvoice = p_voice2
		for ( ; s; s = s.next) {
			if (s.type == C.STAVES)
				continue
			s2 = clone(s)
			if (s.notes) {
				s2.notes = []
				for (i = 0; i <= s.nhd; i++)
					s2.notes.push(clone(s.notes[i]))
			}
			sym_link(s2)
//			s2.time = s.time
			if (p_voice2.second)
				s2.second = true
			else
				delete s2.second
			if (p_voice2.floating)
				s2.floating = true
			else
				delete s2.floating
			delete s2.a_ly;
			g = s2.extra
			if (!g)
				continue
			g2 = clone(g);
			s2.extra = g2;
			s2 = g2;
			s2.v = p_voice2.v;
			s2.p_v = p_voice2;
			s2.st = p_voice2.st
			for (g = g.next; g; g = g.next) {
				g2 = clone(g)
				if (g.notes) {
					g2.notes = []
					for (i = 0; i <= g.nhd; i++)
						g2.notes.push(clone(g.notes[i]))
				}
				s2.next = g2;
				g2.prev = s2;
				s2 = g2;
				s2.v = p_voice2.v;
				s2.p_v = p_voice2;
				s2.st = p_voice2.st
			}
		}
	}
}

/* -- create a new staff system -- */
function new_syst(init) {
	var	st, v,
		sy_new = {
			voices: [],
			staves: [],
			top_voice: 0
		}

	if (init) {				/* first staff system */
		cur_sy = par_sy = sy_new
		return
	}

	// update the previous system
	for (v = 0; v < voice_tb.length; v++) {
		st = par_sy.voices[v].st
		var	sy_staff = par_sy.staves[st],
			p_voice = voice_tb[v]
		if (p_voice.staffnonote != undefined)
			sy_staff.staffnonote = p_voice.staffnonote
		if (p_voice.staffscale)
			sy_staff.staffscale = p_voice.staffscale;
		sy_new.voices[v] = clone(par_sy.voices[v]);
		sy_new.voices[v].range = -1;
		delete sy_new.voices[v].second
	}
	for (st = 0; st < par_sy.staves.length; st++) {
		sy_new.staves[st] = clone(par_sy.staves[st]);
		sy_new.staves[st].flags = 0
	}
	par_sy.next = sy_new;
	par_sy = sy_new
}

/* -- set the bar numbers -- */
function set_bar_num() {
	var	s, s2, tim, bar_time, bar_num, rep_dtime,
		v = cur_sy.top_voice,
		wmeasure = voice_tb[v].meter.wmeasure,
		bar_rep = gene.nbar

	/* don't count a bar at start of line */
	for (s = tsfirst; ; s = s.ts_next) {
		if (!s)
			return
		switch (s.type) {
		case C.METER:
			wmeasure = s.wmeasure
		case C.CLEF:
		case C.KEY:
		case C.STBRK:
			continue
		case C.BAR:
			if (s.bar_num) {
				gene.nbar = s.bar_num	/* (%%setbarnb) */
				break
			}
			if (s.text			// if repeat bar
			 && !cfmt.contbarnb) {
				if (s.text[0] == '1') {
					bar_rep = gene.nbar
				} else {
					gene.nbar = bar_rep; /* restart bar numbering */
					s.bar_num = gene.nbar
				}
			}
			break
		}
		break
	}

	// at start of tune, check for an anacrusis
	bar_time = s.time + wmeasure
	if (s.time == 0) {
		for (s2 = s.ts_next; s2; s2 = s2.ts_next) {
			if (s2.type == C.BAR && s2.time) {
				if (s2.time < bar_time) {	// if anacrusis
					s = s2;
					bar_time = s.time + wmeasure
				}
				break
			}
		}
	}

	// set the measure number on the top bars
	bar_num = gene.nbar

	for ( ; s; s = s.ts_next) {
		switch (s.type) {
		case C.METER:
			wmeasure = s.wmeasure
			if (s.time < bar_time)
				bar_time = s.time + wmeasure
			break
		case C.MREST:
			bar_num += s.nmes - 1
			while (s.ts_next
			    && s.ts_next.type != C.BAR)
				s = s.ts_next
			break
		case C.BAR:
			if (s.bar_num)
				bar_num = s.bar_num	// (%%setbarnb)
			if (s.time < bar_time) {	// incomplete measure
				if (s.text && s.text[0] == '1') {
					bar_rep = bar_num;
					rep_dtime = bar_time - s.time
				}
				break
			}

			/* check if any repeat bar at this time */
			tim = s.time;
			s2 = s
			do {
				if (s2.dur)
					break
				if (s2.type == C.BAR && s2.text)	// if repeat bar
					break
				s2 = s2.next
			} while (s2 && s2.time == tim);
			bar_num++
			if (s2 && s2.type == C.BAR && s2.text) {
				if (s2.text[0] == '1') {
					rep_dtime = 0;
					bar_rep = bar_num
				} else {			// restart bar numbering
					if (!cfmt.contbarnb)
						bar_num = bar_rep
					if (rep_dtime) {	// [1 inside measure
						if (cfmt.contbarnb)
							bar_num--;
						bar_time = tim + rep_dtime
						break
					}
				}
			}
			s.bar_num = bar_num;
			bar_time = tim + wmeasure

			// skip the bars of the other voices
			while (s.ts_next
			    && !s.ts_next.seqst)
				s = s.ts_next
			break
		}
	}
	if (cfmt.measurenb < 0)		/* if no display of measure bar */
		gene.nbar = bar_num	/* update in case of more music to come */
}

// note mapping
// %%map map_name note [print [note_head]] [param]*
function get_map(text) {
	if (!text)
		return

	var	i, note, notes, map, tmp, ns,
		a = info_split(text, 2)

	if (a.length < 3) {
		syntax(1, "Not enough parameters in %%map")
		return
	}
	ns = a[1]
	if (ns.indexOf("octave,") == 0
	 || ns.indexOf("key,") == 0) {		// remove the octave part
		ns = ns.replace(/[,']+$/m, '').toLowerCase(); //'
		if (ns[0] == 'k')		// remove the accidental part
			ns = ns.replace(/[_=^]+/, '')
	} else if (ns[0] == '*' || ns.indexOf("all") == 0) {
		ns = 'all'
	} else {				// exact pitch, rebuild the note
		tmp = new scanBuf();
		tmp.buffer = a[1];
		note = parse_acc_pit(tmp)
		if (!note) {
			syntax(1, "Bad note in %%map")
			return
		}
		ns = 'abcdefg'[(note.pit + 77) % 7]
		if (note.acc)
			ns = ['__', '_', '', '^', '^^', '='][note.acc + 2] + ns
		for (i = note.pit; i >= 28; i -= 7)
			ns += "'"
		for (i = note.pit; i < 21; i += 7)
			ns += ","
	}

	notes = maps[a[0]]
	if (!notes)
		maps[a[0]] = notes = {}
	map = notes[ns]
	if (!map)
		notes[ns] = map = []

	/* try the optional 'print' and 'heads' parameters */
	if (!a[2])
		return
	i = 2
	if (a[2].indexOf('=') < 0) {
		if (a[2][0] != '*') {
			tmp = new scanBuf();		// print
			tmp.buffer = a[2];
			map[1] = parse_acc_pit(tmp)
		}
		if (!a[3])
			return
		i++
		if (a[3].indexOf('=') < 0) {
			map[0] = a[3].split(',');
			i++
		}
	}

	for (; i < a.length; i++) {
		switch (a[i]) {
		case "heads=":
			map[0] = a[++i].split(',')
			break
		case "print=":
			tmp = new scanBuf();
			tmp.buffer = a[++i];
			map[1] = parse_acc_pit(tmp)
			break
//		case "transpose=":
//			switch (a[++i][0]) {
//			case "n":
//				map[2] = false
//				break
//			case "y":
//				map[2] = true
//				break
//			}
//			break
		case "color=":
			map[2] = a[++i]
			break
		}
	}
}

// set the transposition in the previous or starting key
function set_transp() {
	var	s, transp, vtransp

	if (curvoice.ckey.k_bagpipe || curvoice.ckey.k_drum)
		return

	if (cfmt.transp && curvoice.transp)	// if %%transpose and score=
		syntax(0, "Mix of old and new transposition syntaxes");

	transp = (cfmt.transp || 0) +		// %%transpose
		(curvoice.transp || 0) +	// score= / sound=
		(curvoice.shift || 0);		// shift=
	vtransp = curvoice.vtransp || 0
	if (transp == vtransp)
		return

	curvoice.vtransp = transp;

	s = curvoice.last_sym
	if (!s) {				// no symbol yet
		curvoice.key = clone(curvoice.okey);
		key_transp(curvoice.key);
		curvoice.ckey = clone(curvoice.key)
		if (curvoice.key.k_none)
			curvoice.key.k_sf = 0
		return
	}

	// set the transposition in the previous K:
	while (1) {
		if (s.type == C.KEY)
			break
		if (!s.prev) {
			s = curvoice.key
			break
		}
		s = s.prev
	}
	key_transp(s);
	curvoice.ckey = clone(s)
	if (curvoice.key.k_none)
		s.k_sf = 0
}

function set_ottava(dcn) {
	if (cfmt.sound)
		return
	switch (dcn) {
	case "15ma(":
		curvoice.ottava = -14
		break
	case "8va(":
		curvoice.ottava = -7
		break
	case "8vb(":
		curvoice.ottava = 7
		break
	case "15mb(":
		curvoice.ottava = 14
		break
	case "15ma)":
	case "8va)":
	case "8vb)":
	case "15mb)":
		curvoice.ottava = 0
		break
	}
}

/* -- process a pseudo-comment (%% or I:) -- */
function do_pscom(text) {
	var	h1, val, s, cmd, param, n, k, b,
		lock = false

	if (text.slice(-5) == ' lock') {
		lock = true;
		text = text.slice(0, -5).trim()
	}
	cmd = text.match(/(\w|-)+/)
	if (!cmd)
		return
	cmd = cmd[0];
	param = text.replace(cmd, '').trim()
	switch (cmd) {
	case "center":
		if (parse.state >= 2) {
			s = new_block("text");
			s.text = cnv_escape(param);
			s.opt = 'c'
			return
		}
		write_text(cnv_escape(param), 'c')
		return
	case "clef":
		if (parse.state >= 2) {
			if (parse.state == 2)
				goto_tune();
			s = new_clef(param)
			if (s)
				get_clef(s)
		}
		return
	case "deco":
		deco_add(param)
		return
	case "linebreak":
		set_linebreak(param)
		return
	case "map":
		get_map(param)
		return
	case "maxsysstaffsep":
		if (parse.state == 3) {
			par_sy.voices[curvoice.v].maxsep = get_unit(param)
			return
		}
		break
	case "multicol":
		generate()
		switch (param) {
		case "start":
			blk_out();
			multicol = {
				posy: posy,
				maxy: posy,
				lmarg: cfmt.leftmargin,
				rmarg: cfmt.rightmargin,
				state: parse.state
			}
			break
		case "new":
			if (!multicol) {
				syntax(1, "%%multicol new without start")
				break
			}
			if (posy > multicol.maxy)
				multicol.maxy = posy;
			cfmt.leftmargin = multicol.lmarg;
			cfmt.rightmargin = multicol.rmarg;
			img.chg = true;
			set_page();
			posy = multicol.posy
			break
		case "end":
			if (!multicol) {
				syntax(1, "%%multicol end without start")
				break
			}
			if (posy < multicol.maxy)
				posy = multicol.maxy;
			cfmt.leftmargin = multicol.lmarg;
			cfmt.rightmargin = multicol.rmarg;
			multicol = undefined;
			blk_flush();
			img.chg = true;
			set_page()
			break
		default:
			syntax(1, "Unknown keyword '$1' in %%multicol", param)
			break
		}
		return
	case "musicfont":
		musicfont = param
		return
	case "ottava":
		if (parse.state != 3) {
			if (parse.state != 2)
				return
			goto_tune()
		}
		n = parseInt(param)
		if (isNaN(n) || n < -2 || n > 2) {
			syntax(1, errs.bad_val, "%%ottava")
			return
		}
		switch (curvoice.ottava) {
		case 14: b = "15mb)"; break
		case 7: b = "8vb)"; break
		case -7: b = "8va)"; break
		case -14: b = "15ma)"; break
		}
		if (b) {
			if (!a_dcn)
				a_dcn = []
			a_dcn.push(b);
			set_ottava(b)
		}
		switch (n) {
		case -2: b = "15mb("; break
		case -1: b = "8vb("; break
		case 0: return
		case 1: b = "8va("; break
		case 2: b = "15ma("; break
		}
		if (!a_dcn)
			a_dcn = []
		a_dcn.push(b);
		set_ottava(b)
		return
	case "repbra":
		if (parse.state >= 2) {
			if (parse.state == 2)
				goto_tune();
			curvoice.norepbra = !get_bool(param)
		}
		return
	case "repeat":
		if (parse.state != 3)
			return
		if (!curvoice.last_sym) {
			syntax(1, "%%repeat cannot start a tune")
			return
		}
		if (!param.length) {
			n = 1;
			k = 1
		} else {
			b = param.split(/\s+/);

			n = parseInt(b[0]);
			k = parseInt(b[1])
			if (isNaN(n) || n < 1
			 || (curvoice.last_sym.type == C.BAR
			  && n > 2)) {
				syntax(1, "Incorrect 1st value in %%repeat")
				return
			}
			if (isNaN(k)) {
				k = 1
			} else {
				if (k < 1) {
					syntax(1, "Incorrect 2nd value in %%repeat")
					return
				}
			}
		}
		parse.repeat_n = curvoice.last_sym.type == C.BAR ? n : -n;
		parse.repeat_k = k
		return
	case "sep":
		var	h2, len, values, lwidth;

		set_page();
		lwidth = img.width - img.lm - img.rm;
		h1 = h2 = len = 0
		if (param) {
			values = param.split(/\s+/);
			h1 = get_unit(values[0])
			if (values[1]) {
				h2 = get_unit(values[1])
				if (values[2])
					len = get_unit(values[2])
			}
		}
		if (h1 < 1)
			h1 = 14
		if (h2 < 1)
			h2 = h1
		if (len < 1)
			len = 90
		if (parse.state >= 2) {
			s = new_block(cmd);
			s.x = (lwidth - len) / 2 / cfmt.scale;
			s.l = len / cfmt.scale;
			s.sk1 = h1;
			s.sk2 = h2
			return
		}
		blk_out();
		vskip(h1);
		output += '<path class="stroke"\n\td="M';
		out_sxsy((lwidth - len) / 2 / cfmt.scale, ' ', 0);
		output += 'h' + (len / cfmt.scale).toFixed(2) + '"/>\n';
		vskip(h2);
		blk_flush()
		return
	case "setbarnb":
		val = parseInt(param)
		if (isNaN(val))
			syntax(1, "Bad %%setbarnb value")
		else if (parse.state >= 2)
			glovar.new_nbar = val
		else
			cfmt.measurefirst = val
		return
	case "staff":
		if (parse.state != 3) {
			if (parse.state != 2)
				return
			goto_tune()
		}
		val = parseInt(param)
		if (isNaN(val)) {
			syntax(1, "Bad %%staff value '$1'", param)
			return
		}
		var st
		if (param[0] == '+' || param[0] == '-')
			st = curvoice.cst + val
		else
			st = val - 1
		if (st < 0 || st > nstaff) {
			syntax(1, "Bad %%staff number $1 (cur $2, max $3)",
					st, curvoice.cst, nstaff)
			return
		}
		delete curvoice.floating;
		curvoice.cst = st
		return
	case "staffbreak":
		if (parse.state != 3) {
			if (parse.state != 2)
				return
			goto_tune()
		}
		s = {
			type: C.STBRK,
			dur:0
		}
		if (param[0] >= '0' && param[0] <= '9') {
			s.xmx = get_unit(param)
			if (param.slice(-1) == 'f')
				s.stbrk_forced = true
		} else {
			s.xmx = 14
			if (param[0] == 'f')
				s.stbrk_forced = true
		}
		sym_link(s)
		return
	case "stafflines":
	case "staffscale":
	case "staffnonote":
		set_v_param(cmd, param)
		return
	case "staves":
	case "score":
		if (parse.state == 0)
			return
		get_staves(cmd, param)
		return
	case "sysstaffsep":
//--fixme: may be global
		if (parse.state == 3) {
			par_sy.voices[curvoice.v].sep = get_unit(param)
			return
		}
		break
	case "text":
		if (parse.state >= 2) {
			s = new_block(cmd);
			s.text = cnv_escape(param);
			s.opt = cfmt.textoption
			return
		}
		write_text(cnv_escape(param), cfmt.textoption)
		return
	case "transpose":		// (abcm2ps compatibility)
		if (cfmt.sound)
			return
		switch (parse.state) {
		case 0:
			cfmt.transp = 0
			// fall thru
		case 1:
		case 2:
			cfmt.transp = (cfmt.transp || 0) + get_transp(param)
			return
//		case 2:
//			goto_tune()
//			break
		}
		for (s = curvoice.last_sym; s; s = s.prev) {
			switch (s.type) {
			case C.NOTE:		// insert a key
				s = clone(curvoice.okey);
				s.k_old_sf = curvoice.ckey.k_sf;
				sym_link(s)
				break
			case C.KEY:
				break
			default:
				continue
			}
			break
		}
		do_info('V', curvoice.id + ' shift=' + param)
		return
	case "tune":
//fixme: to do
		return
	case "user":
		set_user(param)
		return
	case "voicecolor":
		if (parse.state != 3) {
			if (parse.state != 2)
				return
			goto_tune()
		}
		curvoice.color = param
		return
	case "vskip":
		val = get_unit(param)
		if (val < 0) {
			syntax(1, "%%vskip cannot be negative")
			return
		}
		if (parse.state >= 2) {
			s = new_block(cmd);
			s.sk = val
			return
		}
		vskip(val);
		return
	case "newpage":
	case "leftmargin":
	case "rightmargin":
	case "pagescale":
	case "pagewidth":
	case "printmargin":
	case "scale":
	case "staffwidth":
		if (parse.state == 3) {			// tune body
			s = new_block(cmd);
			s.param = param
			return
		}
		if (cmd == "newpage") {
			blk_flush();
			block.newpage = true;
			return
		}
		break
	}
	set_format(cmd, param, lock)
}

// treat the %%beginxxx / %%endxxx sequences
function do_begin_end(type,
			opt,
			text) {
	var i, j, action, s

	switch (type) {
	case "js":
		js_inject(text)
		break
	case "ml":
		if (parse.state >= 2) {
			s = new_block(type);
			s.text = text
		} else {
			svg_flush();
			user.img_out(text)
		}
		break
	case "svg":
		j = 0
		while (1) {
			i = text.indexOf('<style type="text/css">\n', j)
			if (i < 0)
				break
			j = text.indexOf('</style>', i)
			if (j < 0) {
				syntax(1, "No </style> in %%beginsvg sequence")
				break
			}
			style += text.slice(i + 23, j).replace(/\s+$/, '')
		}
		j = 0
		while (1) {
			i = text.indexOf('<defs>\n', j)
			if (i < 0)
				break
			j = text.indexOf('</defs>', i)
			if (j < 0) {
				syntax(1, "No </defs> in %%beginsvg sequence")
				break
			}
			defs_add(text.slice(i + 6, j))
		}
		break
	case "text":
		action = get_textopt(opt);
		if (!action)
			action = cfmt.textoption
		if (parse.state >= 2) {
			s = new_block(type);
			s.text = cnv_escape(text);
			s.opt = action
			break
		}
		write_text(cnv_escape(text), action)
		break
	}
}

/* -- generate a piece of tune -- */
function generate() {
	var v, p_voice;

	if (vover) {
		syntax(1, "No end of voice overlay");
		get_vover(vover.bar ? '|' : ')')
	}

	if (voice_tb.length == 0)
		return
	voice_adj();
	dupl_voice();
	sort_all()			/* define the time / vertical sequences */
	if (!tsfirst)
		return
	set_bar_num()
	if (!tsfirst)
		return				/* no more symbol */

	// give the parser result to the application
	if (user.get_abcmodel)
		user.get_abcmodel(tsfirst, voice_tb, anno_type, info)

	if (user.img_out)		// if SVG generation
		output_music()

	/* reset the parser */
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v];
		p_voice.time = 0;
		p_voice.sym = p_voice.last_sym = null;
		p_voice.st = cur_sy.voices[v].st;
		p_voice.second = cur_sy.voices[v].second;
//		p_voice.clef.time = 0;
		delete p_voice.have_ly;
		p_voice.hy_st = 0;
		delete p_voice.bar_start
		delete p_voice.slur_st
		delete p_voice.s_tie
		delete p_voice.s_rtie
	}
	staves_found = 0			// (for compress/dup the voices)
}

// transpose a key
//fixme: transpose of the accidental list is not done
function key_transp(s_key) {
	var	t = (curvoice.vtransp / 3) | 0,
		sf = (t & ~1) + (t & 1) * 7 + s_key.k_sf

	switch ((curvoice.vtransp + 210) % 3) {
	case 1:
		sf = (sf + 4 + 12 * 4) % 12 - 4	/* more sharps */
		break
	case 2:
		sf = (sf + 7 + 12 * 4) % 12 - 7	/* more flats */
		break
	default:
		sf = (sf + 5 + 12 * 4) % 12 - 5	/* Db, F# or B */
		break
	}
	s_key.k_sf = sf;
	s_key.k_delta = cgd2cde[(sf + 7) % 7]
}

/* -- set the accidentals when K: with modified accidentals -- */
function set_k_acc(s) {
	var i, j, n, nacc, p_acc,
		accs = [],
		pits = [],
		m_n = [],
		m_d = []

	if (s.k_sf > 0) {
		for (nacc = 0; nacc < s.k_sf; nacc++) {
			accs[nacc] = 1;			// sharp
			pits[nacc] = [26, 23, 27, 24, 21, 25, 22][nacc]
		}
	} else {
		for (nacc = 0; nacc < -s.k_sf; nacc++) {
			accs[nacc] = -1;		// flat
			pits[nacc] = [22, 25, 21, 24, 20, 23, 26][nacc]
		}
	}
	n = s.k_a_acc.length
	for (i = 0; i < n; i++) {
		p_acc = s.k_a_acc[i]
		for (j = 0; j < nacc; j++) {
			if (pits[j] == p_acc.pit) {
				accs[j] = p_acc.acc
				if (p_acc.micro_n) {
					m_n[j] = p_acc.micro_n;
					m_d[j] = p_acc.micro_d
				}
				break
			}
		}
		if (j == nacc) {
			accs[j] = p_acc.acc;
			pits[j] = p_acc.pit
			if (p_acc.micro_n) {
				m_n[j] = p_acc.micro_n;
				m_d[j] = p_acc.micro_d
			}
			nacc++
		}
	}
	for (i = 0; i < nacc; i++) {
		p_acc = s.k_a_acc[i]
		if (!p_acc)
			p_acc = s.k_a_acc[i] = {}
		p_acc.acc = accs[i];
		p_acc.pit = pits[i]
		if (m_n[i]) {
			p_acc.micro_n = m_n[i];
			p_acc.micro_d = m_d[i]
		} else {
			delete p_acc.micro_n
			delete p_acc.micro_d
		}
	}
}

/*
 * for transpose purpose, check if a pitch is already in the measure or
 * if it is tied from a previous note, and return the associated accidental
 */
function acc_same_pitch(pitch) {
	var	i, time,
		s = curvoice.last_sym.prev

	if (!s)
		return //undefined;

	time = s.time

	for (; s; s = s.prev) {
		switch (s.type) {
		case C.BAR:
			if (s.time < time)
				return //undefined // no same pitch
			while (1) {
				s = s.prev
				if (!s)
					return //undefined
				if (s.type == C.NOTE) {
					if (s.time + s.dur == time)
						break
					return //undefined
				}
				if (s.time < time)
					return //undefined
			}
			for (i = 0; i <= s.nhd; i++) {
				if (s.notes[i].pit == pitch
				 && s.notes[i].ti1)
					return s.notes[i].acc
			}
			return //undefined
		case C.NOTE:
			for (i = 0; i <= s.nhd; i++) {
				if (s.notes[i].pit == pitch)
					return s.notes[i].acc
			}
			break
		}
	}
	return //undefined
}

/* -- get staves definition (%%staves / %%score) -- */
function get_staves(cmd, parm) {
	var	s, p_voice, p_voice2, i, flags, v, vid,
		st, range,
		a_vf = parse_staves(parm) // array of [vid, flags]

	if (!a_vf)
		return

	if (voice_tb.length != 0) {
		voice_adj();
		dupl_voice()
	}

	/* create a new staff system */
	var	maxtime = 0,
		no_sym = true

	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (p_voice.time > maxtime)
			maxtime = p_voice.time
		if (p_voice.sym)
			no_sym = false
	}
	if (no_sym				/* if first %%staves */
	 || (maxtime == 0 && staves_found < 0)) {
		for (v = 0; v < par_sy.voices.length; v++)
			par_sy.voices[v].range = -1
	} else {

		/*
		 * create a new staff system and
		 * link the 'staves' symbol in a voice which is seen from
		 * the previous system - see sort_all
		 */
		for (v = 0; v < par_sy.voices.length; v++) {
			if (par_sy.voices[v].range >= 0) {
				curvoice = voice_tb[v]
				break
			}
		}
		curvoice.time = maxtime;
		s = {
			type: C.STAVES,
			dur: 0
		}

		sym_link(s);		// link the staves in this voice
		par_sy.nstaff = nstaff;
		new_syst();
		s.sy = par_sy
	}

	staves_found = maxtime

	/* initialize the (old) voices */
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		delete p_voice.second
		delete p_voice.ignore
		delete p_voice.floating
	}
	range = 0
	for (i = 0; i < a_vf.length; i++) {
		vid = a_vf[i][0];
		p_voice = new_voice(vid);
		p_voice.time = maxtime;
		v = p_voice.v
		if (i == 0)
			par_sy.top_voice = p_voice.v

		// if the voice is already here, clone it
		if (par_sy.voices[v].range >= 0) {
			p_voice2 = clone(p_voice);
			par_sy.voices[voice_tb.length] = clone(par_sy.voices[v]);
			v = voice_tb.length;
			p_voice2.v = v;
			p_voice2.sym = p_voice2.last_sym = null;
			p_voice2.time = maxtime;
			voice_tb.push(p_voice2)
			delete p_voice2.clone
			while (p_voice.clone)
				p_voice = p_voice.clone;
			p_voice.clone = p_voice2;
			p_voice = p_voice2
		}
		a_vf[i][0] = p_voice;
		par_sy.voices[v].range = range++
	}

	/* change the behavior from %%staves to %%score */
	if (cmd[1] == 't') {				/* if %%staves */
		for (i = 0; i < a_vf.length; i++) {
			flags = a_vf[i][1]
			if (!(flags & (OPEN_BRACE | OPEN_BRACE2)))
				continue
			if ((flags & (OPEN_BRACE | CLOSE_BRACE))
					== (OPEN_BRACE | CLOSE_BRACE)
			 || (flags & (OPEN_BRACE2 | CLOSE_BRACE2))
					== (OPEN_BRACE2 | CLOSE_BRACE2))
				continue
			if (a_vf[i + 1][1] != 0)
				continue
			if ((flags & OPEN_PARENTH)
			 || (a_vf[i + 2][1] & OPEN_PARENTH))
				continue

			/* {a b c} -> {a *b c} */
			if (a_vf[i + 2][1] & (CLOSE_BRACE | CLOSE_BRACE2)) {
				a_vf[i + 1][1] |= FL_VOICE

			/* {a b c d} -> {(a b) (c d)} */
			} else if (a_vf[i + 2][1] == 0
				&& (a_vf[i + 3][1]
					& (CLOSE_BRACE | CLOSE_BRACE2))) {
				a_vf[i][1] |= OPEN_PARENTH;
				a_vf[i + 1][1] |= CLOSE_PARENTH;
				a_vf[i + 2][1] |= OPEN_PARENTH;
				a_vf[i + 3][1] |= CLOSE_PARENTH
			}
		}
	}

	/* set the staff system */
	st = -1
	for (i = 0; i < a_vf.length; i++) {
		flags = a_vf[i][1]
		if ((flags & (OPEN_PARENTH | CLOSE_PARENTH))
				== (OPEN_PARENTH | CLOSE_PARENTH)) {
			flags &= ~(OPEN_PARENTH | CLOSE_PARENTH);
			a_vf[i][1] = flags
		}
		p_voice = a_vf[i][0]
		if (flags & FL_VOICE) {
			p_voice.floating = true;
			p_voice.second = true
		} else {
			st++;
			if (!par_sy.staves[st]) {
				par_sy.staves[st] = {
					stafflines: '|||||',
					staffscale: 1
				}
			}
			par_sy.staves[st].flags = 0
		}
		v = p_voice.v;
		p_voice.st = p_voice.cst =
				par_sy.voices[v].st = st;
		par_sy.staves[st].flags |= flags
		if (flags & OPEN_PARENTH) {
			p_voice2 = p_voice
			while (i < a_vf.length - 1) {
				p_voice = a_vf[++i][0];
				v = p_voice.v
				if (a_vf[i][1] & MASTER_VOICE) {
					p_voice2.second = true
					p_voice2 = p_voice
				} else {
					p_voice.second = true;
				}
				p_voice.st = p_voice.cst
						= par_sy.voices[v].st
						= st
				if (a_vf[i][1] & CLOSE_PARENTH)
					break
			}
			par_sy.staves[st].flags |= a_vf[i][1]
		}
	}
	if (st < 0)
		st = 0
	par_sy.nstaff = nstaff = st

	/* change the behaviour of '|' in %%score */
	if (cmd[1] == 'c') {				/* if %%score */
		for (st = 0; st < nstaff; st++)
			par_sy.staves[st].flags ^= STOP_BAR
	}

	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (par_sy.voices[v].range < 0) {
			p_voice.ignore = true
			continue
		}
		par_sy.voices[v].second = p_voice.second;
		st = p_voice.st
		if (st > 0 && !p_voice.norepbra
		 && !(par_sy.staves[st - 1].flags & STOP_BAR))
			p_voice.norepbra = true
	}

	curvoice = parse.state >= 2 ? voice_tb[par_sy.top_voice] : null
}

/* -- get a voice overlay -- */
function get_vover(type) {
	var	p_voice2, p_voice3, range, s, time, v, v2, v3,
		line = parse.line

	// get a voice or create a clone of the current voice
	function clone_voice(id) {
		var v, p_voice

		for (v = 0; v < voice_tb.length; v++) {
			p_voice = voice_tb[v]
			if (p_voice.id == id)
				return p_voice		// found
		}
		p_voice = clone(curvoice);
		p_voice.v = voice_tb.length;
		p_voice.id = id;
		p_voice.sym = p_voice.last_sym = null;

		delete p_voice.nm
		delete p_voice.snm
		delete p_voice.new_name
		delete p_voice.lyric_restart
		delete p_voice.lyric_cont
		delete p_voice.ly_a_h;
		delete p_voice.sym_restart
		delete p_voice.sym_cont

		voice_tb.push(p_voice)
		return p_voice
	} // clone_voice()

	/* treat the end of overlay */
	if (curvoice.ignore)
		return
	if (type == '|'
	 || type == ')')  {
		if (!curvoice.last_note) {
			syntax(1, errs.nonote_vo)
			return
		}
		curvoice.last_note.beam_end = true
		if (!vover) {
			syntax(1, "Erroneous end of voice overlay")
			return
		}
		if (curvoice.time != vover.p_voice.time) {
			syntax(1, "Wrong duration in voice overlay");
			if (curvoice.time > vover.p_voice.time)
				vover.p_voice.time = curvoice.time
		}
		curvoice = vover.p_voice;
		vover = null
		return
	}

	/* treat the full overlay start */
	if (type == '(') {
		if (vover) {
			syntax(1, "Voice overlay already started")
			return
		}
		vover = {
			p_voice: curvoice,
			time: curvoice.time
		}
		return
	}

	/* (here is treated a new overlay - '&') */
	/* create the extra voice if not done yet */
	if (!curvoice.last_note) {
		syntax(1, errs.nonote_vo)
		return
	}
	curvoice.last_note.beam_end = true;
	p_voice2 = curvoice.voice_down
	if (!p_voice2) {
		p_voice2 = clone_voice(curvoice.id + 'o');
		curvoice.voice_down = p_voice2;
		p_voice2.time = 0;
		p_voice2.second = true;
		v2 = p_voice2.v;
		par_sy.voices[v2] = {
			st: curvoice.st,
			second: true
		}
		var f_clone = curvoice.clone != undefined ? 1 : 0;
		range = par_sy.voices[curvoice.v].range
		for (v = 0; v < par_sy.voices.length; v++) {
			if (par_sy.voices[v].range > range)
				par_sy.voices[v].range += f_clone + 1
		}
		par_sy.voices[v2].range = range + 1
		if (f_clone) {
			p_voice3 = clone_voice(p_voice2.id + 'c');
			p_voice3.second = true;
			v3 = p_voice3.v;
			par_sy.voices[v3] = {
				second: true,
				range: range + 2
			}
			p_voice2.clone = p_voice3
		}
	}
	p_voice2.ulen = curvoice.ulen
	p_voice2.dur_fact = curvoice.dur_fact
	if (curvoice.uscale)
		p_voice2.uscale = curvoice.uscale

	if (!vover) {				/* first '&' in a measure */
		vover = {
			bar: true,
			p_voice: curvoice
		}
		time = p_voice2.time
		for (s = curvoice.last_sym; /*s*/; s = s.prev) {
			if (s.type == C.BAR
			 || s.time <= time)	/* (if start of tune) */
				break
		}
		vover.time = s.time
	} else {
		if (curvoice != vover.p_voice
		 && curvoice.time != vover.p_voice.time) {
			syntax(1, "Wrong duration in voice overlay")
			if (curvoice.time > vover.p_voice.time)
				vover.p_voice.time = curvoice.time
		}
	}
	p_voice2.time = vover.time;
	curvoice = p_voice2
}

// check if a clef, key or time signature may go at start of the current voice
function is_voice_sig() {
	var s

	if (!curvoice.sym)
		return true	// new voice (may appear in the middle of a tune)
	if (curvoice.time != 0)
		return false
	for (s = curvoice.last_sym; s; s = s.prev)
		if (w_tb[s.type] != 0)
			return false
	return true
}

// treat a clef found in the tune body
function get_clef(s) {
	var	s2, s3

	if (is_voice_sig()) {
		curvoice.clef = s
		return
	}

	// clef change
	/* the clef must appear before a key signature or a bar */
	for (s2 = curvoice.last_sym;
	     s2 && s2.prev && s2.time == curvoice.time;
	     s2 = s2.prev) {
		if (w_tb[s2.type] != 0)
			break
	}
	if (s2 && s2.prev
	 && s2.time == curvoice.time		// if no time skip
	 && ((s2.type == C.KEY && !s2.k_none) || s2.type == C.BAR)) {
		for (s3 = s2; s3.prev; s3 = s3.prev) {
			switch (s3.prev.type) {
			case C.KEY:
			case C.BAR:
				continue
			}
			break
		}
		s2 = curvoice.last_sym;
		curvoice.last_sym = s3.prev;
		sym_link(s);
		s.next = s3;
		s3.prev = s;
		curvoice.last_sym = s2
	} else {
		sym_link(s)
	}
	s.clef_small = true
}

// treat K: (kp = key signature + parameters)
function get_key(parm) {
	var	v, p_voice, s, transp,
//		[s_key, a] = new_key(parm)	// KO with nodejs
		a = new_key(parm),
		s_key = a[0];

	a = a[1]
	if (s_key.k_sf
	 && !s_key.k_exp
	 && s_key.k_a_acc)
		set_k_acc(s_key)

	switch (parse.state) {
	case 1:				// in tune header (first K:)
		if (s_key.k_sf == undefined && !s_key.k_a_acc) { // empty K:
			s_key.k_sf = 0;
			s_key.k_none = true
		}
		for (v = 0; v < voice_tb.length; v++) {
			p_voice = voice_tb[v];
			p_voice.key = clone(s_key);
			p_voice.okey = clone(s_key);
			p_voice.ckey = clone(s_key)
		}
		parse.okey = clone(s_key);
		parse.ckey = s_key
		if (a.length != 0)
			memo_kv_parm('*', a)
		if (!glovar.ulen)
			glovar.ulen = C.BLEN / 8;
		parse.state = 2;		// in tune header after K:

		set_page();
		write_heading();
		reset_gen();
		gene.nbar = cfmt.measurefirst	// measure numbering
		return
	case 2:					// K: at start of tune body
		goto_tune(true)
		break
	}
	if (a.length != 0)
		set_kv_parm(a);

	transp = (cfmt.transp || 0) +
		(curvoice.transp || 0) +
		(curvoice.shift || 0)

	if (s_key.k_sf == undefined) {
		if (!s_key.k_a_acc
		 && !transp)
			return
		s_key.k_sf = curvoice.okey.k_sf
	}

	curvoice.okey = clone(s_key)
	if (transp) {
		curvoice.vtransp = transp;
		key_transp(s_key)
	}

	s_key.k_old_sf = curvoice.ckey.k_sf;	// memorize the key changes

	curvoice.ckey = s_key

	if (is_voice_sig()) {
		curvoice.key = clone(s_key)
		if (s_key.k_none)
			curvoice.key.k_sf = 0
		return
	}

	/* the key signature must appear before a time signature */
	s = curvoice.last_sym
	if (s && s.type == C.METER) {
		curvoice.last_sym = s.prev
		if (!curvoice.last_sym)
			curvoice.sym = null;
		sym_link(s_key);
		s_key.next = s;
		s.prev = s_key;
		curvoice.last_sym = s
	} else {
		sym_link(s_key)
	}
}

// get / create a new voice
function new_voice(id) {
	var	p_voice, v, p_v_sav,
		n = voice_tb.length

	// if first explicit voice and no music, replace the default V:1
	if (n == 1
	 && voice_tb[0].default) {
		delete voice_tb[0].default
		if (voice_tb[0].time == 0) {
			p_voice = voice_tb[0];
			p_voice.id = id
			if (cfmt.transp	// != undefined
			 && parse.state >= 2) {
				p_v_sav = curvoice;
				curvoice = p_voice;
				set_transp();
				curvoice = p_v_sav
			}
			return p_voice		// default voice
		}
	}
	for (v = 0; v < n; v++) {
		p_voice = voice_tb[v]
		if (p_voice.id == id)
			return p_voice		// old voice
	}

	p_voice = {
		v: v,
		id: id,
		time: 0,
		new: true,
		pos: {
			dyn: 0,
			gch: 0,
			gst: 0,
			orn: 0,
			stm: 0,
			voc: 0,
			vol: 0
		},
		scale: 1,
//		st: 0,
//		cst: 0,
		ulen: glovar.ulen,
		dur_fact: 1,
		key: clone(parse.ckey),
		ckey: clone(parse.ckey),
		okey: clone(parse.okey),
		meter: clone(glovar.meter),
		wmeasure: glovar.meter.wmeasure,
		clef: {
			type: C.CLEF,
			clef_auto: true,
			clef_type: "a",		// auto
			time: 0
		},
		hy_st: 0
	}

	voice_tb.push(p_voice);

	par_sy.voices[v] = {
		range: -1
	}

	return p_voice
}

// this function is called at program start and on end of tune
function init_tune() {
	nstaff = -1;
	voice_tb = [];
	curvoice = null;
	new_syst(true);
	staves_found = -1;
	gene = {}
	a_de = []			// remove old decorations
	od = {}				// no ottava decorations anymore
}

// treat V: with many voices
function do_cloning(vs) {
    var	i, eol,
	file = parse.file,
	start = parse.eol + 1,		// next line after V:
	bol = start

	// search the end of the music to be cloned
	while (1) {
		eol = file.indexOf('\n', bol)
		if (eol < 0) {
			eol = 0
			break
		}

		// stop on comment, or information field
		if (/%.*|\n.*|.:.|\[.:/.test(file.slice(eol + 1, eol + 4)))
			break
		bol = eol + 1
	}

	// insert the music sequence in each voice
	include++;
	tosvg(parse.fname, file, start, eol)	// first voice
	for (i = 0; i < vs.length; i++) {
		get_voice(vs[i]);
		tosvg(parse.fname, file, start, eol)
	}
	include--
}

// treat a 'V:' info
function get_voice(parm) {
	var	v, transp, vtransp, vs,
		a = info_split(parm, 1),
		vid = a.shift();

	if (!vid)
		return				// empty V:

	if (vid.indexOf(',') > 0) {		// if many voices
		vs = vid.split(',');
		vid = vs.shift()
	}

	if (parse.state < 2) {
		if (a.length != 0)
			memo_kv_parm(vid, a)
		if (vid != '*' && parse.state == 1)
			new_voice(vid)
		return
	}

	if (vid == '*') {
		syntax(1, "Cannot have V:* in tune body")
		return
	}
	curvoice = new_voice(vid);
	set_kv_parm(a)
	if (parse.state == 2)			// if first voice
		goto_tune();
	set_transp();

	v = curvoice.v
	if (curvoice.new) {			// if new voice
		delete curvoice.new
		if (staves_found < 0) {		// if no %%score/%%staves
			curvoice.st = curvoice.cst = ++nstaff;
			par_sy.nstaff = nstaff;
			par_sy.voices[v].st = nstaff;
			par_sy.voices[v].range = v;
			par_sy.staves[nstaff] = {
				stafflines: "|||||",
				staffscale: 1
			}
		}
	
		if (par_sy.voices[v].range < 0) {
//			if (cfmt.alignbars)
//				syntax(1, "V: does not work with %%alignbars")
			if (staves_found >= 0)
				curvoice.ignore = true
		}
	}

	if (curvoice.stafflines) {
		par_sy.staves[curvoice.st].stafflines = curvoice.stafflines;
		curvoice.stafflines = ''
	}

	if (!curvoice.filtered
	 && !curvoice.ignore
	 && parse.voice_opts) {
		curvoice.filtered = true;
		voice_filter()
	}

	if (vs)
		do_cloning(vs)
}

// change state from 'tune header after K:' to 'in tune body'
// curvoice is defined when called from get_voice()
function goto_tune(is_K) {
	var	v, p_voice,
		s = {
			type: C.STAVES,
			dur: 0,
			sy: par_sy
		}

	parse.state = 3;			// in tune body

	// if no voice yet, create the default voice
	if (voice_tb.length == 0) {
		curvoice = new_voice("1");
		curvoice.clef.istart = curvoice.key.istart;
		curvoice.clef.iend = curvoice.key.iend;
//		nstaff = 0;
		curvoice.default = true
	} else if (!curvoice) {
		curvoice = voice_tb[staves_found < 0 ? 0 : par_sy.top_voice]
	}

	if (!curvoice.init && !is_K) {
		set_kv_parm([]);
		set_transp()
	}

	// update some voice parameters
	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v];
		p_voice.ulen = glovar.ulen
		if (p_voice.key.k_bagpipe
		 && !p_voice.pos.stm) {
			p_voice.pos = clone(p_voice.pos);
			p_voice.pos.stm = C.SL_BELOW
		}
	}

	// initialize the voices when no %%staves/score	
	if (staves_found < 0) {
		nstaff = voice_tb.length - 1
		for (v = 0; v <= nstaff; v++) {
			p_voice = voice_tb[v];
			delete p_voice.new;		// old voice
			p_voice.st = p_voice.cst =
				par_sy.voices[v].st =
					par_sy.voices[v].range = v;
			par_sy.staves[v] = {
				stafflines: '|||||',
				staffscale: 1
			}
		}
		par_sy.nstaff = nstaff
	}

	// link the first %%score in the top voice
	p_voice = curvoice;
	curvoice = voice_tb[par_sy.top_voice];
	sym_link(s)
	if (staves_found < 0)
		s.default = true;
	curvoice = p_voice
}
// abc2svg - lyrics.js - lyrics
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

// parse a symbol line (s:)
function get_sym(p, cont) {
	var s, c, i, j, d

	if (curvoice.ignore)
		return

	// get the starting symbol of the lyrics
	if (cont) {					// +:
		s = curvoice.sym_cont
		if (!s) {
			syntax(1, "+: symbol line without music")
			return
		}
	} else {
		if (curvoice.sym_restart) {		// new music
			curvoice.sym_start = s = curvoice.sym_restart;
			curvoice.sym_restart = null
		} else {
			s = curvoice.sym_start
		}
		if (!s)
			s = curvoice.sym
		if (!s) {
			syntax(1, "s: without music")
			return
		}
	}

	/* scan the symbol line */
	i = 0
	while (1) {
		while (p[i] == ' ' || p[i] == '\t')
			i++;
		c = p[i]
		if (!c)
			break
		switch (c) {
		case '|':
			while (s && s.type != C.BAR)
				s = s.next
			if (!s) {
				syntax(1, "Not enough measure bars for symbol line")
				return
			}
			s = s.next;
			i++
			continue
		case '!':
		case '"':
			j = ++i
			i = p.indexOf(c, j)
			if (i < 0) {
				syntax(1, c == '!' ?
					"No end of decoration" :
					"No end of guitar chord");
				i = p.length
				continue
			}
			d = p.slice(j - 1, i + 1)
			break
		case '*':
			break
		default:
			d = c.charCodeAt(0)
			if (d < 128) {
				d = char_tb[d]
				if (d.length > 1
				 && (d[0] == '!' || d[0] == '"')) {
					c = d[0]
					break
				}
			}
			syntax(1, errs.bad_char, c)
			break
		}

		/* store the element in the next note */
		while (s && (s.type != C.NOTE || s.grace))
			s = s.next
		if (!s) {
			syntax(1, "Too many elements in symbol line")
			return
		}
		switch (c) {
		default:
//		case '*':
			break
		case '!':
			deco_cnv([d.slice(1, -1)], s, s.prev)
			break
		case '"':
			a_gch = s.a_gch;
			parse_gchord(d)
			if (a_gch)
				gch_build(s)
			break
		}
		s = s.next;
		i++
	}
	curvoice.lyric_cont = s
}

/* -- parse a lyric (vocal) line (w:) -- */
function get_lyrics(text, cont) {
	var s, word, p, i, j, ly

	if (curvoice.ignore)
		return
	if (curvoice.pos.voc != C.SL_HIDDEN)
		curvoice.have_ly = true

	// get the starting symbol of the lyrics
	if (cont) {					// +:
		s = curvoice.lyric_cont
		if (!s) {
			syntax(1, "+: lyric without music")
			return
		}
	} else {
		set_font("vocal")
		if (curvoice.lyric_restart) {		// new music
			curvoice.lyric_start = s = curvoice.lyric_restart;
			curvoice.lyric_restart = null;
			curvoice.lyric_line = 0
		} else {
			curvoice.lyric_line++;
			s = curvoice.lyric_start
		}
		if (!s)
			s = curvoice.sym
		if (!s) {
			syntax(1, "w: without music")
			return
		}
	}

	/* scan the lyric line */
	p = text;
	i = 0
	while (1) {
		while (p[i] == ' ' || p[i] == '\t')
			i++
		if (!p[i])
			break
		j = parse.istart + i + 2	// start index
		switch (p[i]) { 
		case '|':
			while (s && s.type != C.BAR)
				s = s.next
			if (!s) {
				syntax(1, "Not enough measure bars for lyric line")
				return
			}
			s = s.next;
			i++
			continue
		case '-':
			word = "-\n"
			break
		case '_':
			word = "_\n"
			break
		case '*':
			word = ""
			break
		default:
			if (p[i] == '\\'
			 && i == p.length - 1) {
				curvoice.lyric_cont = s
				return
			}
			word = "";
			while (1) {
				if (!p[i])
					break
				switch (p[i]) {
				case '_':
				case '*':
				case '|':
					i--
				case ' ':
				case '\t':
					break
				case '~':
					word += ' ';
					i++
					continue
				case '-':
					word += "\n"
					break
				case '\\':
					word += p[++i];
					i++
					continue
				default:
					word += p[i++]
					continue
				}
				break
			}
			break
		}

		/* store the word in the next note */
		while (s && (s.type != C.NOTE || s.grace))
			s = s.next
		if (!s) {
			syntax(1, "Too many words in lyric line")
			return
		}
		if (word
		 && s.pos.voc != C.SL_HIDDEN) {
			if (word.match(/^\$\d/)) {
				if (word[1] == '0')
					set_font("vocal")
				else
					set_font("u" + word[1]);
				word = word.slice(2)
			}
			ly = {
				t: word,
				font: gene.curfont,
				w: strwh(word)[0],
				istart: j,
				iend: j + word.length
			}
			if (!s.a_ly)
				s.a_ly = []
			s.a_ly[curvoice.lyric_line] = ly
		}
		s = s.next;
		i++
	}
	curvoice.lyric_cont = s
}

// -- set the width needed by the lyrics --
// (called once per tune)
function ly_width(s, wlw) {
	var	ly, sz, swfac, align, xx, w, i, j, k, shift, p,
		a_ly = s.a_ly;

	align = 0
	for (i = 0; i < a_ly.length; i++) {
		ly = a_ly[i]
		if (!ly)
			continue
		p = ly.t;
		if (p == "-\n" || p == "_\n") {
			ly.shift = 0
			continue
		}
		w = ly.w;
		swfac = ly.font.swfac;
		xx = w + 2 * cwid(' ') * swfac
		if (s.type == C.GRACE) {			// %%graceword
			shift = s.wl
		} else if ((p[0] >= '0' && p[0] <= '9' && p.length > 2)
		 || p[1] == ':'
		 || p[0] == '(' || p[0] == ')') {
			if (p[0] == '(') {
				sz = cwid('(') * swfac
			} else {
				j = p.indexOf(' ');
				set_font(ly.font)
				if (j > 0)
					sz = strwh(p.slice(0, j))[0]
				else
					sz = w
			}
			shift = (w - sz + 2 * cwid(' ') * swfac) * .4
			if (shift > 20)
				shift = 20;
			shift += sz
			if (ly.t[0] >= '0' && ly.t[0] <= '9') {
				if (shift > align)
					align = shift
			}
		} else {
			shift = xx * .4
			if (shift > 20)
				shift = 20
		}
		ly.shift = shift
		if (wlw < shift)
			wlw = shift;
//		if (p[p.length - 1] == "\n")		// if "xx-"
//			xx -= cwid(' ') * swfac
		xx -= shift;
		shift = 2 * cwid(' ') * swfac
		for (k = s.next; k; k = k.next) {
			switch (k.type) {
			case C.NOTE:
			case C.REST:
				if (!k.a_ly || !k.a_ly[i]
				 || k.a_ly[i].w == 0)
					xx -= 9
				else if (k.a_ly[i].t == "-\n"
				      || k.a_ly[i].t == "_\n")
					xx -= shift
				else
					break
				if (xx <= 0)
					break
				continue
			case C.CLEF:
			case C.METER:
			case C.KEY:
				xx -= 10
				continue
			default:
				xx -= 5
				break
			}
			break
		}
		if (xx > s.wr)
			s.wr = xx
	}
	if (align > 0) {
		for (i = 0; i < a_ly.length; i++) {
			ly = a_ly[i]
			if (ly && ly.t[0] >= '0' && ly.t[0] <= '9')
				ly.shift = align
		}
	}
	return wlw
}

/* -- draw the lyrics under (or above) notes -- */
/* (the staves are not yet defined) */
/* !! this routine is tied to ly_width() !! */
function draw_lyric_line(p_voice, j, y) {
	var	p, lastx, w, s, s2, ly, lyl,
		hyflag, lflag, x0, font, shift

	if (p_voice.hy_st & (1 << j)) {
		hyflag = true;
		p_voice.hy_st &= ~(1 << j)
	}
	for (s = p_voice.sym; /*s*/; s = s.next)
		if (s.type != C.CLEF
		 && s.type != C.KEY && s.type != C.METER)
			break
	lastx = s.prev ? s.prev.x : tsfirst.x;
	x0 = 0
	for ( ; s; s = s.next) {
		if (s.a_ly)
			ly = s.a_ly[j]
		else
			ly = null
		if (!ly) {
			switch (s.type) {
			case C.REST:
			case C.MREST:
				if (lflag) {
					out_wln(lastx + 3, y, x0 - lastx);
					lflag = false;
					lastx = s.x + s.wr
				}
			}
			continue
		}
		if (ly.font != gene.curfont)		/* font change */
			gene.curfont = font = ly.font;
		p = ly.t;
		w = ly.w;
		shift = ly.shift
		if (hyflag) {
			if (p == "_\n") {		/* '_' */
				p = "-\n"
			} else if (p != "-\n") {	/* not '-' */
				out_hyph(lastx, y, s.x - shift - lastx);
				hyflag = false;
				lastx = s.x + s.wr
			}
		}
		if (lflag
		 && p != "_\n") {		/* not '_' */
			out_wln(lastx + 3, y, x0 - lastx + 3);
			lflag = false;
			lastx = s.x + s.wr
		}
		if (p == "-\n"			/* '-' */
		 || p == "_\n") {		/* '_' */
			if (x0 == 0 && lastx > s.x - 18)
				lastx = s.x - 18
			if (p[0] == '-')
				hyflag = true
			else
				lflag = true;
			x0 = s.x - shift
			continue
		}
		x0 = s.x - shift;
		if (p.slice(-1) == '\n') {
			p = p.slice(0, -1);	/* '-' at end */
			hyflag = true
		}
		if (user.anno_start || user.anno_stop) {
			s2 = {
				st: s.st,
				istart: ly.istart,
				iend: ly.iend,
				x: x0,
				y: y,
				ymn: y,
				ymx: y + gene.curfont.size,
				wl: 0,
				wr: w
			}
			anno_start(s2, 'lyrics')
		}
		xy_str(x0, y, p);
		anno_stop(s2, 'lyrics')
		lastx = x0 + w
	}
	if (hyflag) {
		hyflag = false;
		x0 = realwidth - 10
		if (x0 < lastx + 10)
			x0 = lastx + 10;
		out_hyph(lastx, y, x0 - lastx)
		if (cfmt.hyphencont)
			p_voice.hy_st |= (1 << j)
	}

	/* see if any underscore in the next line */
	for (p_voice.s_next ; s; s = s.next) {
		if (s.type == C.NOTE) {
			if (!s.a_ly)
				break
			ly = s.a_ly[j]
			if (ly && ly.t == "_\n") {
				lflag = true;
				x0 = realwidth - 15
				if (x0 < lastx + 12)
					x0 = lastx + 12
			}
			break
		}
	}
	if (lflag) {
		out_wln(lastx + 3, y, x0 - lastx + 3);
		lflag = false
	}
}

function draw_lyrics(p_voice, nly, a_h, y,
				incr) {	/* 1: below, -1: above */
	var	j, top,
		sc = staff_tb[p_voice.st].staffscale;

	set_font("vocal")
	if (incr > 0) {				/* under the staff */
		if (y > -cfmt.vocalspace)
			y = -cfmt.vocalspace;
		y *= sc
		for (j = 0; j < nly; j++) {
			y -= a_h[j] * 1.1;
			draw_lyric_line(p_voice, j, y)
		}
		return (y - a_h[j - 1] / 6) / sc
	}

	/* above the staff */
	top = staff_tb[p_voice.st].topbar + cfmt.vocalspace
	if (y < top)
		y = top;
	y *= sc
	for (j = nly; --j >= 0;) {
		draw_lyric_line(p_voice, j, y);
		y += a_h[j] * 1.1
	}
	return y / sc
}

// -- draw all the lyrics --
/* (the staves are not yet defined) */
function draw_all_lyrics() {
	var	p_voice, s, v, nly, i, x, y, w, a_ly, ly,
		lyst_tb = new Array(nstaff),
		nv = voice_tb.length,
		h_tb = new Array(nv),
		nly_tb = new Array(nv),
		above_tb = new Array(nv),
		rv_tb = new Array(nv),
		top = 0,
		bot = 0,
		st = -1

	/* compute the number of lyrics per voice - staff
	 * and their y offset on the staff */
	for (v = 0; v < nv; v++) {
		p_voice = voice_tb[v]
		if (!p_voice.sym)
			continue
		if (p_voice.st != st) {
			top = 0;
			bot = 0;
			st = p_voice.st
		}
		nly = 0
		if (p_voice.have_ly) {
			if (!h_tb[v])
				h_tb[v] = []
			for (s = p_voice.sym; s; s = s.next) {
				a_ly = s.a_ly
				if (!a_ly)
					continue
/*fixme:should get the real width*/
				x = s.x;
				w = 10
				for (i = 0; i < a_ly.length; i++) {
					ly = a_ly[i]
					if (ly && ly.w != 0) {
						x -= ly.shift;
						w = ly.w
						break
					}
				}
				y = y_get(p_voice.st, 1, x, w)
				if (top < y)
					top = y;
				y = y_get(p_voice.st, 0, x, w)
				if (bot > y)
					bot = y
				while (nly < a_ly.length)
					h_tb[v][nly++] = 0
				for (i = 0; i < a_ly.length; i++) {
					ly = a_ly[i]
					if (!ly)
						continue
					if (!h_tb[v][i]
					 || ly.font.size > h_tb[v][i])
						h_tb[v][i] = ly.font.size
				}
			}
		} else {
			y = y_get(p_voice.st, 1, 0, realwidth)
			if (top < y)
				top = y;
			y = y_get(p_voice.st, 0, 0, realwidth)
			if (bot > y)
				bot = y
		}
		if (!lyst_tb[st])
			lyst_tb[st] = {}
		lyst_tb[st].top = top;
		lyst_tb[st].bot = bot;
		nly_tb[v] = nly
		if (nly == 0)
			continue
		if (p_voice.pos.voc)
			above_tb[v] = p_voice.pos.voc == C.SL_ABOVE
		else if (voice_tb[v + 1]
/*fixme:%%staves:KO - find an other way..*/
		      && voice_tb[v + 1].st == st
		      && voice_tb[v + 1].have_ly)
			above_tb[v] = true
		else
			above_tb[v] = false
		if (above_tb[v])
			lyst_tb[st].a = true
		else
			lyst_tb[st].b = true
	}

	/* draw the lyrics under the staves */
	i = 0
	for (v = 0; v < nv; v++) {
		p_voice = voice_tb[v]
		if (!p_voice.sym)
			continue
		if (!p_voice.have_ly)
			continue
		if (above_tb[v]) {
			rv_tb[i++] = v
			continue
		}
		st = p_voice.st;
// don't scale the lyrics
		set_dscale(st, true)
		if (nly_tb[v] > 0)
			lyst_tb[st].bot = draw_lyrics(p_voice, nly_tb[v],
							h_tb[v],
							lyst_tb[st].bot, 1)
	}

	/* draw the lyrics above the staff */
	while (--i >= 0) {
		v = rv_tb[i];
		p_voice = voice_tb[v];
		st = p_voice.st;
		set_dscale(st, true);
		lyst_tb[st].top = draw_lyrics(p_voice, nly_tb[v],
						h_tb[v],
						lyst_tb[st].top, -1)
	}

	/* set the max y offsets of all symbols */
	for (v = 0; v < nv; v++) {
		p_voice = voice_tb[v]
		if (!p_voice.sym)
			continue
		st = p_voice.st;
		if (lyst_tb[st].a) {
			top = lyst_tb[st].top + 2
			for (s = p_voice.sym.next; s; s = s.next) {
/*fixme: may have lyrics crossing a next symbol*/
				if (s.a_ly) {
/*fixme:should set the real width*/
					y_set(st, 1, s.x - 2, 10, top)
				}
			}
		}
		if (lyst_tb[st].b) {
			bot = lyst_tb[st].bot - 2
			if (nly_tb[p_voice.v] > 0) {
				for (s = p_voice.sym.next; s; s = s.next) {
					if (s.a_ly) {
/*fixme:should set the real width*/
						y_set(st, 0, s.x - 2, 10, bot)
					}
				}
			} else {
				y_set(st, 0, 0, realwidth, bot)
			}
		}
	}
}
// abc2svg - gchord.js - chord symbols
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

// -- parse a chord symbol / annotation --
// the result is added in the global variable a_gch
// 'type' may be a single '"' or a string '"xxx"' created by U:
function parse_gchord(type) {
	var	c, text, gch, x_abs, y_abs, type,
		i, istart, iend,
		ann_font = get_font("annotation"),
		h_ann = ann_font.size,
		line = parse.line

	function get_float() {
		var txt = ''

		while (1) {
			c = text[i++]
			if ("1234567890.-".indexOf(c) < 0)
				return parseFloat(txt)
			txt += c
		}
	} // get_float()

	istart = parse.bol + line.index
	if (type.length > 1) {			// U:
		text = type.slice(1, -1);
		iend = istart + 1
	} else {
		text = ""
		while (1) {
			c = line.next_char()
			if (!c) {
				syntax(1, "No end of guitar chord")
				return
			}
			if (c == '"')
				break
			if (c == '\\') {
				text += c;
				c = line.next_char()
			}
			text += c
		}
		iend = parse.bol + line.index + 1
	}

	if (curvoice.pos.gch == C.SL_HIDDEN)
		return

	i = 0;
	type = 'g'
	while (1) {
		c = text[i]
		if (!c)
			break
		gch = {
			text: "",
			istart: istart,
			iend: iend,
			font: ann_font
		}
		switch (c) {
		case '@':
			type = c;
			i++;
			x_abs = get_float()
			if (c != ',') {
				syntax(1, "',' lacking in annotation '@x,y'");
				y_abs = 0
			} else {
				y_abs = get_float()
				if (c != ' ')
					i--
			}
			gch.x = x_abs;
			gch.y = y_abs - h_ann / 2
			break
		case '^':
		case '_':
		case '<':
		case '>':
			i++;
			type = c
			break
		default:
			switch (type) {
			case 'g':
				gch.font = get_font("gchord")
				break
			case '@':
				gch.x = x_abs;
				y_abs -= h_ann;
				gch.y = y_abs - h_ann / 2
				break
			}
			break
		}
		gch.type = type
		while (1) {
			c = text[i]
			if (!c)
				break
			switch (c) {
			case '\\':
				c = text[++i]
				if (!c || c == 'n')
					break
				gch.text += '\\'
			default:
				gch.text += c;
				i++
				continue
			case '&':			/* skip "&xxx;" */
				while (1) {
					gch.text += c;
					c = text[++i]
					switch (c) {
					default:
						continue
					case ';':
					case undefined:
					case '\\':
						break
					}
					break
				}
				if (c == ';') {
					gch.text += c
					continue
				}
				break
			case ';':
				break
			}
			i++
			break
		}
		if (!a_gch)
			a_gch = []
		a_gch.push(gch)
	}
}

// transpose a chord symbol
var	note_names = "CDEFGAB",
	latin_names = [ "Do", "Re", "Mi", "Fa", "Sol", "La", "Si" ],
	acc_name = ["bb", "b", "", "#", "##"]

	function gch_tr1(p, i2) {
		var	new_txt, l,
			n, i1, i3, i4, ix, a, ip, ip2,
			latin = 0

		/* main chord */
		switch (p[0]) {
		case 'A': n = 5; break
		case 'B': n = 6; break
		case 'C': n = 0; break
		case 'D':
			if (p[1] == 'o') {
				latin++;
				n = 0		/* Do */
				break
			}
			n = 1
			break
		case 'E': n = 2; break
		case 'F':
			if (p[1] == 'a')
				latin++;	/* Fa */
			n = 3
			break
		case 'G': n = 4; break
		case 'L':
			latin++;		/* La */
			n = 5
			break
		case 'M':
			latin++;		/* Mi */
			n = 2
			break
		case 'R':
			latin++
			n = 1			/* Re */
			break
		case 'S':
			latin++
			if (p[1] == 'o') {
				latin++;
				n = 4		/* Sol */
			} else {
				n = 6		/* Si */
			}
			break
		case '/':			// bass only
			latin--
			break
		default:
			return p
		}

		a = 0;
		ip = latin + 1
		if (latin >= 0) {		// if some chord
			while (p[ip] == '#') {
				a++;
				ip++
			}
			while (p[ip] == 'b') {
				a--;
				ip++
			}
//			if (p[ip] == '=')
//				ip++
			i3 = cde2fcg[n] + i2 + a * 7;
			i4 = cgd2cde[(i3 + 16 * 7) % 7];	// note
			i1 = ((((i3 + 22) / 7) | 0) + 159) % 5;	// accidental
			new_txt = (latin ? latin_names[i4] : note_names[i4]) +
					acc_name[i1]
		} else {
			new_txt = ''
		}

		ip2 = p.indexOf('/', ip)	// skip 'm'/'dim'..
		if (ip2 < 0)
			return new_txt + p.slice(ip);

		/* bass */
		n = note_names.indexOf(p[++ip2])
		if (n < 0)
			return new_txt + p.slice(ip);
//fixme: latin names not treated
		new_txt += p.slice(ip, ip2);
		a = 0
		if (p[++ip2] == '#') {
			a++
			if (p[++ip2] == '#') {
				a++;
				ip2++
			}
		} else if (p[ip2] == 'b') {
			a--
			if (p[++ip2] == 'b') {
				a--;
				ip2++
			}
		}
		i3 = cde2fcg[n] + i2 + a * 7;
		i4 = cgd2cde[(i3 + 16 * 7) % 7];	// note
		i1 = ((((i3 + 22) / 7) | 0) + 159) % 5;	// accidental
		return new_txt + note_names[i4] + acc_name[i1] + p.slice(ip2)
	} // get_tr1

function gch_transp(s) {
	var	gch, p, j,
		i = 0,
		i2 = curvoice.ckey.k_sf - curvoice.okey.k_sf

	while (1) {
		gch = s.a_gch[i++]
		if (!gch)
			return
		if (gch.type != 'g')
			continue
		p = gch.text;
		j = p.indexOf('\t')
		if (j >= 0) {
			j++;
			p = p.slice(0, j) + gch_tr1(p.slice(j), i2)
		}
		gch.text = gch_tr1(p, i2)
	}
}

// -- build the chord indications / annotations --
function gch_build(s) {

	/* split the chord indications / annotations
	 * and initialize their vertical offsets */
	var	gch, wh, xspc, ix,
		pos = curvoice.pos.gch == C.SL_BELOW ? -1 : 1,
		y_above = 0,
		y_below = 0,
		y_left = 0,
		y_right = 0,
		box = cfmt.gchordbox,
		GCHPRE = .4;		// portion of chord before note

	s.a_gch = a_gch;
	a_gch = null

	if (curvoice.vtransp)
		gch_transp(s)

	// change the accidentals in the chord symbols,
	// convert the escape sequences in annotations, and
	// set the offsets
	for (ix = 0; ix < s.a_gch.length; ix++) {
		gch = s.a_gch[ix]
		if (gch.type == 'g') {
			if (cfmt.chordnames) {
				gch.otext = gch.text;	// save for %%diagram
				gch.text = gch.text.replace(/A|B|C|D|E|F|G/g,
					function(c){return cfmt.chordnames[c]})
				if (cfmt.chordnames.B == 'H')
					gch.text = gch.text.replace(/Hb/g, 'Bb')
			}
			gch.text = gch.text.replace(/##|#|=|bb|b/g,
				function(x) {
					switch (x) {
					case '##': return "&#x1d12a;"
					case '#': return "\u266f"
					case '=': return "\u266e"
					case 'b': return "\u266d"
					}
					return "&#x1d12b;"
				});
		} else {
			gch.text = cnv_escape(gch.text);
			if (gch.type == '@'
			 && !user.anno_start && !user.anno_stop)
				continue		/* no width */
		}

		/* set the offsets and widths */
		gene.curfont = gch.font;
		wh = strwh(gch.text);
		gch.w = wh[0]
		switch (gch.type) {
		case '@':
			break
		case '^':			/* above */
			xspc = wh[0] * GCHPRE
			if (xspc > 8)
				xspc = 8;
			gch.x = -xspc;
			y_above -= wh[1];
			gch.y = y_above
			break
		case '_':			/* below */
			xspc = wh[0] * GCHPRE
			if (xspc > 8)
				xspc = 8;
			gch.x = -xspc;
			y_below -= wh[1];
			gch.y = y_below
			break
		case '<':			/* left */
			gch.x = -(wh[0] + 6);
			y_left -= wh[1];
			gch.y = y_left + wh[1] / 2
			break
		case '>':			/* right */
			gch.x = 6;
			y_right -= wh[1];
			gch.y = y_right + wh[1] / 2
			break
		default:			// chord symbol
			gch.box = box
			xspc = wh[0] * GCHPRE
			if (xspc > 8)
				xspc = 8;
			gch.x = -xspc;
			if (pos < 0) {		/* below */
				y_below -= wh[1];
				gch.y = y_below
				if (box) {
					y_below -= 2;
					gch.y -= 1
				}
			} else {
				y_above -= wh[1];
				gch.y = y_above
				if (box) {
					y_above -= 2;
					gch.y -= 1
				}
			}
			break
		}
	}

	/* move upwards the top and middle texts */
	y_left /= 2;
	y_right /= 2
	for (ix = 0; ix < s.a_gch.length; ix++) {
		gch = s.a_gch[ix]
		switch (gch.type) {
		case '^':			/* above */
			gch.y -= y_above
			break
		case '<':			/* left */
			gch.y -= y_left
			break
		case '>':			/* right */
			gch.y -= y_right
			break
		case 'g':			// chord symbol
			if (pos > 0)
				gch.y -= y_above
			break
		}
	}
}

// -- draw the chord symbols and annotations
// (the staves are not yet defined)
// (unscaled delayed output)
function draw_gchord(s, gchy_min, gchy_max) {
	var	gch, gch2, text, ix, x, y, y2, i, j, hbox, h

	// adjust the vertical offset according to the chord symbols
//fixme: w may be too small
	var	w = s.a_gch[0].w,
		y_above = y_get(s.st, 1, s.x - 2, w),
		y_below = y_get(s.st, 0, s.x - 2, w),
		yav = (((s.notes[s.nhd].pit + s.notes[0].pit) >> 1) - 18) * 3

	for (ix = 0; ix < s.a_gch.length; ix++) {
		gch = s.a_gch[ix]
		if (gch.type != 'g')
			continue
		gch2 = gch		// chord symbol closest to the staff
		if (gch.y < 0)
			break
	}
	if (gch2) {
		if (gch2.y >= 0) {
			if (y_above < gchy_max)
				y_above = gchy_max
		} else {
			if (y_below > gchy_min)
				y_below = gchy_min
		}
	}

	set_dscale(s.st);
	for (ix = 0; ix < s.a_gch.length; ix++) {
		gch = s.a_gch[ix];
		use_font(gch.font);
		set_font(gch.font);
		h = gch.font.size;
		w = gch.w;
		x = s.x + gch.x;
		text = gch.text
		switch (gch.type) {
		case '_':			/* below */
			y = gch.y + y_below;
			y_set(s.st, 0, x, w, y - h * .2 - 2)
			break
		case '^':			/* above */
			y = gch.y + y_above;
			y_set(s.st, 1, x, w, y + h * .8 + 2)
			break
		case '<':			/* left */
/*fixme: what symbol space?*/
			if (s.notes[0].acc)
				x -= s.notes[0].shac;
			y = gch.y + yav - h / 2
			break
		case '>':			/* right */
			x += s.xmx
			if (s.dots > 0)
				x += 1.5 + 3.5 * s.dots;
			y = gch.y + yav - h / 2
			break
		default:			// chord symbol
			hbox = gch.box ? 3 : 2
			if (gch.y >= 0) {
				y = gch.y + y_above;
				y_set(s.st, true, x, w, y + h + hbox)
			} else {
				y = gch.y + y_below;
				y_set(s.st, false, x, w, y - hbox)
			}
			i = text.indexOf('\t')

			// if some TAB: expand the chord symbol
			if (i >= 0) {
				x = realwidth
				for (var next = s.next; next; next = next.next) {
					switch (next.type) {
					default:
						continue
					case C.NOTE:
					case C.REST:
					case C.BAR:
						x = next.x
						break
					}
					break
				}
				j = 2
				for (;;) {
					i = text.indexOf('\t', i + 1)
					if (i < 0)
						break
					j++
				}
				var expdx = (x - s.x) / j;

				x = s.x;
				y *= staff_tb[s.st].staffscale
				if (user.anno_start)
					user.anno_start("gchord", gch.istart, gch.iend,
						x - 2, y + h + 2, w + 4, h + 4, s)
				i = 0;
				j = i;
				for (;;) {
					i = text.indexOf('\t', j)
					if (i < 0)
						break
					xy_str(x, y, text.slice(j, i), 'c');
					x += expdx;
					j = i + 1
				}
				xy_str(x, y, text.slice(j), 'c')
				if (user.anno_stop)
					user.anno_stop("gchord", gch.istart, gch.iend,
						s.x - 2, y + h + 2, w + 4, h + 4, s)
				continue
			}
			break
		case '@':			/* absolute */
			y = gch.y + yav
			if (y > 0) {
				y2 = y + h
				if (y2 > staff_tb[s.st].ann_top)
					staff_tb[s.st].ann_top = y2
			} else {
				if (y < staff_tb[s.st].ann_bot)
					staff_tb[s.st].ann_bot = y
			}
			break
		}
		if (user.anno_start)
			user.anno_start("annot", gch.istart, gch.iend,
				x - 2, y + h + 2, w + 4, h + 4, s)
		if (gch.box)
			xy_str_b(x, y, text)
		else
			xy_str(x, y, text)
		if (user.anno_stop)
			user.anno_stop("annot", gch.istart, gch.iend,
				x - 2, y + h + 2, w + 4, h + 4, s)
	}
}
// abc2svg - tail.js
//
// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

function psdeco() { return false }
function psxygl() { return false }

// initialize
	font_init();
	init_tune()

// Abc functions used by the modules
Abc.prototype.add_style = function(s) { style += s };
Abc.prototype.cfmt = function() { return cfmt };
Abc.prototype.get_a_gch = function() { return a_gch };
Abc.prototype.get_cur_sy = function() { return cur_sy };
Abc.prototype.get_curvoice = function() { return curvoice };
Abc.prototype.get_delta_tb = function() { return delta_tb };
Abc.prototype.get_decos = function() { return decos };
Abc.prototype.get_fname = function() { return parse.fname };
Abc.prototype.get_font = get_font;
Abc.prototype.get_font_style = function() { return font_style };
Abc.prototype.get_glyphs = function() { return glyphs };
Abc.prototype.get_img = function() { return img };
Abc.prototype.get_maps = function() { return maps };
Abc.prototype.get_multi = function() { return multicol };
Abc.prototype.get_newpage = function() {
	if (block.newpage) {
		block.newpage = false;
		return true
	}
};
Abc.prototype.get_posy = function() { var t = posy; posy = 0; return t };
Abc.prototype.get_staff_tb = function() { return staff_tb };
Abc.prototype.get_top_v = function() { return par_sy.top_voice };
Abc.prototype.get_tsfirst = function() { return tsfirst };
Abc.prototype.get_voice_tb = function() { return voice_tb };
Abc.prototype.info = function() { return info };
Abc.prototype.set_cur_sy = function(sy) { cur_sy = sy };
Abc.prototype.set_tsfirst = function(s) { tsfirst = s };
Abc.prototype.set_xhtml = function(wt) {
    var wto = write_text;
	write_text = wt
	return wto
};
Abc.prototype.sort_pitch = sort_pitch;
Abc.prototype.stv_g = function() { return stv_g };
Abc.prototype.svg_flush = svg_flush;

    var	hook_init		// set after setting the first module hooks

    // export functions and/or set module hooks
    function set_hooks() {
    var	h = abc2svg.modules.hooks,
	gh = abc2svg.modules.g_hooks

	function set_hs(hs) {
	    var	of, h
		for (var k = 0; k < hs.length; k++) {
			h = hs[k]
			if (typeof h == "string") {
				if (!self[h])
					eval("self." + h + "=" + h)
			} else {
				eval("of=" + h[0] + ";" +
					h[0] + "=" + h[1] + ".bind(self,of)")
			}
		}
	} // set_hs()

	if (hook_init) {			// if new modules
		if (h.length) {
			set_hs(h);
			gh.push.apply(gh, h);
			abc2svg.modules.hooks = []
		}
	} else {				// all modules
		if (h.length) {
			gh.push.apply(gh, h);
			abc2svg.modules.hooks = []
		}
		set_hs(gh);
		hook_init = true
	}
    } // set_hooks()

    var	self = this

}	// end of Abc()

} // end of abc2svg

// compatibility
var Abc = abc2svg.Abc

// nodejs
if (typeof module == 'object' && typeof exports == 'object') {
	exports.abc2svg = abc2svg;
	exports.Abc = Abc
}
// abc2svg - modules.js - module handling
//
// Copyright (C) 2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

abc2svg.loadjs = function(fn, onsuccess, onerror) {
	if (onerror)
		onerror()
}

abc2svg.modules = {
		ambitus: { fn: 'ambitus-1.js' },
		beginps: { fn: 'psvg-1.js' },
		break: { fn: 'break-1.js' },
		capo: { fn: 'capo-1.js' },
		clip: { fn: 'clip-1.js' },
		voicecombine: { fn: 'combine-1.js' },
		diagram: { fn: 'diag-1.js' },
	equalbars: { fn: 'equalbars-1.js' },
		grid: { fn: 'grid-1.js' },
		grid2: { fn: 'grid2-1.js' },
		MIDI: { fn: 'MIDI-1.js' },
		percmap: { fn: 'perc-1.js' },
	sth: { fn: 'sth-1.js' },
	temperament: { fn: 'temper-1.js' },

	nreq: 0,
	hooks: [],
	g_hooks: [],

	// scan the file and find the required modules
	// @file: ABC file
	// @relay: (optional) callback function for continuing the treatment
	// @errmsg: (optional) function to display an error message if any
	//	This function gets one argument: the message
	// return true when all modules are loaded
	load: function(file, relay, errmsg) {

		function get_errmsg() {
			if (typeof user == 'object' && user.errmsg)
				return user.errmsg
			if (typeof printErr == 'function')
				return printErr
			if (typeof alert == 'function')
				return function(m) { alert(m) }
			if (typeof console == 'object')
				return console.log
			return function(){}
		}

		// test if some keyword in the file
	    var	m, r,
		nreq_i = this.nreq,
		ls = file.match(/(^|\n)(%%|I:).+?\b/g)

		if (!ls)
			return true
		this.cbf = relay ||		// (only one callback function)
			function(){}
		this.errmsg = errmsg || get_errmsg()

		for (var i = 0; i < ls.length; i++) {
			m = abc2svg.modules[ls[i].replace(/\n?(%%|I:)/, '')]
			if (!m || m.loaded)
				continue

			m.loaded = true

			// load the module
				this.nreq++;
				abc2svg.loadjs(m.fn,
				    function() {	// if success
					if (--abc2svg.modules.nreq == 0)
						abc2svg.modules.cbf()
				    },
				    function() {	// if error
					abc2svg.modules.errmsg('error loading ' + m.fn);
					if (--abc2svg.modules.nreq == 0)
						abc2svg.modules.cbf()
				    })
		}
		return this.nreq == nreq_i
	}
} // modules
abc2svg.version="1.17.8-4f07d34b4d";abc2svg.vdate="2018-08-24"
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
//#javascript
// Generate a JSON representation of ABC
//
// Copyright (C) 2016 Jean-Francois Moine
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.

// Usage:
//	// Define a get_abcmodel() callback function
//	// This one is called by abc2svg after ABC parsing 
//	user.get_abcmodel = json_callback
//
//	// In this function
//	function json_callback(tsfirst, voice_tb, music_types, info) {
//
//		// Create a AbcJSON instance
//		var abcjson = new AbcJSON();
//
//		// and generate the ABC representation
//		json += abcjson.gen_json(tsfirst, voice_tb, anno_type, info);
//	}
//
//	// result
//	var json = ''

// AbcJSON creation
function AbcJSON(nindent) {			// indentation level
	var inb = Array((nindent || 2) + 1).join(' ') // indentation base

    AbcJSON.prototype.gen_json = function (tsfirst, voice_tb, anno_type, info) {
	var	json, i, j, l, v, s, h,
		ind2 = inb + inb,
		ind3 = ind2 + inb,
		ind4 = ind3 + inb,
		links = {
			next: true,
			prev: true,
			ts_next: true,
			ts_prev: true,
			extra: true,
			p_v: true,
			dd_st: true
		}
	// generate an attribute
	function attr_gen(ind, attr, val) {
		var	i, e,
			indn = ind + inb	// next indentation

		if (links[attr]) {
			if (attr == "extra") {
				json += h + ind + '"extra": [';
				h = '\n'
				for (e = val ; e; e = e.next)
					attr_gen(indn, null, e);
				json += '\n' + ind + ']'
			}
			return
		}
		json += h + ind
		if (attr)
			 json += '"' + attr.toString() + '": ';
		switch (typeof(val)) {
		case "undefined":
			json += "null"
			break
		case "object":
			if (!val) {
				json += "null"
				break
			}
			if (Array.isArray(val)) {
				if (val.length == 0) {
					json += "[]"
					break
				}
				h = '[\n';
				l = val.length
				for (i = 0; i < l; i++)
					attr_gen(indn, null, val[i]);
				json += '\n' + ind + ']'
			} else {
				h = '{\n'
				for (i in val)
				    if (val.hasOwnProperty(i))
					attr_gen(indn, i, val[i]);
				json += '\n' + ind + '}'
			}
			break
		default:
			json += JSON.stringify(val)
			break
		}
		h = ',\n'
	} // attr_gen()

	// music types
	json = '';
	h = '{\n';
	attr_gen(inb, "music_types", anno_type);

	h = ',\n' + inb + '"music_type_ids": {\n';
	l = anno_type.length
	for (i = 0; i < l; i++) {
		if (anno_type[i]) {
			json += h + ind2 + '"' + anno_type[i] + '": ' + i;
			h = ',\n'
		}
	}

	// info
	h = '\n' + inb + '},\n';
	attr_gen(inb, "info", info);

	// voices
	json += ',\n' + inb + '"voices": [';
	v = 0;
	h = '\n'
	while (1) {
		h += ind2 + '{\n' +
			ind3 + '"voice_properties": {\n'
		for (i in voice_tb[v])
		    if (voice_tb[v].hasOwnProperty(i))
			attr_gen(ind4, i, voice_tb[v][i]);

		json += '\n' + ind3 + '},\n' +
			ind3 + '"symbols": [';
		s = voice_tb[v].sym
		if (!s) {
			json += ']\n' + ind3 + '}'
		} else {
			h = '\n'
			for ( ; s; s = s.next)
				attr_gen(ind4, null, s);
			json += '\n' + ind3 + ']\n' +
				ind2 + '}'
		}
		h = ',\n'
		if (!voice_tb[++v])
			break
	}
	return json + '\n' + inb + ']\n}\n'
    }
}
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
//#javascript
// Set the MIDI pitches in the notes
//
// Copyright (C) 2015-2017 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

// Usage:
//	// Define a get_abcmodel() callback function
//	// This one is called by abc2svg after ABC parsing 
//	user.get_abcmodel = my_midi_callback
//
//	// In this function
//	function my_midi_callback(tsfirst, voice_tb, music_types, info) {
//
//		// Create a AbcMIDI instance
//		var abcmidi = new AbcMIDI();
//
//		// and set the MIDI pitches
//		abcmidi.add(tsfirst, voice_tb);
//
//		// The MIDI pitches are stored in the notes
//		//	s.notes[i].midi
//	}

// AbcMIDI creation
function AbcMIDI() {
    var	C = abc2svg.C

	// add MIDI pitches
	AbcMIDI.prototype.add = function(s,		// starting symbol
					voice_tb) {	// voice table

		var	scale = new Int8Array(		// note to pitch
					[0, 2, 4, 5, 7, 9, 11]),
			bmap = new Int8Array(7),	// measure base map
			map = new Int8Array(70),	// current map - 10 octaves
			tie_map,			// index = MIDI pitch
			v,
			transp				// clef transpose

		// re-initialize the map on bar
		function bar_map() {
			for (var j = 0; j < 10; j++)
				for (var i = 0; i < 7; i++)
					map[j * 7 + i] = bmap[i]
		} // bar_map()

		// define the note map
		function key_map(s) {
			for (var i = 0; i < 7; i++)
				bmap[i] = 0
			switch (s.k_sf) {
			case 7: bmap[6] = 1
			case 6: bmap[2] = 1
			case 5: bmap[5] = 1
			case 4: bmap[1] = 1
			case 3: bmap[4] = 1
			case 2: bmap[0] = 1
			case 1: bmap[3] = 1; break
			case -7: bmap[3] = -1
			case -6: bmap[0] = -1
			case -5: bmap[4] = -1
			case -4: bmap[1] = -1
			case -3: bmap[5] = -1
			case -2: bmap[2] = -1
			case -1: bmap[6] = -1; break
			}
			bar_map()
		} // key_map()

		// convert ABC pitch to MIDI
		function pit2midi(p, a) {
			if (a)
				map[p] = a == 3 ? 0 : a; // (3 = natural)
			return ((p / 7) | 0) * 12 + scale[p % 7] +
						(tie_map[p] ||  map[p])
		} // pit2midi()

		// initialize the clefs and keys
		for (v = 0; v < voice_tb.length; v++) {
			if (!voice_tb[v].sym)
				continue
			s = voice_tb[v].clef
			if (!s.clef_octave
			 || s.clef_oct_transp)
				transp = 0
			else
				transp = s.clef_octave

			key_map(voice_tb[v].key);	// init acc. map from key sig.

			// and loop on the symbols of the voice
			vloop(v)
		}
	    function vloop(v) {
		var	i, g, p, note,
			s = voice_tb[v].sym,
			vtime = s.time,		// next time
			tie_time = [],
			rep_tie_map = []

		tie_map = []
		while (s) {
			if (s.time > vtime) {	// if time skip
				bar_map()	// force a measure bar
				vtime = s.time
			}
			if (s.dur)
				vtime = s.time + s.dur
			switch (s.type) {
			case C.BAR:
//fixme: pb when lack of measure bar (voice overlay, new voice)
				// x times repeat
				if (s.text) {
					if (s.text[0] == '1') {	// 1st time
						rep_tie_map = [];
						rep_tie_time = []
						for (i = 0; i < tie_map.length; i++)
							rep_tie_map[i] = tie_map[i]
					} else if (rep_tie_map.length != 0) {
						tie_map = []
						tie_time = []
						for (i = 0; i < rep_tie_map.length; i++) {
							tie_map[i] = rep_tie_map[i];
							tie_time[i] = s.time
						}
					}
				}
				if (!s.invis)
					bar_map()
				break
			case C.CLEF:
				if (!s.clef_octave
				 || s.clef_oct_transp)
					transp = 0
				else
					transp = s.clef_octave
				break
			case C.GRACE:
				for (g = s.extra; g; g = g.next) {
					if (!g.type != C.NOTE)
						continue
					for (i = 0; i <= g.nhd; i++) {
						note = g.notes[i];
						p = note.apit + 19 + transp;
						note.midi = pit2midi(p, note.acc)
					}
				}
				break
			case C.KEY:
				key_map(s)
				break
			case C.NOTE:
				for (i = 0; i <= s.nhd; i++) {
					note = s.notes[i];
					p = note.apit + 19 +	// pitch from C-1
							transp
					if (tie_map[p]) {
						if (s.time > tie_time[p]) {
							delete tie_map[p]
							delete tie_time[p]
						}
					}
					note.midi = pit2midi(p, note.acc)
					if (note.ti1) {
						tie_map[p] = map[p];
						tie_time[p] = s.time + s.dur
					}
				}
				break
			}
			s = s.next
		}
	    } // vloop()
	} // add()
} // end AbcMidi
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// play-1.js - file to include in html pages with abc2svg-1.js for playing
//
// Copyright (C) 2015-2018 Jean-Francois Moine
//
// This file is part of abc2svg.
//
// abc2svg is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with abc2svg.  If not, see <http://www.gnu.org/licenses/>.

// This file is a wrapper around
// - ToAudio (toaudio.js - convert ABC to audio sequences)
// - Audio5 (toaudio5.js - play the audio sequences with webaudio and SF2)
// - Midi5 (tomidi5.js - play the audio sequences with webmidi)

// AbcPlay methods:
//
// get_outputs() - return an array of output devices
//
// set_output() - set the output type/port
//
// set_sfu() - get/set the soundfont URL
// @url: URL - undefined = return current value
//
// set_speed() - get/set the play speed
// @speed: < 1 slower, > 1 faster - undefined = return current value
//
// set_vol() - get/set the current sound volume
// @volume: range [0..1] - undefined = return current value

function AbcPlay(i_conf) {
    var	conf = i_conf,
	audio = ToAudio(),
	audio5, midi5, current,
	abcplay = {				// returned object (only instance)

		// get the output type/ports
		get_outputs: function() {
		    var o,
			outputs = []

			if (midi5) {
				o = midi5.get_outputs()
				if (o)
					outputs = o
			}
			if (audio5) {
				o = audio5.get_outputs()
				if (o)
					outputs = outputs.concat(o)
			}
			return outputs
		},
		set_output: set_output,
		clear: audio.clear,
		add: audio.add,
		set_sft: vf,
		set_sfu: function(v) {
			if (v == undefined)
				return conf.sfu
			conf.sfu = v
		},
		set_speed: function(v) {
			if (v == undefined)
				return conf.speed
			conf.new_speed = v
		},
		set_vol: function(v) {
			if (v == undefined)
				return conf.gain;
			conf.gain = v
			if (current && current.set_vol)
				current.set_vol(v)
		},
		play: play,
		stop: vf
	}

	function vf() {}			// void function

	// start playing when no defined output
	function play(istart, i_iend, a_e) {
	    var o,
		os = abcplay.get_outputs()
		if (os.length == 1) {
			o = 0
		} else {
			o = -1
			var res = window.prompt('Use \n0: ' + os[0] +
					'\n1: ' + os[1] + '?', '0')
			if (res) {
				o = Number(res)
				if (isNaN(o) || o < 0 || o >= os.length)
					o = -1
			}
			if (!res || o < 0) {
				if (conf.onend)
					conf.onend()
				return
			}
		}
		set_output(os[o]);
		abcplay.play(istart, i_iend, a_e)
	}

	// set the current output changing the play functions
	function set_output(name) {
		current = name == 'sf2' ? audio5 : midi5
		if (!current)
			return
		abcplay.play = current.play;
		abcplay.stop = current.stop
		if (current.set_output)
			current.set_output(name)
	} // set_output()

	// set default configuration values
	conf.gain = 0.7;
	conf.speed = 1;

	// get the play parameters from localStorage
	(function get_param() {
		try {
			if (!localStorage)
				return
		} catch (e) {
			return
		}
	    var	v = localStorage.getItem("sfu")
		if (v)
			conf.sfu = v;
		v = localStorage.getItem("volume")
		if (v)
			conf.gain = Number(v)
	})()

	// initialize the playing engines
	if (typeof Midi5 == "function")
		midi5 = Midi5(conf)
	if (typeof Audio5 == "function")
		audio5 = Audio5(conf);

	return abcplay
} // AbcPlay
// toaudio.js - audio generation
//
// Copyright (C) 2015-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

// ToAudio creation
function ToAudio() {

  var	C = abc2svg.C,

	scale = new Uint8Array([0, 2, 4, 5, 7, 9, 11]),	// note to pitch conversion

	a_e,				// event array

	p_time,				// last playing time
	abc_time,			// last ABC time
	play_factor;			// play time factor

// ToAudio
  return {

// clear the playing events and
// return the old ones as an array of Float32Array:
//	[0]: index of the note in the ABC source
//	[1]: time in seconds
//	[2]: MIDI instrument (MIDI GM number - 1)
//	[3]: MIDI note pitch (with cents)
//	[4]: duration
//	[5]: volume (0..1)
//	[6]: voice number
    clear: function() {
	var a_pe = a_e;
	a_e = null
	return a_pe
    }, // clear()

// add playing events from the ABC model
    add: function(start,		// starting symbol
		 voice_tb) {		// voice table
	var	kmaps = [],		// accidentals per voice from key signature
		cmaps = [],		// current accidental table
		map,			// map of the current voice - 10 octaves
		temper,			// temperament
		i, n, dt, d, v,
		top_v,			// top voice
		rep_st_s,		// start of sequence to be repeated
		rep_en_s,		// end ("|1")
		rep_nx_s,		// restart at end of repeat
		rep_st_transp,		// transposition at start of repeat sequence
		rep_st_map,		// and map
		rep_st_fac,		// and play factor
		transp,			// clef transposition per voice
		instr = [],		// instrument per voice
		s = start

	// set the accidentals, transpositions and instruments of the voices
	function set_voices() {
	    var v, p_v, s, mi

		temper = voice_tb[0].temper;	// (set by the module temper.js)
		transp = new Int8Array(voice_tb.length)
		for (v = 0; v < voice_tb.length; v++) {
			p_v = voice_tb[v];

			mi = p_v.instr || 0
			if (p_v.midictl) {
				if (p_v.midictl[32])		// bank LSB
					mi += p_v.midictl[32] * 128
				if (p_v.midictl[0])		// bank MSB
					mi += p_v.midictl[0] * 128 * 128
			}
			instr[v] = mi;			// MIDI instrument

			s = p_v.clef;
			transp[v] = (!s.clef_octave || s.clef_oct_transp) ?
					0 : s.clef_octave

			kmaps[v] = new Float32Array(70);
			cmaps[v] = new Float32Array(70);
			p_v.key.v = v;
			key_map(p_v.key)
		}
	} // set_voices()

	// define the accidentals of a voice
	function key_map(s) {
	    var i, bmap

	    if (s.k_bagpipe) {
		// detune for just intonation in A (C is C#, F is F# and G is Gnat)
//		bmap = new Float32Array([100-13.7, -2, 2, 100-15.6, -31.2, 0, 3.9])
//		for (i = 0; i < 7; i++)
//			bmap[i] = (bmap[i] + 150.6) / 100 // 'A' bagpipe = 480Hz
//				// 150.6 = (Math.log2(480/440) - 1)*1200
		bmap = new Float32Array([2.37, 1.49, 1.53, 2.35, 1.19, 1.51, 1.55])
	    } else {
		bmap = new Float32Array(7)
		switch (s.k_sf) {
		case 7: bmap[6] = 1
		case 6: bmap[2] = 1
		case 5: bmap[5] = 1
		case 4: bmap[1] = 1
		case 3: bmap[4] = 1
		case 2: bmap[0] = 1
		case 1: bmap[3] = 1; break
		case -7: bmap[3] = -1
		case -6: bmap[0] = -1
		case -5: bmap[4] = -1
		case -4: bmap[1] = -1
		case -3: bmap[5] = -1
		case -2: bmap[2] = -1
		case -1: bmap[6] = -1; break
		}
	    }
	    for (i = 0; i < 10; i++)
		kmaps[s.v].set(bmap, i * 7);
	    cmaps[s.v].set(kmaps[s.v])
	} // key_map()

	// convert ABC pitch to MIDI index
	function pit2mid(s, i) {
		var	note = s.notes[i],
			p = note.apit + 19, // pitch from C-1
			a = note.acc

		if (transp[s.v])
			p += transp[s.v]
		if (a) {
			if (a == 3)		// (3 = natural)
				a = 0
			else if (note.micro_n)
				a = (a < 0 ? -note.micro_n : note.micro_n) /
						note.micro_d * 2;
			map[p] = a
		} else {
			a = map[p]
		}
		p = ((p / 7) | 0) * 12 + scale[p % 7] + a
		if (!temper || a | 0 != a)	// if equal temperament or micro-tone
			return p
		return p + temper[p % 12]
	} // pit2mid()

	// handle the ties
	function do_tie(s, note, d) {
		var	n,
			end_time = s.time + s.dur,
			pit = note.apit,
			p = pit + 19,
			a = note.acc

		if (transp[s.v])
			p += transp[s.v]

		// search the end of the tie
		for (s = s.next; ; s = s.next) {
			if (!s)
				return d

			// skip if end of sequence to be repeated
			if (s == rep_en_s) {
				var v = s.v;
				s = rep_nx_s.ts_next
				while (s && s.v != v)
					s = s.ts_next
				if (!s)
					return d
				end_time = s.time
			}
			if (s.time != end_time)
				return d
			if (s.type == C.NOTE)
				break
		}
		n = s.notes.length
		for (i = 0; i < n; i++) {
			note = s.notes[i]
			if (note.apit == pit) {
				d += s.dur / play_factor;
				note.ti2 = true
				return note.ti1 ? do_tie(s, note, d) : d
			}
		}
		return d
	} // do_tie()

	// generate the grace notes
	function gen_grace(s) {
		var	g, i, n, t, d, s2,
			next = s.next

		// before beat
		if (s.sappo) {
			d = C.BLEN / 16
		} else if ((!next || next.type != C.NOTE)
			&& s.prev && s.prev.type == C.NOTE) {
			d = s.prev.dur / 2

		// on beat
		} else {

			// keep the sound elements in time order
			next.ts_prev.ts_next = next.ts_next;
			next.ts_next.ts_prev = next.ts_prev;
			for (s2 = next.ts_next; s2; s2 = s2.ts_next) {
				if (s2.time != next.time) {
					next.ts_next = s2
					next.ts_prev = s2.ts_prev;
					next.ts_prev.ts_next = next;
					s2.ts_prev = next
					break
				}
			}

			if (!next.dots)
				d = next.dur / 2
			else if (next.dots == 1)
				d = next.dur / 3
			else
				d = next.dur * 2 / 7;
			next.time += d;
			next.dur -= d
		}
		n = 0
		for (g = s.extra; g; g = g.next)
			if (g.type == C.NOTE)
				n++;
		d /= n * play_factor;
		t = p_time
		for (g = s.extra; g; g = g.next) {
			if (g.type != C.NOTE)
				continue
			gen_notes(g, t, d);
			t += d
		}
	} // gen_grace()

	// generate the notes
	function gen_notes(s, t, d) {
		for (var i = 0; i <= s.nhd; i++) {
		    var	note = s.notes[i]
			if (note.ti2)
				continue
			a_e.push(new Float32Array([
				s.istart,
				t,
				instr[s.v],
				pit2mid(s, i),
				note.ti1 ? do_tie(s, note, d) : d,
				1,
				s.v]))
		}
	} // gen_note()

	// add() main

	set_voices();			// initialize the voice parameters

	if (!a_e) {			// if first call
		a_e = []
		abc_time = rep_st_t = p_time = 0;
		play_factor = C.BLEN / 4 * 120 / 60	// default: Q:1/4=120
	} else if (s.time < abc_time) {
		abc_time = rep_st_t = s.time
	}

	// loop on the symbols
	while (s) {
//		if (s.type == C.TEMPO
//		 && s.tempo) {
		if (s.tempo) {				// tempo change
			d = 0;
			n = s.tempo_notes.length
			for (i = 0; i < n; i++)
				d += s.tempo_notes[i];
			play_factor = d * s.tempo / 60
		}

		dt = s.time - abc_time
		if (dt > 0) {
			p_time += dt / play_factor;
			abc_time = s.time
		}

		if (s == rep_en_s) {			// repeat end
			s = rep_nx_s;
			abc_time = s.time
		}

		map = cmaps[s.v]
		switch (s.type) {
		case C.BAR:
//fixme: does not work if different measures per voice
			if (s.v != top_v)
				break

			// right repeat
			if (s.bar_type[0] == ':') {
				s.bar_type = '|' +
					 s.bar_type.slice(1); // don't repeat again
				rep_nx_s = s		// repeat next
				if (!rep_en_s)		// if no "|1"
					rep_en_s = s	// repeat end
				if (rep_st_s) {		// if left repeat
					s = rep_st_s
					for (v = 0; v < voice_tb.length; v++) {
						cmaps[v].set(rep_st_map[v]);
						transp[v] = rep_st_transp[v]
					}
					play_factor = rep_st_fac;
				} else {			// back to start
					s = start;
					set_voices();
				}
				abc_time = s.time
				break
			}

			if (!s.invis) {
				for (v = 0; v < voice_tb.length; v++)
					cmaps[v].set(kmaps[v])
			}

			// left repeat
			if (s.bar_type[s.bar_type.length - 1] == ':') {
				rep_st_s = s;
				rep_en_s = null
				for (v = 0; v < voice_tb.length; v++) {
					if (!rep_st_map)
						rep_st_map = []
					if (!rep_st_map[v])
						rep_st_map[v] =
							new Float32Array(70)
					rep_st_map[v].set(cmaps[v]);
					if (!rep_st_transp)
						rep_st_transp = []
					rep_st_transp[v] = transp[v]
				}
				rep_st_fac = play_factor
				break

			// 1st time repeat
			} else if (s.text && s.text[0] == '1') {
				rep_en_s = s
			}
			break
		case C.CLEF:
			transp[s.v] = (!s.clef_octave || s.clef_oct_transp) ?
					0 : s.clef_octave
			break
		case C.GRACE:
			if (s.time == 0		// if before beat at start time
			 && abc_time == 0) {
				dt = 0
				if (s.sappo)
					dt = C.BLEN / 16
				else if (!s.next || s.next.type != C.NOTE)
					dt = d / 2;
				abc_time -= dt
			}
			gen_grace(s)
			break
		case C.KEY:
			key_map(s)
			break
		case C.REST:
		case C.NOTE:
			d = s.dur
			if (s.next && s.next.type == C.GRACE) {
				dt = 0
				if (s.next.sappo)
					dt = C.BLEN / 16
				else if (!s.next.next || s.next.next.type != C.NOTE)
					dt = d / 2;
				s.next.time -= dt;
				d -= dt
			}
			d /= play_factor
			if (s.type == C.NOTE)
				gen_notes(s, p_time, d)
			else
				a_e.push(new Float32Array([
					s.istart,
					p_time,
					0,
					0,
					d,
					0,
					s.v]))
			break
		case C.STAVES:
			top_v = s.sy.top_voice
			break
		}
		s = s.ts_next
	}
    } // add()
  } // return
} // ToAudio

// nodejs
if (typeof module == 'object' && typeof exports == 'object')
	exports.ToAudio = ToAudio
// toaudio5.js - audio output using HTML5 audio
//
// Copyright (C) 2015-2018 Jean-Francois Moine
//
// This file is part of abc2svg.
//
// abc2svg is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with abc2svg.  If not, see <http://www.gnu.org/licenses/>.

// Audio5 creation

// @conf: configuration object - all items are optional:
//	ac: audio context - (default: created on play start)
//	sfu: soundfont URL (sf2 base64 encoded - default: "Scc1t2")
//	onend: callback function called at end of playing
//		(no arguments)
//	onnote: callback function called on note start/stop playing
//		Arguments:
//			i: start index of the note in the ABC source
//			on: true on note start, false on note stop
//	errmsg: function called on error (default: alert)
//
//  When playing, the following items must/may be set:
//	gain: (mandatory) volume, must be set to [0..1]
//	speed: (mandatory) must be set to 1
//	new_speed: (optional) new speed value

// Audio5 methods

// get_outputs() - get the output devices
//	return ['sf2'] or null
//
// play() - start playing
// @start_index -
// @stop_index: indexes of the play_event array
// @play_event: array of array
//		[0]: index of the note in the ABC source
//		[1]: time in seconds
//		[2]: MIDI instrument (MIDI GM number - 1)
//		[3]: MIDI note pitch (with cents)
//		[4]: duration
//		[5]: volume (0..1 - optional)
//
// stop() - stop playing
//
// set_vol() - set the current sound volume
// @volume: range [0..1] - undefined = return current value

    var	abcsf2 = []			// SF2 instruments

function Audio5(i_conf) {
	var	conf = i_conf,		// configuration
		onend = conf.onend || function() {},
		onnote = conf.onnote || function() {},
		errmsg = conf.errmsg || alert,
		ac,			// audio context
		gain,			// global gain

	// instruments/notes
		params = [],		// [instr][key] note parameters per instrument
		rates = [],		// [instr][key] playback rates
		w_instr = 0,		// number of instruments being loaded

	// -- play the memorized events --
		evt_idx,		// event index while playing
		iend,			// play array stop index
		stime			// start playing time

	// base64 stuff
	    var b64d = []
	function init_b64d() {
	    var	b64l = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
		l = b64l.length
		for (var i = 0; i < l; i++)
			b64d[b64l[i]] = i
		b64d['='] = 0
	}
	function b64dcod(s) {
	    var	i, t, dl, a,
		l = s.length,
		j = 0

		dl = l * 3 / 4			// destination length
		if (s[l - 1] == '=') {
			if (s[l - 2] == '=')
				dl--;
			dl--;
			l -= 4
		}
		a = new Uint8Array(dl)
		for (i = 0; i < l; i += 4) {
			t =	(b64d[s[i]] << 18) +
				(b64d[s[i + 1]] << 12) +
				(b64d[s[i + 2]] << 6) +
				 b64d[s[i + 3]];
			a[j++] = (t >> 16) & 0xff;
			a[j++] = (t >> 8) & 0xff;
			a[j++] = t & 0xff
		}
		if (l != s.length) {
			t =	(b64d[s[i]] << 18) +
				(b64d[s[i + 1]] << 12) +
				(b64d[s[i + 2]] << 6) +
				 b64d[s[i + 3]];
			a[j++] = (t >> 16) & 0xff
			if (j < dl)
				a[j++] = (t >> 8) & 0xff
		}
		return a
	}

	// copy a sf2 sample to an audio buffer
	// @b = audio buffer (array of [-1..1])
	// @s = sf2 sample (PCM 16 bits)
	function sample_cp(b, s) {
	    var	i, n,
		a = b.getChannelData(0)		// destination = array of float32

		for (i = 0; i < s.length; i++)
			a[i] = s[i] / 196608	// volume divided by 6
	}

	// create all notes of an instrument
	function sf2_create(parser, instr) {
	    var i, sid, gen, parm, sampleRate, sample,
		infos = parser.getInstruments()[0].info;

		rates[instr] = []
		for (i = 0; i < infos.length; i++) {
			gen = infos[i].generator;
			if (!gen.sampleID)	// (empty generator!)
				continue
			sid = gen.sampleID.amount;
			sampleRate = parser.sampleHeader[sid].sampleRate;
			sample = parser.sample[sid];
			parm = {
				attack: Math.pow(2, (gen.attackVolEnv ?
					gen.attackVolEnv.amount : -12000) / 1200),
				hold: Math.pow(2, (gen.holdVolEnv ?
					gen.holdVolEnv.amount : -12000) / 1200),
				decay: Math.pow(2, (gen.decayVolEnv ?
					gen.decayVolEnv.amount : -12000) / 1200) / 3,
				sustain: gen.sustainVolEnv ?
					(gen.sustainVolEnv.amount / 1000) : 0,
//				release: Math.pow(2, (gen.releaseVolEnv ?
//					gen.releaseVolEnv.amount : -12000) / 1200),
				buffer: ac.createBuffer(1,
							sample.length,
							sampleRate)
			}
			parm.hold += parm.attack;
			parm.decay += parm.hold;

			// sustain > 40dB is not audible
			if (parm.sustain >= .4)
				parm.sustain = 0.01	// must not be null
			else
				parm.sustain = 1 - parm.sustain / .4

			sample_cp(parm.buffer, sample)

			if (gen.sampleModes && (gen.sampleModes.amount & 1)) {
				parm.loopStart = parser.sampleHeader[sid].startLoop /
					sampleRate;
				parm.loopEnd = parser.sampleHeader[sid].endLoop /
					sampleRate
			}

			// define the notes
		    var scale = (gen.scaleTuning ?
					gen.scaleTuning.amount : 100) / 100,
			tune = (gen.coarseTune ? gen.coarseTune.amount : 0) +
				(gen.fineTune ? gen.fineTune.amount : 0) / 100 +
				parser.sampleHeader[sid].pitchCorrection / 100 -
				(gen.overridingRootKey ?
					gen.overridingRootKey.amount :
					parser.sampleHeader[sid].originalPitch)

			for (j = gen.keyRange.lo; j <= gen.keyRange.hi; j++) {
				rates[instr][j] = Math.pow(Math.pow(2, 1 / 12),
							(j + tune) * scale);
				params[instr][j] = parm
			}
		}
	} // sf2_create()

	// load an instrument (.js file)
	function load_instr(instr) {
		w_instr++;
		abc2svg.loadjs(conf.sfu + '/' + instr + '.js',
			function() {
			    var	parser = new sf2.Parser(b64dcod(abcsf2[instr]));
				parser.parse();
				sf2_create(parser, instr);
				w_instr--
			},
			function() {
				errmsg('could not find the instrument ' +
					((instr / 128) | 0).toString() + '-' +
					(instr % 128).toString());
				w_instr--
			})
	} // load_instr()

	// start loading the instruments
	function load_res(a_e) {
		var i, e, instr

		for (i = evt_idx; ; i++) {
			e = a_e[i]
			if (!e || evt_idx >= iend)
				break
			instr = e[2]
			if (!params[instr]) {
				params[instr] = [];
				load_instr(instr)
			}
		}
	}

	// create a note
	// @e[2] = instrument index
	// @e[3] = MIDI key + detune
	// @t = audio start time
	// @d = duration adjusted for speed
	function note_run(e, t, d) {
	    var	g, st,
		instr = e[2],
		key = e[3] | 0,
		parm = params[instr][key],
		o = ac.createBufferSource();

		if (!parm)		// if the instrument could not be loaded
			return		// or if it has not this key
		o.buffer = parm.buffer
		if (parm.loopStart) {
			o.loop = true;
			o.loopStart = parm.loopStart;
			o.loopEnd = parm.loopEnd;
		}
		if (o.detune) {
		    var	dt = (e[3] * 100) % 100
			if (dt)			// if micro-tone
				 o.detune.value = dt
		}
//		o.playbackRate.setValueAtTime(parm.rate, ac.currentTime);
		o.playbackRate.value = rates[instr][key];

		g = ac.createGain();
		if (parm.hold < 0.002) {
			g.gain.setValueAtTime(1, t)
		} else {
			if (parm.attack < 0.002) {
				g.gain.setValueAtTime(1, t)
			} else {
				g.gain.setValueAtTime(0, t);
				g.gain.linearRampToValueAtTime(1, t + parm.attack)
			}
			g.gain.setValueAtTime(1, t + parm.hold)
		}

		g.gain.exponentialRampToValueAtTime(parm.sustain,
					t + parm.decay);

		o.connect(g);
		g.connect(gain);

		// start the note
		o.start(t);
		o.stop(t + d)
	} // note_run()

	// play the next time sequence
	function play_next(a_e) {
		var	t, e, e2, maxt, st, d;

		// play the next events
		e = a_e[evt_idx]
		if (!e || evt_idx >= iend) {
			onend()
			return
		}

		// if speed change, shift the start time
		if (conf.new_speed) {
			stime = ac.currentTime -
					(ac.currentTime - stime) *
						conf.speed / conf.new_speed;
			conf.speed = conf.new_speed;
			conf.new_speed = 0
		}

//fixme: better, count the number of events?
		t = e[1] / conf.speed;		// start time
		maxt = t + 3			// max time = evt time + 3 seconds
		while (1) {
			d = e[4] / conf.speed
			if (e[5] != 0)		// if not a rest
				note_run(e, t + stime, d)

			// follow the notes while playing
			    var	i = e[0];
				st = (t + stime - ac.currentTime) * 1000;
				setTimeout(onnote, st, i, true);
				setTimeout(onnote, st + d * 1000, i, false)

			e = a_e[++evt_idx]
			if (!e || evt_idx >= iend) {
				setTimeout(onend,
					(t + stime - ac.currentTime + d) * 1000)
				return
			}
			t = e[1] / conf.speed
			if (t > maxt)
				break
		}

		// delay before next sound generation
		setTimeout(play_next, (t + stime - ac.currentTime)
				* 1000 - 300,	// wake before end of playing
				a_e)
	} // play_next()

	// wait for all resources, then start playing
	function play_start(a_e) {
		if (iend == 0) {	// play stop
			onend()
			return
		}

		// wait for instruments
		if (w_instr != 0) {
			setTimeout(play_start, 300, a_e)
			return
		}

		// all resources are there
		gain.connect(ac.destination);
		stime = ac.currentTime + .2		// start time + 0.2s
			- a_e[evt_idx][1] * conf.speed;
		play_next(a_e)
	} // play_start()

// Audio5 object creation

	init_b64d();			// initialize base64 decoding

	if (!conf.sfu)
		conf.sfu = "Scc1t2"	// set the default soundfont location

    // external methods
    return {

	// get outputs
	get_outputs: function() {
		return (window.AudioContext || window.webkitAudioContext) ?
				['sf2'] : null
	}, // get_outputs()

	// play the events
	play: function(istart, i_iend, a_e) {
		if (!a_e || istart >= a_e.length) {
			onend()			// nothing to play
			return
		}

		// initialize the audio subsystem if not done yet
		// (needed for iPhone/iPad/...)
		if (!gain) {
			ac = conf.ac
			if (!ac)
				conf.ac = ac = new (window.AudioContext ||
							window.webkitAudioContext);
			gain = ac.createGain();
			gain.gain.value = conf.gain
		}

		iend = i_iend;
		evt_idx = istart;
		load_res(a_e);
		play_start(a_e)
	}, // play()

	// stop playing
	stop: function() {
		iend = 0
		if (gain) {
			gain.disconnect();
			gain = null
		}
	}, // stop()

	// set volume
	set_vol: function(v) {
		if (gain)
			gain.gain.value = v
	} // set_vol()
    }
} // end Audio5
/*! JavaScript SoundFont 2 Parser. Copyright 2013-2015 imaya/GREE Inc and Colin Clark. Licensed under the MIT License. */

/*
 * JavaScript SoundFont 2 Parser
 *
 * Copyright 2013 imaya/GREE Inc
 * Copyright 2015 Colin Clark
 *
 * Based on code from the "SoundFont Synthesizer for WebMidiLink"
 *   https://github.com/gree/sf2synth.js
 *
 * Adapted to abc2svg
 * Copyright (C) 2018 Jean-Francois Moine
 *
 * Licensed under the MIT License.
 */

/*global require*/

(function (root, factory) {
    if (typeof exports === "object") {
        // We're in a CommonJS-style loader.
        root.sf2 = exports;
        factory(exports);
    } else if (typeof define === "function" && define.amd) {
        // We're in an AMD-style loader.
        define(["exports"], function (exports) {
            root.sf2 = exports;
            return (root.sf2, factory(exports));
        });
    } else {
        // Plain old browser.
        root.sf2 = {};
        factory(root.sf2);
    }
}(this, function (exports) {
    "use strict";

    var sf2 = exports;

    sf2.Parser = function (input, options) {
      options = options || {};
      /** @type {ByteArray} */
      this.input = input;
      /** @type {(Object|undefined)} */
      this.parserOptions = options.parserOptions;

      /** @type {Array.<Object>} */
      // this.presetHeader;
      /** @type {Array.<Object>} */
      // this.presetZone;
      /** @type {Array.<Object>} */
      // this.presetZoneModulator;
      /** @type {Array.<Object>} */
      // this.presetZoneGenerator;
      /** @type {Array.<Object>} */
      // this.instrument;
      /** @type {Array.<Object>} */
      // this.instrumentZone;
      /** @type {Array.<Object>} */
      // this.instrumentZoneModulator;
      /** @type {Array.<Object>} */
      // this.instrumentZoneGenerator;
      /** @type {Array.<Object>} */
      //this.sampleHeader;
    };

    sf2.Parser.prototype.parse = function () {
      /** @type {sf2.Riff.Parser} */
      var parser = new sf2.Riff.Parser(this.input, this.parserOptions),
      /** @type {?sf2.Riff.Chunk} */
	  chunk;

      // parse RIFF chunk
      parser.parse();
      if (parser.chunkList.length !== 1)
        throw new Error('wrong chunk length');

      chunk = parser.getChunk(0);
      if (chunk === null)
        throw new Error('chunk not found');

      this.parseRiffChunk(chunk);

      // TODO: Presumably this is here to reduce memory,
      // but does it really matter? Shouldn't we always be
      // referencing the underlying ArrayBuffer and thus
      // it will persist, in which case why delete it?
      this.input = null;
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parseRiffChunk = function (chunk) {
      /** @type {sf2.Riff.Parser} */
      var parser,
      /** @type {ByteArray} */
	  data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {string} */
	  signature;

      // check parse target
      if (chunk.type !== 'RIFF')
        throw new Error('invalid chunk type:' + chunk.type);

      // check signature
      signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);
      if (signature !== 'sfbk')
        throw new Error('invalid signature:' + signature);

      // read structure
      parser = new sf2.Riff.Parser(data, {'index': ip, 'length': chunk.size - 4});
      parser.parse();
      if (parser.getNumberOfChunks() !== 3)
        throw new Error('invalid sfbk structure');

      // INFO-list
      this.parseInfoList(/** @type {!sf2.Riff.Chunk} */parser.getChunk(0));

      // sdta-list
      this.parseSdtaList(/** @type {!sf2.Riff.Chunk} */parser.getChunk(1));

      // pdta-list
      this.parsePdtaList(/** @type {!sf2.Riff.Chunk} */parser.getChunk(2));
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parseInfoList = function (chunk) {
      /** @type {sf2.Riff.Parser} */
      var parser,
      /** @type {ByteArray} */
	  data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {string} */
	  signature;

      // check parse target
      if (chunk.type !== 'LIST')
        throw new Error('invalid chunk type:' + chunk.type);

      // check signature
      signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);
      if (signature !== 'INFO')
        throw new Error('invalid signature:' + signature);

      // read structure
      parser = new sf2.Riff.Parser(data, {'index': ip, 'length': chunk.size - 4});
      parser.parse();
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parseSdtaList = function (chunk) {
      /** @type {sf2.Riff.Parser} */
      var parser,
      /** @type {ByteArray} */
	  data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {string} */
	  signature;

      // check parse target
      if (chunk.type !== 'LIST')
        throw new Error('invalid chunk type:' + chunk.type);

      // check signature
      signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);
      if (signature !== 'sdta')
        throw new Error('invalid signature:' + signature);

      // read structure
      parser = new sf2.Riff.Parser(data, {'index': ip, 'length': chunk.size - 4});
      parser.parse();
      if (parser.chunkList.length !== 1)
        throw new Error('TODO');
      this.samplingData =
        /** @type {{type: string, size: number, offset: number}} */
	  parser.getChunk(0);
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parsePdtaList = function (chunk) {
      /** @type {sf2.Riff.Parser} */
      var parser,
      /** @type {ByteArray} */
	  data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {string} */
	  signature;

      // check parse target
      if (chunk.type !== 'LIST')
        throw new Error('invalid chunk type:' + chunk.type);

      // check signature
      signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);
      if (signature !== 'pdta')
        throw new Error('invalid signature:' + signature);

      // read structure
      parser = new sf2.Riff.Parser(data, {'index': ip, 'length': chunk.size - 4});
      parser.parse();

      // check number of chunks
      if (parser.getNumberOfChunks() !== 9)
        throw new Error('invalid pdta chunk');

      this.parsePhdr(/** @type {sf2.Riff.Chunk} */(parser.getChunk(0)));
      this.parsePbag(/** @type {sf2.Riff.Chunk} */(parser.getChunk(1)));
      this.parsePmod(/** @type {sf2.Riff.Chunk} */(parser.getChunk(2)));
      this.parsePgen(/** @type {sf2.Riff.Chunk} */(parser.getChunk(3)));
      this.parseInst(/** @type {sf2.Riff.Chunk} */(parser.getChunk(4)));
      this.parseIbag(/** @type {sf2.Riff.Chunk} */(parser.getChunk(5)));
      this.parseImod(/** @type {sf2.Riff.Chunk} */(parser.getChunk(6)));
      this.parseIgen(/** @type {sf2.Riff.Chunk} */(parser.getChunk(7)));
      this.parseShdr(/** @type {sf2.Riff.Chunk} */(parser.getChunk(8)));
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parsePhdr = function (chunk) {
      /** @type {ByteArray} */
      var data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {Array.<Object>} */
	  presetHeader = this.presetHeader = [],
      /** @type {number} */
	  size = chunk.offset + chunk.size;

      // check parse target
      if (chunk.type !== 'phdr')
        throw new Error('invalid chunk type:' + chunk.type);

      while (ip < size) {
        presetHeader.push({
          presetName: String.fromCharCode.apply(null, data.subarray(ip, ip += 20)),
          preset: data[ip++] | (data[ip++] << 8),
          bank: data[ip++] | (data[ip++] << 8),
          presetBagIndex: data[ip++] | (data[ip++] << 8),
          library: (data[ip++] | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)) >>> 0,
          genre: (data[ip++] | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)) >>> 0,
          morphology: (data[ip++] | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)) >>> 0
        });
      }
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parsePbag = function (chunk) {
      /** @type {ByteArray} */
      var data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {Array.<Object>} */
	  presetZone = this.presetZone = [],
      /** @type {number} */
	  size = chunk.offset + chunk.size;

      // check parse target
      if (chunk.type !== 'pbag')
        throw new Error('invalid chunk type:'  + chunk.type);

      while (ip < size) {
        presetZone.push({
          presetGeneratorIndex: data[ip++] | (data[ip++] << 8),
          presetModulatorIndex: data[ip++] | (data[ip++] << 8)
        });
      }
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parsePmod = function (chunk) {
      // check parse target
      if (chunk.type !== 'pmod')
        throw new Error('invalid chunk type:' + chunk.type);

      this.presetZoneModulator = this.parseModulator(chunk);
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parsePgen = function (chunk) {
      // check parse target
      if (chunk.type !== 'pgen')
        throw new Error('invalid chunk type:' + chunk.type);
      this.presetZoneGenerator = this.parseGenerator(chunk);
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parseInst = function (chunk) {
      /** @type {ByteArray} */
      var data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {Array.<Object>} */
	  instrument = this.instrument = [],
      /** @type {number} */
	  size = chunk.offset + chunk.size;

      // check parse target
      if (chunk.type !== 'inst')
        throw new Error('invalid chunk type:' + chunk.type);

      while (ip < size) {
        instrument.push({
          instrumentName: String.fromCharCode.apply(null, data.subarray(ip, ip += 20)),
          instrumentBagIndex: data[ip++] | (data[ip++] << 8)
        });
      }
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parseIbag = function (chunk) {
      /** @type {ByteArray} */
      var data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {Array.<Object>} */
	  instrumentZone = this.instrumentZone = [],
      /** @type {number} */
	  size = chunk.offset + chunk.size;

      // check parse target
      if (chunk.type !== 'ibag')
        throw new Error('invalid chunk type:' + chunk.type);

      while (ip < size) {
        instrumentZone.push({
          instrumentGeneratorIndex: data[ip++] | (data[ip++] << 8),
          instrumentModulatorIndex: data[ip++] | (data[ip++] << 8)
        });
      }
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parseImod = function (chunk) {
      // check parse target
      if (chunk.type !== 'imod')
        throw new Error('invalid chunk type:' + chunk.type);

      this.instrumentZoneModulator = this.parseModulator(chunk);
    };


    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parseIgen = function (chunk) {
      // check parse target
      if (chunk.type !== 'igen')
        throw new Error('invalid chunk type:' + chunk.type);

      this.instrumentZoneGenerator = this.parseGenerator(chunk);
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     */
    sf2.Parser.prototype.parseShdr = function (chunk) {
      /** @type {ByteArray} */
      var data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {Array.<Object>} */
	  samples = this.sample = [],
      /** @type {Array.<Object>} */
	  sampleHeader = this.sampleHeader = [],
      /** @type {number} */
	  size = chunk.offset + chunk.size,
      /** @type {string} */
	  sampleName,
      /** @type {number} */
	  start,
      /** @type {number} */
	  end,
      /** @type {number} */
	  startLoop,
      /** @type {number} */
	  endLoop,
      /** @type {number} */
	  sampleRate,
      /** @type {number} */
	  originalPitch,
      /** @type {number} */
	  pitchCorrection,
      /** @type {number} */
	  sampleLink,
      /** @type {number} */
	  sampleType;

      // check parse target
      if (chunk.type !== 'shdr')
        throw new Error('invalid chunk type:' + chunk.type);

      while (ip < size) {
        sampleName = String.fromCharCode.apply(null, data.subarray(ip, ip += 20));
        start =
          (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24);
        end =
          (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24);
        startLoop =
          (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24);
        endLoop =
          (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24);
        sampleRate =
          (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24);
        originalPitch = data[ip++];
        pitchCorrection = (data[ip++] << 24) >> 24;
        sampleLink = data[ip++] | (data[ip++] << 8);
        sampleType = data[ip++] | (data[ip++] << 8);

        var sample = new Int16Array(new Uint8Array(data.subarray(
          this.samplingData.offset + start * 2,
          this.samplingData.offset + end   * 2
        )).buffer);

        startLoop -= start;
        endLoop -= start;

        if (sampleRate > 0) {
          var adjust = this.adjustSampleData(sample, sampleRate);
          sample = adjust.sample;
          sampleRate *= adjust.multiply;
          startLoop *= adjust.multiply;
          endLoop *= adjust.multiply;
        }

        samples.push(sample);

        sampleHeader.push({
          sampleName: sampleName,
          /*
          start: start,
          end: end,
          */
          startLoop: startLoop,
          endLoop: endLoop,
          sampleRate: sampleRate,
          originalPitch: originalPitch,
          pitchCorrection: pitchCorrection,
          sampleLink: sampleLink,
          sampleType: sampleType
        });
      }
    };

    // TODO: This function is questionable;
    // it doesn't interpolate the sample data
    // and always forces a sample rate of 22050 or higher. Why?
    sf2.Parser.prototype.adjustSampleData = function (sample, sampleRate) {
      /** @type {Int16Array} */
      var newSample,
      /** @type {number} */
	  i,
      /** @type {number} */
	  il,
      /** @type {number} */
	  j,
      /** @type {number} */
	  multiply = 1;

      // buffer
      while (sampleRate < 22050) {
        newSample = new Int16Array(sample.length * 2);
        for (i = j = 0, il = sample.length; i < il; ++i) {
          newSample[j++] = sample[i];
          newSample[j++] = sample[i];
        }
        sample = newSample;
        multiply *= 2;
        sampleRate *= 2;
      }

      return {
        sample: sample,
        multiply: multiply
      };
    };

    /**
     * @param {sf2.Riff.Chunk} chunk
     * @return {Array.<Object>}
     */
    sf2.Parser.prototype.parseModulator = function (chunk) {
        /** @type {ByteArray} */
        var data = this.input,
        /** @type {number} */
	    ip = chunk.offset,
        /** @type {number} */
	    size = chunk.offset + chunk.size,
        /** @type {number} */
	    code,
        /** @type {string} */
	    key,
        /** @type {Array.<Object>} */
	    output = [];

        while (ip < size) {
          // Src  Oper
          // TODO
          ip += 2;

          // Dest Oper
          code = data[ip++] | (data[ip++] << 8);
          key = sf2.Parser.GeneratorEnumeratorTable[code];
          if (key === undefined) {
            // Amount
            output.push({
              type: key,
              value: {
                code: code,
                amount: data[ip] | (data[ip+1] << 8) << 16 >> 16,
                lo: data[ip++],
                hi: data[ip++]
              }
            });
          } else {
            // Amount
            switch (key) {
              case 'keyRange': /* FALLTHROUGH */
              case 'velRange': /* FALLTHROUGH */
              case 'keynum': /* FALLTHROUGH */
              case 'velocity':
                output.push({
                  type: key,
                  value: {
                    lo: data[ip++],
                    hi: data[ip++]
                  }
                });
                break;
              default:
                output.push({
                  type: key,
                  value: {
                    amount: data[ip++] | (data[ip++] << 8) << 16 >> 16
                  }
                });
                break;
            }
          }

          // AmtSrcOper
          // TODO
          ip += 2;

          // Trans Oper
          // TODO
          ip += 2;
        }

        return output;
      };

    /**
     * @param {sf2.Riff.Chunk} chunk
     * @return {Array.<Object>}
     */
    sf2.Parser.prototype.parseGenerator = function (chunk) {
      /** @type {ByteArray} */
      var data = this.input,
      /** @type {number} */
	  ip = chunk.offset,
      /** @type {number} */
	  size = chunk.offset + chunk.size,
      /** @type {number} */
	  code,
      /** @type {string} */
	  key,
      /** @type {Array.<Object>} */
	  output = [];

      while (ip < size) {
        code = data[ip++] | (data[ip++] << 8);
        key = sf2.Parser.GeneratorEnumeratorTable[code];
        if (key === undefined) {
          output.push({
            type: key,
            value: {
              code: code,
              amount: data[ip] | (data[ip+1] << 8) << 16 >> 16,
              lo: data[ip++],
              hi: data[ip++]
            }
          });
          continue;
        }

        switch (key) {
          case 'keynum': /* FALLTHROUGH */
          case 'keyRange': /* FALLTHROUGH */
          case 'velRange': /* FALLTHROUGH */
          case 'velocity':
            output.push({
              type: key,
              value: {
                lo: data[ip++],
                hi: data[ip++]
              }
            });
            break;
          default:
            output.push({
              type: key,
              value: {
                amount: data[ip++] | (data[ip++] << 8) << 16 >> 16
              }
            });
            break;
        }
      }

      return output;
    };

    sf2.Parser.prototype.getInstruments = function () {
      /** @type {Array.<Object>} */
      var instrument = this.instrument,
      /** @type {Array.<Object>} */
	  zone = this.instrumentZone,
      /** @type {Array.<Object>} */
	  output = [],
      /** @type {number} */
	  bagIndex,
      /** @type {number} */
	  bagIndexEnd,
      /** @type {Array.<Object>} */
	  zoneInfo,
      /** @type {{generator: Object, generatorInfo: Array.<Object>}} */
	  instrumentGenerator,
      /** @type {{modulator: Object, modulatorInfo: Array.<Object>}} */
	  instrumentModulator,
      /** @type {number} */
	  i,
      /** @type {number} */
	  il,
      /** @type {number} */
	  j,
      /** @type {number} */
	  jl;

      // instrument -> instrument bag -> generator / modulator
      for (i = 0, il = instrument.length; i < il; ++i) {
        bagIndex    = instrument[i].instrumentBagIndex;
        bagIndexEnd = instrument[i+1] ? instrument[i+1].instrumentBagIndex : zone.length;
        zoneInfo = [];

        // instrument bag
        for (j = bagIndex, jl = bagIndexEnd; j < jl; ++j) {
          instrumentGenerator = this.createInstrumentGenerator_(zone, j);
          instrumentModulator = this.createInstrumentModulator_(zone, j);

          zoneInfo.push({
            generator: instrumentGenerator.generator,
            modulator: instrumentModulator.modulator,
          });
        }

        output.push({
          name: instrument[i].instrumentName,
          info: zoneInfo
        });
      }

      return output;
    };

    /**
     * @param {Array.<Object>} zone
     * @param {number} index
     * @returns {{generator: Object, generatorInfo: Array.<Object>}}
     * @private
     */
    sf2.Parser.prototype.createInstrumentGenerator_ = function (zone, index) {
      var modgen = this.createBagModGen_(
        zone,
        zone[index].instrumentGeneratorIndex,
        zone[index+1] ? zone[index+1].instrumentGeneratorIndex: this.instrumentZoneGenerator.length,
        this.instrumentZoneGenerator
      );

      return {
        generator: modgen.modgen,
      };
    };

    /**
     * @param {Array.<Object>} zone
     * @param {number} index
     * @returns {{modulator: Object, modulatorInfo: Array.<Object>}}
     * @private
     */
    sf2.Parser.prototype.createInstrumentModulator_ = function (zone, index) {
      var modgen = this.createBagModGen_(
        zone,
        zone[index].presetModulatorIndex,
        zone[index+1] ? zone[index+1].instrumentModulatorIndex: this.instrumentZoneModulator.length,
        this.instrumentZoneModulator
      );

      return {
        modulator: modgen.modgen
      };
    };

    /**
     * @param {Array.<Object>} zone
     * @param {number} indexStart
     * @param {number} indexEnd
     * @param zoneModGen
     * @returns {{modgen: Object, modgenInfo: Array.<Object>}}
     * @private
     */
    sf2.Parser.prototype.createBagModGen_ = function (zone, indexStart, indexEnd, zoneModGen) {
      /** @type {Object} */
      var modgen = {
        unknown: [],
        'keyRange': {
          hi: 127,
          lo: 0
        }
      }; // TODO
      /** @type {Object} */
      var info,
      /** @type {number} */
	  i,
      /** @type {number} */
	  il;

      for (i = indexStart, il = indexEnd; i < il; ++i) {
        info = zoneModGen[i];

        if (info.type === 'unknown')
          modgen.unknown.push(info.value);
	else
          modgen[info.type] = info.value;
      }

      return {
        modgen: modgen
      };
    };


    /**
     * @type {Array.<string>}
     * @const
     */
    sf2.Parser.GeneratorEnumeratorTable = [
      'startAddrsOffset',
      'endAddrsOffset',
      'startloopAddrsOffset',
      'endloopAddrsOffset',
      'startAddrsCoarseOffset',
      'modLfoToPitch',
      'vibLfoToPitch',
      'modEnvToPitch',
      'initialFilterFc',
      'initialFilterQ',
      'modLfoToFilterFc',
      'modEnvToFilterFc',
      'endAddrsCoarseOffset',
      'modLfoToVolume',
      undefined, // 14
      'chorusEffectsSend',
      'reverbEffectsSend',
      'pan',
      undefined,
      undefined,
      undefined, // 18,19,20
      'delayModLFO',
      'freqModLFO',
      'delayVibLFO',
      'freqVibLFO',
      'delayModEnv',
      'attackModEnv',
      'holdModEnv',
      'decayModEnv',
      'sustainModEnv',
      'releaseModEnv',
      'keynumToModEnvHold',
      'keynumToModEnvDecay',
      'delayVolEnv',
      'attackVolEnv',
      'holdVolEnv',
      'decayVolEnv',
      'sustainVolEnv',
      'releaseVolEnv',
      'keynumToVolEnvHold',
      'keynumToVolEnvDecay',
      'instrument',
      undefined, // 42
      'keyRange',
      'velRange',
      'startloopAddrsCoarseOffset',
      'keynum',
      'velocity',
      'initialAttenuation',
      undefined, // 49
      'endloopAddrsCoarseOffset',
      'coarseTune',
      'fineTune',
      'sampleID',
      'sampleModes',
      undefined, // 55
      'scaleTuning',
      'exclusiveClass',
      'overridingRootKey'
    ];

    sf2.Riff = {};

    sf2.Riff.Parser = function (input, options) {
      options = options || {};
      /** @type {ByteArray} */
      this.input = input;
      /** @type {number} */
      this.ip = options.index || 0;
      /** @type {number} */
      this.length = options.length || input.length - this.ip;
      /** @type {Array.<sf2.Riff.Chunk>} */
    //   this.chunkList;
      /** @type {number} */
      this.offset = this.ip;
      /** @type {boolean} */
      this.padding = options.padding !== undefined ? options.padding : true;
      /** @type {boolean} */
      this.bigEndian = options.bigEndian !== undefined ? options.bigEndian : false;
    };

    /**
     * @param {string} type
     * @param {number} size
     * @param {number} offset
     * @constructor
     */
    sf2.Riff.Chunk = function (type, size, offset) {
      /** @type {string} */
      this.type = type;
      /** @type {number} */
      this.size = size;
      /** @type {number} */
      this.offset = offset;
    };

    sf2.Riff.Parser.prototype.parse = function () {
      /** @type {number} */
      var length = this.length + this.offset;

      this.chunkList = [];

      while (this.ip < length)
        this.parseChunk();
    };

    sf2.Riff.Parser.prototype.parseChunk = function () {
      /** @type {ByteArray} */
      var input = this.input,
      /** @type {number} */
	  ip = this.ip,
      /** @type {number} */
	  size;

      this.chunkList.push(new sf2.Riff.Chunk(
        String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]),
        (size = this.bigEndian ?
           ((input[ip++] << 24) | (input[ip++] << 16) |
            (input[ip++] <<  8) | (input[ip++]      )) :
           ((input[ip++]      ) | (input[ip++] <<  8) |
            (input[ip++] << 16) | (input[ip++] << 24))
        ),
        ip
      ));

      ip += size;

      // padding
      if ((this.padding && (ip - this.offset) & 1) === 1)
        ip++;

      this.ip = ip;
    };

    /**
     * @param {number} index chunk index.
     * @return {?sf2.Riff.Chunk}
     */
    sf2.Riff.Parser.prototype.getChunk = function (index) {
      /** @type {sf2.Riff.Chunk} */
      var chunk = this.chunkList[index];

      if (chunk === undefined)
        return null;

      return chunk;
    };

    /**
     * @return {number}
     */
    sf2.Riff.Parser.prototype.getNumberOfChunks = function () {
      return this.chunkList.length;
    };

    return sf2;
}));
// tomidi5.js - audio output using HTML5 MIDI
//
// Copyright (C) 2018 Jean-Francois Moine
//
// This file is part of abc2svg.
//
// abc2svg is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with abc2svg.  If not, see <http://www.gnu.org/licenses/>.

// Midi5 creation

// @conf: configuration object - all items are optional:
//	onend: callback function called at end of playing
//		(no arguments)
//	onnote: callback function called on note start/stop playing
//		Arguments:
//			i: start index of the note in the ABC source
//			on: true on note start, false on note stop

//  When playing, the following items must/may be set:
//	speed: (mandatory) must be set to 1
//	new_speed: (optional) new speed value

// Midi5 methods

// get_outputs() - get the output ports
//
// set_output() - set the output port
//
// play() - start playing
// @start_index -
// @stop_index: indexes of the play_event array
// @play_event: array of array
//		[0]: index of the note in the ABC source
//		[1]: time in seconds
//		[2]: MIDI instrument (MIDI GM number - 1)
//		[3]: MIDI note pitch (with cents)
//		[4]: duration
//		[5]: volume (0..1 - optional)
//		[6]: voice number
//
// stop() - stop playing

function Midi5(i_conf) {
    var	conf = i_conf,		// configuration
	onend = conf.onend || function() {},
	onnote = conf.onnote || function() {},

// MIDI variables
	op,			// output port
	v_i = [],		// voice (channel) to instrument

// -- play the memorized events --
	evt_idx,		// event index while playing
	iend,			// play array stop index
	stime			// start playing time in ms

// create a note
// @e[2] = instrument index
// @e[3] = MIDI key + detune
// @e[6] = voice (channel) number
// @t = audio start time (ms)
// @d = duration adjusted for speed (ms)
    function note_run(e, t, d) {
    var	k = e[3] | 0,
	i = e[2],
	c = e[6] & 0x0f,	//fixme
	d = (e[3] * 100) % 100

	if (i != v_i[c]) {			// if program change
		v_i[c] = i
		op.send(new Uint8Array([
				0xb0 + c, 0, (i >> 14) & 0x7f,	// MSB bank
				0xb0 + c, 32, (i >> 7) & 0x7f,	// LSB bank
				0xc0 + c, i & 0x7f		// program
			]))
	}
	if (d && Midi5.ma.sysexEnabled) {	// if microtone
// fixme: should cache the current microtone values
		op.send(new Uint8Array([
			0xf0, 0x7f,	// realtime SysEx
			0x7f,		// all devices
			0x08,		// MIDI tuning standard
			0x02,		// note change
			i & 0x7f,		// tuning prog number
			0x01,		// number of notes
				k,		// key
				k,		// note
				d / .78125,	// MSB fract
				0,		// LSB fract
			0xf7		// SysEx end
			]), t);
	}
	op.send(new Uint8Array([0x90 + c, k, 127]), t);		// note on
	op.send(new Uint8Array([0x80 + c, k, 0x40]), t + d - 20) // note off
    } // note_run()

// play the next time sequence
    function play_next(a_e) {
    var	t, e, e2, maxt, st, d

	// play the next events
	e = a_e[evt_idx]
	if (!op || evt_idx >= iend || !e) {
		onend()
		return
	}
			
	// if speed change, shift the start time
	if (conf.new_speed) {
		stime = window-performance.now() -
				(window.performance.now() - stime) *
					conf.speed / conf.new_speed;
		conf.speed = conf.new_speed;
		conf.new_speed = 0
	}

	t = e[1] / conf.speed * 1000;	// start time
	maxt = t + 3000			// max time = evt time + 3 seconds
	while (1) {
		d = e[4] / conf.speed * 1000
		if (e[5] != 0)		// if not a rest
			note_run(e, t + stime, d)

		// follow the notes while playing
			st = t + stime - window.performance.now();
			setTimeout(onnote, st, e[0], true);
			setTimeout(onnote, st + d, e[0], false)

		e = a_e[++evt_idx]
		if (!e || evt_idx >= iend) {
			setTimeout(onend,
				t + stime - window.performance.now() + d)
			return
		}
		t = e[1] / conf.speed * 1000
		if (t > maxt)
			break
	}

	// delay before next sound generation
	setTimeout(play_next, (t + stime - window.performance.now())
			- 300,		// wake before end of playing
			a_e)
    } // play_next()

// Midi5 object creation (only one instance)

// public methods
    return {

	// get outputs
	get_outputs: function() {
//fixme: just the first output port for now...
		if (Midi5.ma)
			op = Midi5.ma.outputs.values().next().value
			if (op)
				return [op.name]
	}, // get_outputs()

	// set the output port
	set_output: function(name) {
//fixme: todo
//		if (!Midi5.ma)
//			return
	},

	// play the events
	play: function(istart, i_iend, a_e) {
		if (!a_e || istart >= a_e.length) {
			onend()			// nothing to play
			return
		}
		iend = i_iend;
		evt_idx = istart;
if (0) {
// temperament
	op.send(new Uint8Array([
			0xf0, 0x7f,	// realtime SysEx
			0x7f,		// all devices
			0x08,		// MIDI tuning standard
			0x02,		// note change
			0x00,		// tuning prog number
			0x01,		// number of notes
				0x69,		// key
				0x69,		// note
				0x00,		// MSB fract
				0,		// LSB fract
			0xf7		// SysEx end
			]), t);
}

		stime = window.performance.now() + 200	// start time + 0.2s
			- a_e[evt_idx][1] * conf.speed * 1000;
		play_next(a_e)
	}, // play()

	// stop playing
	stop: function() {
		iend = 0
//fixme: op.clear() should exist...
		if (op && op.clear)
			op.clear()
	} // stop()
    }
} // end Midi5

// check MIDI access at script load time
function onMIDISuccess(access) {
	Midi5.ma = access	// store the MIDI access in the Midi5 function
} // onMIDISuccess()

// (no SysEx)
function onMIDIFailure1(msg) {
	navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure2)
} // onMIDIFailure1()

// (no MIDI access)
function onMIDIFailure2(msg) {
} // onMIDIFailure2()

// (try SysEx)
if (navigator.requestMIDIAccess)
	navigator.requestMIDIAccess({sysex: true}).then(onMIDISuccess, onMIDIFailure1)
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// ambitus.js - module to insert an ambitus at start of a voice
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%ambitus" appears in a ABC source.
//
// Parameters
//	%%ambitus 1

abc2svg.ambitus = {
    do_ambitus: function() {
    var	C = abc2svg.C,
	s, v, p_v, min, max,
	voice_tb = this.get_voice_tb()

	for (v = 0; v < voice_tb.length; v++) {
		p_v = voice_tb[v];
		if (p_v.second)
			continue
		min = 100;
		max = -100

		// search the top and bottom pitches
		for (s = p_v.sym; s; s = s.next) {
			if (s.type != C.NOTE)
				continue
			if (s.notes[s.nhd].pit > max)
				max = s.notes[s.nhd].pit
			if (s.notes[0].pit < min)
				min = s.notes[0].pit
		}
		if (min == 100)
			continue			// no note

		s = p_v.clef;
		s.stem = 1;
		s.head = C.FULL;
		s.stemless = true;
		s.nhd = 1;
		s.notes = [{
				dur: C.BLEN / 4,
				pit: min,
				shhd: 0
			},{
				dur: C.BLEN / 4,
				pit: max,
				shhd: 0
			}]
	}
    }, // do_ambitus()

    draw_symbols: function(of, p_voice) {
// constants from the abc2svg core
    var	staff_tb = this.get_staff_tb(),
	s = p_voice.sym

	if (s.clef_type != undefined && s.nhd > 0) {
		s.x -= 26;
		this.set_scale(s);
		this.draw_note(s)
		if (s.notes[1].pit - s.notes[0].pit > 4) {
			this.xypath(s.x, 3 * (s.notes[1].pit - 18) + staff_tb[s.st].y);
			this.out_svg('v' +
				((s.notes[1].pit - s.notes[0].pit) * 3).toFixed(2) +
				'" stroke-width=".6"/>\n');
		}
		s.x += 26;
		p_voice.clef.nhd = 0
	}
	of(p_voice)
    }, // draw_symbols()

    set_pitch: function(of, last_s) {
	of(last_s)
	if (!last_s && this.cfmt().ambitus)
		abc2svg.ambitus.do_ambitus.call(this)
    },

    set_fmt: function(of, cmd, param, lock) {
	if (cmd == "ambitus") {
		this.cfmt().ambitus = param
		return
	}
	of(cmd, param, lock)
    },

    set_width: function(of, s) {
	if (s.clef_type != undefined && s.nhd > 0) {
		s.wl = 40;
		s.wr = 12
	} else {
		of(s)
	}
    }
} // ambitus

abc2svg.modules.hooks.push(
// export
	"draw_note",
	"set_scale",
// hooks
	[ "draw_symbols", "abc2svg.ambitus.draw_symbols" ],
	[ "set_pitch", "abc2svg.ambitus.set_pitch" ],
	[ "set_format", "abc2svg.ambitus.set_fmt" ],
	[ "set_width", "abc2svg.ambitus.set_width" ]
)

// the module is loaded
abc2svg.modules.ambitus.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// break.js - module to handle the %%break command
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%break" appears in a ABC source.
//
// Parameters
//	%%break measure_nb [":" num "/" den] [" " measure ...]*

abc2svg.break = {

	// get the %%break parameters
	get_break: function(parm) {
	    var	C = abc2svg.C,
		b, c, d, sq,
		a = parm.split(/[ ,]/),
		cfmt = this.cfmt()

		if (!cfmt.break)
			cfmt.break = []
		for (n = 1; n < a.length; n++) {
			b = a[n];
			c = b.match(/(\d+)([a-z]?)(:\d+\/\d+)?/)
			if (!c) {
				this.syntax(1, errs.bad_val, "%%break")
				continue
			}
			if (c[2])
				sq = c[2].charCodeAt(0) - 0x61
			if (!c[3]) {
				cfmt.break.push({	// on measure bar
						m: c[1],
						t: 0,
						sq: sq})
				continue
			}
			d = c[3].match(/:(\d+)\/(\d+)/)
			if (!d || d[2] < 1) {
				this.syntax(1, "Bad denominator in %%break")
				continue
			}
			cfmt.break.push({
					m: c[1],
					t: d[1] * C.BLEN / d[2],
					sq: sq})
		}
	}, // get_break()

	// insert the EOLs of %%break
	do_break: function() {
	    var	i, m, t, brk, seq,
		voice_tb = this.get_voice_tb()
		v = this.get_cur_sy().top_voice,
		s1 = voice_tb[v].sym,
		cfmt = this.cfmt()

		for (i = 0; i < cfmt.break.length; i++) {
			brk = cfmt.break[i];
			m = brk.m
			for (s = s1; s; s = s.next) {
				if (s.bar_num == m)
					break
			}
			if (!s)
				continue

			if (brk.sq) {
				seq = brk.sq
				for (s = s.ts_next; s; s = s.ts_next) {
					if (s.bar_num == m) {
						if (--seq == 0)
							break
					}
				}
				if (!s)
					continue
			}

			t = brk.t
			if (t) {
				t = s.time + t
				for ( ; s; s = s.next) {
					if (s.time >= t)
						break
				}
				if (!s)
					continue
				s = s.prev
			}
			s.eoln = true
		}
	}, // do_break()

    do_pscom: function (of, text) {
	if (text.slice(0, 6) == "break ")
		abc2svg.break.get_break.call(this, text)
	else
		of(text)
    },

    set_bar_num: function(of) {
	of()
	if (this.cfmt().break)
		abc2svg.break.do_break.call(this)
    }
} // break

abc2svg.modules.hooks.push(
// export
	"errs",
	"syntax",
// hooks
	[ "do_pscom", "abc2svg.break.do_pscom" ],
	[ "set_bar_num", "abc2svg.break.set_bar_num" ]
);

// the module is loaded
abc2svg.modules.break.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// capo.js - module to add a capo chord line
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%capo" appears in a ABC source.
//
// Parameters
//	%%capo n	'n' is the capo fret number

abc2svg.capo = {

// function called when setting a chord symbol on a music element
    gch_capo: function(a_gch) {
    var	gch, gch2, i2,
	cfmt = this.cfmt(),
	transp = cfmt.capo,
	i = 0

	while (1) {
		gch = a_gch[i++]
		if (!gch)
			return
		if (gch.type == 'g')
			break
	}
	gch2 = Object.create(gch);
	gch2.capo = false;		// (would be erased when setting gch)
	gch2.text = this.gch_tr1(gch2.text,
			[0, 5, -2, 3, -4, 1, -6, -1, 4, -3, 2, -5][transp % 12])
	if (!this.capo_first) {			// if new tune
		this.capo_first = true;
		gch2.text += "  (capo: " + transp.toString() + ")"
	}

	gch2.font = this.get_font(cfmt.capofont ? "capo" : "annotation");
	a_gch.splice(i, 0, gch2)

	// set a mark in the first chord symbol for %%diagram
	gch.capo = true
    }, // gch_capo()

    gch_build: function(of, s) {
    var	a_gch = this.get_a_gch()
	if (this.cfmt().capo && a_gch)
		abc2svg.capo.gch_capo.call(this, a_gch);
	of(s)
    },

    output_music: function(of) {
	this.capo_first = false;
	of()
    },

    set_fmt: function(of, cmd, param, lock) {
	if (cmd == "capo") {
		this.cfmt().capo = param
		return
	}
	of(cmd, param, lock)
    }

} // capo


abc2svg.modules.hooks.push(
// export
	"gch_tr1",
	"get_font",
// hooks
	[ "set_format", "abc2svg.capo.set_fmt" ],
	[ "gch_build", "abc2svg.capo.gch_build" ],
	[ "output_music", "abc2svg.capo.output_music" ]
)

// the module is loaded
abc2svg.modules.capo.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// clip.js - module to handle the %%clip command
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%clip" appears in a ABC source.
//
// Parameters
//	%%clip start_measure_nb [":" num "/" den] "-" end_measure_nb [":" num "/" den]

abc2svg.clip = {

    get_clip: function(parm) {
    var	C = abc2svg.C

	// get the start/stop points
	function get_symsel(a) {
	    var	j, d, sq,
		b = a.match(/(\d+)([a-z]?)(:\d+\/\d+)?/)

		if (!b)
			return
		if (b[2])
			sq = b[2].charCodeAt(0) - 0x61
		if (!b[3])
			return {m: b[1], t: 0, sq: sq}	// on measure bar
		a = b[3].match(/:(\d+)\/(\d+)/)
		if (!a || a[2] < 1)
			return
		return {m: b[1], t: a[1] * C.BLEN / a[2], sq: sq}
	} // get_symsel()

	    var	b, c,
		a = parm.split(/[ -]/)

		if (a.length != 3) {
			this.syntax(1, this.errs.bad_val, "%%clip")
			return
		}
		if (!a[1])
			b = {m: 0, t: 0}
		else
			b = get_symsel(a[1]);
		c = get_symsel(a[2])
		if (!b || !c) {
			this.syntax(1, this.errs.bad_val, "%%clip")
			return
		}
		this.cfmt().clip = [b, c]
    }, // get_clip()

    // cut the tune
    do_clip: function() {
    var	C = abc2svg.C
	voice_tb = this.get_voice_tb(),
	cfmt = this.cfmt()

	// go to a global (measure + time)
	function go_global_time(s, sel) {
	    var	s2, bar_time, seq

		if (sel.m <= 1) {	// special case: there is no measure 0/1
			if (sel.m == 1) {
				for (s2 = s; s2; s2 = s2.ts_next) {
					if (s2.type == C.BAR
					 && s2.time != 0)
						break
				}
				if (s2.time < voice_tb[this.get_cur_sy().top_voice].
								meter.wmeasure)
					s = s2
			}
		} else {
			for ( ; s; s = s.ts_next) {
				if (s.type == C.BAR
				 && s.bar_num >= sel.m)
					break
			}
			if (!s)
				return // null

			if (sel.sq) {
				seq = sel.sq
				for (s = s.ts_next; s; s = s.ts_next) {
					if (s.type == C.BAR
					 && s.bar_num == sel.m) {
						if (--seq == 0)
							break
					}
				}
				if (!s)
					return // null
			}
		}

		if (sel.t == 0)
			return s;
		bar_time = s.time + sel.t
		while (s.time < bar_time) {
			s = s.ts_next
			if (!s)
				return s
		}
		do {
			s = s.ts_prev	// go back to the previous sequence
		} while (!s.seqst)
		return s
	}

	    var	s, s2, sy, p_voice, v

		// remove the beginning of the tune
		s = this.get_tsfirst()
		if (cfmt.clip[0].m > 0
		 || cfmt.clip[0].t > 0) {
			s = go_global_time(s, cfmt.clip[0])
			if (!s) {
				this.set_tsfirst(null)
				return
			}

			// update the start of voices
			sy = this.get_cur_sy()
			for (s2 = this.get_tsfirst(); s2 != s; s2 = s2.ts_next) {
				switch (s2.type) {
				case C.CLEF:
					s2.p_v.clef = s2
					break
				case C.KEY:
					s2.p_v.key = this.clone(s2.as.u.key)
					break
				case C.METER:
					s2.p_v.meter = this.clone(s2.as.u.meter)
					break
				case C.STAVES:
					sy = s2.sy;
					this.set_cur_sy(sy)
					break
				}
			}
			for (v = 0; v < voice_tb.length; v++) {
				p_voice = voice_tb[v]
				for (s2 = s; s2; s2 = s2.ts_next) {
					if (s2.v == v) {
						delete s2.prev
						break
					}
				}
				p_voice.sym = s2
			}
			this.set_tsfirst(s)
			delete s.ts_prev
		}

		/* remove the end of the tune */
		s = go_global_time(s, cfmt.clip[1])
		if (!s)
			return

		/* keep the current sequence */
		do {
			s = s.ts_next
			if (!s)
				return
		} while (!s.seqst)

		/* cut the voices */
		for (v = 0; v < voice_tb.length; v++) {
			p_voice = voice_tb[v]
			for (s2 = s.ts_prev; s2; s2 = s2.ts_prev) {
				if (s2.v == v) {
					delete s2.next
					break
				}
			}
			if (!s2)
				p_voice.sym = null
		}
		delete s.ts_prev.ts_next
	}, // do_clip()

    do_pscom: function (of, text) {
	if (text.slice(0, 5) == "clip ")
		abc2svg.clip.get_clip.call(this, text)
	else
		of(text)
    },

    set_bar_num: function(of) {
	of()
	if (this.cfmt().clip)
		abc2svg.clip.do_clip.call(this)
    }
} // clip

abc2svg.modules.hooks.push(
// export
	"clone",
	"errs",
	"syntax",
// hooks
	[ "do_pscom", "abc2svg.clip.do_pscom" ],
	[ "set_bar_num", "abc2svg.clip.set_bar_num" ]
);

// the module is loaded
abc2svg.modules.clip.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// combine.js - module to add a combine chord line
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%voicecombine" appears in a ABC source.
//
// Parameters
//	%%voicecombine n	'n' is the combine level

abc2svg.combine = {

    // function called at start of the generation when multi-voices
    comb_v: function() {
    var	C = abc2svg.C

    // check if voice combine may occur
    function may_combine(s) {
    var	nhd2,
	s2 = s.ts_next

	if (!s2 || (s2.type != C.NOTE && s2.type != C.REST))
		return false
	if (s2.v == s.v
	 || s2.st != s.st
	 || s2.time != s.time
	 || s2.dur != s.dur)
		return false
	if (s.combine <= 0
	 && s2.type != s.type)
		return false
//	if (s2.a_dd) { //fixme: should check the double decorations
//		return false
//	}
	if (s.a_gch && s2.a_gch)
		return false
	if (s.type == C.REST) {
		if (s.type == s2.type && s.invis && !s2.invis)
			return false
		return true
	}
	if (s2.a_ly
	 || s2.sl1 || s2.sl2
	 || s2.slur_start || s2.slur_end)
		return false
	if (s2.beam_st != s.beam_st
	 || s2.beam_end != s.beam_end)
		return false;
	nhd2 = s2.nhd
	if (s.combine <= 1
	 && s.notes[0].pit <= s2.notes[nhd2].pit + 1)
		return false
	return true
    } // may_combine()

    // combine two notes
    function combine_notes(s, s2) {
    var	nhd, type, m;

	s.notes = s.notes.concat(s2.notes);
	s.nhd = nhd = s.notes.length - 1;
	this.sort_pitch(s)		// sort the notes by pitch

	if (s.combine >= 3) {		// remove unison heads
		for (m = nhd; m > 0; m--) {
			if (s.notes[m].pit == s.notes[m - 1].pit
			 && s.notes[m].acc == s.notes[m - 1].acc)
				s.notes.splice(m, 1)
		}
		s.nhd = nhd = s.notes.length - 1
	}

	s.ymx = 3 * (s.notes[nhd].pit - 18) + 4;
	s.ymn = 3 * (s.notes[0].pit - 18) - 4;

	// force the tie directions
	type = s.notes[0].ti1
	if ((type & 0x0f) == C.SL_AUTO)
		s.notes[0].ti1 = C.SL_BELOW | (type & ~C.SL_DOTTED);
	type = s.notes[nhd].ti1
	if ((type & 0x0f) == C.SL_AUTO)
		s.notes[nhd].ti1 = C.SL_ABOVE | (type & ~C.SL_DOTTED)
} // combine_notes()

// combine 2 voices
function do_combine(s) {
	var s2, nhd, nhd2, type

	while (1) {
		nhd = s.nhd;
		s2 = s.ts_next;
		nhd2 = s2.nhd
		if (s.type != s2.type) {	// if note and rest
			if (s2.type != C.REST) {
				s2 = s;
				s = s2.ts_next
			}
		} else if (s.type == C.REST) {
			if (s.invis
			 && !s2.invis)
				delete s.invis
		} else {
			combine_notes.call(this, s, s2)
		}

		if (s2.a_gch)
			s.a_gch = s2.a_gch
		if (s2.a_dd) {
			if (!s.a_dd)
				s.a_dd = s2.a_dd
			else
				s.a_dd = s.a_dd.concat(s2.a_dd)
		}
		this.unlksym(s2)			// remove the next symbol

		// there may be more voices
		if (s.in_tuplet || !may_combine.call(this, s))
			break
	}
} // do_combine()

	var s, s2, g, i, r

	for (s = this.get_tsfirst(); s; s = s.ts_next) {
		switch (s.type) {
		case C.REST:
			if (s.combine == undefined || s.combine < 0)
				continue
			if (may_combine.call(this, s))
				do_combine.call(this, s)
			continue
		default:
			continue
		case C.NOTE:
			if (s.combine == undefined || s.combine <= 0)
				continue
			break
		}

		if (!s.beam_st)
			continue
		if (s.beam_end) {
			if (may_combine.call(this, s))
				do_combine.call(this, s)
			continue
		}

		s2 = s
		while (1) {
			if (!may_combine.call(this, s2)) {
				s2 = null
				break
			}
//fixme: may have rests in beam
			if (s2.beam_end)
				break
			do {
				s2 = s2.next
			} while (s2.type != C.NOTE && s2.type != C.REST)
		}
		if (!s2)
			continue
		s2 = s
		while (1) {
			do_combine.call(this, s2)
//fixme: may have rests in beam
			if (s2.beam_end)
				break
			do {
				s2 = s2.next
			} while (s2.type != C.NOTE && s2.type != C.REST)
		}
	}
    }, // comb_v()

    do_pscom: function(of, text) {
	if (text.slice(0, 13) == "voicecombine ")
		this.set_v_param("combine", text.split(/[ \t]/)[1])
	else
		of(text)
    },

    new_note: function(of, gr, tp) {
    var curvoice = this.get_curvoice()
    var s = of(gr, tp)
	if (s && s.notes && curvoice.combine != undefined)
		s.combine = curvoice.combine
	return s
    },

    set_stem_dir: function(of) {
	of();
	abc2svg.combine.comb_v.call(this)
    },

    // set the combine parameter in the current voice
    set_vp: function(of, a) {
    var	i,
	curvoice = this.get_curvoice()

	for (i = 0; i < a.length; i++) {
		if (a[i] == "combine=") {	// %%voicecombine
			curvoice.combine = a[i + 1]
			break
		}
	}
	of(a)
    }
} // combine

abc2svg.modules.hooks.push(
// export
	"set_v_param",
	"sort_pitch",
	"unlksym",
// hooks
	[ "do_pscom", "abc2svg.combine.do_pscom" ],
	[ "new_note", "abc2svg.combine.new_note" ],
	[ "set_stem_dir", "abc2svg.combine.set_stem_dir" ],
	[ "set_vp", "abc2svg.combine.set_vp" ]
);

// the module is loaded
abc2svg.modules.voicecombine.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// diag.js - module to insert guitar chord diagrams
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%diagram" appears in a ABC source.
//
// Parameters
//	%%diagram 1

abc2svg.diag = {

// function called before tune generation
    do_diag: function() {
    var	glyphs = this.get_glyphs(),
	voice_tb = this.get_voice_tb()

	// create the decorations if not done yet
	if (!glyphs['fb']) {
	    var	i, j, d,
		decos = this.get_decos();
		ns = "CDEFGAB",
		ms = ["", "m", "7", "m7", "maj7", "sus4"]

		this.add_style("\
\n.diag {font:6px sans-serif}\
\n.frn {font:italic 7px sans-serif}")

		for (i = 0; i < ns.length; i++) {
			for (j = 0; j < ms.length; j++) {
				d = ns[i] + ms[j];
				decos[d] = "3 " + d + " 40 0 0"
			}
		}
		for (j = 0; j < ms.length; j++) {
			d = "F♯" + ms[j]
			decos[d] = "3 F#" + ms[j] + " 40 0 0"
		}

	// add the glyphs (converted to SVG from Guido Gonzato PS)

	// fingerboard
		glyphs['fb'] = '<g id="fb">\n\
<path class="stroke" stroke-width="0.4" d="\
M-10 -34h20m0 6h-20\
m0 6h20m0 6h-20\
m0 6h20"/>\n\
<path class="stroke" stroke-width="0.5" d="\
M-10 -34v24m4 0v-24\
m4 0v24m4 0v-24\
m4 0v24m4 0v-24"/>\n\
</g>';

// fret information
		glyphs['nut'] =
			'<path id="nut" class="stroke" stroke-width="1.6" d="\
M-10.2 -34.5h20.4"/>';
		glyphs['barre'] =
			'<path id="barre" class="stroke" stroke-width=".9" d="\
M-10.2 -31h20.4"/>';
		glyphs['fr1'] =
			'<text id="fr1" x="-20" y="-29" class="frn">fr1</text>';
		glyphs['fr2'] =
			'<text id="fr2" x="-20" y="-29" class="frn">fr2</text>';
		glyphs['fr3'] =
			'<text id="fr3" x="-20" y="-29" class="frn">fr3</text>';
		glyphs['ddot'] =
			'<circle id="ddot" class="fill" r="1.5"/>';

// chords
		glyphs['C'] = '<g id="C">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-3,4" y="-36" class="diag">321</text>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
<use x="6" y="-31" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Cm'] = '<g id="Cm">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr3"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,0,4" y="-36" class="diag">342</text>\n\
<use x="2" y="-19" xlink:href="#ddot"/>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
<use x="6" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['C7'] = '<g id="C7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4,0,4" y="-36" class="diag">3241</text>\n\
<use x="2" y="-19" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
<use x="6" y="-31" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Cm7'] = '<g id="Cm7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr3"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-4,4" y="-36" class="diag">x32</text>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
<use x="6" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Cmaj7'] = '<g id="Cmaj7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-8,-4" y="-36" class="diag">x21</text>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Csus4'] = '<g id="Csus4">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr3"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,0,4" y="-36" class="diag">x34</text>\n\
<use x="6" y="-13" xlink:href="#ddot"/>\n\
<use x="2" y="-19" xlink:href="#ddot"/>\n\
</g>';

		glyphs['D'] = '<g id="D">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,0,4,8" y="-36" class="diag">x132</text>\n\
<use x="6" y="-19" xlink:href="#ddot"/>\n\
<use x="10" y="-25" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Dm'] = '<g id="Dm">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,0,4,8" y="-36" class="diag">x231</text>\n\
<use x="6" y="-19" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="10" y="-31" xlink:href="#ddot"/>\n\
</g>';
		glyphs['D7'] = '<g id="D7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,0,4,8" y="-36" class="diag">x312</text>\n\
<use x="10" y="-25" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="6" y="-31" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Dm7'] = '<g id="Dm7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-8,0,4,8" y="-36" class="diag">xx211</text>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="10" y="-31" xlink:href="#ddot"/>\n\
<use x="6" y="-31" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Dmaj7'] = '<g id="Dmaj7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-8,0,4,8" y="-36" class="diag">xx123</text>\n\
<use x="10" y="-25" xlink:href="#ddot"/>\n\
<use x="6" y="-25" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Dsus4'] = '<g id="Dsus4">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-8,0,4,8" y="-36" class="diag">xx123</text>\n\
<use x="10" y="-19" xlink:href="#ddot"/>\n\
<use x="6" y="-19" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
</g>';

		glyphs['E'] = '<g id="E">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4,0" y="-36" class="diag">231</text>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
<use x="-6" y="-25" xlink:href="#ddot"/>\n\
<use x="2" y="-31" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Em'] = '<g id="Em">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4" y="-36" class="diag">23</text>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
<use x="-6" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['E7'] = '<g id="E7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,0" y="-36" class="diag">21</text>\n\
<use x="2" y="-31" xlink:href="#ddot"/>\n\
<use x="-6" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Em7'] = '<g id="Em7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8" y="-36" class="diag">1</text>\n\
<use x="-6" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Emaj7'] = '<g id="Emaj7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4,0" y="-36" class="diag">312</text>\n\
<use x="2" y="-31" xlink:href="#ddot"/>\n\
<use x="-2" y="-31" xlink:href="#ddot"/>\n\
<use x="-6" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Esus4'] = '<g id="Esus4">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,0" y="-36" class="diag">12</text>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
</g>';

		glyphs['F'] = '<g id="F">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr1"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4,0" y="-36" class="diag">342</text>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Fm'] = '<g id="Fm">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr1"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4" y="-36" class="diag">34</text>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['F7'] = '<g id="F7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr1"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,0" y="-36" class="diag">32</text>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Fm7'] = '<g id="Fm7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr1"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8" y="-36" class="diag">3</text>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Fmaj7'] = '<g id="Fmaj7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr1"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4,0" y="-36" class="diag">423</text>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Fsus4'] = '<g id="Fsus4">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr1"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,0" y="-36" class="diag">34</text>\n\
<use x="2" y="-19" xlink:href="#ddot"/>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
</g>';

		glyphs['F#'] = '<g id="F#">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4,0" y="-36" class="diag">342</text>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['F#m'] = '<g id="F#m">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4" y="-36" class="diag">34</text>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['F#7'] = '<g id="F#7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,0" y="-36" class="diag">32</text>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['F#m7'] = '<g id="F#m7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8" y="-36" class="diag">3</text>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['F#maj7'] = '<g id="F#maj7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4,0" y="-36" class="diag">423</text>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['F#sus4'] = '<g id="F#sus4">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,0" y="-36" class="diag">34</text>\n\
<use x="2" y="-19" xlink:href="#ddot"/>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
</g>';

		glyphs['G'] = '<g id="G">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-8,8" y="-36" class="diag">234</text>\n\
<use x="10" y="-19" xlink:href="#ddot"/>\n\
<use x="-10" y="-19" xlink:href="#ddot"/>\n\
<use x="-6" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Gm'] = '<g id="Gm">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr3"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8,-4" y="-36" class="diag">34</text>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['G7'] = '<g id="G7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-8,8" y="-36" class="diag">321</text>\n\
<use x="-10" y="-19" xlink:href="#ddot"/>\n\
<use x="-6" y="-25" xlink:href="#ddot"/>\n\
<use x="10" y="-31" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Gm7'] = '<g id="Gm7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr3"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-8" y="-36" class="diag">3</text>\n\
<use x="-6" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Gmaj7'] = '<g id="Gmaj7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-8,8" y="-36" class="diag">312</text>\n\
<use x="10" y="-25" xlink:href="#ddot"/>\n\
<use x="-6" y="-25" xlink:href="#ddot"/>\n\
<use x="-10" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Gsus4'] = '<g id="Gsus4">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr3"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,0" y="-36" class="diag">34</text>\n\
<use x="2" y="-19" xlink:href="#ddot"/>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
</g>';

		glyphs['A'] = '<g id="A">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,0,4" y="-36" class="diag">234</text>\n\
<use x="6" y="-25" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Am'] = '<g id="Am">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,0,4" y="-36" class="diag">231</text>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
<use x="6" y="-31" xlink:href="#ddot"/>\n\
</g>';
		glyphs['A7'] = '<g id="A7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,4" y="-36" class="diag">23</text>\n\
<use x="6" y="-25" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Am7'] = '<g id="Am7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,4" y="-36" class="diag">21</text>\n\
<use x="6" y="-31" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
</g>';
	glyphs['Amaj7'] = '<g id="Amaj7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-4,0,4" y="-36" class="diag">x213</text>\n\
<use x="6" y="-25" xlink:href="#ddot"/>\n\
<use x="2" y="-31" xlink:href="#ddot"/>\n\
<use x="-2" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Asus4'] = '<g id="Asus4">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,0,4" y="-36" class="diag">x12</text>\n\
<use x="6" y="-19" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
</g>';

		glyphs['B'] = '<g id="B">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,0,4" y="-36" class="diag">234</text>\n\
<use x="6" y="-19" xlink:href="#ddot"/>\n\
<use x="2" y="-19" xlink:href="#ddot"/>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Bm'] = '<g id="Bm">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-4,0,4" y="-36" class="diag">341</text>\n\
<use x="6" y="-25" xlink:href="#ddot"/>\n\
<use x="2" y="-19" xlink:href="#ddot"/>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['B7'] = '<g id="B7">\n\
<use xlink:href="#nut"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-8,-4,0,8" y="-36" class="diag">x2134</text>\n\
<use x="10" y="-25" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="-6" y="-25" xlink:href="#ddot"/>\n\
<use x="-2" y="-31" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Bm7'] = '<g id="Bm7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,0,8" y="-36" class="diag">x32</text>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
<use x="6" y="-25" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Bmaj7'] = '<g id="Bmaj7">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,-4,0,4" y="-36" class="diag">x324</text>\n\
<use x="6" y="-19" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
<use x="-2" y="-19" xlink:href="#ddot"/>\n\
</g>';
		glyphs['Bsus4'] = '<g id="Bsus4">\n\
<use xlink:href="#barre"/>\n\
<use xlink:href="#fr2"/>\n\
<use xlink:href="#fb"/>\n\
<text x="-12,0,4" y="-36" class="diag">x34</text>\n\
<use x="6" y="-19" xlink:href="#ddot"/>\n\
<use x="2" y="-25" xlink:href="#ddot"/>\n\
</g>'
	}

    var	s, i, gch, t

	for (s = voice_tb[0].sym; s; s = s.next) {
		if (!s.a_gch)
			continue
		for (i = 0; i < s.a_gch.length; i++) {
			gch = s.a_gch[i]
			if (!gch || gch.type != 'g' || gch.capo)
				continue

			t = gch.otext || gch.text

			// insert the diagram as a decoration
			this.deco_cnv(t.split(/[ \t/]/, 1), s, null)
		}
	}
    }, // do_diag()

    output_music: function(of) {
	if (this.cfmt().diag)
		abc2svg.diag.do_diag.call(this)
	of()
    },

    set_fmt: function(of, cmd, param, lock) {
	if (cmd == "diagram") {
		this.cfmt().diag = param
		return
	}
	of(cmd, param, lock)
    }
} // diag

abc2svg.modules.hooks.push(
// export
	"deco_cnv",
// hooks
	[ "output_music", "abc2svg.diag.output_music" ],
	[ "set_format", "abc2svg.diag.set_fmt" ]
);

// the module is loaded
abc2svg.modules.diagram.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// equalbars.js - module to set equal spaced measure bars
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%equalbars" appears in a ABC source.
//
// Parameters
//	%%equalbars bool

abc2svg.equalbars = {

    // new tune - clear the width of the start of the staff
    output_music: function(of) {
	this.equalbars_d = 0;
	of()
    },

    // get the equalbars parameter
    set_fmt: function(of, cmd, param, lock) {
	if (cmd == "equalbars")
		this.cfmt().equalbars = this.get_bool(param)
	else
		of(cmd, param, lock)
    },

    // adjust the symbol offsets of a music line
    set_sym_glue: function(of, width) {
    var	C = abc2svg.C,
	s, s2, w, i, n, x, g, t, t0,
	bars = [],
	tsfirst = this.get_tsfirst();

	of(width)			// compute the x offset of the symbols
	if (!this.cfmt().equalbars)
		return

	// search the first note/rest/bar
	for (s2 = tsfirst; s2; s2 = s2.ts_next) {
		if (!s2.seqst)
			continue
		switch (s2.type) {
		default:
			continue
		case C.BAR:
		case C.GRACE:
		case C.MREST:
		case C.NOTE:
		case C.REST:
		case C.SPACE:
			break
		}
		break
	}
	if (!s2)
		return

	// build an array of the bars
	s = s2.ts_next;
	t0 = t = s.time
	while (1) {
		if (!s.ts_next) {
			bars.push([s, s.time - t]);
			t = s.time
			if (s.dur)
				t += s.dur
			break
		}
		if (s.type == C.BAR && s.seqst) {
			bars.push([s, s.time - t]);
			t = s.time
		}
		s = s.ts_next
	}
	n = bars.length
	if (n == 0)
		return				// no bar!

	// set the measure parameters
	x = s2.type == C.GRACE ? s2.extra.x : s2.x;
	d = this.equalbars_d
	if (!d)
		d = this.equalbars_d = x;	// offset first note/rest

	w = (width - d) / (t - t0)		// width per time unit

	// loop on the bars
	for (i = 0; i < n; i++) {
		s = bars[i][0];			// next bar
		f = w * bars[i][1] / (s.x - x)

		// and update the x offsets
		for ( ; s2 != s; s2 = s2.ts_next) {
			if (s2.type == C.GRACE) {
				for (g = s2.extra; g; g = g.next)
					g.x = d + (g.x - x) * f
			} else if (s2.x) {
				s2.x = d + (s2.x - x) * f
			}
		}
		d += w * bars[i][1];
		x = s2.x
		while (1) {
			s2.x = d;
			s2 = s2.ts_next
			if (!s2 || s2.seqst)
				break
		}
		if (!s2)
			break
	}
    } // set_sym_glue()
} // equalbars


abc2svg.modules.hooks.push(
// export
	"get_bool",
// hooks
	[ "output_music", "abc2svg.equalbars.output_music" ],
	[ "set_format", "abc2svg.equalbars.set_fmt" ],
	[ "set_sym_glue", "abc2svg.equalbars.set_sym_glue" ]
)

// the module is loaded
abc2svg.modules.equalbars.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// grid.js - module to insert a chord grid before or after a tune
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%grid" appears in a ABC source.
//
// Parameters
//	%%grid 1 | -1	(above the tune | below the tune)
//	%%gridfont font_name size (default: 'serif 16')

abc2svg.grid = {

// function called before tune generation
    do_grid: function() {
    var	C = abc2svg.C,
	tsfirst = this.get_tsfirst(),
	voice_tb = this.get_voice_tb(),
	img, font_cl, cls,
	cfmt = this.cfmt()

function get_beat(s) {
    var	beat = C.BLEN / 4

	if (!s.a_meter[0] || s.a_meter[0].top[0] == 'C' || !s.a_meter[0].bot)
		return beat;
	beat = C.BLEN / s.a_meter[0].bot[0] |0
	if (s.a_meter[0].bot[0] == 8
	 && s.a_meter[0].top[0] % 3 == 0)
		beat = C.BLEN / 8 * 3
	return beat
} // get_beat()

// generate the grid
function build_grid(chords, bars, font) {
    var	i, j, nr, line, bar, bar2, chord, cell, w, hr, x0, x, y,
	wmx = 0,
	cells = [],
	nc = chords.length % 6 == 0 ? 6 : 8;	// number of columns

	if (nc > chords.length)
		nc = chords.length;

	// build the content of the cells
	nr = 0
	for (i = 0; i < chords.length; i++) {
		if (i % nc == 0)
			nr++;			// number of rows
		chord = chords[i]
		if (chord.length == 0) {
			cell = '%'
		} else {
			cell = ''
			for (j = 0; j < chord.length; j++) {
				if (chord[j]) {
					if (j != 0)
						cell += ' / ';
					cell += chord[j]
				} else if (j == 0) {
					cell += '%'
				}
			}
		}
		bar = bars[i];
		if (bar[bar.length - 1] == ':')
			cell = '  ' + cell
		bar2 = bars[i + 1]
		if (bar2 && bar2[0] == ':')
			cell += '  ';
		cells.push(cell)

		// and find their max width
		if (bar[bar.length - 1] == ':')
			cell += '  '
		if (bar2 && bar2[0] == ':')
			cell += '  ';
		w = this.strwh(cell)[0]
		if (w > wmx)
			wmx = w
	}
	if (wmx < 20)
		wmx = 20;
	w = wmx * nc
	if (w > img.width) {
		nc /= 2;
		nr *= 2;
		w /= 2
	}

	// build the SVG image
	hr = font.size + 8;		// vert: 4 - cell - 4
	line = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1"\n\
	xmlns:xlink="http://www.w3.org/1999/xlink"\n\
	color="black" width="' + img.width.toFixed(0) +
			'px" height="' + (hr * nr + 6).toFixed(0) + 'px"'
	i = cfmt.bgcolor
	if (i)
		line += ' style="background-color: ' + i + '"';
	line += '>\n<style type="text/css">\n\
.mid {text-anchor:middle}\n'

	if (cfmt.fullsvg)
		line += '\
.stroke {stroke: currentColor; fill: none}\n\
.' + font_cl + ' {' + this.style_font(font.name + '.' + font.size) +  '}\n'
	line += '</style>\n'

	// draw the lines
	line += '<path class="stroke" d="\n';
	x0 = (img.width - w) / 2;
	y = 1
	for (j = 0; j <= nr; j++) {
		line += 'M' + x0.toFixed(2) + ' ' + y.toFixed(2) +
			'h' + w.toFixed(2)+ '\n';
		y += hr
	}
	x = x0
	for (i = 0; i <= nc; i++) {
		line += 'M' + x.toFixed(2) + ' 1v' + (hr * nr).toFixed(2) + '\n';
		x += wmx
	}
	line += '"/>\n';

	// insert the chords
	y = -1 - hr * .2
	for (i = 0; i < cells.length; i++) {
		if (i % nc == 0) {
			y += hr;			// new row
			x = x0 + wmx / 2
		}
		line += '<text class="' + cls + '" x="' +
			x.toFixed(2) + '" y="' + y.toFixed(2) + '">' +
			cells[i] + '</text>\n';
		x += wmx
	}

	// show the repeat signs
	y = -1 - hr * .2;
	x = x0
	for (i = 0; i < bars.length; i++) {
		bar = bars[i]
		if (bar[0] == ':')
			line += '<text class="' + cls + '" x="' +
				(x - 5).toFixed(2) +
				'" y="' + y.toFixed(2) +
				'" style="font-weight:bold;font-size:' +
			(font.size + 2).toFixed(2) + '">:|</text>\n'
		if (i % nc == 0) {
			y += hr;			// new row
			x = x0
		}
		if (bar[bar.length - 1] == ':')
			line += '<text class="' + cls + '" x="' +
				(x + 5).toFixed(2) +
				'" y="' + y.toFixed(2) +
				'" style="font-weight:bold;font-size:' +
			(font.size + 2).toFixed(2) + '">|:</text>\n'
		x += wmx
	}

	return line + '</svg>'
} // build_grid()

    var	s, beat, cur_beat, i, beat_i, p_voice, n, font,
	bars = [],
	chords = [],
	chord = []

	img = this.get_img();

	// get the beat
	beat = get_beat(voice_tb[0].meter);

	// scan the tune
	cur_beat = beat_i = n = 0;
	bars.push('|')
	for (s = voice_tb[0].sym; s; s = s.next) {
		while (s.time > cur_beat) {
			beat_i++;
			cur_beat += beat
		}
		switch (s.type) {
		case C.NOTE:
		case C.REST:
			if (s.a_gch) {		// search a chord symbol
				for (i = 0; i < s.a_gch.length; i++) {
					if (s.a_gch[i].type == 'g') {
						if (!chord[beat_i]) {
							chord[beat_i] = s.a_gch[i].text;
							n++
						}
						break
					}
				}
			}
			break
		case C.BAR:
			if (s.time < beat) {		// if anacrusis
				bars[0] = s.bar_type;
//				chord = [];
				beat_i = 0;
				cur_beat = s.time	// re-synchronize
				break
			}
			if (s.time != cur_beat)		// if out of time
				break
			chords.push(chord);
			bars.push(s.bar_type);
			chord = [];
			beat_i = 0
			break
		case C.METER:
			beat = get_beat(s)
			break
		}
	}
	if (n == 0)				// no chord in this tune
		return

	if (chord.length != 0) {
		bars.push('')
		chords.push(chord)
	}

	// set the text style
	if (!this.cfmt().gridfont)
		this.param_set_font("gridfont", "serif 16");
	font = this.get_font('grid');
	font_cl = this.font_class(font)
	cls = font_cl + " mid";
	this.set_font('grid');		// (for strwh())

	// create the grid
	p_voice = voice_tb[this.get_top_v()]
	s = {
		type: C.BLOCK,
		subtype: 'ml',
		dur: 0,
		time: 0,
		p_v: p_voice,
		v: p_voice.v,
		text: build_grid.call(this, chords, bars, font)
	}

	// and insert it in the tune
	if (cfmt.grid < 0) {		// below
		for (var s2 = tsfirst; s2.ts_next; s2 = s2.ts_next)
			;
		s.time = s2.time;
		s.prev = p_voice.last_sym;
		s.ts_prev = s2;
		p_voice.last_sym.next = s;
		s2.ts_next = s
	} else {			// above
		s.time = 0;
		s.next = p_voice.sym;
		s.ts_next = tsfirst;
		tsfirst.ts_prev = s;
		tsfirst = s;
		this.set_tsfirst(s);
		p_voice.sym.prev = s;
		p_voice.sym = s
	}
    }, // do_grid()

    output_music: function(of) {
	if (this.cfmt().grid)
		abc2svg.grid.do_grid.call(this);
	of()
    },

    set_fmt: function(of, cmd, param, lock) {
	if (cmd == "grid") {
		this.cfmt().grid = param
		return
	}
	of(cmd, param, lock)
    }
} // grid

abc2svg.modules.hooks.push(
// export
	"font_class",
	"get_font",
	"param_set_font",
	"set_font",
	"strwh",
// hooks
	[ "output_music", "abc2svg.grid.output_music" ],
	[ "set_format", "abc2svg.grid.set_fmt" ]
)

// the module is loaded
abc2svg.modules.grid.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// grid2.js - module to replace a voice in the music by a chord grid
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%grid2" appears in a ABC source.
//
// Parameters
//	%%grid2 y
// This command must appear in a voice.

abc2svg.grid2 = {

// function called before tune generation
    do_grid: function() {
    var s, v, p_v,
	voice_tb = this.get_voice_tb()

	for (v = 0; v < voice_tb.length; v++) {
		p_v = voice_tb[v]
		if (!p_v.grid2)
			continue
		p_v.stafflines = '...';		// no staff lines
		p_v.clef.invis = true;		// no clef
		p_v.key.k_sf = p_v.key.k_a_acc = 0; // no key signature
		p_v.staffnonote = 2		// draw the staff
		for (s = p_v.sym; s; s = s.next) {
			if (s.dur) {		// set all notes
				s.invis = true;	//  as invisible
				delete s.sl1;	//  with no slur
				s.ti1 = 0	//  and no tie
			}
		}
	}
    }, // do_grid()

    // draw the chord symbol in the middle of the staff
    draw_chosym: function(s) {
    var	ix, gch;

	this.set_dscale(s.st)
	for (ix = 0; ix < s.a_gch.length; ix++) {
		gch = s.a_gch[ix]
		if (gch.type != 'g')
			continue
		this.use_font(gch.font);
		this.set_font(gch.font);
		this.xy_str(s.x + gch.x, gch.y + 6, gch.text)
	}
    }, // draw_chosym()

    draw_gchord: function(of, s, gchy_min, gchy_max) {
	if (s.p_v.grid2)
		abc2svg.grid2.draw_chosym.call(this, s)
	else
		of(s, gchy_min, gchy_max)
    },

    output_music: function(of) {
	abc2svg.grid2.do_grid.call(this);
	of()
    },

    set_format: function(of, cmd, param, lock) {
	if (cmd == "grid2") {
	    var	curvoice = this.get_curvoice()
		if (curvoice)
			curvoice.grid2 = param
		return
	}
	of(cmd, param, lock)
    }
} // grid2

abc2svg.modules.hooks.push(
// export
	"set_dscale",
	"set_font",
	"use_font",
	"xy_str",
// hooks
	[ "draw_gchord",  "abc2svg.grid2.draw_gchord" ],
	[ "output_music", "abc2svg.grid2.output_music" ],
	[ "set_format", "abc2svg.grid2.set_format" ]
);

// the module is loaded
abc2svg.modules.grid2.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// MIDI.js - module to handle the %%MIDI parameters
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%MIDI" appears in a ABC source.
//
// Parameters (see abcMIDI for details)
//	%%MIDI channel n
//	%%MIDI program n
//	%%MIDI control k v
//	%%MIDI drummap ABC_note MIDI_pitch

abc2svg.MIDI = {

    // parse %%MIDI commands
    do_midi: function(parm) {
    var	pits = new Int8Array([0, 0, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6]),
	accs = new Int8Array([0, 1, 0, -1, 0, 0, 1, 0, -1, 0, -1, 0])

    // convert a MIDI pitch to a note
    function tonote(p) {
    var	pit = Number(p)
	if (isNaN(pit))
		return
	p = ((pit / 12) | 0) * 7 - 19;	// octave
	pit = pit % 12;			// in octave
	p += pits[pit]
	note = {
		pit: p,
		apit: p,
	}
	if (accs[pit])
		note.acc = accs[pit]
	return note
    } // tonote()

    // normalize a note for mapping
    function norm(p) {
    var	a = p.match(/^([_^]*)([A-Ga-g])([,']*)$/)	// '
	if (!a)
		return
	if (p.match(/[A-Z]/)) {
		p = p.toLowerCase();
		if (p.indexOf("'") > 0)
			p = p.replace("'", '')
		else
			p += ','
	}
	return p
    } // norm()

	var	n, v,
	maps = this.get_maps(),
		a = parm.split(/\s+/)

	switch (a[1]) {
	case "channel":
		if (a[2] != "10")
			break
		this.set_v_param("midictl", "0 1") // channel 10 is bank 128 program 0
		break
	case "drummap":
		if (this.cfmt().sound != "play")
			break
//fixme: should have a 'MIDIdrum' per voice?
		n = norm(a[2]);
		v = tonote(a[3]);
		if (!n || !v) {
			this.syntax(1, abc.errs.bad_val, "%%MIDI drummap")
			break
		}
		if (!maps.MIDIdrum)
			maps.MIDIdrum = {}
		maps.MIDIdrum[n] = [null, v];
		this.set_v_param("mididrum", "MIDIdrum")
		break
	case "program":
		if (a[3] != undefined)	// the channel is unused
			v = a[3]
		else
			v = a[2];
		v = parseInt(v)
		if (isNaN(v) || v < 0 || v > 127) {
			this.syntax(1, "Bad program in %%MIDI")
			return
		}
		this.set_v_param("instr", v)
		break
	case "control":
		n = parseInt(a[2])
		if (isNaN(n) || n < 0 || n > 127) {
			this.syntax(1, "Bad controller number in %%MIDI")
			return
		}
		v = parseInt(a[3])
		if (isNaN(v) || v < 0 || v > 127) {
			this.syntax(1, "Bad controller value in %%MIDI")
			return
		}
		this.set_v_param("midictl", a[2] + ' ' + a[3])
		break
	}
    }, // do_midi()

    // set the MIDI parameters in the current voice
    set_midi: function(a) {
    var	i, item,
	curvoice = this.get_curvoice()

	for (i = 0; i < a.length; i++) {
		switch (a[i]) {
		case "instr=":			// %%MIDI program
			curvoice.instr = a[i + 1]
			break
		case "midictl=":		// %%MIDI control
			if (!curvoice.midictl)
				curvoice.midictl = {}
			item = a[i + 1].split(' ');
			curvoice.midictl[item[0]] = Number(item[1])
			break
		case "mididrum=":		// %%MIDI drummap note midipitch
			if (!curvoice.map)
				curvoice.map = {}
			curvoice.map = a[i + 1]
			break
		}
	}
    }, // set_midi()

    do_pscom: function(of, text) {
	if (text.slice(0, 5) == "MIDI ")
		abc2svg.MIDI.do_midi.call(this, text)
	else
		of(text)
    },

    set_vp: function(of, a) {
	abc2svg.MIDI.set_midi.call(this, a);
	of(a)
    }
} // MIDI

abc2svg.modules.hooks.push(
// export
	"errs",
	"set_v_param",
	"syntax",
// hooks
	[ "do_pscom", "abc2svg.MIDI.do_pscom" ],
	[ "set_vp", "abc2svg.MIDI.set_vp" ]
);

// the module is loaded
abc2svg.modules.MIDI.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// wps.js
// (c) 2009 Tomas Hlavaty

function isQuoted(V) {
  return V.q;
}

function quote(V) {
  V.q = true;
  return V;
}

function unquote(V) {
  delete V.q;
  return V;
}

function Symbol(N) {
  this.nm = N;
  return this;
}

function isSymbol(V) {
  return V &&  V.constructor === Symbol;
}

function symbolName(V) {
  return V.nm;
}

function isArray(V) {
  return V &&  V.constructor === Array;
}

function inDs(Ds, K) {
  for(var I = Ds.length - 1; 0 <= I; --I) {
	if("undefined" != typeof Ds[I][K])
	  return Ds[I];
  }
  return false;
}

function member(C, L) {
  return 0 <= L.indexOf(C);
}

function PsParser() {
  var Self = this;
  function init(L) {
    Self.L = L;
    Self.N = L.length;
    Self.I = 0;
    Self.D = 0;
  }
  function peek() {return Self.I < Self.N && Self.L[Self.I];}
  function xchar() {return Self.I < Self.N && Self.L[Self.I++];}
  function skip() { // TODO white space ffeed + null???
    while(Self.I < Self.N && member(Self.L[Self.I], " \t\n"))
      Self.I++;
  }
  function comment() {
    while("%" == peek()) {
      while(peek() && "\n" != peek())
        xchar();
      skip();
    }
  }
  function text() {
    // TODO hex text in <>
    // TODO ASCII base-85 <~ and ~>
    xchar();
    var L = [];
    var N = 1;
    while(0 < N && peek()) {
      var C = xchar();
      switch(C) {
        case "(":
          N++;
          break;
        case ")":
          N--;
          if(N <= 0) C = false;
          break;
        case "\\":
          C = xchar();
          switch(C) {
            case "(": break;
            case ")": break;
            case "\\": break;
            case "n": C = "\n"; break;
            case "r": C = "\r"; break;
            case "t": C = "\t"; break;
            // TODO \n (ignore \n) \b \f \ddd octal
            default:
              C = false;
          }
          break;
      }
      if(C !== false) L.push(C);
    }
    return L.join("");
  }
  function symbol() {
    // TODO 1e10 1E-5 real numbers
    // TODO radix numbers 8#1777 16#FFFE 2#1000
    var C = xchar();
    if(member(C, "()<>/% \t\n")) throw new Error("Symbol expected, got " + C);
    var N = member(C, "+-0123456789.");
    var F = "." == C;
    var L = [C];
    while(peek() && !member(peek(), "()<>[]{}/% \t\n")) {
      C = xchar();
      L.push(C);
      if(N && !member(C, "0123456789")) {
        if(!F && "." == C) F = true;
        else N = false;
      }
    }
    L = L.join("");
    if(1 == L.length && member(L, "+-.")) N = false;
    return N ? (F ? parseFloat(L) : parseInt(L, 10)) : new Symbol(L);
  }
  function token() {
    skip();
    switch(peek()) { // TODO read dict in <> <~~> <<>> immediate literal //
      case false: return undefined;
      case "%": return comment();
      case "[": return new Symbol(xchar());
      case "]": return new Symbol(xchar());
      case "{": Self.D++; return new Symbol(xchar());
      case "}": Self.D--; return new Symbol(xchar());
      case "/": xchar(); var X = symbol(); return quote(X);
      case "(": return text();
      case "<":
        xchar();
        if("<" != peek()) throw new Error("Encoded strings not implemented yet");
        xchar();
        return new Symbol("<<");
      case ">":
        xchar();
        if(">" != peek()) throw new Error("Unexpected >");
        xchar();
        return new Symbol(">>");
      default: return symbol();
    }
  }
  PsParser.prototype.init = init;
  PsParser.prototype.peek = peek;
  PsParser.prototype.token = token;
  return this;
}

function Ps0(Os, Ds, Es) {
  function run(X, Z) {
    if(isSymbol(X) && !isQuoted(X)) { // executable name
      var K = symbolName(X);
      var D = inDs(Ds, K);
      if(!D)
        throw new Error("bind error '" + K + "'");
      Es.push([false, D[K]]);
    } else if(Z && isArray(X) && isQuoted(X)) { // proc from Es
      if(0 < X.length) {
        var F = X[0];
        var R = quote(X.slice(1));
        if(0 < R.length) Es.push([false, R]);
        run(F, false);
      }
    } else if("function" == typeof X) X(); // operator
    else Os.push(X);
  }
  function exec() {
    var X = Os.pop();
    run(X, false);
  }
  function step() {
    var C = Es.pop();
    var L = C.shift(); // TODO use for 'exit'
    var X = C.pop();
    for(var I = 0; I < C.length; I++)
      Os.push(C[I]);
    run(X, true);
  }
  var PsP = new PsParser;
  function parse(L) {
    PsP.init(L);
    while(PsP.peek()) {
      var T = PsP.token();
      if(T || T === 0) {
        Os.push(T);
        if(PsP.D <= 0 || isSymbol(T) &&
           (member(symbolName(T), "[]{}") ||
            "<<" == symbolName(T) || ">>" == symbolName(T))) {
          exec();
          while(0 < Es.length)
            step();
        }
      }
    }
    return Os;
  }
  Ps0.prototype.run = run;
  Ps0.prototype.exec = exec;
  Ps0.prototype.step = step;
  Ps0.prototype.parse = parse;
  return this;
}

function Wps(psvg_i) {
	var psvg = psvg_i;
  var Os = [];
  var Sd = {};
  var Ds = [Sd];
  var Es = [];
  var Ps = new Ps0(Os, Ds, Es);

  // trivial
  Sd["true"] = function() {Os.push(true);};
  Sd["false"] = function() {Os.push(false);};
  Sd["null"] = function() {Os.push(null);};
  // math
  Sd["sub"] = function() {var X = Os.pop(); Os.push(Os.pop() - X);};
  Sd["mul"] = function() {Os.push(Os.pop() * Os.pop());};
  Sd["div"] = function() {var X = Os.pop(); Os.push(Os.pop() / X);};
  Sd["mod"] = function() {var X = Os.pop(); Os.push(Os.pop() % X);};
  // stack
  var M = {};
  Sd["mark"] = function() {Os.push(M);};
  Sd["counttomark"] = function() {
    var N = 0;
    for(var I = Os.length - 1; 0 <= I; I--)
      if(M === Os[I]) return Os.push(N);
      else N++;
    throw new Error("Mark not found");
  };
  Sd["<<"] = Sd["mark"]; // TODO doc
  Sd[">>"] = function() { // TODO doc
    var D = {};
    while(0 < Os.length) {
      var V = Os.pop();
      if(M === V) return Os.push(D);
      D[Os.pop()] = V;
    }
    throw new Error("Mark not found");
  };
  Sd["exch"] = function() {
    var Y = Os.pop();
    var X = Os.pop();
    Os.push(Y);
    Os.push(X);
  };
  Sd["clear"] = function() {Os.length = 0;};
  Sd["pop"] = function() {Os.pop();};
  Sd["index"] = function() {
    Os.push(Os[Os.length - 2 - Os.pop()]);
  };
  Sd["roll"] = function() { // TODO in ps
    var J = Os.pop();
    var N = Os.pop();
    var X = [];
    var Y = [];
//jfm patch
    if (J < 0)
    	J = N + J
    for(var I = 0; I < N; I++)
      if(I < J) X.unshift(Os.pop());
      else Y.unshift(Os.pop());
    for(I = 0; I < J; I++) Os.push(X.shift());
    for(I = 0; I < N - J; I++) Os.push(Y.shift());
  };
  Sd["copy"] = function() {
	var N = Os.pop();
	if("object" == typeof N) {
	  var X = Os.pop();
	  for(var I in X)
        N[I] = X[I];
      Os.push(N);
    } else {
      var X = Os.length - N;
      for(var I = 0; I < N; I++)
        Os.push(Os[X + I]);
    }
  };
  // array
  Sd["length"] = function() {Os.push(Os.pop().length);};
  Sd["astore"] = function() {
    var A = Os.pop();
    var N = A.length;
    for(var I = N - 1; 0 <= I; I--)
      A[I] = Os.pop();
    Os.push(A);
  };
  Sd["array"] = function() {Os.push(new Array(Os.pop()));};
  // conditionals
  Sd["eq"] = function() {var Y = Os.pop(); var X = Os.pop(); Os.push(X == Y);};
  Sd["lt"] = function() {var Y = Os.pop(); var X = Os.pop(); Os.push(X < Y);};
  // control
  Sd["ifelse"] = function() {
    var N = Os.pop();
    var P = Os.pop();
    var C = Os.pop();
    Es.push([false, C === true ? P : N]);
  };
//jfm++
	Sd["and"] = function() {
		var A = Os.pop();
		var B = Os.pop();
		if (true === A || false === A) {
			Os.push(A == true && B === true)
			return
		}
		Os.push(A & B)
	}
//jfm--
  Sd["repeat"] = function Xrepeat() { // TODO in ps
    var B = Os.pop();
    var N = Os.pop();
    if(1 < N) Es.push([true, N - 1, B, Xrepeat]);
    if(0 < N) Es.push([false, B]);
  };
  Sd["for"] = function Xfor() { // TODO in ps
    var B = Os.pop();
    var L = Os.pop();
    var K = Os.pop();
    var J = Os.pop();
    if(K < 0) {
      if(L <= J + K) Es.push([true, J + K, K, L, B, Xfor]);
      if(L <= J) Es.push([false, J, B]);
    } else {
      if(J + K <= L) Es.push([true, J + K, K, L, B, Xfor]);
      if(J <= L) Es.push([false, J, B]);
    }
  };
  Sd["exec"] = function() {Es.push([false, Os.pop()]);};
  Sd["cvx"] = function() {
    var X = Os.pop();
    if(isSymbol(X) && isQuoted(X)) Os.push(unquote(X)); // executable name
    else if(isArray(X) && !isQuoted(X)) Os.push(quote(X)); // proc
    // TODO string -> parse
    else Os.push(X);
  };
  // dictionary
  Sd["dict"] = function() {Os.pop(); Os.push({});};
  Sd["get"] = function() {
    var K = Os.pop();
    var D = Os.pop();
    // TODO other datatypes
    if(isSymbol(K)) Os.push(D[symbolName(K)]);
    else Os.push(D[K]);
  };
  Sd["getinterval"] = function() {
    var N = Os.pop(),
	K = Os.pop() + N,
	D = Os.pop(),
	A = []
	while (--N >= 0)
		A.push(D[K++])
	Os.push(A);
  };
  Sd["put"] = function() {
    var V = Os.pop();
    var K = Os.pop();
    var D = Os.pop();
    // TODO other datatypes
    if(isSymbol(K)) D[symbolName(K)] = V;
    else D[K] = V;
  };
  Sd["begin"] = function() {Ds.push(Os.pop());};
  Sd["end"] = function() {Ds.pop();};
  Sd["currentdict"] = function() {Os.push(Ds[Ds.length - 1]);};
  Sd["where"] = function() {
    var K = symbolName(Os.pop());
    var D = inDs(Ds, K);
	if(D) {
	  Os.push(D);
	  Os.push(true);
	} else Os.push(false);
  };
  // miscellaneous
  Sd["save"] = function() {
    var X = Ds.slice();
    for(var I = 0; I < X.length; I++) {
      var A = X[I];
      var B = {};
      for(var J in A)
        B[J] = A[J];
      X[I] = B;
    }
    Os.push(X);
  };
  Sd["restore"] = function() {
    var X = Os.pop();
    while(0 < Ds.length)
      Ds.pop();
    while(0 < X.length)
      Ds.unshift(X.pop());
  };
  Sd["type"] = function() {
    var A = Os.pop();
    var X;
    if(null === A) X = "nulltype";
    else if(true === A || false === A) X = "booleantype";
    else if(M === A) X = "marktype";
    else if("string" == typeof A) X = "stringtype";
    else if(isSymbol(A)) X = isQuoted(A) ? "nametype" : "operatortype";
    else if("function" == typeof A) X = "operatortype";
    else if(isArray(A)) X = "arraytype";
    else if("object" == typeof A) X = "dicttype";
    else if(1 * A == A) X = A % 1 == 0 ? "integertype" : "realtype";
    else throw new Error("Undefined type '" + A + "'");
    Os.push(X);
    // filetype
    // packedarraytype (LanguageLevel 2)
    // fonttype
    // gstatetype (LanguageLevel 2)
    // savetype
  };
  var Sb = true;
  Sd[".strictBind"] = function() {Sb = true === Os.pop();};
  Sd["bind"] = function() {Os.push(bind(Os.pop()));};
  function bind(X) {
    if(isSymbol(X) && !isQuoted(X)) {
//jfm++
//      var K = symbolName(X);
//      var D = inDs(Ds, K);
//      if(Sb) {
//        if(!D)
//          throw new Error("bind error '" + K + "'");
//        return bind(D[K]);
//      } else return !D ? X : bind(D[K]);
	return X
//jfm--
    } else if(isArray(X) && isQuoted(X)) {
      var N = X.length;
      var A = [];
      for(var I = 0; I < N; I++) {
        var Xi = X[I];
        var Xb = bind(Xi);
        if(isArray(Xi))
          A = A.concat(isQuoted(Xi) ? quote([Xb]) : [Xb]);
        else
          A = A.concat(Xb);
      }
      return quote(A);
    }
    return X;
  }
  // debugging
  Sd["="] = function() {var X = Os.pop(); alert(X && X.nm || X);}; // TODO
  Sd["=="] = function() {alert(Os.pop());}; // TODO
  Sd["stack"] = function() {alert(Os);}; // TODO
  Sd["pstack"] = function() {alert(Os);}; // TODO
  // js ffi
  Sd[".call"] = function() {
    var N = Os.pop();
    var K = Os.pop();
    var D = Os.pop();
    var X = [];
    for(var I = 0; I < N; I++) X.unshift(Os.pop());
    if (!D[K]) throw new Error(".call: " + K + " undef")
    Os.push(D[K].apply(D, X));
  };
//jfm++
  Sd[".call0"] = function() {
    var N = Os.pop(),
	K = Os.pop(),
	D = Os.pop(),
	X = []
    for(var I = 0; I < N; I++) X.unshift(Os.pop());
    if (!D[K]) throw new Error(".call0: " + K + " undef")
    D[K].apply(D, X);
  };
  Sd[".svg"] = function() {Os.push(psvg)};
//jfm--
  Sd[".math"] = function() {Os.push(Math);};
  Sd[".date"] = function() {Os.push(new Date());}; // TODO split new and Date
  Sd[".window"] = function() {Os.push(window);};
  Sd[".callback"] = function() { // TODO event arg?
    var X = Os.pop();
    Os.push(function() {
              Ps.run(X, true);
              while(0 < Es.length)
                Ps.step();
            });
  };
  // html5
  Sd[".minv"] = function() { // TODO in ps
    var M = Os.pop();
    var a = M[0]; var b = M[1];
    var d = M[2]; var e = M[3];
    var g = M[4]; var h = M[5];
    Os.push([e, b, d, a, d*h-e*g, b*g-a*h]);
  };
  Sd[".mmul"] = function() { // TODO in ps
    var B = Os.pop();
    var A = Os.pop();
    var a = A[0]; var b = A[1];
    var d = A[2]; var e = A[3];
    var g = A[4]; var h = A[5];
    var r = B[0]; var s = B[1];
    var u = B[2]; var v = B[3];
    var x = B[4]; var y = B[5];
    Os.push([a*r+b*u, a*s+b*v, d*r+e*u, d*s+e*v, g*r+h*u+x, g*s+h*v+y]);
  };
  Sd[".xy"] = function() { // TODO in ps
    var M = Os.pop();
    var Y = Os.pop();
    var X = Os.pop();
    Os.push(M[0] * X + M[2] * Y + M[4]);
    Os.push(M[1] * X + M[3] * Y + M[5]);
  };
  // TODO js ffi to manipulate strings so the following can be in ps
  Sd[".rgb"] = function() { // TODO in ps
    var B = Os.pop();
    var G = Os.pop();
    var R = Os.pop();
    Os.push("rgb(" + R + "," + G + "," + B + ")");
  };
  Sd[".rgba"] = function() { // TODO in ps
    var A = Os.pop();
    var B = Os.pop();
    var G = Os.pop();
    var R = Os.pop();
    Os.push("rgba(" + R + "," + G + "," + B + "," + A + ")");
  };

  function parse() {
    var T = arguments;
    if(T.length)
      for(var I = 0; I < T.length; I++)
        Ps.parse(T[I]);
    else Ps.parse(T);
    return Os;
  }
  Wps.prototype.parse = parse;
  return this;
}
// psvg.js - small PS to SVG convertor for abc2svg

// Copyright (C) 2014-2018 Jean-Francois Moine
//
// This file is part of abc2svg-core.
//
// abc2svg-core is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// abc2svg-core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with abc2svg-core.  If not, see <http://www.gnu.org/licenses/>.

function Psvg(abcobj_r) {
    var	svgbuf = '',

// SVG functions - adapted from abcm2ps svg.c
	abcobj = abcobj_r,
	wps = new Wps(this),
	g = 0,			// graphic state
	gchg,			// graphic change
	gcur = {		// current graphic context
		cx:0,
		cy:0,
		xoffs:0,
		yoffs:0,
		xscale: 1,
		yscale: 1,
		rotate: 0,
		sin: 0,
		cos: 1,
		linewidth: 0.7,
		dash: ''
	},
	gc_stack = [],		// graphic stack
	x_rot = 0,
	y_rot = 0,
	font_n = "",
	font_n_old = "",
	font_s = 0,
	path;

// function called from Abc
    function getorig() {
	setg(0);
	return [gcur.xoffs - gcur.xorig, gcur.yoffs - gcur.yorig]
    }

    function defg1() {
	gchg = false;
	setg(0);
	svgbuf += "<g"
	if (gcur.xscale != 1 || gcur.yscale != 1 || gcur.rotate) {
		svgbuf += ' transform="'
		if (gcur.xscale != 1 || gcur.yscale != 1) {
			if (gcur.xscale == gcur.yscale)
				svgbuf += "scale(" + gcur.xscale.toFixed(3) + ")"
			else
				svgbuf += "scale(" + gcur.xscale.toFixed(3) +
						"," + gcur.yscale.toFixed(3) + ")"
		}
		if (gcur.rotate) {
			if (gcur.xoffs || gcur.yoffs) {
				var	x, xtmp = gcur.xoffs,
					y = gcur.yoffs,
					_sin = gcur.sin,
					_cos = gcur.cos;
				x = xtmp * _cos - y * _sin;
				y = xtmp * _sin + y * _cos;
				svgbuf += " translate(" + x.toFixed(2) + "," +
						y.toFixed(2) + ")";
				x_rot = gcur.xoffs;
				y_rot = gcur.yoffs;
				gcur.xoffs = 0;
				gcur.yoffs = 0
			}
			svgbuf += " rotate(" + gcur.rotate.toFixed(2) + ")"
		}
		svgbuf += '"'
	}
	output_font(false)
	if (gcur.rgb)
		svgbuf += ' style="color:' + gcur.rgb + '"';
	svgbuf += ">\n";
	g = 1
    }

    function objdup(obj) {
	var	k, tmp = new obj.constructor()
	for (k in obj)
	    if (obj.hasOwnProperty(k))
		tmp[k] = obj[k]
	return tmp
    }

    function output_font(back) {
	var	name = gcur.font_n
	if (!name)
		return
	var	prop = "",
		i = name.indexOf("Italic"),
		j = 100,
		o = name.indexOf("Oblique"),
		b = name.indexOf("Bold"),
		flags = 0
	if (b > 0) {
		prop = ' font-weight="bold"';
		j = b;
		flags = 2
	}
	if (i > 0 || o > 0) {
		if (i > 0) {
			prop += ' font-style="italic"';
			if (i < j)
				j = i;
			flags |= 4
		}
		if (o > 0) {
			prop += ' font-style="oblique"';
			if (o < j)
				j = o;
			flags = 8
		}
	}
	if (j != 100) {
		if (name[j - 1] == '-')
			j--;
		name = name.slice(0, j)
	}

	if (back) {
		if (!(flags & 2)
		 && font_n_old.indexOf("Bold") >= 0)
			prop += ' font-weight="normal"';
		if (!(flags & 12)
		 && (font_n_old.indexOf("Italic") >= 0
		  || font_n_old.indexOf("Oblique") >= 0))
			prop += ' font-style="normal"'
	}
	svgbuf += ' font-family="' + name + '"' +
		prop + ' font-size="' + gcur.font_s + '"'
    }

    function path_def() {
	if (path)
		return
	setg(1);
	gcur.px = gcur.cx;
	gcur.py = gcur.cy;
	path = '<path d="m' + (gcur.xoffs + gcur.cx).toFixed(2) +
		' ' + (gcur.yoffs - gcur.cy).toFixed(2) + '\n'
    }

    function path_end() {
	svgbuf += path;
	path = ''
    }

    function setg(newg) {
	if (g == 2) {
		svgbuf += "</text>\n";
		g = 1
	}
	if (newg == 0) {
		if (g) {
			g = 0;
			svgbuf += "</g>\n"
			if (gcur.rotate) {
				gcur.xoffs = x_rot;
				gcur.yoffs = y_rot;
				x_rot = 0;
				y_rot = 0
			}
		}
	} else if (gchg) {
		defg1()
	}
    }

    function strw(s) {
	return s.length * gcur.font_s * 0.5	// fixme: approximate value
    }
    Psvg.prototype.strw = strw;

// graphic functions called from wps.js
    function arc(x, y, r, a1, a2, arcn) {
	var x1, y1, x2, y2
	if (a1 >= 360)
		a1 -= 360
	if (a2 >= 360)
		a2 -= 360;
	x1 = x + r * Math.cos(a1 * Math.PI / 180);
	y1 = y + r * Math.sin(a1 * Math.PI / 180)

	if (gcur.cx != undefined) {
		if (path) {
			if (x1 != gcur.cx || y1 != gcur.cy)
				path += 'l'
			else
				path += 'm';
			path += (x1 - gcur.cx).toFixed(2) + " " +
				(-(y1 - gcur.cy)).toFixed(2)
		} else {
			gcur.cx = x1;
			gcur.cy = y1;
			path_def()
		}
	} else {
		if (path)		// should not occur
			path = ''
		gcur.cx = x1;
		gcur.cy = y1;
		path_def()
	}

	if (a1 == a2) {			/* circle */
		a2 = 180 - a1;
		x2 = x + r * Math.cos(a2 * Math.PI / 180);
		y2 = y + r * Math.sin(a2 * Math.PI / 180);
		path += 'a' + r.toFixed(2) + ' ' + r.toFixed(2) + ' 0 0 ' +
			(arcn ? '1 ' : '0 ') +
			(x2 - x1).toFixed(2) + ' ' +
			(y1 - y2).toFixed(2) + ' ' +
			r.toFixed(2) + ' ' + r.toFixed(2) + ' 0 0 ' +
			(arcn ? '1 ' : '0 ') +
			(x1 - x2).toFixed(2) + ' ' +
			(y2 - y1).toFixed(2) + '\n';
		gcur.cx = x1;
		gcur.cy = y1
	} else {
		x2 = x + r * Math.cos(a2 * Math.PI / 180);
		y2 = y + r * Math.sin(a2 * Math.PI / 180);
		path += 'a' + r.toFixed(2) + ' ' + r.toFixed(2) + ' 0 0 ' +
			(arcn ? '1 ' : '0 ') +
			(x2 - x1).toFixed(2) + ' ' +
			(y1 - y2).toFixed(2) + '\n';
		gcur.cx = x2;
		gcur.cy = y2
	}
    }
    Psvg.prototype.arc = arc

    Psvg.prototype.arcn = function(x, y, r, a1, a2) {
	arc(x, y, r, a1, a2, true)
    }

    Psvg.prototype.closepath = function() {
	if (path && gcur.cx)
		rlineto(gcur.px - gcur.cx, gcur.py - gcur.cy)
    }

    Psvg.prototype.cx = function() {
	return gcur.cx
    }

    Psvg.prototype.cy = function() {
	return gcur.cy
    }

    Psvg.prototype.curveto = function(x1, y1, x2, y2, x, y) {
	path_def();
	path += "\tC" + 
		(gcur.xoffs + x1).toFixed(2) + " " + (gcur.yoffs - y1).toFixed(2) + " " +
		(gcur.xoffs + x2).toFixed(2) + " " + (gcur.yoffs - y2).toFixed(2) + " " +
		(gcur.xoffs + x).toFixed(2) + " " + (gcur.yoffs - y).toFixed(2) + "\n";
	gcur.cx = x;
	gcur.cy = y
    }

    Psvg.prototype.eofill = function() {
	path_end();
	svgbuf += '" fill-rule="evenodd" fill="currentColor"/>\n'
    }

    Psvg.prototype.fill = function() {
	path_end();
	svgbuf += '" fill="currentColor"/>\n'
    }

    Psvg.prototype.gsave = function() {
	gc_stack.push(objdup(gcur))
    }

    Psvg.prototype.grestore = function() {
	gcur = gc_stack.pop();
	gchg = true
    }

    Psvg.prototype.lineto = function(x, y) {
	path_def()
	if (x == gcur.cx)
		path += "\tv" + (gcur.cy - y).toFixed(2) + "\n"
	else if (y == gcur.cy)
		path += "\th" + (x - gcur.cx).toFixed(2) + "\n"
	else
		path += "\tl" + (x - gcur.cx).toFixed(2) + " " +
			(gcur.cy - y).toFixed(2) + "\n";
	gcur.cx = x;
	gcur.cy = y
    }

    Psvg.prototype.moveto = function(x, y) {
	gcur.cx = x;
	gcur.cy = y
	if (path) {
		path += "\tM" + (gcur.xoffs + gcur.cx).toFixed(2) + " " +
				(gcur.yoffs - gcur.cy).toFixed(2) + "\n"
	} else if (g == 2) {
		svgbuf += "</text>\n";
		g = 1
	}
    }

    Psvg.prototype.newpath = function() {
	gcur.cx = gcur.cy = undefined
    }

    Psvg.prototype.rcurveto = function(x1, y1, x2, y2, x, y) {
	path_def();
	path += "\tc" + 
		x1.toFixed(2) + " " + (-y1).toFixed(2) + " " +
		x2.toFixed(2) + " " + (-y2).toFixed(2) + " " +
		x.toFixed(2) + " " + (-y).toFixed(2) + "\n";
	gcur.cx += x;
	gcur.cy += y
    }

    function rlineto(x, y) {
	path_def()
	if (x == 0)
		path += "\tv" + (-y).toFixed(2) + "\n"
	else if (y == 0)
		path += "\th" + x.toFixed(2) + "\n"
	else
		path += "\tl" + x.toFixed(2) + " " +
			(-y).toFixed(2) + "\n";
	gcur.cx += x;
	gcur.cy += y
    }
    Psvg.prototype.rlineto = rlineto;

    Psvg.prototype.rmoveto = function(x, y) {
	if (path) {
		path += "\tm" + x.toFixed(2) + " " +
				(-y).toFixed(2) + "\n"
	} else if (g == 2) {
		svgbuf += "</text>\n";
		g = 1
	}
	gcur.cx += x;
	gcur.cy += y
    }

    Psvg.prototype.rotate = function(a) {
	setg(0)

	// convert orig and currentpoint coord to absolute coord
	var	x, xtmp = gcur.xoffs,
		y = gcur.yoffs,
		_sin = gcur.sin,
		_cos = gcur.cos;
	x = xtmp * _cos - y * _sin;
	y = xtmp * _sin + y * _cos;
	gcur.xoffs = x / gcur.xscale;
	gcur.yoffs = y / gcur.yscale;

	xtmp = gcur.cx;
	y = gcur.cy;
	x = xtmp * _cos - y * _sin;
	y = -xtmp * _sin + y * _cos;
	gcur.cx = x / gcur.xscale;
	gcur.cy = y / gcur.yscale;

	// rotate
	a = 360 - a;
	gcur.rotate += a
	if (gcur.rotate > 180)
		gcur.rotate -= 360
	else if (gcur.rotate <= -180)
		gcur.rotate += 360
	a = gcur.rotate * Math.PI / 180;
	gcur.sin = _sin = Math.sin(a);
	gcur.cos = _cos = Math.cos(a);
	x = gcur.cx;
	gcur.cx = (x * _cos + gcur.cy * _sin) * gcur.xscale;
	gcur.cy = (-x * _sin + gcur.cy * _cos) * gcur.yscale;
	x = gcur.xoffs;
	gcur.xoffs = (x * _cos + gcur.yoffs * _sin) *
			gcur.xscale;
	gcur.yoffs = (-x * _sin + gcur.yoffs * _cos) *
			gcur.yscale;
	gchg = true
    }

    Psvg.prototype.scale = function(sx, sy) {
	gcur.xoffs /= sx;
	gcur.yoffs /= sy;
	gcur.cx /= sx;
	gcur.cy /= sy;
	gcur.xscale *= sx;
	gcur.yscale *= sy;
	gchg = true
    }

    Psvg.prototype.selectfont = function(s, h) {
	s = s.nm;			// Symbol
	if (font_s != h || s != font_n) {
		gcur.font_n_old = gcur.font_n;
		gcur.font_n = s;
		gcur.font_s = h;
		gchg = true
	}
    }

    Psvg.prototype.setdash = function(a, o) {
	var n = a.length, i
	if (n == 0) {
		gcur.dash= ''
		return
	}
	gcur.dash = ' stroke-dashoffset="' + o + '"  stroke-dasharray="';
	i = 0
	while (1) {
		gcur.dash += a[i]
		if (--n == 0)
			break
		gcur.dash += ' '
	}
	gcur.dash += '"'
    }

    Psvg.prototype.setlinewidth = function(w) {
	gcur.linewidth = w
    }

    Psvg.prototype.setrgbcolor = function(r, g, b) {
	var rgb = 0x1000000 +
		(Math.floor(r * 255) << 16) +
		(Math.floor(g * 255) << 8) +
		Math.floor(b * 255);
	rgb = rgb.toString(16);
	rgb = rgb.replace('1', '#')
	if (rgb != gcur.rgb) {
		gcur.rgb = rgb;
		gchg = true
	}
    }

    Psvg.prototype.show = function(s) {
	var span, x, y
	if (gchg) {
		if (g == 2)
			span = true
		else
			defg1()
	}
	x = gcur.cx;
	y = gcur.cy
	if (span) {
		svgbuf += "<tspan\n\t";
		output_font(true);
		svgbuf += ">"
	} else if (g != 2) {
		svgbuf += '<text x="' + (x + gcur.xoffs).toFixed(2) + '" y="' +
				(gcur.yoffs - y).toFixed(2) + '">';
		g = 2
	}
	svgbuf += s.replace(/<|>|&|  /g, function(c){
			switch (c) {
			case '<': return "&lt;"
			case '>': return "&gt;"
			case '&': return "&amp;"
			case '  ': return '  '		// space + nbspace
			}
		})
	if (span)
		svgbuf += "</tspan>";
	gcur.cx = x + strw(s)
    }

    Psvg.prototype.stroke = function() {
	path_end()
	if (gcur.linewidth != 0.7)
		svgbuf += '" stroke-width="' + gcur.linewidth.toFixed(2);
	svgbuf += '" stroke="currentColor" fill="none"' + gcur.dash + '/>\n'
    }

    Psvg.prototype.translate = function(x, y) {
	gcur.xoffs += x;
	gcur.yoffs -= y;
	gcur.cx -= x;
	gcur.cy -= y
    }

// abcm2ps functions
    Psvg.prototype.arp = function(val, x, y) {
    var	xy = getorig();
	ps_flush();
	abcobj.out_arp((x + xy[0]) * abcobj.stv_g().scale, y - xy[1], val)
    }
    Psvg.prototype.ltr = function(val, x, y) {
    var	xy = getorig();
	ps_flush();
	abcobj.out_ltr((x + xy[0]) * abcobj.stv_g().scale, y - xy[1], val)
    }
    Psvg.prototype.xygl = function(x, y, gl) {
    var	xy = getorig();
	ps_flush();
	abcobj.xygl((x + xy[0]) * abcobj.stv_g().scale, y - xy[1], gl)
    }
    Psvg.prototype.xygls = function(str, x, y, gl) {
    var	xy = getorig();
	ps_flush();
	abcobj.out_deco_str((x + xy[0]) * abcobj.stv_g().scale, y - xy[1], gl, str)
    }
    Psvg.prototype.xyglv = function(val, x, y, gl) {
    var	xy = getorig();
	ps_flush();
	abcobj.out_deco_val((x + xy[0]) * abcobj.stv_g().scale, y - xy[1], gl, val)
    }
    Psvg.prototype.y0 = function(y) {
    var	staff_tb = abcobj.get_staff_tb()
	return y + staff_tb[0].y
    }
    Psvg.prototype.y1 = function(y) {
    var	staff_tb = abcobj.get_staff_tb()
	return y + staff_tb[1].y
    }

// flush the PS buffer
function ps_flush(g0) {
	if (g0)
		setg(0);
	if (!svgbuf)
		return
	abcobj.out_svg(svgbuf);
	svgbuf = ''
}
Psvg.prototype.ps_flush = ps_flush

// evaluate a PS user sequence (%beginps .. %%endps)
Psvg.prototype.ps_eval = function(txt) {
	wps.parse(txt);
	ps_flush()
}

// ------ output builtin decorations
// common part
function pscall(f, x, y, script) {
	gcur.xorig = gcur.xoffs = abcobj.sx(0);
	gcur.yorig = gcur.yoffs = abcobj.sy(0);
	gcur.cx = 0;
	gcur.cy = 0;
	wps.parse(script +
		(x / abcobj.stv_g().scale).toFixed(2) + ' ' + y.toFixed(2) + ' ' + f);
	ps_flush(true)			// + setg(0)
	return true
}

// try to generate a decoration by PS
Psvg.prototype.psdeco = function(f, x, y, de) {
	var	dd, de2, script, defl,
		Os = wps.parse('/' + f + ' where'),
		A = Os.pop(),
	staff_tb = abcobj.get_staff_tb()

	if (!A)
		return false;
	defl = 0
	if (de.defl.nost)
		defl = 1
	if (de.defl.noen)
		defl |= 2
	if (de.s.stem >= 0)
		defl |= 4;

	Os.pop();
	script = '/defl ' + defl + ' def '
	if (de.lden) {
		script += x.toFixed(2) + ' ' + y.toFixed(2) + ' ';
		de2 = de.start;
		x = de2.x;
		y = de2.y + staff_tb[de2.st].y
		if (x > de.x - 20)
			x = de.x - 20
	}
	dd = de.dd
	if (de.has_val) {
		script += de.val + ' '
	} else if (dd.str) {
		script += '(' + dd.str + ') ';
		y += dd.h * 0.2
	}
	return pscall(f, x, y, script)
}

// try to generate a glyph by PS
Psvg.prototype.psxygl = function(x, y, gl) {
	var	Os = wps.parse('/' + gl + ' where'),
		A = Os.pop()
	if (!A)
		return false
	Os.pop()
	return pscall(gl, x, y, 'dlw ')
}

Psvg.prototype.svgcall = function(f, x, y, v1, v2) {
    var	xy = getorig();
	ps_flush();
	f((x + xy[0]) * abcobj.stv_g().scale, y - xy[1], v1, v2)
}

//  initialize the PostScript functions
	wps.parse("\
currentdict/systemdict currentdict put\n\
systemdict/{/mark cvx put\n\
systemdict/[/mark cvx put\n\
systemdict/]\n\
/counttomark cvx\n\
/array cvx\n\
/astore cvx\n\
/exch cvx\n\
/pop cvx\n\
5 array astore cvx put\n\
systemdict/}/] cvx/cvx cvx 2 array astore cvx put\n\
systemdict/def{currentdict 2 index 2 index put pop pop}put\n\
\n\
/maxlength 1000 def % TODO\n\
/.bdef{bind def}bind def\n\
/.xdef{exch def}.bdef\n\
/dup{0 index}.bdef\n\
/load{dup where pop exch get}.bdef\n\
/.ldef{load def}.bdef\n\
/if{{}ifelse}.bdef\n\
/cleartomark{array pop}.bdef\n\
/known{exch begin where{currentdict eq}{false}if end}.bdef\n\
/store{1 index where{3 1 roll put}{def}ifelse}.bdef\n\
/not{{false}{true}ifelse}.bdef\n\
%/.logand{{{true}{false}ifelse}{pop false}ifelse}.bdef\n\
%/and/.logand .ldef % TODO numeric and\n\
/.logor{{pop true}{{true}{false}ifelse}ifelse}.bdef\n\
/or/.logor .ldef % TODO numeric or\n\
/ne{eq not}.bdef\n\
/ge{lt not}.bdef\n\
/le{1 index 1 index eq 3 1 roll lt or}.bdef\n\
/gt{le not}.bdef\n\
/.repeat{1 1 4 2 roll for}.bdef\n\
\n\
%% math\n\
\n\
/floor{.math(floor)1 .call}.bdef\n\
\n\
/neg{0 exch sub}.bdef\n\
/add{neg sub}.bdef\n\
/idiv{div floor}.bdef\n\
\n\
/.pi{.math(PI)get}.bdef\n\
\n\
/abs{.math(abs)1 .call}.bdef\n\
%/.acos{.math(acos)1 .call}.bdef\n\
%/.asin{.math(asin)1 .call}.bdef\n\
/atan{.math(atan2)2 .call 180 mul .pi div}.bdef\n\
%/.atan2{.math(atan2)2 .call}.bdef\n\
%/ceiling{.math(ceil)1 .call}.bdef\n\
/cos{.pi mul 180 div .math(cos)1 .call}.bdef\n\
%/.exp{.math(exp)1 .call}.bdef\n\
%/log{.math(log)1 .call}.bdef\n\
%/.max{.math(max)2 .call}.bdef\n\
%/.min{.math(min)2 .call}.bdef\n\
%/.pow{.math(pow)2 .call}.bdef\n\
%/.random{.math(random)0 .call}.bdef\n\
%/rand{.random}.bdef % TODO follow spec\n\
%/round{.math(round)1 .call}.bdef\n\
%/sin{.math(sin)1 .call}.bdef\n\
%/sqrt{.math(sqrt)1 .call}.bdef\n\
%/.tan{.math(tan)1 .call}.bdef\n\
%/truncate{.math(truncate)1 .call}.bdef % TODO Math.truncate does not exist!\n\
\n\
% graphic\n\
/arc{.svg(arc)5 .call0}.bdef\n\
/arcn{.svg(arcn)5 .call0}.bdef\n\
/closepath{.svg(closepath)0 .call}.bdef\n\
/currentpoint{.svg(cx)0 .call .svg(cy)0 .call}.bdef\n\
/curveto{.svg(curveto)6 .call0}.bdef\n\
/eofill{.svg(eofill)0 .call0}.bdef\n\
/fill{.svg(fill)0 .call0}.bdef\n\
/grestore{.svg(grestore)0 .call0}.bdef\n\
/gsave{.svg(gsave)0 .call0}.bdef\n\
/lineto{.svg(lineto)2 .call0}.bdef\n\
/moveto{.svg(moveto)2 .call0}.bdef\n\
/newpath{.svg(newpath)0 .call0}.bdef\n\
/rcurveto{.svg(rcurveto)6 .call0}.bdef\n\
/rlineto{.svg(rlineto)2 .call0}.bdef\n\
/rmoveto{.svg(rmoveto)2 .call0}.bdef\n\
/rotate{.svg(rotate)1 .call0}.bdef\n\
/scale{.svg(scale)2 .call0}.bdef\n\
/selectfont{.svg(selectfont)2 .call0}.bdef\n\
/setdash{.svg(setdash)2 .call0}.bdef\n\
/setlinewidth{.svg(setlinewidth)1 .call0}.bdef\n\
/setrgbcolor{.svg(setrgbcolor)3 .call0}.bdef\n\
/show{.svg(show)1 .call0}.bdef\n\
/stroke{.svg(stroke)0 .call0}.bdef\n\
/stringwidth{.svg(strw)1 .call 1}.bdef		%fixme: height KO\n\
/translate{.svg(translate)2 .call0}.bdef\n\
\n\
/setgray{255 mul dup dup setrgbcolor}.bdef\n\
% abcm2ps syms.c\n\
/!{bind def}bind def\n\
/T/translate load def\n\
/M/moveto load def\n\
/RM/rmoveto load def\n\
/L/lineto load def\n\
/RL/rlineto load def\n\
/C/curveto load def\n\
/RC/rcurveto load def\n\
/SLW/setlinewidth load def\n\
/defl 0 def\n\
/dlw{0.7 SLW}!\n\
/xymove{/x 2 index def/y 1 index def M}!\n\
/showc{dup stringwidth pop .5 mul neg 0 RM show}!\n\
%\n\
% abcm2ps internal glyphs\n\
/arp{.svg(arp)3 .call0}.bdef\n\
/ltr{.svg(ltr)3 .call0}.bdef\n\
/ft0{(acc-1).svg(xygl)3 .call0}.bdef\n\
/nt0{(acc3).svg(xygl)3 .call0}.bdef\n\
/sh0{(acc1).svg(xygl)3 .call0}.bdef\n\
/dsh0{(acc2).svg(xygl)3 .call0}.bdef\n\
/trl{(trl).svg(xygl)3 .call0}.bdef\n\
/lmrd{(lmrd).svg(xygl)3 .call0}.bdef\n\
/turn{(turn).svg(xygl)3 .call0}.bdef\n\
/umrd{(umrd).svg(xygl)3 .call0}.bdef\n\
/y0{.svg(y0)1 .call}.bdef\n\
/y1{.svg(y1)1 .call}.bdef\n")

} // Psvg()

abc2svg.modules.psvg = {
	do_begin_end: function(of, type, opt, text) {
		if (type != "ps") {
			of(type, opt, text)
			return
		}
		if (opt == 'nosvg')
			return
		if (!this.psvg)
			this.psvg = new Psvg(this);
		this.psvg.ps_eval.call(this.psvg, text)
	},
	psdeco: function(of, f, x, y, de) {
		if (!this.psvg)			// no %%beginps yet
			return false
		return this.psvg.psdeco.call(this.psvg, f, x, y, de)
	},
	psxygl: function(of, x, y, gl) {
		if (!this.psvg)
			return false
		return this.psvg.psxygl.call(this.psvg, x, y, gl)
	}
}

abc2svg.modules.hooks.push(
// export
	"out_arp",
	"out_deco_str",
	"out_deco_val",
	"out_ltr",
	"xygl",
// hooks
	[ "do_begin_end", "abc2svg.modules.psvg.do_begin_end" ],
	[ "psdeco", "abc2svg.modules.psvg.psdeco" ],
	[ "psxygl", "abc2svg.modules.psvg.psxygl" ]
);

// the module is loaded
abc2svg.modules.beginps.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// sth.js - module to set the stem heights
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%sth" appears in a ABC source.
//
// Parameters
//	%%sth h1 h2 h3 ...
// The values h1, h2, .. are applied to the following notes which
// have a stem and which are not inside a beam.
// The value may be '*' for keeping the original stem length.

abc2svg.sth = {

// function called after beam calculation
    recal_beam: function(bm, s) {
    var staff_tb = this.get_staff_tb(),
	st = s.st,
	s2 = bm.s2
	if (s.sth)
		s.ys = s.sth
	if (s2.sth)
		s2.ys = s2.sth;
	bm.a = (s.ys- s2.ys) / (s.xs - s2.xs);
	bm.b = s.ys - s.xs * bm.a + staff_tb[st].y
	while (1) {
		s.ys = bm.a * s.xs + bm.b - staff_tb[st].y
		if (s.stem > 0)
			s.ymx = s.ys + 2.5
		else
			s.ymn = s.ys - 2.5;
		s = s.next
		if (s == s2)
			break
	}
    },

// function called after the stem heights have been computed
    set_sth: function() {
    var s, h, v, sth_a, p_voice,
	voice_tb = this.get_voice_tb()

	for (v = 0; v < voice_tb.length; v++) {
		p_voice = voice_tb[v]
		if (p_voice.sth != null)	// if no stem length in this voice
			continue
		sth_a = []
		for (s = p_voice.sym; s; s = s.next) {
			if (s.sth) {
				sth_a = s.sth;
				s.sth = null
			}
			if (sth_a.length == 0
			 || s.nflags <= -2 || s.stemless
			 || !(s.beam_st || s.beam_end))
				continue
			h = sth_a.shift()
			if (h == '*')
				continue	// no change
			if (h == '|') {		// skip to the next measure bar
				for (s = s.next; s; s = s.next) {
					if (s.bar_type)
						break
				}
				continue
			}
			h = Number(h)
			if (isNaN(h) || !h)
				continue	// fixme: error
			if (s.stem >= 0) {
				s.ys = s.y + h;
				s.ymx = (s.ys + 2.5) | 0
			} else {
				s.ys = s.y - h;
				s.ymn = (s.ys - 2.5) | 0
			}
			s.sth = s.ys
		}
	}
    }, // set_sth()

    calculate_beam: function(of, bm, s1) {
    var	done = of(bm, s1)
	if (done && bm.s2 && s1.sth)
		abc2svg.sth.recal_beam.call(this, bm, s1)
	return done
    },

    new_note: function(of, grace, tp_fact) {
    var	C = abc2svg.C,
	s = of(grace, tp_fact),
	curvoice = this.get_curvoice()

	if (curvoice.sth && s && s.type == C.NOTE) {
		s.sth = curvoice.sth;
		curvoice.sth = null
	}
	return s
    },

    set_format: function(of, cmd, param, lock) {
	if (cmd == "sth") {
	    var	curvoice = this.get_curvoice()
		if (this.parse.state == 2)
			this.goto_tune()
		if (curvoice)
			curvoice.sth = param.split(/[ \t;-]+/)
		return
	}
	of(cmd, param, lock)
    },

    set_stems: function(of) {
	of();
	abc2svg.sth.set_sth.call(this)
    }

} // sth

abc2svg.modules.hooks.push(
// export
	"goto_tune",
	"parse",
// hooks
	[ "calculate_beam", "abc2svg.sth.calculate_beam" ],
	[ "new_note", "abc2svg.sth.new_note" ],
	[ "set_format", "abc2svg.sth.set_format" ],
	[ "set_stems", "abc2svg.sth.set_stems" ]
);

// the module is loaded
abc2svg.modules.sth.loaded = true
// abc2svg - ABC to SVG translator
// @source: https://chiselapp.com/user/moinejf/repository/abc2svg
// Copyright (C) 2014-2018 Jean-Francois Moine - LGPL3+
// temper.js - module to define the temperament
//
// Copyright (C) 2018 Jean-Francois Moine - GPL3+
//
// This module is loaded when "%%temperament" appears in a ABC source.
//
// Parameters
//	%%temperament <list>
// The <list> must contain 12 integer values that are the detune values in cents
// of the 12 notes of the equal scale.
// Examples:
//
// % pythagore (~500 B.C)
// %%temperament +00 +14 +04 -06 +08 -02 +12 +02 +16 +06 -04 +10
//
// % just intonation
// %%temperament +00 -08 -18 -06 -14 -02 -10 +02 -08 -16 -04 -12
//
// % meantone (Pietro Aaron 1523)
// %%temperament +00 -24 -07 +10 -14 +03 -21 -03 -27 +10 +07 -17
//
// % Andreas Werckmeister III (1681)
// %%temperament +00 -04 +04 +00 -04 +04 +00 +02 -08 +00 +02 -02
//
// % well temperament (F.A. Vallotti 1754)
// %%temperament +00 -06 -04 -02 -08 +02 -08 -02 -04 -06 +00 -10

abc2svg.temper = {

    // move the temperament to the 1st voice
    set_bar_num: function(of) {
	of()
	if (this.cfmt().temper) {
	    var	v0 = this.get_voice_tb()[0];

		v0.temper = new Float32Array(12)
		for (var i = 0; i < 12; i++)
			v0.temper[i] = this.cfmt().temper[i] / 100
	}
    },

    // get the temperament
    set_fmt: function(of, cmd, param, lock) {
	if (cmd == "temperament") {
	    var	ls = new Float32Array(param.split(/ +/)),
		i = ls.length

		if (i == 12) {
			while (--i >= 0) {
				if (isNaN(parseInt(ls[i])))
					break
			}
			if (i < 0) {
				this.cfmt().temper = ls
				return
			}
		}
		this.syntax(1, errs.bad_val, "%%temperament")
		return
	}
	of(cmd, param, lock)
    }

} // temper


abc2svg.modules.hooks.push(
// export
	"syntax",
// hooks
	[ "set_bar_num", "abc2svg.temper.set_bar_num" ],
	[ "set_format", "abc2svg.temper.set_fmt" ]
)

// the module is loaded
abc2svg.modules.temperament.loaded = true
Opal.loaded(["abc2svg-1"]);
/* Generated by Opal 0.11.4 */
Opal.modules["opal-webworker"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$is_a?', '$Native', '$to_json', '$lambda', '$[]', '$parse', '$call', '$post_message', '$empty?', '$on_message', '$[]=', '$-']);
  
  (function($base, $super, $parent_nesting) {
    function $Webworker(){};
    var self = $Webworker = $klass($base, $super, 'Webworker', $Webworker);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Webworker_initialize_1, TMP_Webworker_createWorker_2, TMP_Webworker_post_message_3, TMP_Webworker_on_message_4;

    def.worker = nil;
    
    
    Opal.defn(self, '$initialize', TMP_Webworker_initialize_1 = function $$initialize(parent) {
      var self = this;

      
      self.handlers = $hash2([], {});
      if ($truthy(self.$Native(parent)['$is_a?'](Opal.const_get_relative($nesting, 'String')))) {
        
        self.worker = new Worker(parent);
        return (self.name = "main script");
        } else {
        
        self.worker = parent;
        return (self.name = "worker");
      };
    }, TMP_Webworker_initialize_1.$$arity = 1);
    
    Opal.defn(self, '$createWorker', TMP_Webworker_createWorker_2 = function $$createWorker(script) {
      var self = this;

      return (self.worker = new Worker(script))
    }, TMP_Webworker_createWorker_2.$$arity = 1);
    
    Opal.defn(self, '$post_message', TMP_Webworker_post_message_3 = function $$post_message(object) {
      var self = this;

      return self.worker.postMessage(object.$to_json());
    }, TMP_Webworker_post_message_3.$$arity = 1);
    return (Opal.defn(self, '$on_message', TMP_Webworker_on_message_4 = function $$on_message() {
      var TMP_5, self = this, $iter = TMP_Webworker_on_message_4.$$p, block = $iter || nil, listener = nil;

      if ($iter) TMP_Webworker_on_message_4.$$p = null;
      
      listener = $send(self, 'lambda', [], (TMP_5 = function(event){var self = TMP_5.$$s || this, payload = nil, result = nil;
if (event == null) event = nil;
      
        payload = self.$Native(event)['$[]']("data");
        result = nil;
        result = Opal.const_get_relative($nesting, 'JSON').$parse(payload);
        block.$call(result);
        return nil;}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
      return  self.worker.addEventListener('message', listener, false);;
    }, TMP_Webworker_on_message_4.$$arity = 0), nil) && 'on_message';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    function $NamedWebworker(){};
    var self = $NamedWebworker = $klass($base, $super, 'NamedWebworker', $NamedWebworker);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NamedWebworker_post_named_message_6, TMP_NamedWebworker_on_named_message_7;

    def.handlers = nil;
    
    
    Opal.defn(self, '$post_named_message', TMP_NamedWebworker_post_named_message_6 = function $$post_named_message(cmd, object) {
      var self = this;

      return self.$post_message($hash2(["name", "payload"], {"name": cmd, "payload": object}))
    }, TMP_NamedWebworker_post_named_message_6.$$arity = 2);
    return (Opal.defn(self, '$on_named_message', TMP_NamedWebworker_on_named_message_7 = function $$on_named_message(cmd) {
      var TMP_8, self = this, $iter = TMP_NamedWebworker_on_named_message_7.$$p, block = $iter || nil, $writer = nil;

      if ($iter) TMP_NamedWebworker_on_named_message_7.$$p = null;
      
      if ($truthy(self.handlers['$empty?']())) {
        $send(self, 'on_message', [], (TMP_8 = function(object){var self = TMP_8.$$s || this, handler = nil;
          if (self.handlers == null) self.handlers = nil;
if (object == null) object = nil;
        if ($truthy(object['$is_a?'](Opal.const_get_relative($nesting, 'Hash')))) {
            
            handler = self.handlers['$[]'](object['$[]']("name"));
            if ($truthy(handler)) {
              return handler.$call(object)
              } else {
              return nil
            };
            } else {
            return nil
          }}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))};
      
      $writer = [cmd, block];
      $send(self.handlers, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];;
    }, TMP_NamedWebworker_on_named_message_7.$$arity = 1), nil) && 'on_named_message';
  })($nesting[0], Opal.const_get_relative($nesting, 'Webworker'), $nesting);
};

/* Generated by Opal 0.11.4 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var TMP_perform_worker_task_34, TMP_35, TMP_36, TMP_38, TMP_40, TMP_41, TMP_43, self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $gvars = Opal.gvars, $writer = nil;
  if (self.namedworker == null) self.namedworker = nil;
  if (self.worker == null) self.worker = nil;
  if ($gvars.log == null) $gvars.log = nil;

  Opal.add_stubs(['$require', '$[]', '$Native', '$attr_accessor', '$write_worker', '$[]=', '$-', '$post_named_message', '$new', '$strict=', '$push', '$init_conf', '$controller=', '$lambda', '$meta_data', '$join', '$map', '$to_s', '$year', '$now', '$reset_to', '$transform', '$abc_model', '$player_model_abc=', '$checksum=', '$t', '$load_music_model', '$debug', '$layout_harpnotes', '$benchmark', '$load_song', '$active_voices', '$clear', '$set_view_box', '$draw', '$error', '$message', '$backtrace', '$keys', '$get', '$==', '$loglevel', '$validate_conf', '$set_extracts_menu', '$uri=', '$get_placeholder_replacers', '$placeholders=', '$layout', '$pop', '$inject', '$dig', '$last', '$include?', '$to_i', '$first', '$call', '$worker=', '$post_message', '$on_named_message', '$perform_worker_task', '$loglevel=', '$clear_errors', '$clear_annotations', '$compute_tune_preview', '$get_status', '$phrases=', '$systemstatus=', '$config_from_editor=', '$abc_part_from_editor=', '$compute_harpnotes_preview', '$music_model', '$extracts', '$player_model_abc', '$harpnote_player', '$get_worker_model']);
  
  

  // polyfills from https://gist.github.com/jmshal/b14199f7402c8f3a4568733d8bed0f25
  //global.btoa = function btoa(b) {return new Buffer(b).toString('base64');};
  //global.atob = function atob(a) {return new Buffer(a, 'base64').toString('binary');};

  //jsPDF = require ("jspdf")   // adapt in opal-jspdf.rb
  // Ajv = require("ajv")        // adapt in opal-ajv.rb
  //neatJSON = require("./neatjson_js") // adapt in opal-neatjson.rb

  // these requires are required by nodejs/dir, nodejs/file
  // fs = require('fs')
  // glob = require("glob")      // don't know who needs this
;
  self.$require("opal");
  self.$require("opal-platform");
  self.$require("ajv.min.js");
  self.$require("vector2d");
  self.$require("opal-ajv");
  self.$require("consolelogger");
  self.$require("harpnotes");
  self.$require("abc_to_harpnotes_factory");
  self.$require("abc2svg_to_harpnotes");
  self.$require("svg_engine");
  self.$require("init_conf");
  self.$require("text_pane");
  self.$require("harpnote_player");
  self.$require("confstack2");
  self.$require("opal-abc2svg");
  self.$require("version-prod");
  self.$require("abc2svg-1.js");
  self.$require("opal-webworker");
  (function($base, $parent_nesting) {
    var $I18n, self = $I18n = $module($base, 'I18n');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_I18n_t_1, TMP_I18n_phrases_2, TMP_I18n_phrases$eq_3;

    
    Opal.defs(self, '$t', TMP_I18n_t_1 = function $$t(text) {
      var $a, self = this;
      if (self.phrasesOpal == null) self.phrasesOpal = nil;

      try {
        return ($truthy($a = self.phrasesOpal['$[]'](text)) ? $a : text)
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
          try {
            return text
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, TMP_I18n_t_1.$$arity = 1);
    Opal.defs(self, '$phrases', TMP_I18n_phrases_2 = function $$phrases() {
      var self = this;
      if (self.phrases == null) self.phrases = nil;

      return self.phrases
    }, TMP_I18n_phrases_2.$$arity = 0);
    Opal.defs(self, '$phrases=', TMP_I18n_phrases$eq_3 = function(phrases) {
      var self = this;

      
      self.phrases = phrases;
      return (self.phrasesOpal = self.$Native(phrases));
    }, TMP_I18n_phrases$eq_3.$$arity = 1);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    function $WorkerLogger(){};
    var self = $WorkerLogger = $klass($base, $super, 'WorkerLogger', $WorkerLogger);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_WorkerLogger_error_4, TMP_WorkerLogger_info_5, TMP_WorkerLogger_warning_6, TMP_WorkerLogger_message_7, TMP_WorkerLogger_debug_8, TMP_WorkerLogger_write_worker_9;

    def.worker = nil;
    
    self.$attr_accessor("worker");
    
    Opal.defn(self, '$error', TMP_WorkerLogger_error_4 = function $$error($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send(self, 'write_worker', ["error"].concat(Opal.to_a(args)))
    }, TMP_WorkerLogger_error_4.$$arity = -1);
    
    Opal.defn(self, '$info', TMP_WorkerLogger_info_5 = function $$info($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send(self, 'write_worker', ["info"].concat(Opal.to_a(args)))
    }, TMP_WorkerLogger_info_5.$$arity = -1);
    
    Opal.defn(self, '$warning', TMP_WorkerLogger_warning_6 = function $$warning($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send(self, 'write_worker', ["warning"].concat(Opal.to_a(args)))
    }, TMP_WorkerLogger_warning_6.$$arity = -1);
    
    Opal.defn(self, '$message', TMP_WorkerLogger_message_7 = function $$message($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send(self, 'write_worker', ["message"].concat(Opal.to_a(args)))
    }, TMP_WorkerLogger_message_7.$$arity = -1);
    
    Opal.defn(self, '$debug', TMP_WorkerLogger_debug_8 = function $$debug($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return $send(self, 'write_worker', ["debug"].concat(Opal.to_a(args)))
    }, TMP_WorkerLogger_debug_8.$$arity = -1);
    return (Opal.defn(self, '$write_worker', TMP_WorkerLogger_write_worker_9 = function $$write_worker(type, $a_rest) {
      var self = this, args, the_args = nil, $writer = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      
      the_args = args;
      
      $writer = [0, "" + "worker: " + (args['$[]'](0))];
      $send(the_args, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return self.worker.$post_named_message("log", $hash2(["type", "args"], {"type": type, "args": the_args}));
    }, TMP_WorkerLogger_write_worker_9.$$arity = -2), nil) && 'write_worker';
  })($nesting[0], Opal.const_get_relative($nesting, 'Logger'), $nesting);
  $gvars.log = Opal.const_get_relative($nesting, 'WorkerLogger').$new(nil);
  (function($base, $super, $parent_nesting) {
    function $WorkerController(){};
    var self = $WorkerController = $klass($base, $super, 'WorkerController', $WorkerController);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_WorkerController_initialize_10, TMP_WorkerController_get_placeholder_replacers_24, TMP_WorkerController_load_music_model_25, TMP_WorkerController_compute_harpnotes_preview_27, TMP_WorkerController_layout_harpnotes_30, TMP_WorkerController_set_extracts_menu_33;

    def.harpnote_player = def.config_from_editor = def.abc_part_from_editor = def.checksum = def.music_model = def.systemstatus = def.song_harpnotes = def.harpnote_preview_printer = nil;
    
    self.$attr_accessor("config_from_editor", "abc_part_from_editor", "systemstatus", "harpnote_player", "abc_model", "extracts", "music_model", "checksum");
    
    Opal.defn(self, '$initialize', TMP_WorkerController_initialize_10 = function $$initialize() {
      var self = this, $writer = nil;
      if ($gvars.conf == null) $gvars.conf = nil;

      
      $gvars.conf = Opal.const_get_relative($nesting, 'Confstack').$new(nil);
      
      $writer = [false];
      $send($gvars.conf, 'strict=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      $gvars.conf.$push(Opal.const_get_relative($nesting, 'InitConf').$init_conf());
      self.harpnote_player = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Music'), 'HarpnotePlayer').$new();
      
      $writer = [self];
      $send(self.harpnote_player, 'controller=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return (self.json_validator = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Ajv'), 'JsonValidator').$new());
    }, TMP_WorkerController_initialize_10.$$arity = 0);
    
    Opal.defn(self, '$get_placeholder_replacers', TMP_WorkerController_get_placeholder_replacers_24 = function $$get_placeholder_replacers(print_variant_nr) {
      var TMP_11, TMP_12, TMP_13, TMP_14, TMP_15, TMP_16, TMP_17, TMP_18, TMP_19, TMP_20, TMP_22, TMP_23, self = this;

      return $hash2(["composer", "key", "meter", "number", "o_key", "tempo", "title", "extract_title", "extract_filename", "printed_extracts", "watermark", "current_year"], {"composer": $send(self, 'lambda', [], (TMP_11 = function(){var self = TMP_11.$$s || this;
        if (self.music_model == null) self.music_model = nil;

      return self.music_model.$meta_data()['$[]']("composer")}, TMP_11.$$s = self, TMP_11.$$arity = 0, TMP_11)), "key": $send(self, 'lambda', [], (TMP_12 = function(){var self = TMP_12.$$s || this;
        if (self.music_model == null) self.music_model = nil;

      return self.music_model.$meta_data()['$[]']("key")}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12)), "meter": $send(self, 'lambda', [], (TMP_13 = function(){var self = TMP_13.$$s || this;
        if (self.music_model == null) self.music_model = nil;

      return self.music_model.$meta_data()['$[]']("meter").$join(" ")}, TMP_13.$$s = self, TMP_13.$$arity = 0, TMP_13)), "number": $send(self, 'lambda', [], (TMP_14 = function(){var self = TMP_14.$$s || this;
        if (self.music_model == null) self.music_model = nil;

      return self.music_model.$meta_data()['$[]']("number")}, TMP_14.$$s = self, TMP_14.$$arity = 0, TMP_14)), "o_key": $send(self, 'lambda', [], (TMP_15 = function(){var self = TMP_15.$$s || this;
        if (self.music_model == null) self.music_model = nil;

      return self.music_model.$meta_data()['$[]']("o_key")}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15)), "tempo": $send(self, 'lambda', [], (TMP_16 = function(){var self = TMP_16.$$s || this;
        if (self.music_model == null) self.music_model = nil;

      return self.music_model.$meta_data()['$[]']("tempo_display")}, TMP_16.$$s = self, TMP_16.$$arity = 0, TMP_16)), "title": $send(self, 'lambda', [], (TMP_17 = function(){var self = TMP_17.$$s || this;
        if (self.music_model == null) self.music_model = nil;

      return self.music_model.$meta_data()['$[]']("title")}, TMP_17.$$s = self, TMP_17.$$arity = 0, TMP_17)), "extract_title": $send(self, 'lambda', [], (TMP_18 = function(){var self = TMP_18.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("" + "extract." + (print_variant_nr) + ".title")}, TMP_18.$$s = self, TMP_18.$$arity = 0, TMP_18)), "extract_filename": $send(self, 'lambda', [], (TMP_19 = function(){var self = TMP_19.$$s || this;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $gvars.conf['$[]']("" + "extract." + (print_variant_nr) + ".filenamepart")}, TMP_19.$$s = self, TMP_19.$$arity = 0, TMP_19)), "printed_extracts": $send(self, 'lambda', [], (TMP_20 = function(){var self = TMP_20.$$s || this, TMP_21;
        if ($gvars.conf == null) $gvars.conf = nil;

      return $send($gvars.conf['$[]']("produce"), 'map', [], (TMP_21 = function(k){var self = TMP_21.$$s || this;
          if ($gvars.conf == null) $gvars.conf = nil;
if (k == null) k = nil;
        return $gvars.conf['$[]']("" + "extract." + (k) + ".filenamepart")}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21)).$join(" ")}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20)), "watermark": $send(self, 'lambda', [], (TMP_22 = function(){var self = TMP_22.$$s || this, $a;
        if ($gvars.settings == null) $gvars.settings = nil;

      return ($truthy($a = $gvars.settings['$[]']("watermark")) ? $a : "")}, TMP_22.$$s = self, TMP_22.$$arity = 0, TMP_22)), "current_year": $send(self, 'lambda', [], (TMP_23 = function(){var self = TMP_23.$$s || this;

      return Opal.const_get_relative($nesting, 'Time').$now().$year().$to_s()}, TMP_23.$$s = self, TMP_23.$$arity = 0, TMP_23))})
    }, TMP_WorkerController_get_placeholder_replacers_24.$$arity = 1);
    
    Opal.defn(self, '$load_music_model', TMP_WorkerController_load_music_model_25 = function $$load_music_model() {
      var $a, $b, self = this, config = nil, harpnote_engine = nil, player_model_abc = nil, $writer = nil;
      if ($gvars.conf == null) $gvars.conf = nil;

      
      config = self.config_from_editor;
      $gvars.conf.$reset_to(1);
      $gvars.conf.$push(config);
      harpnote_engine = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Input'), 'Abc2svgToHarpnotes').$new();
      $b = harpnote_engine.$transform(self.abc_part_from_editor), $a = Opal.to_ary($b), (self.music_model = ($a[0] == null ? nil : $a[0])), (player_model_abc = ($a[1] == null ? nil : $a[1])), $b;
      self.abc_model = harpnote_engine.$abc_model();
      
      $writer = [player_model_abc];
      $send(self.harpnote_player, 'player_model_abc=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [self.checksum];
      $send(self.music_model, 'checksum=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];;
    }, TMP_WorkerController_load_music_model_25.$$arity = 0);
    
    Opal.defn(self, '$compute_harpnotes_preview', TMP_WorkerController_compute_harpnotes_preview_27 = function $$compute_harpnotes_preview() {
      var TMP_26, self = this, result = nil, e = nil;
      if ($gvars.log == null) $gvars.log = nil;

      
      result = $hash2(["svg", "interactive_elements", "error_alert"], {"svg": Opal.const_get_relative($nesting, 'I18n').$t("BUG: worker did not finsh"), "interactive_elements": [], "error_alert": true});
      
      try {
        
        self.$load_music_model();
        $gvars.log.$debug("" + "viewid: " + (self.systemstatus['$[]']("view")) + " " + ("znworker") + " " + (201));
        self.song_harpnotes = self.$layout_harpnotes(self.systemstatus['$[]']("view"), "A3");
        if ($truthy(self.song_harpnotes)) {
          
          $send($gvars.log, 'benchmark', ["loading music to player"], (TMP_26 = function(){var self = TMP_26.$$s || this;
            if (self.harpnote_player == null) self.harpnote_player = nil;
            if (self.music_model == null) self.music_model = nil;
            if (self.song_harpnotes == null) self.song_harpnotes = nil;

          return self.harpnote_player.$load_song(self.music_model, self.song_harpnotes.$active_voices())}, TMP_26.$$s = self, TMP_26.$$arity = 0, TMP_26));
          self.harpnote_preview_printer = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'SvgEngine').$new(nil, 2200, 1400);
          self.harpnote_preview_printer.$clear();
          self.harpnote_preview_printer.$set_view_box(0, 0, 420, 297);
          result = self.harpnote_preview_printer.$draw(self.song_harpnotes);};
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
          try {
            $gvars.log.$error("" + (e.$message()), nil, nil, e.$backtrace())
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };;
      return result;
    }, TMP_WorkerController_compute_harpnotes_preview_27.$$arity = 0);
    
    Opal.defn(self, '$layout_harpnotes', TMP_WorkerController_layout_harpnotes_30 = function $$layout_harpnotes(print_variant, page_format) {
      var TMP_28, TMP_29, self = this, result = nil, e = nil;
      if ($gvars.conf == null) $gvars.conf = nil;
      if ($gvars.log == null) $gvars.log = nil;

      if (print_variant == null) {
        print_variant = 0;
      }
      if (page_format == null) {
        page_format = "A4";
      }
      
      $gvars.image_list = (function() { try {
        return $gvars.conf.$get()['$[]']("resources").$keys()
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
          try {
            return nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }})();
      
      try {
      try {
        
        $send($gvars.log, 'benchmark', ["validate default conf"], (TMP_28 = function(){var self = TMP_28.$$s || this, $a;
          if (self.json_validator == null) self.json_validator = nil;
          if ($gvars.log == null) $gvars.log = nil;
          if ($gvars.settings == null) $gvars.settings = nil;
          if ($gvars.conf == null) $gvars.conf = nil;

        
          self.validation_errors = [];
          if ($truthy(($truthy($a = $gvars.log.$loglevel()['$==']("debug")) ? $a : $gvars.settings['$[]']("validate")['$==']("true")))) {
            return (self.validation_errors = self.json_validator.$validate_conf($gvars.conf))
            } else {
            return nil
          };}, TMP_28.$$s = self, TMP_28.$$arity = 0, TMP_28));
        self.$set_extracts_menu();
        result = nil;
        $send($gvars.log, 'benchmark', ["computing layout"], (TMP_29 = function(){var self = TMP_29.$$s || this, layouter = nil, $writer = nil;
          if (self.music_model == null) self.music_model = nil;
          if ($gvars.uri == null) $gvars.uri = nil;

        
          layouter = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Harpnotes'), 'Layout'), 'Default').$new();
          
          $writer = [$gvars.uri];
          $send(layouter, 'uri=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [self.$get_placeholder_replacers(print_variant)];
          $send(layouter, 'placeholders=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return (result = layouter.$layout(self.music_model, nil, print_variant, page_format));}, TMP_29.$$s = self, TMP_29.$$arity = 0, TMP_29));
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
          try {
            $gvars.log.$error("" + (e.$message()), nil, nil, e.$backtrace())
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
      } finally {
        $gvars.conf.$pop()
      };;
      return result;
    }, TMP_WorkerController_layout_harpnotes_30.$$arity = -1);
    return (Opal.defn(self, '$set_extracts_menu', TMP_WorkerController_set_extracts_menu_33 = function $$set_extracts_menu() {
      var TMP_31, self = this;
      if ($gvars.log == null) $gvars.log = nil;

      return $send($gvars.log, 'benchmark', ["prepare extract menu"], (TMP_31 = function(){var self = TMP_31.$$s || this, TMP_32, printed_extracts = nil;
        if ($gvars.conf == null) $gvars.conf = nil;

      
        printed_extracts = $gvars.conf['$[]']("produce");
        return (self.extracts = $send($gvars.conf.$get("extract"), 'inject', [[]], (TMP_32 = function(r, entry){var self = TMP_32.$$s || this, extract_number = nil, print = nil, title = nil;
if (r == null) r = nil;if (entry == null) entry = nil;
        
          extract_number = entry.$last().$dig("filenamepart");
          print = (function() {if ($truthy(printed_extracts['$include?'](entry.$first().$to_i()))) {
            return "*  "
            } else {
            return " "
          }; return nil; })();
          title = "" + (print) + (extract_number) + " " + (entry.$last()['$[]']("title")) + " ";
          return r.$push([entry.$first(), title]);}, TMP_32.$$s = self, TMP_32.$$arity = 2, TMP_32)));}, TMP_31.$$s = self, TMP_31.$$arity = 0, TMP_31))
    }, TMP_WorkerController_set_extracts_menu_33.$$arity = 0), nil) && 'set_extracts_menu';
  })($nesting[0], null, $nesting);
  
  Opal.defn(Opal.Object, '$perform_worker_task', TMP_perform_worker_task_34 = function $$perform_worker_task(title) {
    var self = this, $iter = TMP_perform_worker_task_34.$$p, block = $iter || nil, e = nil;
    if (self.namedworker == null) self.namedworker = nil;
    if ($gvars.log == null) $gvars.log = nil;

    if (title == null) {
      title = nil;
    }
    if ($iter) TMP_perform_worker_task_34.$$p = null;
    
    try {
      return block.$call()
    } catch ($err) {
      if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'Exception')])) {e = $err;
        try {
          
          $gvars.log.$error("" + (title) + ": " + (e.$message()), nil, nil, e.$backtrace());
          return self.namedworker.$post_named_message("rescue_from_worker_error", nil);
        } finally { Opal.pop_exception() }
      } else { throw $err; }
    };
  }, TMP_perform_worker_task_34.$$arity = -1);
  self.worker = Opal.const_get_relative($nesting, 'Webworker').$new(this);
  self.namedworker = Opal.const_get_relative($nesting, 'NamedWebworker').$new(this);
  
  $writer = [self.namedworker];
  $send($gvars.log, 'worker=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  self.worker.$post_message("" + "worker started " + ("znworker"));
  $send(self.namedworker, 'on_named_message', ["abort"], (TMP_35 = function(data){var self = TMP_35.$$s || this;
    if ($gvars.log == null) $gvars.log = nil;
if (data == null) data = nil;
  return $gvars.log.$error("" + "aborting worker: " + (data['$[]']("payload")['$[]']("render_stack").$to_s()))}, TMP_35.$$s = self, TMP_35.$$arity = 1, TMP_35));
  $send(self.namedworker, 'on_named_message', ["set_loglevel"], (TMP_36 = function(data){var self = TMP_36.$$s || this, TMP_37;
if (data == null) data = nil;
  return $send(self, 'perform_worker_task', [data['$[]']("cmd")], (TMP_37 = function(){var self = TMP_37.$$s || this;
      if ($gvars.log == null) $gvars.log = nil;

    
      $writer = [data['$[]']("payload")];
      $send($gvars.log, 'loglevel=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];}, TMP_37.$$s = self, TMP_37.$$arity = 0, TMP_37))}, TMP_36.$$s = self, TMP_36.$$arity = 1, TMP_36));
  $send(self.namedworker, 'on_named_message', ["compute_tune_preview"], (TMP_38 = function(data){var self = TMP_38.$$s || this, TMP_39;
if (data == null) data = nil;
  return $send(self, 'perform_worker_task', [data['$[]']("name")], (TMP_39 = function(){var self = TMP_39.$$s || this, payload = nil, svg_and_position = nil;
      if (self.tune_preview_printer == null) self.tune_preview_printer = nil;
      if (self.namedworker == null) self.namedworker = nil;
      if ($gvars.log == null) $gvars.log = nil;

    
      $gvars.log.$clear_errors();
      $gvars.log.$clear_annotations();
      self.tune_preview_printer = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'ABC2SVG'), 'Abc2Svg').$new(nil);
      payload = data['$[]']("payload");
      svg_and_position = self.tune_preview_printer.$compute_tune_preview(payload['$[]']("abc"), payload['$[]']("checksum"));
      self.namedworker.$post_named_message(data['$[]']("name"), svg_and_position);
      return self.namedworker.$post_named_message("set_logger_status", $gvars.log.$get_status());}, TMP_39.$$s = self, TMP_39.$$arity = 0, TMP_39))}, TMP_38.$$s = self, TMP_38.$$arity = 1, TMP_38));
  $send(self.namedworker, 'on_named_message', ["i18n_set_locale"], (TMP_40 = function(data){var self = TMP_40.$$s || this;
if (data == null) data = nil;
  
    
    $writer = [JSON.parse(data['$[]']("payload"))];
    $send(Opal.const_get_relative($nesting, 'I18n'), 'phrases=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    return Opal.const_get_relative($nesting, 'I18n').$t("locales loaded");}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40));
  $send(self.namedworker, 'on_named_message', ["compute_harpnotes_preview"], (TMP_41 = function(data){var self = TMP_41.$$s || this, TMP_42;
if (data == null) data = nil;
  return $send(self, 'perform_worker_task', [data['$[]']("name")], (TMP_42 = function(){var self = TMP_42.$$s || this, controller = nil, result = nil, document_title = nil;
      if (self.namedworker == null) self.namedworker = nil;

    
      controller = Opal.const_get_relative($nesting, 'WorkerController').$new();
      $gvars.settings = data['$[]']("payload")['$[]']("settings");
      $gvars.resources = data['$[]']("payload")['$[]']("resources");
      $gvars.uri = data['$[]']("payload")['$[]']("uri");
      
      $writer = [data['$[]']("payload")['$[]']("checksum")];
      $send(controller, 'checksum=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [data['$[]']("payload")['$[]']("systemstatus")];
      $send(controller, 'systemstatus=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [data['$[]']("payload")['$[]']("config_from_editor")];
      $send(controller, 'config_from_editor=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [data['$[]']("payload")['$[]']("abc_part_from_editor")];
      $send(controller, 'abc_part_from_editor=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      result = controller.$compute_harpnotes_preview();
      if ($truthy(result['$[]']("error_alert"))) {
        self.namedworker.$post_named_message("error_alert", nil)
        } else {
        
        document_title = (function() { try {
          return controller.$music_model().$meta_data()['$[]']("filename")
        } catch ($err) {
          if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
            try {
              return "error"
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        }})();
        self.namedworker.$post_named_message("update_ui", $hash2(["extracts", "document_title"], {"extracts": controller.$extracts(), "document_title": document_title}));
      };
      self.namedworker.$post_named_message("compute_harpnotes_preview", result);
      self.namedworker.$post_named_message("load_abc_model", controller.$abc_model());
      self.namedworker.$post_named_message("load_player_model_abc", JSON.stringify(controller.$harpnote_player().$player_model_abc()));
      return self.namedworker.$post_named_message("load_player_from_worker", controller.$harpnote_player().$get_worker_model());}, TMP_42.$$s = self, TMP_42.$$arity = 0, TMP_42))}, TMP_41.$$s = self, TMP_41.$$arity = 1, TMP_41));
  return $send(self.namedworker, 'on_named_message', ["get_worker_info"], (TMP_43 = function(data){var self = TMP_43.$$s || this, result = nil;
    if (self.namedworker == null) self.namedworker = nil;
if (data == null) data = nil;
  
    result = $hash2(["version"], {"version": Opal.const_get_relative($nesting, 'VERSION')});
    return self.namedworker.$post_named_message("get_worker_info", result);}, TMP_43.$$s = self, TMP_43.$$arity = 1, TMP_43));
})(Opal);
