@@ -0,0 +1,125 @@
@startuml
class foo
package bar {
    class foobar
    class josef
    foo <-> josef
    }
@enduml

@startuml zupnfoter_integration
    box Zupfnoter
        participant controller
        participant harpnotePlayer
    end box

    box snd-1
        participant Abc
        participant AbcPlay
        participant Audio5
    end box

    controller -> Abc:tosvg
    Abc -> controller:callback get_abcmodel

    controller -> AbcPlay:play(istart,iend, 0)
    AbcPlay -> Audio5
@enduml


@startuml abcplayer

    box zupfnoter
        participant HarpnotePlayer as hp
    end box

    box sndaud
        participant Audio5
    end box

    box sndmid
        participant Midi5
    end box

    box sndmem
        participant Mem
    end box

    box toaudio5.js
        participant Audio5
    end box
@enduml


@startuml "bigpicture-of-playing in abc2svg"
    skinparam BoxPadding 10

    box "zupfnoter"
    participant Zupfnoter as App
    end box

    box "abc2svg.js"
    participant Abc
    end box

    box "play.js" #ffaaaa
    participant EventSndgen
    end box

    box "toaudio5.js" #ffaaaa
    participant Audio5 as ToAudio5
    end box

    box "sndgen.js"
    participant Sndgen
    end box

    box "sndaud.js"
    participant Audio5
    end box

    box "sndmem.js"
    participant Sndmem
    end box



    == parsing abc to a model ==

    App -> Abc:to_svg(abctext)
    Abc -> App:get_abcmodel(abcmodel)

    == playing the model ==

    App -> Audio5 : play(first_symbol, last_symbol, repeat_level)

    Audio5 -> Audio5 : 'get the play resources\n(instruments)\n initialize po

    ...
        note over Audio5 #red: **all resourses loaded** #red

    Audio5 -> Sndgen:play_next(po)

    group loop over play_next \nwhile (not po.stop )
       Sndgen -> Audio5 : po.note_run(po, ...)
       Audio5 -> : Audio out
       note right : sound
    end

    == getting play events ==

    App -> Sndmem : play(first_symbol, last_symbol, repeat_level)
    Sndmem -> Sndgen : play_next(po)

    group loop over Sndgen.play_next \nwhile (not po.stop )
         Sndgen -> Sndmem : po.note_run(po, ...)
         Sndmem -> Sndmem : p_e += ...
         note right : store play events
    end

    App <-- Sndmem : return p_e

    note over Sndgen, Sndmem #lightblue
    This last step just builds the audio array in the same format as in the previous version.
    To play any sequence, do:
    end note
    == playing arbitrary events ==

    App -> ToAudio5 : play_events(p_e, ...)

    ToAudio5 -> ToAudio5 : 'get the play resources\n(instruments)\n initialize epo

    ...
        note over ToAudio5 #red: **all resourses loaded** #red

    ToAudio5 -> EventSndgen : play_next(epo)

    loop over play_next(epo)
       EventSndgen -> ToAudio5 : po.note_run(epo, ...)
       ToAudio5 -> : Audio out
       note right : sound
    end

    @enduml

    @startuml Controller-abc2svg

    participant controller
    participant "Abc2svgToHarpnotes::\nharpnote_engine" as harpnote_engine
    participant "Abc2svg::\nabcparser" as abc_parser
    participant abc2svg as abc2svg
    participant "Abc2svg::\n@tune_preview_printer" as tune_preview_printer
    participant "Abc2svgToHarpnotes::\n@abc_transformer" as abc_transformer
    participant "tunePreview" as tunePreview

    group init
       controller -> abc_transformer ++ :new(Abc2svgToHarpnotes mode:svg)
       note right: **todo** we don't need this\ncreate on demand

       controller -> tune_preview_printer ++ : Abc2svg.new($('#tunePreview'))
       note right: **todo** we don't need this\ncreate on demand

    end

    group load_music_model
        controller -> harpnote_engine++:harpnote_engine=new(Abc2svgToHarpnotes mode:model)
        controller ->harpnote_engine:transform(abc_code)
          group player_model_abc=getplayer_model(abc_code)
            harpnote_engine -> abc_parser ++ :abc_parser = new(Abc2svg)
              abc_parser -> abc2svg ++   : new abc2svg.Abc(\n{user:get_abcmodel})
                harpnote_engine -> abc_parser : get_abcmodel(abc_code)
                abc_parser -> abc2svg:to_svg
              return _callback_get_abcmodel\n@player_model\n@abc_model
            return [@abc_model, @player_model_abc]
          end

          harpnote_engine -> harpnote_engine : music_model = _transform_voices

        harpnote_engine --> controller:return [music_model, player_model_abc]
        deactivate harpnote_engine
    end

    group render_tunepreview_in_uithread
       controller -> tune_preview_printer ++ : Abc2svg.new($('#tunePreview'))
          tune_preview_printer -> abc2svg ++ : new abc2svg.Abc(\nuser:img_out ...}
            controller -> tune_preview_printer : svg_and_positions = compute_tune_preview(abc_text, @editor.get_checksum)
            tune_preview_printer -> abc2svg : to_svg
               abc2svg -> tune_preview_printer: callback img_out
            tune_preview_printer <-- abc2svg : to_svg is finished\ncan collect svg_buffer
            controller <-- tune_preview_printer : return svg_and_positions
            controller -> tune_preview_printer : set_svg(svg_and_positions)
            tune_preview_printer -> tunePreview : place svg_and_positions
          abc2svg --
       return
    end
    @enduml

    @startuml "proposal for playing infrastructure"

    package {
    class AbstractGen <<abstract>>{
      PlayObject playobject
      void play(void playdata, AbstractSoundevice: **sounddevice**)
      void play_next(void **playobject**)
      AbstractSounddevice: sounddevice
    }


    class AbstractSounddevice  <<abstract>> {
      void new()
      void note_run(**soundobject**)
    }
    }

    AbstractGen --> AbstractSounddevice

    AbstractSounddevice <|-- Sndmid
    AbstractSounddevice <|-- Sndmem
    AbstractSounddevice <|-- Sndaud

    AbstractGen <|-- SndgenAbc
    AbstractGen <|-- SndgenEvent

    @enduml

    @startuml "application of playing infrastructure"

    participant "Abc\nZupfnoter" as App
    participant SndgenAbc
    participant SndgenEvent

        == playing the model ==

        App -> Sndaud++ : sounddevice = new Sndaud

        App -> SndgenAbc : void = play(first_symbol, last_symbol, repeat_level, Sndaud)

        Sndaud -> Sndaud : 'get the play resources\n(instruments)\n initialize po

        ...
        note over Sndaud #red: **all resourses loaded** #red

        group loop over play_next \nwhile (not po.stop )
           SndgenAbc -> Sndaud : note_run(soudobject, ...)
           Sndaud -> : Audio out
           note right : sound
        end

        return

        == Getting events ==

         App -> Sndmem++ : sounddevice = new Sndmem
         App -> SndgenAbc : p_e = play(first_symbol, last_symbol, repeat_level, Sndmem)

            group loop over SndgenAbc.play_next \nwhile (not po.stop )
                 SndgenAbc -> Sndmem : note_run(soundobject, ...)
                 Sndmem -> Sndmem : p_e += ...
                 note right : store play events
             end
         return

         App <-- Sndmem : return p_e

        == Playing events ==

        App -> Sndaud++ : sounddevice = new Sndaud
        App -> SndgenEvent : play(p_e, sounddevice)

        Sndaud -> Sndaud : 'get the play resources\n(instruments)\n initialize po

        ...
        note over Sndaud #red: **all resourses loaded** #red

        group loop over play_next \nwhile (not po.stop )
           SndgenEvent -> Sndaud : note_run(soundobject, ...)
           Sndaud -> : Audio out
           note right  : sound
        end

        return


    @enduml



